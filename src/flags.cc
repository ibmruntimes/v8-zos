

















namespace std {
inline namespace __1 {}
}




#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {



   typedef long ptrdiff_t;






       typedef unsigned long size_t;
   }


#pragma checkout(resume)



extern "C++" {

namespace std {
typedef decltype(nullptr) nullptr_t;
}
using std::nullptr_t;
}



typedef long double max_align_t;


#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {




#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
extern "C" {
}


#pragma checkout(resume)








       typedef signed char int8_t;

       typedef signed short int16_t;

       typedef signed int int32_t;






       typedef signed long int64_t;
       typedef unsigned char uint8_t;



       typedef unsigned short uint16_t;





       typedef unsigned int uint32_t;




       typedef unsigned long uint64_t;






       typedef signed long intptr_t;


       typedef unsigned long uintptr_t;
      typedef int8_t int_least8_t;
      typedef int16_t int_least16_t;
      typedef int32_t int_least32_t;


        typedef int64_t int_least64_t;


      typedef uint8_t uint_least8_t;
      typedef uint16_t uint_least16_t;
      typedef uint32_t uint_least32_t;


        typedef uint64_t uint_least64_t;
      typedef int8_t int_fast8_t;
      typedef int32_t int_fast16_t;
      typedef int32_t int_fast32_t;


        typedef int64_t int_fast64_t;


      typedef uint8_t uint_fast8_t;
      typedef uint32_t uint_fast16_t;
      typedef uint32_t uint_fast32_t;


        typedef uint64_t uint_fast64_t;
          typedef int64_t intmax_t;
          typedef uint64_t uintmax_t;
    }


#pragma checkout(resume)









namespace std { inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;





typedef long double max_align_t;


} }




#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
    inline void * memcpy (void *x, const void *y, size_t z)
       { return __memcpy(x, y, z); }
    inline int memcmp (const void *x, const void *y, size_t z)
       { return __memcmp(x, y, z); }
    inline void * memset (void *x, int y, size_t z)
       { return __memset(x, y, z); }
    inline char * strcpy (char *x, const char *y)
       { return __strcpy(x, y); }
    inline char * strcat (char *x, const char *y)
       { return __strcat(x, y); }
    inline size_t strlen (const char *x)
       { return __strlen(x); }
    inline int strcmp (const char *x, const char *y)
       { return __strcmp(x, y); }

    }
    extern "C++" {
      inline const void * memchr (const void *x, int y, size_t z)
         { return (const void *) __memchr(x, y, z); }
      inline void * memchr (void *x, int y, size_t z)
         { return __memchr((const void *)x, y, z); }
      inline const char * strchr (const char *s, int c)
         { return (const char *) __strchr(s, c); }
      inline char * strchr (char *s, int c)
         { return __strchr((const char*)s, c); }
      inline const char * strrchr (const char *s, int c)
         { return (const char *) __strrchr(s, c); }
      inline char * strrchr (char *s, int c)
         { return __strrchr((const char*)s, c); }
    }
    extern "C" {
    inline char * strncpy (char *s, const char *x, size_t z)
       { return __strncpy(s, x, z); }
    inline char * strncat (char *s, const char *x, size_t z)
       { return __strncat(s, x, z); }
    inline int strncmp (const char *x, const char *y, size_t z)
       { return __strncmp(x, y, z); }
    int strerror_r (int, char *, size_t);
    void * memmove (void *, const void *, size_t);
    int strcoll (const char *, const char *);
    size_t strcspn (const char *, const char *);
    char * strerror (int);


      char * __strpbrk (const char *, const char *);
      char * __strstr (const char *, const char *);
    }
    extern "C++" {
      inline const char * strpbrk (const char *s1, const char *s2)
         { return __strpbrk(s1, s2); }
      inline char * strpbrk (char *s1, const char *s2)
         { return __strpbrk(s1, s2); }
      inline const char * strstr (const char *s1, const char *s2)
         { return __strstr(s1, s2); }
      inline char * strstr (char *s1, const char *s2)
         { return __strstr(s1, s2); }
    }
    extern "C" {
#pragma map(__strpbrk, "STRPBRK")
#pragma map(__strstr, "STRSTR")




 size_t strspn (const char *, const char *);

    char * strtok (char * , const char * );
    size_t strxfrm (char * ,
                     const char * , size_t);
       void * memccpy (void * ,
                       const void * ,
                       int, size_t);
       char * strdup (const char *);
  char * strtok_r (char *, const char *, char ** );
    }


#pragma checkout(resume)
extern "C++" {
inline __attribute__((__visibility__("hidden"), __always_inline__)) char *__libcpp_strchr(const char *__s,
                                                       int __c) {
  return (char *)strchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const char *
strchr(const char *__s, int __c) {
  return __libcpp_strchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) char *
strchr(char *__s, int __c) {
  return __libcpp_strchr(__s, __c);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) char *__libcpp_strpbrk(const char *__s1,
                                                        const char *__s2) {
  return (char *)strpbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const char *
strpbrk(const char *__s1, const char *__s2) {
  return __libcpp_strpbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) char *
strpbrk(char *__s1, const char *__s2) {
  return __libcpp_strpbrk(__s1, __s2);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) char *__libcpp_strrchr(const char *__s,
                                                        int __c) {
  return (char *)strrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const char *
strrchr(const char *__s, int __c) {
  return __libcpp_strrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) char *
strrchr(char *__s, int __c) {
  return __libcpp_strrchr(__s, __c);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void *__libcpp_memchr(const void *__s, int __c,
                                                       size_t __n) {
  return (void *)memchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const void *
memchr(const void *__s, int __c, size_t __n) {
  return __libcpp_memchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) void *
memchr(void *__s, int __c, size_t __n) {
  return __libcpp_memchr(__s, __c, __n);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) char *__libcpp_strstr(const char *__s1,
                                                       const char *__s2) {
  return (char *)strstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const char *
strstr(const char *__s1, const char *__s2) {
  return __libcpp_strstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) char *
strstr(char *__s1, const char *__s2) {
  return __libcpp_strstr(__s1, __s2);
}
}


namespace std { inline namespace __1 {

using ::size_t;
using ::memcpy;
using ::memmove;
using ::strcpy;
using ::strncpy;
using ::strcat;
using ::strncat;
using ::memcmp;
using ::strcmp;
using ::strncmp;
using ::strcoll;
using ::strxfrm;
using ::memchr;
using ::strchr;
using ::strcspn;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;

using ::strtok;

using ::memset;
using ::strerror;
using ::strlen;

} }


namespace std
{



template <class _Ep> class __attribute__((__visibility__("default"))) initializer_list {
  const _Ep *__begin_;
  size_t __size_;

  __attribute__((__visibility__("hidden"), __always_inline__))

  initializer_list(const _Ep *__b, size_t __s) noexcept : __begin_(__b),
                                                           __size_(__s) {}

public:
  typedef _Ep value_type;
  typedef const _Ep &reference;
  typedef const _Ep &const_reference;
  typedef size_t size_type;

  typedef const _Ep *iterator;
  typedef const _Ep *const_iterator;

  __attribute__((__visibility__("hidden"), __always_inline__))

  initializer_list() noexcept : __begin_(nullptr), __size_(0) {}

  __attribute__((__visibility__("hidden"), __always_inline__))

  size_t size() const noexcept { return __size_; }

  __attribute__((__visibility__("hidden"), __always_inline__))

  const _Ep *begin() const noexcept { return __begin_; }

  __attribute__((__visibility__("hidden"), __always_inline__))

  const _Ep *end() const noexcept { return __begin_ + __size_; }
};

template <class _Ep>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const _Ep *
begin(initializer_list<_Ep> __il) noexcept {
  return __il.begin();
}

template <class _Ep>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const _Ep *
end(initializer_list<_Ep> __il) noexcept {
  return __il.end();
}



}


namespace std { inline namespace __1 {

template <class _T1, class _T2> struct __attribute__((__visibility__("default"))) pair;
template <class _Tp> class __attribute__((__visibility__("default"))) reference_wrapper;
template <class _Tp> struct __attribute__((__visibility__("default"))) hash;

template <class> struct __void_t { typedef void type; };

template <class _Tp> struct __identity { typedef _Tp type; };

template <class _Tp, bool>
struct __attribute__((__visibility__("default"))) __dependent_type : public _Tp {};

template <bool _Bp, class _If, class _Then>
struct __attribute__((__visibility__("default"))) conditional {
  typedef _If type;
};
template <class _If, class _Then>
struct __attribute__((__visibility__("default"))) conditional<false, _If, _Then> {
  typedef _Then type;
};






template <bool, class _Tp> struct __attribute__((__visibility__("default"))) __lazy_enable_if {};
template <class _Tp> struct __attribute__((__visibility__("default"))) __lazy_enable_if<true, _Tp> {
  typedef typename _Tp::type type;
};

template <bool, class _Tp = void> struct __attribute__((__visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__((__visibility__("default"))) enable_if<true, _Tp> {
  typedef _Tp type;
};
template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
addressof(_Tp &__x) noexcept {
  return (_Tp *)&reinterpret_cast<const volatile char &>(__x);
}
struct __two {
  char __lx[2];
};



template <class _Tp, _Tp __v> struct __attribute__((__visibility__("default"))) integral_constant {
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr operator value_type() const noexcept { return value; }




};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;
typedef integral_constant<bool, (true)> true_type;
typedef integral_constant<bool, (false)> false_type;





template <bool _Last, class... _Preds> struct __lazy_and_impl;

template <class... _Preds>
struct __lazy_and_impl<false, _Preds...> : false_type {};

template <> struct __lazy_and_impl<true> : true_type {};

template <class _Pred>
struct __lazy_and_impl<true, _Pred>
    : integral_constant<bool, _Pred::type::value> {};

template <class _Hp, class... _Tp>
struct __lazy_and_impl<true, _Hp, _Tp...>
    : __lazy_and_impl<_Hp::type::value, _Tp...> {};

template <class _P1, class... _Pr>
struct __lazy_and : __lazy_and_impl<_P1::type::value, _Pr...> {};



template <bool _List, class... _Preds> struct __lazy_or_impl;

template <class... _Preds>
struct __lazy_or_impl<true, _Preds...> : true_type {};

template <> struct __lazy_or_impl<false> : false_type {};

template <class _Hp, class... _Tp>
struct __lazy_or_impl<false, _Hp, _Tp...>
    : __lazy_or_impl<_Hp::type::value, _Tp...> {};

template <class _P1, class... _Pr>
struct __lazy_or : __lazy_or_impl<_P1::type::value, _Pr...> {};



template <class _Pred>
struct __lazy_not : integral_constant<bool, !_Pred::type::value> {};


template <class...> struct __and_;
template <> struct __and_<> : true_type {};

template <class _B0> struct __and_<_B0> : _B0 {};

template <class _B0, class _B1>
struct __and_<_B0, _B1> : conditional<_B0::value, _B1, _B0>::type {};

template <class _B0, class _B1, class _B2, class... _Bn>
struct __and_<_B0, _B1, _B2, _Bn...>
    : conditional<_B0::value, __and_<_B1, _B2, _Bn...>, _B0>::type {};


template <class...> struct __or_;
template <> struct __or_<> : false_type {};

template <class _B0> struct __or_<_B0> : _B0 {};

template <class _B0, class _B1>
struct __or_<_B0, _B1> : conditional<_B0::value, _B0, _B1>::type {};

template <class _B0, class _B1, class _B2, class... _Bn>
struct __or_<_B0, _B1, _B2, _Bn...>
    : conditional<_B0::value, _B0, __or_<_B1, _B2, _Bn...>>::type {};


template <class _Tp>
struct __not_ : conditional<_Tp::value, false_type, true_type>::type {};





template <class _Tp>
struct __attribute__((__visibility__("default"))) is_const : public false_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_const<_Tp const> : public true_type {};







template <class _Tp>
struct __attribute__((__visibility__("default"))) is_volatile : public false_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};
template <class _Tp> struct __attribute__((__visibility__("default"))) remove_const {
  typedef _Tp type;
};
template <class _Tp> struct __attribute__((__visibility__("default"))) remove_const<const _Tp> {
  typedef _Tp type;
};






template <class _Tp> struct __attribute__((__visibility__("default"))) remove_volatile {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) remove_volatile<volatile _Tp> {
  typedef _Tp type;
};







template <class _Tp> struct __attribute__((__visibility__("default"))) remove_cv {
  typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;
};






template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};







template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <>
struct __libcpp_is_integral<unsigned long long> : public true_type {};





template <class _Tp>
struct __attribute__((__visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <>
struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_array : public false_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_array<_Tp[]> : public true_type {};
template <class _Tp, size_t _Np>
struct __attribute__((__visibility__("default"))) is_array<_Tp[_Np]> : public true_type {};







template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp *> : public true_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_lvalue_reference<_Tp &> : public true_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_rvalue_reference : public false_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_rvalue_reference<_Tp &&> : public true_type {};


template <class _Tp>
struct __attribute__((__visibility__("default"))) is_reference : public false_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_reference<_Tp &> : public true_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_reference<_Tp &&> : public true_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
template <class _Tp, class _Up>
struct __attribute__((__visibility__("default"))) is_same : public false_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};
namespace __libcpp_is_function_imp {
struct __dummy_type {};
template <class _Tp> char __test(_Tp *);
template <class _Tp> char __test(__dummy_type);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp &__source(int);
template <class _Tp> __dummy_type __source(...);
}

template <class _Tp, bool = is_class<_Tp>::value || is_union<_Tp>::value ||
                            is_void<_Tp>::value || is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value>
struct __libcpp_is_function
    : public integral_constant<
          bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(
                    __libcpp_is_function_imp::__source<_Tp>(0))) == 1> {};
template <class _Tp>
struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_function : public __libcpp_is_function<_Tp> {};
template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp {

};

template <class _Tp>
struct __libcpp_is_member_function_pointer : public false_type {};

template <class _Ret, class _Class>
struct __libcpp_is_member_function_pointer<_Ret _Class::*>
    : public is_function<_Ret> {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<
          typename remove_cv<_Tp>::type>::type {};
template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up>
struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool,
                               is_member_pointer<_Tp>::value &&
                                   !is_member_function_pointer<_Tp>::value> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                         is_floating_point<_Tp>::value> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                         __is_nullptr_t<_Tp>::value ||
                                         is_arithmetic<_Tp>::value> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_scalar
    : public integral_constant<
          bool, is_arithmetic<_Tp>::value || is_member_pointer<_Tp>::value ||
                    is_pointer<_Tp>::value || __is_nullptr_t<_Tp>::value ||
                    is_enum<_Tp>::value> {};

template <>
struct __attribute__((__visibility__("default"))) is_scalar<nullptr_t> : public true_type {};







template <class _Tp>
struct __attribute__((__visibility__("default"))) is_object
    : public integral_constant<
          bool, is_scalar<_Tp>::value || is_array<_Tp>::value ||
                    is_union<_Tp>::value || is_class<_Tp>::value> {};







template <class _Tp>
struct __attribute__((__visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
struct __is_referenceable_impl {
  template <class _Tp> static _Tp &__test(int);
  template <class _Tp> static __two __test(...);
};

template <class _Tp>
struct __is_referenceable
    : integral_constant<
          bool, !is_same<decltype(__is_referenceable_impl::__test<_Tp>(0)),
                         __two>::value> {};



template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value || is_const<_Tp>::value>
struct __add_const {
  typedef _Tp type;
};

template <class _Tp> struct __add_const<_Tp, false> { typedef const _Tp type; };

template <class _Tp> struct __attribute__((__visibility__("default"))) add_const {
  typedef typename __add_const<_Tp>::type type;
};







template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value || is_volatile<_Tp>::value>
struct __add_volatile {
  typedef _Tp type;
};

template <class _Tp> struct __add_volatile<_Tp, false> {
  typedef volatile _Tp type;
};

template <class _Tp> struct __attribute__((__visibility__("default"))) add_volatile {
  typedef typename __add_volatile<_Tp>::type type;
};







template <class _Tp> struct __attribute__((__visibility__("default"))) add_cv {
  typedef typename add_const<typename add_volatile<_Tp>::type>::type type;
};







template <class _Tp> struct __attribute__((__visibility__("default"))) remove_reference {
  typedef _Tp type;
};
template <class _Tp> struct __attribute__((__visibility__("default"))) remove_reference<_Tp &> {
  typedef _Tp type;
};

template <class _Tp> struct __attribute__((__visibility__("default"))) remove_reference<_Tp &&> {
  typedef _Tp type;
};
template <class _Tp, bool = __is_referenceable<_Tp>::value>
struct __add_lvalue_reference_impl {
  typedef _Tp type;
};
template <class _Tp> struct __add_lvalue_reference_impl<_Tp, true> {
  typedef _Tp &type;
};

template <class _Tp> struct __attribute__((__visibility__("default"))) add_lvalue_reference {
  typedef typename __add_lvalue_reference_impl<_Tp>::type type;
};
template <class _Tp, bool = __is_referenceable<_Tp>::value>
struct __add_rvalue_reference_impl {
  typedef _Tp type;
};
template <class _Tp> struct __add_rvalue_reference_impl<_Tp, true> {
  typedef _Tp &&type;
};

template <class _Tp> struct __attribute__((__visibility__("default"))) add_rvalue_reference {
  typedef typename __add_rvalue_reference_impl<_Tp>::type type;
};
template <class _Tp> _Tp &&__declval(int);
template <class _Tp> _Tp __declval(long);

template <class _Tp> decltype(std::__1::__declval<_Tp>(0)) declval() noexcept;
template <class _Tp> struct __uncvref {
  typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp> struct __unconstref {
  typedef
      typename remove_const<typename remove_reference<_Tp>::type>::type type;
};


template <class _Tp> using __uncvref_t = typename __uncvref<_Tp>::type;




template <class _Tp, class _Up>
struct __is_same_uncvref
    : is_same<typename __uncvref<_Tp>::type, typename __uncvref<_Up>::type> {};

struct __any {
  __any(...);
};



template <class _Tp> struct __attribute__((__visibility__("default"))) remove_pointer {
  typedef _Tp type;
};
template <class _Tp> struct __attribute__((__visibility__("default"))) remove_pointer<_Tp *> {
  typedef _Tp type;
};
template <class _Tp> struct __attribute__((__visibility__("default"))) remove_pointer<_Tp *const> {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) remove_pointer<_Tp *volatile> {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) remove_pointer<_Tp *const volatile> {
  typedef _Tp type;
};
template <class _Tp, bool = __is_referenceable<_Tp>::value ||
                            is_same<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl {
  typedef typename remove_reference<_Tp>::type *type;
};
template <class _Tp> struct __add_pointer_impl<_Tp, false> {
  typedef _Tp type;
};

template <class _Tp> struct __attribute__((__visibility__("default"))) add_pointer {
  typedef typename __add_pointer_impl<_Tp>::type type;
};







template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl
    : public integral_constant<bool, (_Tp(-1) < _Tp(0))> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp>
struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};







template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl
    : public integral_constant<bool, (_Tp(0) < _Tp(-1))> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp>
struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) rank : public integral_constant<size_t, 0> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np>
struct __attribute__((__visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};







template <class _Tp, unsigned _Ip = 0>
struct __attribute__((__visibility__("default"))) extent : public integral_constant<size_t, 0> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip>
struct __attribute__((__visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip - 1>::value> {};
template <class _Tp, size_t _Np>
struct __attribute__((__visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip>
struct __attribute__((__visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip - 1>::value> {};
template <class _Tp> struct __attribute__((__visibility__("default"))) remove_extent {
  typedef _Tp type;
};
template <class _Tp> struct __attribute__((__visibility__("default"))) remove_extent<_Tp[]> {
  typedef _Tp type;
};
template <class _Tp, size_t _Np>
struct __attribute__((__visibility__("default"))) remove_extent<_Tp[_Np]> {
  typedef _Tp type;
};







template <class _Tp> struct __attribute__((__visibility__("default"))) remove_all_extents {
  typedef _Tp type;
};
template <class _Tp> struct __attribute__((__visibility__("default"))) remove_all_extents<_Tp[]> {
  typedef typename remove_all_extents<_Tp>::type type;
};
template <class _Tp, size_t _Np>
struct __attribute__((__visibility__("default"))) remove_all_extents<_Tp[_Np]> {
  typedef typename remove_all_extents<_Tp>::type type;
};
template <class _Tp> struct __attribute__((__visibility__("default"))) decay {
private:
  typedef typename remove_reference<_Tp>::type _Up;

public:
  typedef typename conditional<
      is_array<_Up>::value, typename remove_extent<_Up>::type *,
      typename conditional<is_function<_Up>::value,
                           typename add_pointer<_Up>::type,
                           typename remove_cv<_Up>::type>::type>::type type;
};







namespace __is_abstract_imp {
template <class _Tp> char __test(_Tp (*)[1]);
template <class _Tp> __two __test(...);
}

template <class _Tp, bool = is_class<_Tp>::value>
struct __libcpp_abstract
    : public integral_constant<bool,
                               sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {
};

template <class _Tp>
struct __libcpp_abstract<_Tp, false> : public false_type {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_abstract : public __libcpp_abstract<_Tp> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) __libcpp_is_final
    : public integral_constant<bool, __is_final(_Tp)> {};
template <class _Bp, class _Dp>
struct __attribute__((__visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
template <class _T1, class _T2>
struct __attribute__((__visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                         !is_abstract<_T2>::value> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};
template <class _Hp, class _Tp> struct __type_list {
  typedef _Hp _Head;
  typedef _Tp _Tail;
};

struct __nat {

  __nat() = delete;
  __nat(const __nat &) = delete;
  __nat &operator=(const __nat &) = delete;
  ~__nat() = delete;

};

template <class _Tp> struct __align_type {
  static const size_t value = alignment_of<_Tp>::value;
  typedef _Tp type;
};

struct __struct_double {
  long double __lx;
};
struct __struct_double4 {
  double __lx[4];
};

typedef __type_list<
    __align_type<unsigned char>,
    __type_list<
        __align_type<unsigned short>,
        __type_list<
            __align_type<unsigned int>,
            __type_list<
                __align_type<unsigned long>,
                __type_list<
                    __align_type<unsigned long long>,
                    __type_list<
                        __align_type<double>,
                        __type_list<
                            __align_type<long double>,
                            __type_list<
                                __align_type<__struct_double>,
                                __type_list<__align_type<__struct_double4>,
                                            __type_list<__align_type<int *>,
                                                        __nat>>>>>>>>>>
    __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align> {
  typedef typename conditional<_Align == _Hp::value, typename _Hp::type,
                               void>::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align> {
  typedef
      typename conditional<_Align == _Hp::value, typename _Hp::type,
                           typename __find_pod<_Tp, _Align>::type>::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len>
    : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2> struct __select_align {
private:
  static const size_t __min = _A2 < _A1 ? _A2 : _A1;
  static const size_t __max = _A1 < _A2 ? _A2 : _A1;

public:
  static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<
          size_t, __select_align<_Len, _Hp::value,
                                 __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len,
          size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__((__visibility__("default"))) aligned_storage {
  typedef typename __find_pod<__all_types, _Align>::type _Aligner;
  static_assert(!is_void<_Aligner>::value, "");
  union type {
    _Aligner __align;
    unsigned char __data[(_Len + _Align - 1) / _Align * _Align];
  };
};
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x1> { struct alignas(0x1) type { unsigned char __lx[(_Len + 0x1 - 1) / 0x1 * 0x1]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x2> { struct alignas(0x2) type { unsigned char __lx[(_Len + 0x2 - 1) / 0x2 * 0x2]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x4> { struct alignas(0x4) type { unsigned char __lx[(_Len + 0x4 - 1) / 0x4 * 0x4]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x8> { struct alignas(0x8) type { unsigned char __lx[(_Len + 0x8 - 1) / 0x8 * 0x8]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x10> { struct alignas(0x10) type { unsigned char __lx[(_Len + 0x10 - 1) / 0x10 * 0x10]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x20> { struct alignas(0x20) type { unsigned char __lx[(_Len + 0x20 - 1) / 0x20 * 0x20]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x40> { struct alignas(0x40) type { unsigned char __lx[(_Len + 0x40 - 1) / 0x40 * 0x40]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x80> { struct alignas(0x80) type { unsigned char __lx[(_Len + 0x80 - 1) / 0x80 * 0x80]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x100> { struct alignas(0x100) type { unsigned char __lx[(_Len + 0x100 - 1) / 0x100 * 0x100]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x200> { struct alignas(0x200) type { unsigned char __lx[(_Len + 0x200 - 1) / 0x200 * 0x200]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x400> { struct alignas(0x400) type { unsigned char __lx[(_Len + 0x400 - 1) / 0x400 * 0x400]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x800> { struct alignas(0x800) type { unsigned char __lx[(_Len + 0x800 - 1) / 0x800 * 0x800]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x1000> { struct alignas(0x1000) type { unsigned char __lx[(_Len + 0x1000 - 1) / 0x1000 * 0x1000]; }; };
template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x2000> { struct alignas(0x2000) type { unsigned char __lx[(_Len + 0x2000 - 1) / 0x2000 * 0x2000]; }; };


template <size_t _Len> struct __attribute__((__visibility__("default"))) aligned_storage<_Len, 0x4000> { struct alignas(0x4000) type { unsigned char __lx[(_Len + 0x4000 - 1) / 0x4000 * 0x4000]; }; };
template <size_t _I0, size_t... _In> struct __static_max;

template <size_t _I0> struct __static_max<_I0> {
  static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t... _In>
struct __static_max<_I0, _I1, _In...> {
  static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value
                                         : __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class... _Types> struct aligned_union {
  static const size_t alignment_value =
      __static_max<__alignof__(_Type0), __alignof__(_Types)...>::value;
  static const size_t __len =
      __static_max<_Len, sizeof(_Type0), sizeof(_Types)...>::value;
  typedef typename aligned_storage<__len, alignment_value>::type type;
};
template <class _Tp> struct __numeric_type {
  static void __test(...);
  static float __test(float);
  static double __test(char);
  static double __test(int);
  static double __test(unsigned);
  static double __test(long);
  static double __test(unsigned long);
  static double __test(long long);
  static double __test(unsigned long long);
  static double __test(double);
  static long double __test(long double);

  typedef decltype(__test(declval<_Tp>())) type;
  static const bool value = !is_same<type, void>::value;
};

template <> struct __numeric_type<void> { static const bool value = true; };



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&__numeric_type<_A2>::value
              &&__numeric_type<_A3>::value>
class __promote_imp {
public:
  static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;
  typedef typename __promote_imp<_A3>::type __type3;

public:
  typedef decltype(__type1() + __type2() + __type3()) type;
  static const bool value = true;
};

template <class _A1, class _A2> class __promote_imp<_A1, _A2, void, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;

public:
  typedef decltype(__type1() + __type2()) type;
  static const bool value = true;
};

template <class _A1> class __promote_imp<_A1, void, void, true> {
public:
  typedef typename __numeric_type<_A1>::type type;
  static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};



typedef __type_list<
    signed char,
    __type_list<
        signed short,
        __type_list<signed int,
                    __type_list<signed long, __type_list<signed long long,



                                                                     __nat



                                                         >>>>>
    __signed_types;

typedef __type_list<
    unsigned char,
    __type_list<unsigned short,
                __type_list<unsigned int,
                            __type_list<unsigned long,
                                        __type_list<unsigned long long,



                                                                __nat



                                                    >>>>>
    __unsigned_types;

template <class _TypeList, size_t _Size,
          bool = _Size <= sizeof(typename _TypeList::_Head)>
struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true> {
  typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false> {
  typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up,
          bool = is_const<typename remove_reference<_Tp>::type>::value,
          bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv {
  typedef _Up type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, true, false> {
  typedef const _Up type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, false, true> {
  typedef volatile _Up type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, true, true> {
  typedef const volatile _Up type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, false, false> {
  typedef _Up &type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, true, false> {
  typedef const _Up &type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, false, true> {
  typedef volatile _Up &type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, true, true> {
  typedef const volatile _Up &type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp> struct __make_signed<_Tp, true> {
  typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed<signed short, true> { typedef short type; };
template <> struct __make_signed<unsigned short, true> { typedef short type; };
template <> struct __make_signed<signed int, true> { typedef int type; };
template <> struct __make_signed<unsigned int, true> { typedef int type; };
template <> struct __make_signed<signed long, true> { typedef long type; };
template <> struct __make_signed<unsigned long, true> { typedef long type; };
template <> struct __make_signed<signed long long, true> {
  typedef long long type;
};
template <> struct __make_signed<unsigned long long, true> {
  typedef long long type;
};







template <class _Tp> struct __attribute__((__visibility__("default"))) make_signed {
  typedef typename __apply_cv<
      _Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type
      type;
};





template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp> struct __make_unsigned<_Tp, true> {
  typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned<signed short, true> {
  typedef unsigned short type;
};
template <> struct __make_unsigned<unsigned short, true> {
  typedef unsigned short type;
};
template <> struct __make_unsigned<signed int, true> {
  typedef unsigned int type;
};
template <> struct __make_unsigned<unsigned int, true> {
  typedef unsigned int type;
};
template <> struct __make_unsigned<signed long, true> {
  typedef unsigned long type;
};
template <> struct __make_unsigned<unsigned long, true> {
  typedef unsigned long type;
};
template <> struct __make_unsigned<signed long long, true> {
  typedef unsigned long long type;
};
template <> struct __make_unsigned<unsigned long long, true> {
  typedef unsigned long long type;
};
template <class _Tp> struct __attribute__((__visibility__("default"))) make_unsigned {
  typedef typename __apply_cv<
      _Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type
      type;
};
template <class... _Tp> struct __attribute__((__visibility__("default"))) common_type {};



template <class _Tp> struct __attribute__((__visibility__("default"))) common_type<_Tp> {
  typedef typename decay<_Tp>::type type;
};



template <class _Tp, class _Up, class = void> struct __common_type2 {};

template <class _Tp, class _Up>
struct __common_type2<
    _Tp, _Up, typename __void_t<decltype(true ? std::__1::declval<_Tp>()
                                              : std::__1::declval<_Up>())>::type> {
  typedef typename decay<decltype(true ? std::__1::declval<_Tp>()
                                       : std::__1::declval<_Up>())>::type type;
};

template <class _Tp, class _Up>
struct __attribute__((__visibility__("default"))) common_type<_Tp, _Up> : __common_type2<_Tp, _Up> {
};



template <class... Tp> struct __common_types;

template <class, class = void> struct __common_type_impl {};

template <class _Tp, class _Up, class... _Vp>
struct __common_type_impl<
    __common_types<_Tp, _Up, _Vp...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type> {
  typedef typename common_type<typename common_type<_Tp, _Up>::type,
                               _Vp...>::type type;
};

template <class _Tp, class _Up, class... _Vp>
struct __attribute__((__visibility__("default"))) common_type<_Tp, _Up, _Vp...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp...>> {};
template <typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<
    decltype((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type
__is_assignable_test(int);

template <class, class> false_type __is_assignable_test(...);

template <class _Tp, class _Arg,
          bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public decltype((std::__1::__is_assignable_test<_Tp, _Arg>(0))) {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true> : public false_type {};

template <class _Tp, class _Arg>
struct is_assignable : public __is_assignable_imp<_Tp, _Arg> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_copy_assignable
    : public is_assignable<
          typename add_lvalue_reference<_Tp>::type,
          typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_move_assignable

    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type> {
};
template <class> struct __is_destructible_apply { typedef int type; };

template <typename _Tp> struct __is_destructor_wellformed {
  template <typename _Tp1>
  static char __test(typename __is_destructible_apply<
                     decltype(std::__1::declval<_Tp1 &>().~_Tp1())>::type);

  template <typename _Tp1> static __two __test(...);

  static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool> struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
    : public std::__1::integral_constant<
          bool, __is_destructor_wellformed<
                    typename std::__1::remove_all_extents<_Tp>::type>::value> {};

template <class _Tp>
struct __destructible_imp<_Tp, true> : public std::__1::true_type {};

template <class _Tp, bool> struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false>
    : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__1::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]> : public std::__1::false_type {};

template <> struct is_destructible<void> : public std::__1::false_type {};
template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    typename remove_reference<_Tp>::type &&
    move(_Tp &&__t) noexcept {
  typedef typename remove_reference<_Tp>::type _Up;
  return static_cast<_Up &&>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr _Tp &&
forward(typename remove_reference<_Tp>::type &__t) noexcept {
  return static_cast<_Tp &&>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr _Tp &&
forward(typename remove_reference<_Tp>::type &&__t) noexcept {
  static_assert(!is_lvalue_reference<_Tp>::value,
                "can not forward an rvalue as an lvalue");
  return static_cast<_Tp &&>(__t);
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename decay<_Tp>::type
__decay_copy(_Tp &&__t) {
  return std::__1::forward<_Tp>(__t);
}
template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true,
                                   false> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true,
                                   false> {
  typedef _Class const _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true,
                                   false> {
  typedef _Class const _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true,
                                   false> {
  typedef _Class volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile,
                                   true, false> {
  typedef _Class volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile,
                                   true, false> {
  typedef _Class const volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<
    _Rp (_Class::*)(_Param..., ...) const volatile, true, false> {
  typedef _Class const volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};




template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false> {
  typedef _Class &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true,
                                   false> {
  typedef _Class &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const &, true,
                                   false> {
  typedef _Class const &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const &,
                                   true, false> {
  typedef _Class const &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile &, true,
                                   false> {
  typedef _Class volatile &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile &,
                                   true, false> {
  typedef _Class volatile &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile &,
                                   true, false> {
  typedef _Class const volatile &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<
    _Rp (_Class::*)(_Param..., ...) const volatile &, true, false> {
  typedef _Class const volatile &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false> {
  typedef _Class &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true,
                                   false> {
  typedef _Class &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const &&, true,
                                   false> {
  typedef _Class const &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const &&,
                                   true, false> {
  typedef _Class const &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile &&, true,
                                   false> {
  typedef _Class volatile &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile &&,
                                   true, false> {
  typedef _Class volatile &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile &&,
                                   true, false> {
  typedef _Class const volatile &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<
    _Rp (_Class::*)(_Param..., ...) const volatile &&, true, false> {
  typedef _Class const volatile &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                                         is_member_function_pointer<_MP>::value,
                                         is_member_object_pointer<_MP>::value> {



};

template <class _DecayedFp> struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};



template <class _Callable> class result_of;
namespace __is_construct {
struct __nat {};
}



template <class _Tp, class... _Args>
struct __attribute__((__visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp, typename add_lvalue_reference<
                                       typename add_const<_Tp>::type>::type> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_move_constructible

    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>



{
};
template <class _Tp, class... _Args>
struct __attribute__((__visibility__("default"))) is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<
          _Tp, typename add_lvalue_reference<const _Tp>::type> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_trivially_move_constructible

    : public is_trivially_constructible<
          _Tp, typename add_rvalue_reference<_Tp>::type>



{
};
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<
          typename add_lvalue_reference<_Tp>::type,
          typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,

                                     typename add_rvalue_reference<_Tp>::type>



{
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_trivially_destructible
    : public integral_constant<
          bool, is_destructible<_Tp>::value &&__has_trivial_destructor(_Tp)> {};
template <bool, bool, class _Tp, class... _Args>
struct __libcpp_is_nothrow_constructible;

template <class _Tp, class... _Args>
struct __libcpp_is_nothrow_constructible< true,
                                                          false, _Tp, _Args...>
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))> {};

template <class _Tp> void __implicit_conversion_to(_Tp) noexcept {}

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_constructible< true,
                                                          true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(__implicit_conversion_to<_Tp>(
                                         declval<_Arg>()))> {};

template <class _Tp, bool _IsReference, class... _Args>
struct __libcpp_is_nothrow_constructible< false,
                                         _IsReference, _Tp, _Args...>
    : public false_type {};

template <class _Tp, class... _Args>
struct __attribute__((__visibility__("default"))) is_nothrow_constructible
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value,
                                        is_reference<_Tp>::value, _Tp,
                                        _Args...> {};

template <class _Tp, size_t _Ns>
struct __attribute__((__visibility__("default"))) is_nothrow_constructible<_Tp[_Ns]>
    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value,
                                        is_reference<_Tp>::value, _Tp> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<
          _Tp,
          typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_nothrow_move_constructible

    : public is_nothrow_constructible<_Tp,
                                      typename add_rvalue_reference<_Tp>::type>



{
};
template <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<false, _Tp, _Arg> : public false_type {};

template <class _Tp, class _Arg>
struct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>() =
                                                  std::__1::declval<_Arg>())> {};

template <class _Tp, class _Arg>
struct __attribute__((__visibility__("default"))) is_nothrow_assignable
    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value,
                                            _Tp, _Arg> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<
          typename add_lvalue_reference<_Tp>::type,
          typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,

                                   typename add_rvalue_reference<_Tp>::type>



{
};
template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp> : public false_type {};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool, noexcept(std::__1::declval<_Tp>().~_Tp())> {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value,
                                              _Tp> {};

template <class _Tp, size_t _Ns>
struct __attribute__((__visibility__("default"))) is_nothrow_destructible<_Tp[_Ns]>
    : public is_nothrow_destructible<_Tp> {};

template <class _Tp>
struct __attribute__((__visibility__("default"))) is_nothrow_destructible<_Tp &> : public true_type {
};



template <class _Tp>
struct __attribute__((__visibility__("default"))) is_nothrow_destructible<_Tp &&>
    : public true_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_literal_type

    : public integral_constant<bool, __is_literal(_Tp)>





{
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>




{
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>







{
};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>





{
};






template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp>
struct __is_reference_wrapper_impl<reference_wrapper<_Tp>> : public true_type {
};
template <class _Tp>
struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};





template <class... _Tp> struct __check_complete;

template <> struct __check_complete<> {};

template <class _Hp, class _T0, class... _Tp>
struct __check_complete<_Hp, _T0, _Tp...>
    : private __check_complete<_Hp>, private __check_complete<_T0, _Tp...> {};

template <class _Hp>
struct __check_complete<_Hp, _Hp> : private __check_complete<_Hp> {};

template <class _Tp> struct __check_complete<_Tp> {
  static_assert(sizeof(_Tp) > 0, "Type must be complete.");
};

template <class _Tp>
struct __check_complete<_Tp &> : private __check_complete<_Tp> {};

template <class _Tp>
struct __check_complete<_Tp &&> : private __check_complete<_Tp> {};

template <class _Rp, class... _Param>
struct __check_complete<_Rp (*)(_Param...)> : private __check_complete<_Rp> {};

template <class... _Param> struct __check_complete<void (*)(_Param...)> {};

template <class _Rp, class... _Param>
struct __check_complete<_Rp(_Param...)> : private __check_complete<_Rp> {};

template <class... _Param> struct __check_complete<void(_Param...)> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...)>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const &>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile &>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile &>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) &&>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const &&>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) volatile &&>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class, class... _Param>
struct __check_complete<_Rp (_Class::*)(_Param...) const volatile &&>
    : private __check_complete<_Class> {};

template <class _Rp, class _Class>
struct __check_complete<_Rp _Class::*> : private __check_complete<_Class> {};

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 =
    typename enable_if<is_member_function_pointer<_DecayFp>::value &&
                       is_base_of<_ClassT, _DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 =
    typename enable_if<is_member_function_pointer<_DecayFp>::value &&
                       __is_reference_wrapper<_DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 =
    typename enable_if<is_member_function_pointer<_DecayFp>::value &&
                       !is_base_of<_ClassT, _DecayA0>::value &&
                       !__is_reference_wrapper<_DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 =
    typename enable_if<is_member_object_pointer<_DecayFp>::value &&
                       is_base_of<_ClassT, _DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 =
    typename enable_if<is_member_object_pointer<_DecayFp>::value &&
                       __is_reference_wrapper<_DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 =
    typename enable_if<is_member_object_pointer<_DecayFp>::value &&
                       !is_base_of<_ClassT, _DecayA0>::value &&
                       !__is_reference_wrapper<_DecayA0>::value>::type;
template <class... _Args> auto __invoke(__any, _Args &&... __args) -> __nat;

template <class... _Args>
auto __invoke_constexpr(__any, _Args &&... __args) -> __nat;



template <class _Fp, class _A0, class... _Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__((__visibility__("hidden"), __always_inline__)) auto __invoke(_Fp &&__f, _A0 &&__a0,
                                               _Args &&... __args)
    noexcept(noexcept((std::__1::forward<_A0>(__a0).* __f)(std::__1::forward<_Args>(__args)...)))->decltype((std::__1::forward<_A0>(__a0).* __f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).* __f)(std::__1::forward<_Args>(__args)...); }


        template <class _Fp, class _A0, class... _Args,
                  class = __enable_if_bullet1<_Fp, _A0>>
        inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    auto __invoke_constexpr(_Fp &&__f, _A0 &&__a0, _Args &&... __args)
        noexcept(noexcept((std::__1::forward<_A0>(__a0).* __f)(std::__1::forward<_Args>(__args)...)))->decltype((std::__1::forward<_A0>(__a0).* __f)(std::__1::forward<_Args>(__args)...)) { return (std::__1::forward<_A0>(__a0).* __f)(std::__1::forward<_Args>(__args)...); }


            template <class _Fp, class _A0, class... _Args,
                      class = __enable_if_bullet2<_Fp, _A0>>
            inline __attribute__((__visibility__("hidden"), __always_inline__))
    auto __invoke(_Fp &&__f, _A0 &&__a0, _Args &&... __args)
        noexcept(noexcept((__a0.get().* __f)(std::__1::forward<_Args>(__args)...)))->decltype((__a0.get().* __f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().* __f)(std::__1::forward<_Args>(__args)...); }


            template <class _Fp, class _A0, class... _Args,
                      class = __enable_if_bullet2<_Fp, _A0>>
            inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    auto __invoke_constexpr(_Fp &&__f, _A0 &&__a0, _Args &&... __args)
        noexcept(noexcept((__a0.get().* __f)(std::__1::forward<_Args>(__args)...)))->decltype((__a0.get().* __f)(std::__1::forward<_Args>(__args)...)) { return (__a0.get().* __f)(std::__1::forward<_Args>(__args)...); }


            template <class _Fp, class _A0, class... _Args,
                      class = __enable_if_bullet3<_Fp, _A0>>
            inline __attribute__((__visibility__("hidden"), __always_inline__))
    auto __invoke(_Fp &&__f, _A0 &&__a0, _Args &&... __args)
        noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).* __f)(std::__1::forward<_Args>(__args)...)))->decltype(((*std::__1::forward<_A0>(__a0)).* __f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).* __f)(std::__1::forward<_Args>(__args)...); }


            template <class _Fp, class _A0, class... _Args,
                      class = __enable_if_bullet3<_Fp, _A0>>
            inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    auto __invoke_constexpr(_Fp &&__f, _A0 &&__a0, _Args &&... __args)
        noexcept(noexcept(((*std::__1::forward<_A0>(__a0)).* __f)(std::__1::forward<_Args>(__args)...)))->decltype(((*std::__1::forward<_A0>(__a0)).* __f)(std::__1::forward<_Args>(__args)...)) { return ((*std::__1::forward<_A0>(__a0)).* __f)(std::__1::forward<_Args>(__args)...); }




    template <class _Fp, class _A0, class = __enable_if_bullet4<_Fp, _A0>>
    inline __attribute__((__visibility__("hidden"), __always_inline__))
    auto __invoke(_Fp &&__f,
                  _A0 &&__a0) noexcept(noexcept(std::__1::forward<_A0>(__a0).* __f))->decltype(std::__1::forward<_A0>(__a0).* __f) { return std::__1::forward<_A0>(__a0).* __f; }


        template <class _Fp, class _A0, class = __enable_if_bullet4<_Fp, _A0>>
        inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    auto __invoke_constexpr(_Fp &&__f, _A0 &&__a0) noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f))->decltype(std::__1::forward<_A0>(__a0).*__f) { return std::__1::forward<_A0>(__a0).*__f; }


        template <class _Fp, class _A0, class = __enable_if_bullet5<_Fp, _A0>>
        inline __attribute__((__visibility__("hidden"), __always_inline__))
    auto __invoke(_Fp &&__f, _A0 &&__a0) noexcept(noexcept(__a0.get().*__f))->decltype(__a0.get().*__f) { return __a0.get().*__f; }

        template <class _Fp, class _A0, class = __enable_if_bullet5<_Fp, _A0>>
        inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    auto __invoke_constexpr(_Fp &&__f,
                            _A0 &&__a0) noexcept(noexcept(__a0.get().*__f))->decltype(__a0.get().*__f) { return __a0.get().*__f; }

        template <class _Fp, class _A0, class = __enable_if_bullet6<_Fp, _A0>>
        inline __attribute__((__visibility__("hidden"), __always_inline__))
    auto __invoke(_Fp &&__f, _A0 &&__a0) noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f))->decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }


        template <class _Fp, class _A0, class = __enable_if_bullet6<_Fp, _A0>>
        inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    auto __invoke_constexpr(_Fp &&__f, _A0 &&__a0)
        noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f))->decltype((*std::__1::forward<_A0>(__a0)).*__f) { return (*std::__1::forward<_A0>(__a0)).*__f; }



    template <class _Fp, class... _Args>
    inline __attribute__((__visibility__("hidden"), __always_inline__))
    auto __invoke(_Fp &&__f, _Args &&... __args) noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)))->decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }


        template <class _Fp, class... _Args>
        inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    auto __invoke_constexpr(_Fp &&__f, _Args &&... __args)
        noexcept(noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)))->decltype(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) { return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...); }






    template <class _Ret, class _Fp, class... _Args>
    struct __invokable_r : private __check_complete<_Fp> {
  using _Result = decltype(
      std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));

  static const bool value =
      conditional<!is_same<_Result, __nat>::value,
                  typename conditional<is_void<_Ret>::value, true_type,
                                       is_convertible<_Result, _Ret>>::type,
                  false_type>::type::value;
};

template <class _Fp, class... _Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp,
          class... _Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...> {
  typedef __nothrow_invokable_r_imp _ThisT;

  template <class _Tp> static void __test_noexcept(_Tp) noexcept;

  static const bool value = noexcept(_ThisT::__test_noexcept<_Ret>(
      std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...)));
};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...> {
  static const bool value = noexcept(
      std::__1::__invoke(std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));
};

template <class _Ret, class _Fp, class... _Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<__invokable_r<_Ret, _Fp, _Args...>::value,
                              is_void<_Ret>::value, _Ret, _Fp, _Args...>;

template <class _Fp, class... _Args>
struct __invoke_of
    : public enable_if<__invokable<_Fp, _Args...>::value,
                       typename __invokable_r<void, _Fp, _Args...>::_Result> {};



template <class _Fp, class... _Args>
class __attribute__((__visibility__("default"))) result_of<_Fp(_Args...)>
    : public __invoke_of<_Fp, _Args...> {};
template <class _Tp, bool _NotVoid = !is_void<_Tp>::value>
struct __is_swappable;
template <class _Tp, bool _NotVoid = !is_void<_Tp>::value>
struct __is_nothrow_swappable;

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))

    typename enable_if<is_move_constructible<_Tp>::value &&
                       is_move_assignable<_Tp>::value>::type



    swap(_Tp &__x, _Tp &__y)
        noexcept(is_nothrow_move_constructible<_Tp>::value &&is_nothrow_move_assignable<_Tp>::value) {

  _Tp __t(std::__1::move(__x));
  __x = std::__1::move(__y);
  __y = std::__1::move(__t);
}

template <class _Tp, size_t _Np>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Np],
                                                              _Tp (&__b)[_Np])
        noexcept(__is_nothrow_swappable<_Tp>::value);

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void iter_swap(_ForwardIterator1 __a,
                                                _ForwardIterator2 __b)

    noexcept(noexcept(swap(*std::__1::declval<_ForwardIterator1>(), *std::__1::declval<_ForwardIterator2>()))) {

  swap(*__a, *__b);
}



namespace __detail {



template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with {
  template <class _LHS, class _RHS>
  static decltype(swap(std::__1::declval<_LHS>(), std::__1::declval<_RHS>()))
  __test_swap(int);
  template <class, class> static __nat __test_swap(long);


  typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
  typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

  static const bool value =
      !is_same<__swap1, __nat>::value && !is_same<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp,
          bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::__1::declval<_Tp>(), std::__1::declval<_Up>())) &&
      noexcept(swap(std::__1::declval<_Up>(), std::__1::declval<_Tp>()));



};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

}

template <class _Tp, bool _NotVoid>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp &>::value> {
};

template <class _Tp> struct __is_swappable<_Tp, false> : false_type {};

template <class _Tp, bool _NotVoid>
struct __is_nothrow_swappable
    : public integral_constant<
          bool, __detail::__nothrow_swappable_with<_Tp &>::value> {};

template <class _Tp> struct __is_nothrow_swappable<_Tp, false> : false_type {};
template <class _Tp> struct underlying_type {
  typedef __underlying_type(_Tp) type;
};
template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type {
  typedef typename underlying_type<_Tp>::type type;
  typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp> struct __sfinae_underlying_type<_Tp, false> {};

inline __attribute__((__visibility__("hidden"), __always_inline__)) int __convert_to_integral(int __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) unsigned
__convert_to_integral(unsigned __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) long __convert_to_integral(long __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long
__convert_to_integral(unsigned long __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) long long
__convert_to_integral(long long __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long long
__convert_to_integral(unsigned long long __val) {
  return __val;
}
template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename __sfinae_underlying_type<_Tp>::__promoted_type
    __convert_to_integral(_Tp __val) {
  return __val;
}



template <class _Tp> struct __has_operator_addressof_member_imp {
  template <class _Up>
  static auto __test(int) ->
      typename __select_2nd<decltype(std::__1::declval<_Up>().operator&()),
                            true_type>::type;
  template <class> static auto __test(long) -> false_type;

  static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp> struct __has_operator_addressof_free_imp {
  template <class _Up>
  static auto __test(int) ->
      typename __select_2nd<decltype(operator&(std::__1::declval<_Up>())),
                            true_type>::type;
  template <class> static auto __test(long) -> false_type;

  static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<
          bool, __has_operator_addressof_member_imp<_Tp>::value ||
                    __has_operator_addressof_free_imp<_Tp>::value> {};
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<is_same<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
    : conditional<is_same<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};





template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, is_same<_RawValTy, _Key>::value> {};



template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy> : false_type {};



} }


namespace std
{

class __attribute__((__visibility__("default"))) exception {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) exception() noexcept {}
  virtual ~exception() noexcept;
  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) bad_exception : public exception {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) bad_exception() noexcept {}
  virtual ~bad_exception() noexcept;
  virtual const char *what() const noexcept;
};

typedef void (*unexpected_handler)();
__attribute__((__visibility__("default")))
    unexpected_handler set_unexpected(unexpected_handler) noexcept;
__attribute__((__visibility__("default"))) unexpected_handler get_unexpected() noexcept;
[[noreturn]] __attribute__((__visibility__("default"))) void unexpected();

typedef void (*terminate_handler)();
__attribute__((__visibility__("default"))) terminate_handler set_terminate(terminate_handler) noexcept;
__attribute__((__visibility__("default"))) terminate_handler get_terminate() noexcept;
[[noreturn]] __attribute__((__visibility__("default"))) void terminate() noexcept;

__attribute__((__visibility__("default"))) bool uncaught_exception() noexcept;
__attribute__((__visibility__("default"))) int uncaught_exceptions() noexcept;

class __attribute__((__visibility__("default"))) exception_ptr;

__attribute__((__visibility__("default"))) exception_ptr current_exception() noexcept;
[[noreturn]] __attribute__((__visibility__("default"))) void rethrow_exception(exception_ptr);

class __attribute__((__visibility__("default"))) exception_ptr {
  void *__ptr_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) exception_ptr() noexcept : __ptr_() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) exception_ptr(nullptr_t) noexcept : __ptr_() {}
  exception_ptr(const exception_ptr &) noexcept;
  exception_ptr &operator=(const exception_ptr &) noexcept;
  ~exception_ptr() noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit
  operator bool() const noexcept { return __ptr_ != nullptr; }

  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator==(const exception_ptr &__x, const exception_ptr &__y) noexcept {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator!=(const exception_ptr &__x, const exception_ptr &__y) noexcept {
    return !(__x == __y);
  }

  friend __attribute__((__visibility__("default"))) exception_ptr current_exception() noexcept;
  friend __attribute__((__visibility__("default"))) void rethrow_exception(exception_ptr);
};

template <class _Ep> exception_ptr make_exception_ptr(_Ep __e) noexcept {

  try {
    throw __e;
  } catch (...) {
    return current_exception();
  }

}



class __attribute__((__visibility__("default"))) nested_exception {
  exception_ptr __ptr_;

public:
  nested_exception() noexcept;



  virtual ~nested_exception() noexcept;


  [[noreturn]] void rethrow_nested() const;
  __attribute__((__visibility__("hidden"), __always_inline__)) exception_ptr nested_ptr() const noexcept {
    return __ptr_;
  }
};

template <class _Tp> struct __nested : public _Tp, public nested_exception {
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __nested(const _Tp &__t) : _Tp(__t) {}
};

template <class _Tp>
[[noreturn]] void

throw_with_nested(
    _Tp &&__t,
    typename enable_if<
        is_class<typename remove_reference<_Tp>::type>::value &&
        !is_base_of<nested_exception,
                    typename remove_reference<_Tp>::type>::value &&
        !__libcpp_is_final<typename remove_reference<_Tp>::type>::value>::type
        * = 0)






{

  throw __nested<typename remove_reference<_Tp>::type>(
      std::__1::forward<_Tp>(__t));

}

template <class _Tp>
[[noreturn]] void

throw_with_nested(
    _Tp &&__t,
    typename enable_if<
        !is_class<typename remove_reference<_Tp>::type>::value ||
        is_base_of<nested_exception,
                   typename remove_reference<_Tp>::type>::value ||
        __libcpp_is_final<typename remove_reference<_Tp>::type>::value>::type
        * = 0)






{

  throw std::__1::forward<_Tp>(__t);

}

template <class _Ep>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
rethrow_if_nested(const _Ep &__e,
                  typename enable_if<is_polymorphic<_Ep>::value>::type * = 0) {
  const nested_exception *__nep =
      dynamic_cast<const nested_exception *>(std::__1::addressof(__e));
  if (__nep)
    __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
rethrow_if_nested(const _Ep &,
                  typename enable_if<!is_polymorphic<_Ep>::value>::type * = 0) {
}

}
namespace std
{

class __attribute__((__visibility__("default"))) bad_alloc : public exception {
public:
  bad_alloc() noexcept;
  virtual ~bad_alloc() noexcept;
  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) bad_array_new_length : public bad_alloc {
public:
  bad_array_new_length() noexcept;
  virtual ~bad_array_new_length() noexcept;
  virtual const char *what() const noexcept;
};

[[noreturn]] __attribute__((__visibility__("default"))) void __throw_bad_alloc();
struct __attribute__((__visibility__("default"))) nothrow_t {};
extern __attribute__((__visibility__("default"))) const nothrow_t nothrow;
typedef void (*new_handler)();
__attribute__((__visibility__("default"))) new_handler set_new_handler(new_handler) noexcept;
__attribute__((__visibility__("default"))) new_handler get_new_handler() noexcept;

}
__attribute__((__visibility__("default"))) void *operator new(std::size_t __sz) ;
__attribute__((__visibility__("default"))) void *
operator new(std::size_t __sz, const std::nothrow_t &) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete(void *__p)noexcept;
__attribute__((__visibility__("default"))) void operator delete(void *__p,
                                            const std::nothrow_t &)noexcept;





__attribute__((__visibility__("default"))) void *operator new[](std::size_t __sz) ;
__attribute__((__visibility__("default"))) void *
operator new[](std::size_t __sz, const std::nothrow_t &) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void operator delete[](void *__p) noexcept;
__attribute__((__visibility__("default"))) void operator delete[](void *__p,
                                              const std::nothrow_t &) noexcept;

__attribute__((__visibility__("default"))) void operator delete[](void *__p,
                                              std::size_t __sz) noexcept;
inline __attribute__((__visibility__("hidden"), __always_inline__)) void *operator new(std::size_t,
                                                    void *__p) noexcept {
  return __p;
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) void *operator new[](std::size_t,
                                                      void *__p) noexcept {
  return __p;
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) void operator delete(void *, void *)noexcept {
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) void operator delete[](void *,
                                                        void *) noexcept {}

namespace std { inline namespace __1 {

inline __attribute__((__visibility__("hidden"), __always_inline__)) void *__allocate(size_t __size) {

  return ::operator new(__size);



}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void __deallocate(void *__ptr) {

  ::operator delete(__ptr);



}
} }



namespace std { inline namespace __1 {

using ::int8_t;
using ::int16_t;
using ::int32_t;
using ::int64_t;

using ::uint8_t;
using ::uint16_t;
using ::uint32_t;
using ::uint64_t;

using ::int_least8_t;
using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;

using ::uint_least8_t;
using ::uint_least16_t;
using ::uint_least32_t;
using ::uint_least64_t;

using ::int_fast8_t;
using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;

using ::uint_fast8_t;
using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;

using ::intptr_t;
using ::uintptr_t;

using ::intmax_t;
using ::uintmax_t;

} }


namespace std
{

class __attribute__((__visibility__("default"))) type_info {
  type_info &operator=(const type_info &);
  type_info(const type_info &);

protected:

  const char *__type_name;





  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit type_info(const char *__n)

      : __type_name(__n) {
  }





public:
  virtual ~type_info();

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char *name() const noexcept

  {
    return __type_name;
  }







  __attribute__((__visibility__("hidden"), __always_inline__))
  bool before(const type_info &__arg) const noexcept

  {
    return __type_name < __arg.__type_name;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t hash_code() const noexcept

  {
    return reinterpret_cast<size_t>(__type_name);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator==(const type_info &__arg) const noexcept

  {
    return __type_name == __arg.__type_name;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator!=(const type_info &__arg) const noexcept {
    return !operator==(__arg);
  }
};

class __attribute__((__visibility__("default"))) bad_cast : public exception {
public:
  bad_cast() noexcept;
  virtual ~bad_cast() noexcept;
  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) bad_typeid : public exception {
public:
  bad_typeid() noexcept;
  virtual ~bad_typeid() noexcept;
  virtual const char *what() const noexcept;
};

}

namespace std { inline namespace __1 {
[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void __throw_bad_cast() {

  throw bad_cast();



}
} }


namespace std { inline namespace __1 {

template <class _Arg, class _Result>
struct __attribute__((__visibility__("default"))) unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__((__visibility__("default"))) binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};

template <class _Tp> struct __has_result_type {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::result_type * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};




template <class _Tp>

struct __attribute__((__visibility__("default"))) less : binary_function<_Tp, _Tp, bool> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x < __y;
  }
};
template <class _Tp> struct __derives_from_unary_function {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  static __two __test(...);
  template <class _Ap, class _Rp>
  static unary_function<_Ap, _Rp>
  __test(const volatile unary_function<_Ap, _Rp> *);

public:
  static const bool value = !is_same<decltype(__test((_Tp *)0)), __two>::value;
  typedef decltype(__test((_Tp *)0)) type;
};

template <class _Tp> struct __derives_from_binary_function {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  static __two __test(...);
  template <class _A1, class _A2, class _Rp>
  static binary_function<_A1, _A2, _Rp>
  __test(const volatile binary_function<_A1, _A2, _Rp> *);

public:
  static const bool value = !is_same<decltype(__test((_Tp *)0)), __two>::value;
  typedef decltype(__test((_Tp *)0)) type;
};

template <typename...> using void_t = void;

template <class _Tp, class = void_t<>> struct __maybe_has_argument_type {};

template <class _Tp>
struct __maybe_has_argument_type<_Tp, void_t<typename _Tp::argument_type>> {
  typedef typename _Tp::argument_type argument_type;
};

template <class _Tp, typename = void_t<>, typename = void_t<>>
struct __maybe_has_first_and_second_argument_type {};

template <class _Tp>
struct __maybe_has_first_and_second_argument_type<
    _Tp, void_t<typename _Tp::first_argument_type>,
    void_t<typename _Tp::second_argument_type>> {
  typedef typename _Tp::first_argument_type first_argument_type;
  typedef typename _Tp::second_argument_type second_argument_type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type {};





template <class _Tp>
struct __maybe_derive_from_unary_function<_Tp, false>
    : public __maybe_has_argument_type<_Tp> {};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type {};






template <class _Tp>
struct __maybe_derive_from_binary_function<_Tp, false>
    : public __maybe_has_first_and_second_argument_type<_Tp> {};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp> {
  typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp> {};

template <class _Tp>
struct __weak_result_type : public __weak_result_type_imp<_Tp> {};



template <class _Rp> struct __weak_result_type<_Rp()> {
  typedef _Rp result_type;
};

template <class _Rp> struct __weak_result_type<_Rp (&)()> {
  typedef _Rp result_type;
};

template <class _Rp> struct __weak_result_type<_Rp (*)()> {
  typedef _Rp result_type;
};



template <class _Rp, class _A1>
struct __weak_result_type<_Rp(_A1)> : public unary_function<_A1, _Rp> {};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)> : public unary_function<_A1, _Rp> {};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)> : public unary_function<_A1, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()> : public unary_function<_Cp *, _Rp> {
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp *, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp *, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp *, _Rp> {};



template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp *, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp *, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp *, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp *, _A1, _Rp> {};




template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp(_A1, _A2, _A3, _A4...)> {
  typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)> {
  typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)> {
  typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)> {
  typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const> {
  typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile> {
  typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile> {
  typedef _Rp result_type;
};





template <class _Tp, class... _Args> struct __invoke_return {
  typedef decltype(
      __invoke(std::__1::declval<_Tp>(), std::__1::declval<_Args>()...)) type;
};







template <class _Ret> struct __invoke_void_return_wrapper {

  template <class... _Args> static _Ret __call(_Args &&... __args) {
    return __invoke(std::__1::forward<_Args>(__args)...);
  }
};

template <> struct __invoke_void_return_wrapper<void> {

  template <class... _Args> static void __call(_Args &&... __args) {
    __invoke(std::__1::forward<_Args>(__args)...);
  }
};

template <class _Tp>
class __attribute__((__visibility__("default"))) reference_wrapper : public __weak_result_type<_Tp> {
public:

  typedef _Tp type;

private:
  type *__f_;

public:

  __attribute__((__visibility__("hidden"), __always_inline__)) reference_wrapper(type &__f) noexcept
      : __f_(std::__1::addressof(__f)) {}

private:
  reference_wrapper(type &&);
public:



  __attribute__((__visibility__("hidden"), __always_inline__)) operator type &() const noexcept { return *__f_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) type &get() const noexcept { return *__f_; }



  template <class... _ArgTypes>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename __invoke_of<type &, _ArgTypes...>::type
  operator()(_ArgTypes &&... __args) const {
    return __invoke(get(), std::__1::forward<_ArgTypes>(__args)...);
  }
};

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) reference_wrapper<_Tp>
ref(_Tp &__t) noexcept {
  return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept {
  return ref(__t.get());
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) reference_wrapper<const _Tp>
cref(const _Tp &__t) noexcept {
  return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept {
  return cref(__t.get());
}





template <class _Tp> void ref(const _Tp &&) = delete;
template <class _Tp> void cref(const _Tp &&) = delete;
struct __attribute__((__visibility__("default"))) allocator_arg_t {};




constexpr allocator_arg_t allocator_arg = allocator_arg_t();




template <class _Tp> struct __has_allocator_type {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::allocator_type * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<
          bool, is_convertible<_Alloc, typename _Tp::allocator_type>::value> {};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false> : public false_type {};

template <class _Tp, class _Alloc>
struct __attribute__((__visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc> {};
template <class _Tp, class _Alloc, class... _Args>
struct __uses_alloc_ctor_imp {
  static const bool __ua = uses_allocator<_Tp, _Alloc>::value;
  static const bool __ic =
      is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
  static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class... _Args>
struct __uses_alloc_ctor
    : integral_constant<int,
                        __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value> {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__user_alloc_construct_impl(integral_constant<int, 0>, _Tp *__storage,
                            const _Allocator &, _Args &&... __args) {
  new (__storage) _Tp(std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__user_alloc_construct_impl(integral_constant<int, 1>, _Tp *__storage,
                            const _Allocator &__a, _Args &&... __args) {
  new (__storage) _Tp(allocator_arg, __a, std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__user_alloc_construct_impl(integral_constant<int, 2>, _Tp *__storage,
                            const _Allocator &__a, _Args &&... __args) {
  new (__storage) _Tp(std::__1::forward<_Args>(__args)..., __a);
}

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__user_alloc_construct(_Tp *__storage, const _Allocator &__a,
                       _Args &&... __args) {
  __user_alloc_construct_impl(__uses_alloc_ctor<_Tp, _Allocator>(), __storage,
                              __a, std::__1::forward<_Args>(__args)...);
}


} }










#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {


#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {


#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
          typedef unsigned int dev_t ;
             typedef int gid_t;
          typedef unsigned int ino_t ;






          typedef int mode_t ;







          typedef int nlink_t ;
            typedef long off_t ;
           typedef long long off64_t;





          typedef signed int pid_t ;
            typedef signed long ssize_t;
             typedef int uid_t;
          typedef long time_t ;







          typedef unsigned int clock_t ;
          typedef struct {
                     unsigned int __sigs_0;
                     unsigned int __sigs_1;
                  } sigset_t ;






          typedef unsigned char cc_t;






          typedef unsigned int speed_t ;






          typedef unsigned int tcflag_t ;
          typedef unsigned int mtm_t ;







          typedef unsigned int rdev_t ;







          typedef char tid_t[8];
          typedef struct {

                     unsigned long long __;



          } pthread_t;




          typedef struct {

                      double __[13];



          } pthread_attr_t;
             typedef union {
                        unsigned long __m;
                        double __d[8];
             } pthread_mutex_t;





          typedef struct {



                     char __[0x08];

          } pthread_mutexattr_t;
                typedef union {
                           unsigned long __m;
                           double __[8];
                } pthread_cond_t;





          typedef struct {



                     char __[0x08];

          } pthread_condattr_t;




          typedef struct {



                     char __[0x08];

          } pthread_key_t;




          typedef int pthread_once_t;





             typedef struct {



                        char __[0x08];

              } pthread_rwlockattr_t;




             typedef struct {



                        char __[0x08];

              } pthread_rwlock_t;
         typedef int key_t;
         typedef int id_t;






         typedef unsigned int useconds_t;







         typedef unsigned char sa_family_t;






         typedef unsigned short in_port_t;
             typedef long mcontext_t[85];
         typedef unsigned int in_addr_t;




         typedef in_addr_t ip_addr_t;





         typedef char * caddr_t;
         typedef signed long blkcnt_t;


         typedef signed int blksize_t;

         typedef unsigned long fsblkcnt_t;


         typedef unsigned int fsfilcnt_t;



         typedef signed int suseconds_t;
  }


#pragma checkout(resume)




        struct timespec
            {
            time_t tv_sec;
            long tv_nsec;
            };
  struct tm
     {
     int tm_sec;
     int tm_min;
     int tm_hour;
     int tm_mday;
     int tm_mon;
     int tm_year;
     int tm_wday;
     int tm_yday;
     int tm_isdst;
     };


#pragma map(clock,"\174\174OCLCK")
 clock_t clock (void);
     double difftime (time_t, time_t);
     time_t mktime (struct tm *);
     time_t time (time_t *);
     char *asctime (const struct tm *);
     char *ctime (const time_t *);
     struct tm *gmtime (const time_t *);
     struct tm *localtime (const time_t *);
     size_t strftime (char * , size_t,
                           const char * ,
                           const struct tm * );
     void __tzset(void);







      char *strptime(const char *, const char *,
                        struct tm *);





    inline char *ctime(const time_t *t) {return(asctime(localtime(t)));}

       inline double difftime (time_t t1, time_t t0)
                              {return((double)((t1) - (t0)));}
         void tzset(void);


      extern char *tzname[2];






#pragma map(__TzznA, "\174\174TZZNA")

 char *(*__TzznA(void))[2];
      char *(*__Tzzn(void))[2];
      extern int daylight;
      extern long int timezone;
        long int *__tzone(void);
        int *__dlght(void);
      extern int getdate_err;
        struct tm *getdate(const char *);

        int *__gderr(void);
    char * asctime_r (const struct tm *, char *);

    char * ctime_r (const time_t *, char*);
    struct tm * gmtime_r (const time_t *, struct tm *);

    struct tm * localtime_r (const time_t *, struct tm *);
             }






#pragma checkout(resume)
      typedef short mbstate_t;
      typedef int wint_t;




      typedef unsigned int wctype_t;







     struct __file;
     typedef int _GETCFUNC(struct __file *);
     typedef int _PUTCFUNC(int, struct __file *);
     struct __file
        {
        unsigned char *__bufPtr;
        long int __countIn;
        long int __countOut;
        _GETCFUNC *__fcbgetc;
        _PUTCFUNC *__fcbputc;
        unsigned int __cntlinterpret : 1;
        unsigned int __fcb_ascii : 1;
        unsigned int __fcb_orientation : 2;
        };

     struct __ffile
       {
       struct __file *__fp;
       };

     typedef struct __ffile *__FILEP;




      typedef struct __ffile FILE;





        typedef char *___valist;




     typedef ___valist va_list;
#pragma map(vswprintf, "\174\174VSWPT")
#pragma map(vwprintf, "\174\174VWPT2")
#pragma map(vfwprintf, "\174\174VFWPT2")
 wint_t fgetwc(FILE *);
    wchar_t *fgetws(wchar_t * , int, FILE * );
    int fputws(const wchar_t * , FILE * );
    wint_t getwc(FILE *);
    wint_t getwchar(void);
    wint_t ungetwc(wint_t, FILE *);


      int swprintf(wchar_t * , size_t,
                         const wchar_t * , ...);
      int swscanf(const wchar_t * ,
                        const wchar_t * , ...);
      int vswprintf(wchar_t * , size_t,
                          const wchar_t * , va_list);







      wint_t fputwc(wchar_t, FILE *);
      wint_t putwc(wchar_t, FILE *);
      wint_t putwchar(wchar_t);


    double wcstod(const wchar_t * ,
                     wchar_t ** );
    long int wcstol(const wchar_t * ,
                     wchar_t ** , int);
    unsigned long int wcstoul(const wchar_t * ,
                               wchar_t ** , int);



    int fwprintf (FILE * , const wchar_t * , ...);

    int wprintf (const wchar_t * , ...);
    int vfwprintf (FILE * , const wchar_t * , va_list);

    int vwprintf (const wchar_t * , va_list);



     long long wcstoll (const wchar_t * , wchar_t ** , int );

     unsigned long long wcstoull (const wchar_t * , wchar_t ** , int );
#pragma map(wcwidth,"\174\174WCWDTH")
 wchar_t *wcscpy (wchar_t * ,
                       const wchar_t * );
    wchar_t *wcsncpy (wchar_t * ,
                       const wchar_t * , size_t);
    wchar_t *wcscat (wchar_t * ,
                      const wchar_t * );
    wchar_t *wcsncat (wchar_t * ,
                       const wchar_t * , size_t);
    int wcscoll(const wchar_t *, const wchar_t *);
    int wcscmp (const wchar_t *, const wchar_t *);
    int wcsncmp (const wchar_t *, const wchar_t *, size_t);
    size_t wcsxfrm(wchar_t * ,
                      const wchar_t * , size_t);




      wchar_t * __wcschr (const wchar_t *, wchar_t);
      wchar_t * __wcspbrk (const wchar_t *, const wchar_t *);
      wchar_t * __wcsrchr (const wchar_t *, wchar_t);
    }
    extern "C++" {
      inline const wchar_t *wcschr (const wchar_t *wc1, wchar_t wc2)
         { return __wcschr(wc1, wc2); }
      inline wchar_t *wcschr (wchar_t *wc1, wchar_t wc2)
         { return __wcschr(wc1, wc2); }
      inline const wchar_t *wcspbrk (const wchar_t *wc1, const wchar_t *wc2)
         { return __wcspbrk(wc1, wc2); }
      inline wchar_t *wcspbrk (wchar_t *wc1, const wchar_t *wc2)
         { return __wcspbrk(wc1, wc2); }
      inline const wchar_t *wcsrchr (const wchar_t *wc1, wchar_t wc2)
         { return __wcsrchr(wc1, wc2); }
      inline wchar_t *wcsrchr (wchar_t *wc1, wchar_t wc2)
         { return __wcsrchr(wc1, wc2); }
    }
    extern "C" {
#pragma map(__wcschr, "WCSCHR")
#pragma map(__wcspbrk, "WCSPBRK")
#pragma map(__wcsrchr, "WCSRCHR")






 size_t wcscspn (const wchar_t *, const wchar_t *);
    size_t wcsspn (const wchar_t *, const wchar_t *);
    size_t wcslen (const wchar_t *);
    int wcswidth(const wchar_t *, size_t);





      wchar_t *wcstok(wchar_t * , const wchar_t * ,
                      wchar_t ** );
      size_t wcsftime(wchar_t * , size_t,
                        const wchar_t * ,
                        const struct tm * );







         int wcwidth(const wchar_t);
         wchar_t * __wcsstr (const wchar_t *, const wchar_t *);
         wchar_t * __wmemchr (const wchar_t *, wchar_t , size_t );

       }
       extern "C++" {
         inline const wchar_t *wcsstr (const wchar_t *wc1, const wchar_t *wc2)
            { return __wcsstr(wc1, wc2); }
         inline wchar_t *wcsstr (wchar_t *wc1, const wchar_t *wc2)
            { return __wcsstr(wc1, wc2); }
         inline const wchar_t *wmemchr (const wchar_t *wc1, wchar_t wc2,
                                                               size_t s3)
            { return __wmemchr(wc1, wc2, s3); }
         inline wchar_t *wmemchr (wchar_t *wc1, wchar_t wc2, size_t s3)
            { return __wmemchr(wc1, wc2, s3); }

       }
       extern "C" {
#pragma map(__wcsstr, "WCSSTR")



#pragma map(__wmemchr, "WMEMCHR")
 int wmemcmp (const wchar_t *,
                           const wchar_t *, size_t );
        wchar_t *wmemcpy (wchar_t * ,
                           const wchar_t * , size_t );
        wchar_t *wmemset (wchar_t *, wchar_t, size_t );


      wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t );
      int mbsinit(const mbstate_t *);
      size_t mbrlen (const char * , size_t,
                        mbstate_t * );
      int wctob (wint_t);
      size_t mbrtowc (wchar_t * ,
                         const char * , size_t,
                          mbstate_t * );
      size_t wcrtomb (char * , wchar_t,
                         mbstate_t * );
      size_t mbsrtowcs (wchar_t * ,
                           const char ** , size_t,
                            mbstate_t * );
      size_t wcsrtombs (char * ,
                           const wchar_t ** , size_t,
                             mbstate_t * );
    wint_t btowc (int);
        wctype_t wctype (const char *);







      wchar_t *wcswcs (const wchar_t *, const wchar_t *);
       typedef const unsigned short *__cusp;
      } extern "C++" {
        inline int iswalnum(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0800):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0800)));}
        inline int iswalpha(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0100):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0100)));}
        inline int iswcntrl(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0020):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0020)));}
        inline int iswdigit(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0002):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0002)));}
        inline int iswgraph(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0200):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0200)));}
        inline int iswlower(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0040):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0040)));}
        inline int iswprint(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0400):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0400)));}
        inline int iswpunct(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0010):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0010)));}
        inline int iswspace(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0008):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0008)));}
        inline int iswupper(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0080):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0080)));}
        inline int iswxdigit(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x0001):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x0001)));}
        inline wint_t towlower(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E), ( *((int *)(_Gtab(1))) ) < 256 ? (short)((( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )+514])) : (((((char * const) (*(_Gtab(17)))) == 0) || (((char * const) (*(_Gtab(17))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? (( *((int *)(_Gtab(1))) )) : ((unsigned short * const) (*(_Gtab(19)))) [(((char * const) (*(_Gtab(17))))[( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)]));}
        inline wint_t towupper(wint_t _E) {return (( *((int *)(_Gtab(1))) )=(_E), ( *((int *)(_Gtab(1))) ) < 256 ? (short)((( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )+257])) : (((((char * const) (*(_Gtab(16)))) == 0) || (((char * const) (*(_Gtab(16))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? (( *((int *)(_Gtab(1))) )) : ((unsigned short * const) (*(_Gtab(18)))) [(((char * const) (*(_Gtab(16))))[( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)]));}
        inline wint_t iswctype(wint_t _E,wctype_t _M)
                                            {return (( *((int *)(_Gtab(1))) )=(_E), ( *((int *)(_Gtab(24))) )=(_M), (( *((int *)(_Gtab(1))) ) < 256 ? (( *((int *)(_Gtab(24))) ) > 0x8000 ? (((unsigned short * const) (*(_Gtab(20)))) == 0 ? 0 :((unsigned short * const) (*(_Gtab(20))))[( *((int *)(_Gtab(1))) )] & (( *((int *)(_Gtab(24))) ) >> 16)) : (( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & ( *((int *)(_Gtab(24))) ))) : (((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & ( *((int *)(_Gtab(24))) ))));}


      } extern "C" {
        int fwide (FILE *, int);

        int fwscanf (FILE * , const wchar_t * , ...);

        int wscanf (const wchar_t * , ...);
#pragma map (vfwscanf, "\174\174VFWSC2")
#pragma map (vwscanf, "\174\174VWSC2")
#pragma map (vswscanf, "\174\174VSWSC2")
 int vfwscanf (FILE * , const wchar_t * , va_list );


        int vwscanf (const wchar_t * , va_list );

        int vswscanf (const wchar_t * , const wchar_t * , va_list );


        float wcstof (const wchar_t * , wchar_t ** );

        long double wcstold (const wchar_t * , wchar_t ** );
      }


#pragma checkout(resume)
extern "C++" {
inline __attribute__((__visibility__("hidden"), __always_inline__)) wchar_t *__libcpp_wcschr(const wchar_t *__s,
                                                          wchar_t __c) {
  return (wchar_t *)wcschr(__s, __c);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const wchar_t *
wcschr(const wchar_t *__s, wchar_t __c) {
  return __libcpp_wcschr(__s, __c);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) wchar_t *
wcschr(wchar_t *__s, wchar_t __c) {
  return __libcpp_wcschr(__s, __c);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) wchar_t *
__libcpp_wcspbrk(const wchar_t *__s1, const wchar_t *__s2) {
  return (wchar_t *)wcspbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const wchar_t *
wcspbrk(const wchar_t *__s1, const wchar_t *__s2) {
  return __libcpp_wcspbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) wchar_t *
wcspbrk(wchar_t *__s1, const wchar_t *__s2) {
  return __libcpp_wcspbrk(__s1, __s2);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) wchar_t *__libcpp_wcsrchr(const wchar_t *__s,
                                                           wchar_t __c) {
  return (wchar_t *)wcsrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const wchar_t *
wcsrchr(const wchar_t *__s, wchar_t __c) {
  return __libcpp_wcsrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) wchar_t *
wcsrchr(wchar_t *__s, wchar_t __c) {
  return __libcpp_wcsrchr(__s, __c);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) wchar_t *__libcpp_wcsstr(const wchar_t *__s1,
                                                          const wchar_t *__s2) {
  return (wchar_t *)wcsstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const wchar_t *
wcsstr(const wchar_t *__s1, const wchar_t *__s2) {
  return __libcpp_wcsstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) wchar_t *
wcsstr(wchar_t *__s1, const wchar_t *__s2) {
  return __libcpp_wcsstr(__s1, __s2);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) wchar_t *
__libcpp_wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) {
  return (wchar_t *)wmemchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) const wchar_t *
wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) {
  return __libcpp_wmemchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) __attribute__((__enable_if__(true, ""))) wchar_t *
wmemchr(wchar_t *__s, wchar_t __c, size_t __n) {
  return __libcpp_wmemchr(__s, __c, __n);
}
}


namespace std { inline namespace __1 {

class __attribute__((__visibility__("default"))) ios_base;

template <class _CharT> struct __attribute__((__visibility__("default"))) char_traits;
template <class _Tp> class __attribute__((__visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State> class __attribute__((__visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;






typedef long long streamoff;


template <class _CharT,
          class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char>> string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> wstring;


template <class _Tp, class _Alloc = allocator<_Tp>>
class __attribute__((__visibility__("default"))) vector;

} }







namespace std { inline namespace __1 {

struct __attribute__((__visibility__("default"))) input_iterator_tag {};
struct __attribute__((__visibility__("default"))) output_iterator_tag {};
struct __attribute__((__visibility__("default"))) forward_iterator_tag : public input_iterator_tag {
};
struct __attribute__((__visibility__("default"))) bidirectional_iterator_tag
    : public forward_iterator_tag {};
struct __attribute__((__visibility__("default"))) random_access_iterator_tag
    : public bidirectional_iterator_tag {};

template <class _Tp> struct __has_iterator_category {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up>
  static char __test(typename _Up::iterator_category * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter> struct __iterator_traits_impl<_Iter, true> {
  typedef typename _Iter::difference_type difference_type;
  typedef typename _Iter::value_type value_type;
  typedef typename _Iter::pointer pointer;
  typedef typename _Iter::reference reference;
  typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl<
          _Iter, is_convertible<typename _Iter::iterator_category,
                                input_iterator_tag>::value ||
                     is_convertible<typename _Iter::iterator_category,
                                    output_iterator_tag>::value> {};







template <class _Iter>
struct __attribute__((__visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};

template <class _Tp> struct __attribute__((__visibility__("default"))) iterator_traits<_Tp *> {
  typedef ptrdiff_t difference_type;
  typedef typename remove_const<_Tp>::type value_type;
  typedef _Tp *pointer;
  typedef _Tp &reference;
  typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up,
          bool = __has_iterator_category<iterator_traits<_Tp>>::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<
          bool, is_convertible<typename iterator_traits<_Tp>::iterator_category,
                               _Up>::value> {};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false>
    : public false_type {};

template <class _Tp>
struct __is_input_iterator
    : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_forward_iterator
    : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {
};

template <class _Tp>
struct __is_bidirectional_iterator
    : public __has_iterator_category_convertible_to<
          _Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_random_access_iterator
    : public __has_iterator_category_convertible_to<
          _Tp, random_access_iterator_tag> {};

template <class _Tp>
struct __is_exactly_input_iterator
    : public integral_constant<bool,
                               __has_iterator_category_convertible_to<
                                   _Tp, input_iterator_tag>::value &&
                                   !__has_iterator_category_convertible_to<
                                       _Tp, forward_iterator_tag>::value> {};

template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp *, class _Reference = _Tp &>
struct __attribute__((__visibility__("default"))) iterator {
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
  typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__advance(_InputIter &__i,
          typename iterator_traits<_InputIter>::difference_type __n,
          input_iterator_tag) {
  for (; __n > 0; --__n)
    ++__i;
}

template <class _BiDirIter>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__advance(_BiDirIter &__i,
          typename iterator_traits<_BiDirIter>::difference_type __n,
          bidirectional_iterator_tag) {
  if (__n >= 0)
    for (; __n > 0; --__n)
      ++__i;
  else
    for (; __n < 0; ++__n)
      --__i;
}

template <class _RandIter>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__advance(_RandIter &__i,
          typename iterator_traits<_RandIter>::difference_type __n,
          random_access_iterator_tag) {
  __i += __n;
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
advance(_InputIter &__i,
        typename iterator_traits<_InputIter>::difference_type __n) {
  __advance(__i, __n,
            typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename iterator_traits<_InputIter>::difference_type
    __distance(_InputIter __first, _InputIter __last, input_iterator_tag) {
  typename iterator_traits<_InputIter>::difference_type __r(0);
  for (; __first != __last; ++__first)
    ++__r;
  return __r;
}

template <class _RandIter>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename iterator_traits<_RandIter>::difference_type
    __distance(_RandIter __first, _RandIter __last,
               random_access_iterator_tag) {
  return __last - __first;
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename iterator_traits<_InputIter>::difference_type
    distance(_InputIter __first, _InputIter __last) {
  return __distance(__first, __last,
                    typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_input_iterator<_InputIter>::value, _InputIter>::type
    next(_InputIter __x,
         typename iterator_traits<_InputIter>::difference_type __n = 1) {
  std::__1::advance(__x, __n);
  return __x;
}

template <class _BidiretionalIter>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value,
                       _BidiretionalIter>::type
    prev(_BidiretionalIter __x,
         typename iterator_traits<_BidiretionalIter>::difference_type __n = 1) {
  std::__1::advance(__x, -__n);
  return __x;
}

template <class _Iter>
class __attribute__((__visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference> {
private:
              _Iter
      __t;
protected:
  _Iter current;

public:
  typedef _Iter iterator_type;
  typedef typename iterator_traits<_Iter>::difference_type difference_type;
  typedef typename iterator_traits<_Iter>::reference reference;
  typedef typename iterator_traits<_Iter>::pointer pointer;

  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator()
      : __t(), current() {}
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit reverse_iterator(_Iter __x)
      : __t(__x), current(__x) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator(const reverse_iterator<_Up> &__u)
      : __t(__u.base()), current(__u.base()) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator &
  operator=(const reverse_iterator<_Up> &__u) {
    __t = current = __u.base();
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) _Iter base() const {
    return current;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference
  operator*() const {
    _Iter __tmp = current;
    return *--__tmp;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer
  operator->() const {
    return std::__1::addressof(operator*());
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator &
  operator++() {
    --current;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator
  operator++(int) {
    reverse_iterator __tmp(*this);
    --current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator &
  operator--() {
    ++current;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator
  operator--(int) {
    reverse_iterator __tmp(*this);
    ++current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator
  operator+(difference_type __n) const {
    return reverse_iterator(current - __n);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator &
  operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator
  operator-(difference_type __n) const {
    return reverse_iterator(current + __n);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reverse_iterator &
  operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference
  operator[](difference_type __n) const {
    return *(*this + __n);
  }
};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const reverse_iterator<_Iter1> &__x,
           const reverse_iterator<_Iter2> &__y) {
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const reverse_iterator<_Iter1> &__x,
          const reverse_iterator<_Iter2> &__y) {
  return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const reverse_iterator<_Iter1> &__x,
           const reverse_iterator<_Iter2> &__y) {
  return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const reverse_iterator<_Iter1> &__x,
          const reverse_iterator<_Iter2> &__y) {
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const reverse_iterator<_Iter1> &__x,
           const reverse_iterator<_Iter2> &__y) {
  return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const reverse_iterator<_Iter1> &__x,
           const reverse_iterator<_Iter2> &__y) {
  return __x.base() >= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) auto
operator-(const reverse_iterator<_Iter1> &__x,
          const reverse_iterator<_Iter2> &__y)
    -> decltype(__y.base() - __x.base()) {
  return __y.base() - __x.base();
}
template <class _Iter>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  reverse_iterator<_Iter>
    operator+(typename reverse_iterator<_Iter>::difference_type __n,
              const reverse_iterator<_Iter> &__x) {
  return reverse_iterator<_Iter>(__x.base() - __n);
}
template <class _Container>
class __attribute__((__visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
protected:
  _Container *container;

public:
  typedef _Container container_type;

  __attribute__((__visibility__("hidden"), __always_inline__)) explicit back_insert_iterator(_Container &__x)
      : container(std::__1::addressof(__x)) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) back_insert_iterator &
  operator=(const typename _Container::value_type &__value_) {
    container->push_back(__value_);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) back_insert_iterator &
  operator=(typename _Container::value_type &&__value_) {
    container->push_back(std::__1::move(__value_));
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) back_insert_iterator &operator*() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) back_insert_iterator &operator++() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) back_insert_iterator operator++(int) {
    return *this;
  }
};

template <class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__)) back_insert_iterator<_Container>
back_inserter(_Container &__x) {
  return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__((__visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
protected:
  _Container *container;

public:
  typedef _Container container_type;

  __attribute__((__visibility__("hidden"), __always_inline__)) explicit front_insert_iterator(_Container &__x)
      : container(std::__1::addressof(__x)) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) front_insert_iterator &
  operator=(const typename _Container::value_type &__value_) {
    container->push_front(__value_);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) front_insert_iterator &
  operator=(typename _Container::value_type &&__value_) {
    container->push_front(std::__1::move(__value_));
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) front_insert_iterator &operator*() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) front_insert_iterator &operator++() {
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) front_insert_iterator operator++(int) {
    return *this;
  }
};

template <class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__)) front_insert_iterator<_Container>
front_inserter(_Container &__x) {
  return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__((__visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
protected:
  _Container *container;
  typename _Container::iterator iter;

public:
  typedef _Container container_type;

  __attribute__((__visibility__("hidden"), __always_inline__)) insert_iterator(_Container &__x,
                                            typename _Container::iterator __i)
      : container(std::__1::addressof(__x)), iter(__i) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) insert_iterator &
  operator=(const typename _Container::value_type &__value_) {
    iter = container->insert(iter, __value_);
    ++iter;
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) insert_iterator &
  operator=(typename _Container::value_type &&__value_) {
    iter = container->insert(iter, std::__1::move(__value_));
    ++iter;
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) insert_iterator &operator*() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) insert_iterator &operator++() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) insert_iterator &operator++(int) { return *this; }
};

template <class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__)) insert_iterator<_Container>
inserter(_Container &__x, typename _Container::iterator __i) {
  return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>,
          class _Distance = ptrdiff_t>
class __attribute__((__visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp *,
                      const _Tp &> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef basic_istream<_CharT, _Traits> istream_type;

private:
  istream_type *__in_stream_;
  _Tp __value_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr istream_iterator()
      : __in_stream_(0), __value_() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) istream_iterator(istream_type &__s)
      : __in_stream_(std::__1::addressof(__s)) {
    if (!(*__in_stream_ >> __value_))
      __in_stream_ = 0;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) const _Tp &operator*() const { return __value_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) const _Tp *operator->() const {
    return std::__1::addressof((operator*()));
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) istream_iterator &operator++() {
    if (!(*__in_stream_ >> __value_))
      __in_stream_ = 0;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) istream_iterator operator++(int) {
    istream_iterator __t(*this);
    ++(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator==(const istream_iterator &__x, const istream_iterator &__y) {
    return __x.__in_stream_ == __y.__in_stream_;
  }

  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator!=(const istream_iterator &__x, const istream_iterator &__y) {
    return !(__x == __y);
  }
};

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
  ostream_type *__out_stream_;
  const char_type *__delim_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) ostream_iterator(ostream_type &__s) noexcept
      : __out_stream_(std::__1::addressof(__s)),
        __delim_(0) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  ostream_iterator(ostream_type &__s, const _CharT *__delimiter) noexcept
      : __out_stream_(std::__1::addressof(__s)),
        __delim_(__delimiter) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) ostream_iterator &operator=(const _Tp &__value_) {
    *__out_stream_ << __value_;
    if (__delim_)
      *__out_stream_ << __delim_;
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) ostream_iterator &operator*() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) ostream_iterator &operator++() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) ostream_iterator &operator++(int) { return *this; }
};

template <class _CharT, class _Traits>
class __attribute__((__visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT *, _CharT> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename _Traits::int_type int_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_istream<_CharT, _Traits> istream_type;

private:
  mutable streambuf_type *__sbuf_;

  class __proxy {
    char_type __keep_;
    streambuf_type *__sbuf_;
    __attribute__((__visibility__("hidden"), __always_inline__)) __proxy(char_type __c, streambuf_type *__s)
        : __keep_(__c), __sbuf_(__s) {}
    friend class istreambuf_iterator;

  public:
    __attribute__((__visibility__("hidden"), __always_inline__)) char_type operator*() const { return __keep_; }
  };

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool __test_for_eof() const {
    if (__sbuf_ &&
        traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
      __sbuf_ = 0;
    return __sbuf_ == 0;
  }

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr istreambuf_iterator() noexcept
      : __sbuf_(0) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(istream_type &__s) noexcept
      : __sbuf_(__s.rdbuf()) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(streambuf_type *__s) noexcept
      : __sbuf_(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) istreambuf_iterator(const __proxy &__p) noexcept
      : __sbuf_(__p.__sbuf_) {}

  __attribute__((__visibility__("hidden"), __always_inline__)) char_type operator*() const {
    return traits_type::to_char_type(__sbuf_->sgetc());
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) char_type *operator->() const { return nullptr; }
  __attribute__((__visibility__("hidden"), __always_inline__)) istreambuf_iterator &operator++() {
    __sbuf_->sbumpc();
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) __proxy operator++(int) {
    return __proxy(__sbuf_->sbumpc(), __sbuf_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) bool equal(const istreambuf_iterator &__b) const {
    return __test_for_eof() == __b.__test_for_eof();
  }
};

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const istreambuf_iterator<_CharT, _Traits> &__a,
           const istreambuf_iterator<_CharT, _Traits> &__b) {
  return __a.equal(__b);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const istreambuf_iterator<_CharT, _Traits> &__a,
           const istreambuf_iterator<_CharT, _Traits> &__b) {
  return !__a.equal(__b);
}

template <class _CharT, class _Traits>
class __attribute__((__visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
  streambuf_type *__sbuf_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(ostream_type &__s) noexcept
      : __sbuf_(__s.rdbuf()) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator(streambuf_type *__s) noexcept
      : __sbuf_(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator &operator=(_CharT __c) {
    if (__sbuf_ &&
        traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
      __sbuf_ = 0;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator &operator*() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator &operator++() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) ostreambuf_iterator &operator++(int) {
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool failed() const noexcept {
    return __sbuf_ == 0;
  }






  template <class _Ch, class _Tr>
  friend __attribute__((__visibility__("hidden"))) ostreambuf_iterator<_Ch, _Tr>
  __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s, const _Ch *__ob,
                   const _Ch *__op, const _Ch *__oe, ios_base &__iob, _Ch __fl);

};

template <class _Iter> class __attribute__((__visibility__("default"))) move_iterator {
private:
  _Iter __i;

public:
  typedef _Iter iterator_type;
  typedef typename iterator_traits<iterator_type>::iterator_category
      iterator_category;
  typedef typename iterator_traits<iterator_type>::value_type value_type;
  typedef
      typename iterator_traits<iterator_type>::difference_type difference_type;
  typedef iterator_type pointer;

  typedef typename iterator_traits<iterator_type>::reference __reference;
  typedef typename conditional<is_reference<__reference>::value,
                               typename remove_reference<__reference>::type &&,
                               __reference>::type reference;




  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator() : __i() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit move_iterator(_Iter __x) : __i(__x) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator(const move_iterator<_Up> &__u)
      : __i(__u.base()) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Iter base() const { return __i; }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator*() const {
    return static_cast<reference>(*__i);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer operator->() const { return __i; }
  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator &operator++() {
    ++__i;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator operator++(int) {
    move_iterator __tmp(*this);
    ++__i;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator &operator--() {
    --__i;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator operator--(int) {
    move_iterator __tmp(*this);
    --__i;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator operator+(difference_type __n) const {
    return move_iterator(__i + __n);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator &operator+=(difference_type __n) {
    __i += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator operator-(difference_type __n) const {
    return move_iterator(__i - __n);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator &operator-=(difference_type __n) {
    __i -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const {
    return static_cast<reference>(__i[__n]);
  }
};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() <= __y.base();
}


template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) auto
operator-(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y)
    -> decltype(__x.base() - __y.base()) {
  return __x.base() - __y.base();
}
template <class _Iter>
inline __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n,
          const move_iterator<_Iter> &__x) {
  return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__((__visibility__("hidden"), __always_inline__)) move_iterator<_Iter>
make_move_iterator(_Iter __i) {
  return move_iterator<_Iter>(__i);
}



template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"), __always_inline__)) bool operator<(const __wrap_iter<_Iter1> &,
                                         const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"), __always_inline__)) bool operator>(const __wrap_iter<_Iter1> &,
                                         const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;


template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden"), __always_inline__)) auto
operator-(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter2> &__y) noexcept
    -> decltype(__x.base() - __y.base());






template <class _Iter>
__attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type,
          __wrap_iter<_Iter>) noexcept;

template <class _Ip, class _Op>
_Op __attribute__((__visibility__("hidden"), __always_inline__)) copy(_Ip, _Ip, _Op);
template <class _B1, class _B2>
_B2 __attribute__((__visibility__("hidden"), __always_inline__)) copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op>
_Op __attribute__((__visibility__("hidden"), __always_inline__)) move(_Ip, _Ip, _Op);
template <class _B1, class _B2>
_B2 __attribute__((__visibility__("hidden"), __always_inline__)) move_backward(_B1, _B1, _B2);

template <class _Tp>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type
    __unwrap_iter(__wrap_iter<_Tp *>);

template <class _Iter> class __wrap_iter {
public:
  typedef _Iter iterator_type;
  typedef typename iterator_traits<iterator_type>::iterator_category
      iterator_category;
  typedef typename iterator_traits<iterator_type>::value_type value_type;
  typedef
      typename iterator_traits<iterator_type>::difference_type difference_type;
  typedef typename iterator_traits<iterator_type>::pointer pointer;
  typedef typename iterator_traits<iterator_type>::reference reference;

private:
  iterator_type __i;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter() noexcept




  {



  }
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter(
      const __wrap_iter<_Up> &__u,
      typename enable_if<is_convertible<_Up, iterator_type>::value>::type * =
          0) noexcept : __i(__u.base()) {



  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator*() const noexcept {




    return *__i;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer operator->() const noexcept {




    return (pointer)std::__1::addressof(*__i);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter &operator++() noexcept {




    ++__i;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter operator++(int)noexcept {
    __wrap_iter __tmp(*this);
    ++(*this);
    return __tmp;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter &operator--() noexcept {




    --__i;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter operator--(int)noexcept {
    __wrap_iter __tmp(*this);
    --(*this);
    return __tmp;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter
  operator+(difference_type __n) const noexcept {
    __wrap_iter __w(*this);
    __w += __n;
    return __w;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter &
  operator+=(difference_type __n) noexcept {




    __i += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter
  operator-(difference_type __n) const noexcept {
    return *this + (-__n);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter &
  operator-=(difference_type __n) noexcept {
    *this += -__n;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference
  operator[](difference_type __n) const noexcept {




    return __i[__n];
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) iterator_type base() const noexcept { return __i; }

private:






  __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter(iterator_type __x) noexcept
      : __i(__x) {}


  template <class _Up> friend class __wrap_iter;
  template <class _CharT, class _Traits, class _Alloc>
  friend class basic_string;
  template <class _Tp, class _Alloc> friend class __attribute__((__visibility__("default"))) vector;

  template <class _Iter1, class _Iter2>
  friend bool operator==(const __wrap_iter<_Iter1> &,
                         const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  friend bool operator<(const __wrap_iter<_Iter1> &,
                        const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  friend bool operator!=(const __wrap_iter<_Iter1> &,
                         const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  friend bool operator>(const __wrap_iter<_Iter1> &,
                        const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  friend bool operator>=(const __wrap_iter<_Iter1> &,
                         const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  friend bool operator<=(const __wrap_iter<_Iter1> &,
                         const __wrap_iter<_Iter2> &) noexcept;


  template <class _Iter1, class _Iter2>
  friend auto operator-(const __wrap_iter<_Iter1> &__x,
                        const __wrap_iter<_Iter2> &__y) noexcept
      -> decltype(__x.base() - __y.base());






  template <class _Iter1>
  friend __wrap_iter<_Iter1>
  operator+(typename __wrap_iter<_Iter1>::difference_type,
            __wrap_iter<_Iter1>) noexcept;

  template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
  template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
  template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
  template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);

  template <class _Tp>
  friend
      typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type
      __unwrap_iter(__wrap_iter<_Tp *>);
};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter2> &__y) noexcept {
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter2> &__y) noexcept {




  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter2> &__y) noexcept {
  return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter2> &__y) noexcept {
  return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter2> &__y) noexcept {
  return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter2> &__y) noexcept {
  return !(__y < __x);
}

template <class _Iter1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter1> &__y) noexcept {
  return !(__x == __y);
}

template <class _Iter1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter1> &__y) noexcept {
  return __y < __x;
}

template <class _Iter1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter1> &__y) noexcept {
  return !(__x < __y);
}

template <class _Iter1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter1> &__y) noexcept {
  return !(__y < __x);
}


template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) auto
operator-(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter2> &__y) noexcept
    -> decltype(__x.base() - __y.base()) {




  return __x.base() - __y.base();
}
template <class _Iter>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) noexcept {
  __x += __n;
  return __x;
}

template <class _Iter>
struct __libcpp_is_trivial_iterator
    : public integral_constant<bool, (is_pointer<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter>>
    : public integral_constant<bool, (__libcpp_is_trivial_iterator<_Iter>::value)> {
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter>>
    : public integral_constant<bool, (__libcpp_is_trivial_iterator<_Iter>::value)> {
};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter>>
    : public integral_constant<bool, (__libcpp_is_trivial_iterator<_Iter>::value)> {
};

template <class _Tp, size_t _Np>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
    begin(_Tp (&__array)[_Np]) {
  return __array;
}

template <class _Tp, size_t _Np>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
    end(_Tp (&__array)[_Np]) {
  return __array + _Np;
}



template <class _Cp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) auto begin(_Cp &__c) -> decltype(__c.begin()) {
  return __c.begin();
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) auto begin(const _Cp &__c)
    -> decltype(__c.begin()) {
  return __c.begin();
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) auto end(_Cp &__c) -> decltype(__c.end()) {
  return __c.end();
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) auto end(const _Cp &__c)
    -> decltype(__c.end()) {
  return __c.end();
}
} }










namespace std { inline namespace __1 {

enum float_round_style {
  round_indeterminate = -1,
  round_toward_zero = 0,
  round_to_nearest = 1,
  round_toward_infinity = 2,
  round_toward_neg_infinity = 3
};

enum float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent = 0,
  denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits {
protected:
  typedef _Tp type;

  static constexpr const bool is_specialized = false;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return type();
  }

  static constexpr const int digits = 0;
  static constexpr const int digits10 = 0;
  static constexpr const int max_digits10 = 0;
  static constexpr const bool is_signed = false;
  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 0;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return type();
  }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static constexpr const float_denorm_style has_denorm = denorm_absent;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return type();
  }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = false;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style =
      round_toward_zero;
};

template <class _Tp, int digits, bool is_signed> struct __libcpp_compute_min {
  static constexpr const _Tp value = _Tp(_Tp(1) << digits);
};

template <class _Tp, int digits>
struct __libcpp_compute_min<_Tp, digits, false> {
  static constexpr const _Tp value = _Tp(0);
};

template <class _Tp> class __libcpp_numeric_limits<_Tp, true> {
protected:
  typedef _Tp type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = type(-1) < type(0);
  static constexpr const int digits =
      static_cast<int>(sizeof(type) * 8 - is_signed);
  static constexpr const int digits10 = digits * 3 / 10;
  static constexpr const int max_digits10 = 0;
  static constexpr const type __min =
      __libcpp_compute_min<type, digits, is_signed>::value;
  static constexpr const type __max =
      is_signed ? type(type(~0) ^ __min) : type(~0);
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return __min;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return __max;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return min();
  }

  static constexpr const bool is_integer = true;
  static constexpr const bool is_exact = true;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return type(0);
  }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static constexpr const float_denorm_style has_denorm = denorm_absent;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return type(0);
  }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = !std::__1::is_signed<_Tp>::value;





  static constexpr const bool traps = false;

  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style =
      round_toward_zero;
};

template <> class __libcpp_numeric_limits<bool, true> {
protected:
  typedef bool type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = false;
  static constexpr const int digits = 1;
  static constexpr const int digits10 = 0;
  static constexpr const int max_digits10 = 0;
  static constexpr const type __min = false;
  static constexpr const type __max = true;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return __min;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return __max;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return min();
  }

  static constexpr const bool is_integer = true;
  static constexpr const bool is_exact = true;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return type(0);
  }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static constexpr const float_denorm_style has_denorm = denorm_absent;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return type(0);
  }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style =
      round_toward_zero;
};
extern "C" int printf(const char *, ...);

template <> class __libcpp_numeric_limits<float, true> {
protected:
  typedef float type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 24;
  static constexpr const int digits10 = 6;
  static constexpr const int max_digits10 =
      2 + (digits * 30103) / 100000;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return 1.17549435e-38F;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return 3.40282347e+38F;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return -max();
  }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return 1.19209290e-7F;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return 0.5F;
  }

  static constexpr const int min_exponent = (-125);
  static constexpr const int min_exponent10 = (-37);
  static constexpr const int max_exponent = 128;
  static constexpr const int max_exponent10 = 38;






  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;

  static constexpr const float_denorm_style has_denorm = denorm_present;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"), __always_inline__)) static type infinity() noexcept {
    return __builtin_huge_valf();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return __builtin_nanf("");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return __builtin_nansf("");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return 1.40129846e-45F;
  }






  static constexpr const bool is_iec559 = true;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style =
      round_to_nearest;
};

template <> class __libcpp_numeric_limits<double, true> {
protected:
  typedef double type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 53;
  static constexpr const int digits10 = 15;
  static constexpr const int max_digits10 =
      2 + (digits * 30103) / 100000;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return 2.2250738585072014e-308;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return 1.7976931348623157e+308;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return -max();
  }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return 2.2204460492503131e-16;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return 0.5;
  }

  static constexpr const int min_exponent = (-1021);
  static constexpr const int min_exponent10 = (-307);
  static constexpr const int max_exponent = 1024;
  static constexpr const int max_exponent10 = 308;







  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;

  static constexpr const float_denorm_style has_denorm = denorm_present;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {
    return __builtin_huge_val();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return __builtin_nan("");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return __builtin_nans("");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return 4.9406564584124654e-324;
  }





  static constexpr const bool is_iec559 = true;

  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style =
      round_to_nearest;
};

template <> class __libcpp_numeric_limits<long double, true> {
protected:
  typedef long double type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 113;
  static constexpr const int digits10 = 33;
  static constexpr const int max_digits10 =
      2 + (digits * 30103) / 100000;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return 3.36210314311209350626267781732175260e-4932L;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return 1.18973149535723176508575932662800702e+4932L;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return -max();
  }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return 1.92592994438723585305597794258492732e-34L;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return 0.5;
  }

  static constexpr const int min_exponent = (-16381);
  static constexpr const int min_exponent10 = (-4931);
  static constexpr const int max_exponent = 16384;
  static constexpr const int max_exponent10 = 4932;






  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;

  static constexpr const float_denorm_style has_denorm = denorm_present;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {
    return __builtin_huge_vall();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return __builtin_nanl("");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return __builtin_nansl("");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return 6.47517511943802511092443895822764655e-4966L;
  }




  static constexpr const bool is_iec559 = true;

  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style =
      round_to_nearest;
};

template <class _Tp>
class __attribute__((__visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type> {
  typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
  typedef typename __base::type type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return __base::min();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return __base::max();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return __base::lowest();
  }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return __base::epsilon();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return __base::round_error();
  }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN =
      __base::has_signaling_NaN;
  static constexpr const float_denorm_style has_denorm =
      __base::has_denorm;
  static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {
    return __base::infinity();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return __base::quiet_NaN();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return __base::signaling_NaN();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return __base::denorm_min();
  }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style =
      __base::round_style;
};

template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp> constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp> constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp> constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__((__visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp> {
  typedef numeric_limits<_Tp> __base;
  typedef _Tp type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return __base::min();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return __base::max();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return __base::lowest();
  }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return __base::epsilon();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return __base::round_error();
  }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN =
      __base::has_signaling_NaN;
  static constexpr const float_denorm_style has_denorm =
      __base::has_denorm;
  static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {
    return __base::infinity();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return __base::quiet_NaN();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return __base::signaling_NaN();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return __base::denorm_min();
  }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style =
      __base::round_style;
};

template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style
    numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style
    numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__((__visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp> {
  typedef numeric_limits<_Tp> __base;
  typedef _Tp type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return __base::min();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return __base::max();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return __base::lowest();
  }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return __base::epsilon();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return __base::round_error();
  }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN =
      __base::has_signaling_NaN;
  static constexpr const float_denorm_style has_denorm =
      __base::has_denorm;
  static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {
    return __base::infinity();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return __base::quiet_NaN();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return __base::signaling_NaN();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return __base::denorm_min();
  }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style =
      __base::round_style;
};

template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style
    numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style
    numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__((__visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp> {
  typedef numeric_limits<_Tp> __base;
  typedef _Tp type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type min() noexcept {
    return __base::min();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type max() noexcept {
    return __base::max();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type lowest() noexcept {
    return __base::lowest();
  }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type epsilon() noexcept {
    return __base::epsilon();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  round_error() noexcept {
    return __base::round_error();
  }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN =
      __base::has_signaling_NaN;
  static constexpr const float_denorm_style has_denorm =
      __base::has_denorm;
  static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type infinity() noexcept {
    return __base::infinity();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  quiet_NaN() noexcept {
    return __base::quiet_NaN();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  signaling_NaN() noexcept {
    return __base::signaling_NaN();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr type
  denorm_min() noexcept {
    return __base::denorm_min();
  }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style =
      __base::round_style;
};

template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool
    numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style
    numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
constexpr const bool
    numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
constexpr const bool
    numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style
    numeric_limits<const volatile _Tp>::round_style;

} }




namespace std { inline namespace __1 {
class __attribute__((__visibility__("hidden"))) __libcpp_refstring {

  const char *__imp_ __attribute__((__unused__));



};
} }


namespace std
{

class __attribute__((__visibility__("default"))) logic_error : public exception {
private:
  std::__1::__libcpp_refstring __imp_;

public:
  explicit logic_error(const string &);
  explicit logic_error(const char *);

  logic_error(const logic_error &) noexcept;
  logic_error &operator=(const logic_error &) noexcept;

  virtual ~logic_error() noexcept;

  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) runtime_error : public exception {
private:
  std::__1::__libcpp_refstring __imp_;

public:
  explicit runtime_error(const string &);
  explicit runtime_error(const char *);

  runtime_error(const runtime_error &) noexcept;
  runtime_error &operator=(const runtime_error &) noexcept;

  virtual ~runtime_error() noexcept;

  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) domain_error : public logic_error {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit domain_error(const string &__s)
      : logic_error(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit domain_error(const char *__s)
      : logic_error(__s) {}

  virtual ~domain_error() noexcept;
};

class __attribute__((__visibility__("default"))) invalid_argument : public logic_error {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const string &__s)
      : logic_error(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit invalid_argument(const char *__s)
      : logic_error(__s) {}

  virtual ~invalid_argument() noexcept;
};

class __attribute__((__visibility__("default"))) length_error : public logic_error {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit length_error(const string &__s)
      : logic_error(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit length_error(const char *__s)
      : logic_error(__s) {}

  virtual ~length_error() noexcept;
};

class __attribute__((__visibility__("default"))) out_of_range : public logic_error {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const string &__s)
      : logic_error(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit out_of_range(const char *__s)
      : logic_error(__s) {}

  virtual ~out_of_range() noexcept;
};

class __attribute__((__visibility__("default"))) range_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit range_error(const string &__s)
      : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit range_error(const char *__s)
      : runtime_error(__s) {}

  virtual ~range_error() noexcept;
};

class __attribute__((__visibility__("default"))) overflow_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const string &__s)
      : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit overflow_error(const char *__s)
      : runtime_error(__s) {}

  virtual ~overflow_error() noexcept;
};

class __attribute__((__visibility__("default"))) underflow_error : public runtime_error {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const string &__s)
      : runtime_error(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit underflow_error(const char *__s)
      : runtime_error(__s) {}

  virtual ~underflow_error() noexcept;
};

}

namespace std { inline namespace __1 {


[[noreturn]] __attribute__((__visibility__("default"))) void __throw_runtime_error(const char *);

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__throw_logic_error(const char *__msg) {

  throw logic_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__throw_domain_error(const char *__msg) {

  throw domain_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__throw_invalid_argument(const char *__msg) {

  throw invalid_argument(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__throw_length_error(const char *__msg) {

  throw length_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__throw_out_of_range(const char *__msg) {

  throw out_of_range(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__throw_range_error(const char *__msg) {

  throw range_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__throw_overflow_error(const char *__msg) {

  throw overflow_error(__msg);



}

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__throw_underflow_error(const char *__msg) {

  throw underflow_error(__msg);



}

} }


namespace std { inline namespace __1 {

template <class _Tp> class __attribute__((__visibility__("default"))) tuple_size;

template <class _Tp>
class __attribute__((__visibility__("default"))) tuple_size<const _Tp> : public tuple_size<_Tp> {};

template <class _Tp>
class __attribute__((__visibility__("default"))) tuple_size<volatile _Tp> : public tuple_size<_Tp> {
};

template <class _Tp>
class __attribute__((__visibility__("default"))) tuple_size<const volatile _Tp>
    : public tuple_size<_Tp> {};

template <size_t _Ip, class _Tp> class __attribute__((__visibility__("default"))) tuple_element;

template <size_t _Ip, class _Tp>
class __attribute__((__visibility__("default"))) tuple_element<_Ip, const _Tp> {
public:
  typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
class __attribute__((__visibility__("default"))) tuple_element<_Ip, volatile _Tp> {
public:
  typedef
      typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
class __attribute__((__visibility__("default"))) tuple_element<_Ip, const volatile _Tp> {
public:
  typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <class _Tp> struct __tuple_like : false_type {};

template <class _Tp>
struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp>
struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp>
struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};





template <size_t...> struct __tuple_indices {};

template <class _IdxType, _IdxType... _Values> struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq,
            class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t,
                                _Ep - _Sp>::template __to_tuple_indices<_Sp>;
template <size_t _Ep, size_t _Sp = 0> struct __make_tuple_indices {
  static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
  typedef __make_indices_imp<_Ep, _Sp> type;
};

template <class... _Tp> class __attribute__((__visibility__("default"))) tuple;

template <class... _Tp> struct __tuple_like<tuple<_Tp...>> : true_type {};

template <class... _Tp>
class __attribute__((__visibility__("default"))) tuple_size<tuple<_Tp...>>
    : public integral_constant<size_t, sizeof...(_Tp)> {};

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename tuple_element<_Ip, tuple<_Tp...>>::type &
    get(tuple<_Tp...> &) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"), __always_inline__))
                                  const typename tuple_element<
        _Ip, tuple<_Tp...>>::type &
    get(const tuple<_Tp...> &) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename tuple_element<_Ip, tuple<_Tp...>>::type &&
    get(tuple<_Tp...> &&) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden"), __always_inline__))
                                  const typename tuple_element<
        _Ip, tuple<_Tp...>>::type &&
    get(const tuple<_Tp...> &&) noexcept;




template <class _T1, class _T2>
struct __tuple_like<pair<_T1, _T2>> : true_type {};

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename tuple_element<_Ip, pair<_T1, _T2>>::type &
    get(pair<_T1, _T2> &) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"), __always_inline__))
                                  const typename tuple_element<
        _Ip, pair<_T1, _T2>>::type &
    get(const pair<_T1, _T2> &) noexcept;


template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename tuple_element<_Ip, pair<_T1, _T2>>::type &&
    get(pair<_T1, _T2> &&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden"), __always_inline__))
                                  const typename tuple_element<
        _Ip, pair<_T1, _T2>>::type &&
    get(const pair<_T1, _T2> &&) noexcept;




template <class _Tp, size_t _Size> struct __attribute__((__visibility__("default"))) array;

template <class _Tp, size_t _Size>
struct __tuple_like<array<_Tp, _Size>> : true_type {};

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"), __always_inline__)) _Tp &
get(array<_Tp, _Size> &) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"), __always_inline__)) const _Tp &
get(const array<_Tp, _Size> &) noexcept;


template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"), __always_inline__)) _Tp &&
get(array<_Tp, _Size> &&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden"), __always_inline__)) const _Tp &&
get(const array<_Tp, _Size> &&) noexcept;






template <class... _Tp> struct __tuple_types {};



namespace __indexer_detail {

template <size_t _Idx, class _Tp> struct __indexed { using type = _Tp; };

template <class _Types, class _Indexes> struct __indexer;

template <class... _Types, size_t... _Idx>
struct __indexer<__tuple_types<_Types...>, __tuple_indices<_Idx...>>
    : __indexed<_Idx, _Types>... {};

template <size_t _Idx, class _Tp>
__indexed<_Idx, _Tp> __at_index(__indexed<_Idx, _Tp> const &);

}

template <size_t _Idx, class... _Types>
using __type_pack_element =
    typename decltype(__indexer_detail::__at_index<_Idx>(
        __indexer_detail::__indexer<
            __tuple_types<_Types...>,
            typename __make_tuple_indices<sizeof...(_Types)>::type>{}))::type;


template <size_t _Ip, class... _Types>
class __attribute__((__visibility__("default"))) tuple_element<_Ip, __tuple_types<_Types...>> {
public:
  static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
  typedef __type_pack_element<_Ip, _Types...> type;
};

template <class... _Tp>
class __attribute__((__visibility__("default"))) tuple_size<__tuple_types<_Tp...>>
    : public integral_constant<size_t, sizeof...(_Tp)> {};

template <class... _Tp>
struct __tuple_like<__tuple_types<_Tp...>> : true_type {};

template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <> struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <> struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply = const _Tp;
};
template <> struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply = volatile _Tp;
};
template <> struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply = const volatile _Tp;
};
template <> struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply = _Tp &;
};
template <> struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply = const _Tp &;
};
template <> struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply = volatile _Tp &;
};
template <> struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply = const volatile _Tp &;
};
template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
using __apply_cv_t =
    __apply_cv_mf<is_lvalue_reference<_Tp>::value, is_const<_RawTp>::value,
                  is_volatile<_RawTp>::value>;
template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class... _Types, size_t... _Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<typename _ApplyFn::template __apply<
      __type_pack_element<_Idx, _Types...>>...>;
};

template <class _Vt, size_t _Np, size_t... _Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t> using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals =
      __tuple_types<typename _ApplyFn::template __apply<__value_type<_Idx>>...>;
};

template <class _Tp,
          size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
          size_t _Sp = 0,
          bool _SameSize =
              (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
struct __make_tuple_types {
  static_assert(_Sp <= _Ep, "__make_tuple_types input error");
  using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
  using _Maker =
      __make_tuple_types_flat<_RawTp,
                              typename __make_tuple_indices<_Ep, _Sp>::type>;
  using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class... _Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <class... _Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <bool... _Preds> struct __all_dummy;

template <bool... _Pred>
using __all =
    is_same<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait, class... _LArgs,
            class... _RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
      -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{
          true}...>;
  template <template <class...> class> static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible =
      decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible =
      decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable =
      decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};



template <class _Tp, class _Up,
          bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
          bool = __tuple_like<_Up>::value>
struct __tuple_convertible : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
          typename __make_tuple_types<_Tp>::type,
          typename __make_tuple_types<_Up>::type> {};



template <class _Tp, class _Up,
          bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
          bool = __tuple_like<_Up>::value>
struct __tuple_constructible : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
          typename __make_tuple_types<_Tp>::type,
          typename __make_tuple_types<_Up>::type> {};



template <class _Tp, class _Up,
          bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
          bool = __tuple_like<_Up>::value>
struct __tuple_assignable : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
          typename __make_tuple_types<_Tp>::type,
          typename __make_tuple_types<_Up &>::type> {};

template <size_t _Ip, class... _Tp>
class __attribute__((__visibility__("default"))) tuple_element<_Ip, tuple<_Tp...>> {
public:
  typedef typename tuple_element<_Ip, __tuple_types<_Tp...>>::type type;
};
template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};

template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};

template <class _Tuple, size_t _ExpectedSize,
          class _RawTuple = typename __uncvref<_Tuple>::type>
using __tuple_like_with_size =
    __tuple_like_with_size_imp<__tuple_like<_RawTuple>::value,
                               tuple_size<_RawTuple>, _ExpectedSize>;

struct __attribute__((__visibility__("default"))) __check_tuple_constructor_fail {
  template <class...> static constexpr bool __enable_default() { return false; }
  template <class...> static constexpr bool __enable_explicit() {
    return false;
  }
  template <class...> static constexpr bool __enable_implicit() {
    return false;
  }
  template <class...> static constexpr bool __enable_assign() { return false; }
};
} }




namespace std { inline namespace __1 {

namespace rel_ops {

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator!=(const _Tp &__x,
                                                 const _Tp &__y) {
  return !(__x == __y);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator>(const _Tp &__x,
                                                const _Tp &__y) {
  return __y < __x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator<=(const _Tp &__x,
                                                 const _Tp &__y) {
  return !(__y < __x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator>=(const _Tp &__x,
                                                 const _Tp &__y) {
  return !(__x < __y);
}

}



template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
            _ForwardIterator2 __first2) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    swap(*__first1, *__first2);
  return __first2;
}


template <class _Tp, size_t _Np>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_swappable<_Tp>::value>::type swap(_Tp (&__a)[_Np],
                                                              _Tp (&__b)[_Np])
        noexcept(__is_nothrow_swappable<_Tp>::value) {
  std::__1::swap_ranges(__a, __a + _Np, __b);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))

    typename conditional<!is_nothrow_move_constructible<_Tp>::value &&
                             is_copy_constructible<_Tp>::value,
                         const _Tp &, _Tp &&>::type



    move_if_noexcept(_Tp &__x) noexcept {
  return std::__1::move(__x);
}
struct __attribute__((__visibility__("default"))) piecewise_construct_t {};




constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
template <class _T1, class _T2>
struct __attribute__((__visibility__("default"))) pair



{
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;


  pair(pair const &) = default;
  pair(pair &&) = default;
  template <bool _Val> using _EnableB = typename enable_if<_Val, bool>::type;

  struct _CheckArgs {
    template <class _U1, class _U2> static constexpr bool __enable_default() {
      return is_default_constructible<_U1>::value &&
             is_default_constructible<_U2>::value;
    }

    template <class _U1, class _U2> static constexpr bool __enable_explicit() {
      return is_constructible<first_type, _U1>::value &&
             is_constructible<second_type, _U2>::value &&
             (!is_convertible<_U1, first_type>::value ||
              !is_convertible<_U2, second_type>::value);
    }

    template <class _U1, class _U2> static constexpr bool __enable_implicit() {
      return is_constructible<first_type, _U1>::value &&
             is_constructible<second_type, _U2>::value &&
             is_convertible<_U1, first_type>::value &&
             is_convertible<_U2, second_type>::value;
    }
  };

  template <bool _MaybeEnable>
  using _CheckArgsDep =
      typename conditional<_MaybeEnable, _CheckArgs,
                           __check_tuple_constructor_fail>::type;

  struct _CheckTupleLikeConstructor {
    template <class _Tuple> static constexpr bool __enable_implicit() {
      return __tuple_convertible<_Tuple, pair>::value;
    }

    template <class _Tuple> static constexpr bool __enable_explicit() {
      return __tuple_constructible<_Tuple, pair>::value &&
             !__tuple_convertible<_Tuple, pair>::value;
    }

    template <class _Tuple> static constexpr bool __enable_assign() {
      return __tuple_assignable<_Tuple, pair>::value;
    }
  };

  template <class _Tuple>
  using _CheckTLC = typename conditional<
      __tuple_like_with_size<_Tuple, 2>::value &&
          !is_same<typename decay<_Tuple>::type, pair>::value,
      _CheckTupleLikeConstructor, __check_tuple_constructor_fail>::type;

  template <
      bool _Dummy = true,
      _EnableB<_CheckArgsDep<_Dummy>::template __enable_default<_T1, _T2>()> =
          false>
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr pair() : first(), second() {}

  template <bool _Dummy = true,
            _EnableB<_CheckArgsDep<_Dummy>::template __enable_explicit<
                _T1 const &, _T2 const &>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit pair(_T1 const &__t1,
                                                  _T2 const &__t2)
      : first(__t1), second(__t2) {}

  template <bool _Dummy = true,
            _EnableB<_CheckArgsDep<_Dummy>::template __enable_implicit<
                _T1 const &, _T2 const &>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair(_T1 const &__t1,
                                                               _T2 const &__t2)
      : first(__t1), second(__t2) {}

  template <
      class _U1, class _U2,
      _EnableB<_CheckArgs::template __enable_explicit<_U1, _U2>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit pair(_U1 &&__u1, _U2 &&__u2)
      : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

  template <
      class _U1, class _U2,
      _EnableB<_CheckArgs::template __enable_implicit<_U1, _U2>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair(_U1 &&__u1,
                                                               _U2 &&__u2)
      : first(std::__1::forward<_U1>(__u1)), second(std::__1::forward<_U2>(__u2)) {}

  template <class _U1, class _U2,
            _EnableB<_CheckArgs::template __enable_explicit<
                _U1 const &, _U2 const &>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit pair(pair<_U1, _U2> const &__p)
      : first(__p.first), second(__p.second) {}

  template <class _U1, class _U2,
            _EnableB<_CheckArgs::template __enable_implicit<
                _U1 const &, _U2 const &>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair(pair<_U1, _U2> const &__p)
      : first(__p.first), second(__p.second) {}

  template <
      class _U1, class _U2,
      _EnableB<_CheckArgs::template __enable_explicit<_U1, _U2>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit pair(pair<_U1, _U2> &&__p)
      : first(std::__1::forward<_U1>(__p.first)),
        second(std::__1::forward<_U2>(__p.second)) {}

  template <
      class _U1, class _U2,
      _EnableB<_CheckArgs::template __enable_implicit<_U1, _U2>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair(pair<_U1, _U2> &&__p)
      : first(std::__1::forward<_U1>(__p.first)),
        second(std::__1::forward<_U2>(__p.second)) {}

  template <
      class _Tuple,
      _EnableB<_CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit pair(_Tuple &&__p)
      : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
        second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

  template <
      class _Tuple,
      _EnableB<_CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair(_Tuple &&__p)
      : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
        second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

  template <class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair(piecewise_construct_t __pc,
                                 tuple<_Args1...> __first_args,
                                 tuple<_Args2...> __second_args)
      : pair(__pc, __first_args, __second_args,
             typename __make_tuple_indices<sizeof...(_Args1)>::type(),
             typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  pair &
  operator=(typename conditional<is_copy_assignable<first_type>::value &&
                                     is_copy_assignable<second_type>::value,
                                 pair, __nat>::type const &__p)
      noexcept(is_nothrow_copy_assignable<first_type>::value &&is_nothrow_copy_assignable<second_type>::value) {

    first = __p.first;
    second = __p.second;
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  pair &
  operator=(typename conditional<is_move_assignable<first_type>::value &&
                                     is_move_assignable<second_type>::value,
                                 pair, __nat>::type &&__p)
      noexcept(is_nothrow_move_assignable<first_type>::value &&is_nothrow_move_assignable<second_type>::value) {

    first = std::__1::forward<first_type>(__p.first);
    second = std::__1::forward<second_type>(__p.second);
    return *this;
  }

  template <
      class _Tuple,
      _EnableB<_CheckTLC<_Tuple>::template __enable_assign<_Tuple>()> = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair &operator=(_Tuple &&__p) {
    first = std::__1::get<0>(std::__1::forward<_Tuple>(__p));
    second = std::__1::get<1>(std::__1::forward<_Tuple>(__p));
    return *this;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(pair &__p)
      noexcept(__is_nothrow_swappable<first_type>::value &&__is_nothrow_swappable<second_type>::value) {

    using std::__1::swap;
    swap(first, __p.first);
    swap(second, __p.second);
  }

private:

  template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair(piecewise_construct_t, tuple<_Args1...> &__first_args,
       tuple<_Args2...> &__second_args, __tuple_indices<_I1...>,
       __tuple_indices<_I2...>);

};

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_swappable<_T1>::value && __is_swappable<_T2>::value,
                       void>::type
    swap(pair<_T1, _T2> &__x, pair<_T1, _T2> &__y)
        noexcept((__is_nothrow_swappable<_T1>::value && __is_nothrow_swappable<_T2>::value)) {

  __x.swap(__y);
}



template <class _Tp> struct __make_pair_return_impl { typedef _Tp type; };

template <class _Tp> struct __make_pair_return_impl<reference_wrapper<_Tp>> {
  typedef _Tp &type;
};

template <class _Tp> struct __make_pair_return {
  typedef
      typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;
};

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  pair<typename __make_pair_return<_T1>::type,
                                       typename __make_pair_return<_T2>::type>
    make_pair(_T1 &&__t1, _T2 &&__t2) {
  return pair<typename __make_pair_return<_T1>::type,
              typename __make_pair_return<_T2>::type>(
      std::__1::forward<_T1>(__t1), std::__1::forward<_T2>(__t2));
}
template <class _T1, class _T2>
class __attribute__((__visibility__("default"))) tuple_size<pair<_T1, _T2>>
    : public integral_constant<size_t, 2> {};

template <class _T1, class _T2>
class __attribute__((__visibility__("default"))) tuple_element<0, pair<_T1, _T2>> {
public:
  typedef _T1 type;
};

template <class _T1, class _T2>
class __attribute__((__visibility__("default"))) tuple_element<1, pair<_T1, _T2>> {
public:
  typedef _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <> struct __get_pair<0> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"), __always_inline__)) _T1 &
  get(pair<_T1, _T2> &__p) noexcept {
    return __p.first;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"), __always_inline__)) const _T1 &
  get(const pair<_T1, _T2> &__p) noexcept {
    return __p.first;
  }



  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"), __always_inline__)) _T1 &&
  get(pair<_T1, _T2> &&__p) noexcept {
    return std::__1::forward<_T1>(__p.first);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"), __always_inline__)) const _T1 &&
  get(const pair<_T1, _T2> &&__p) noexcept {
    return std::__1::forward<const _T1>(__p.first);
  }


};

template <> struct __get_pair<1> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"), __always_inline__)) _T2 &
  get(pair<_T1, _T2> &__p) noexcept {
    return __p.second;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"), __always_inline__)) const _T2 &
  get(const pair<_T1, _T2> &__p) noexcept {
    return __p.second;
  }



  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"), __always_inline__)) _T2 &&
  get(pair<_T1, _T2> &&__p) noexcept {
    return std::__1::forward<_T2>(__p.second);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden"), __always_inline__)) const _T2 &&
  get(const pair<_T1, _T2> &&__p) noexcept {
    return std::__1::forward<const _T2>(__p.second);
  }


};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename tuple_element<_Ip, pair<_T1, _T2>>::type &
    get(pair<_T1, _T2> &__p) noexcept {
  return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  const typename tuple_element<
        _Ip, pair<_T1, _T2>>::type &
    get(const pair<_T1, _T2> &__p) noexcept {
  return __get_pair<_Ip>::get(__p);
}



template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename tuple_element<_Ip, pair<_T1, _T2>>::type &&
    get(pair<_T1, _T2> &&__p) noexcept {
  return __get_pair<_Ip>::get(std::__1::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  const typename tuple_element<
        _Ip, pair<_T1, _T2>>::type &&
    get(const pair<_T1, _T2> &&__p) noexcept {
  return __get_pair<_Ip>::get(std::__1::move(__p));
}
} }


namespace std { inline namespace __1 {





template <size_t _Ip, class _Hp,
          bool = is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value>
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(__tuple_leaf<_Ip, _Hp, _Ep> &__x,
                                           __tuple_leaf<_Ip, _Hp, _Ep> &__y)
    noexcept(__is_nothrow_swappable<_Hp>::value) {
  swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool> class __tuple_leaf {
  _Hp value;

  template <class _Tp> static constexpr bool __can_bind_reference() {
    using _RawTp = typename remove_reference<_Tp>::type;
    using _RawHp = typename remove_reference<_Hp>::type;
    using _CheckLValueArg = integral_constant<
        bool, is_lvalue_reference<_Tp>::value ||
                  is_same<_RawTp, reference_wrapper<_RawHp>>::value ||
                  is_same<_RawTp, reference_wrapper<typename remove_const<
                                      _RawHp>::type>>::value>;
    return !is_reference<_Hp>::value ||
           (is_lvalue_reference<_Hp>::value && _CheckLValueArg::value) ||
           (is_rvalue_reference<_Hp>::value &&
            !is_lvalue_reference<_Tp>::value);
  }

  __tuple_leaf &operator=(const __tuple_leaf &);

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr __tuple_leaf()
      noexcept(is_nothrow_default_constructible<_Hp>::value)
      : value() {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) __tuple_leaf(integral_constant<int, 0>,
                                         const _Alloc &)
      : value() {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) __tuple_leaf(integral_constant<int, 1>,
                                         const _Alloc &__a)
      : value(allocator_arg_t(), __a) {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) __tuple_leaf(integral_constant<int, 2>,
                                         const _Alloc &__a)
      : value(__a) {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to default construct a reference element in a tuple");
  }

  template <class _Tp,
            class = typename enable_if<__lazy_and<
                __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>,
                is_constructible<_Hp, _Tp>>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit __tuple_leaf(_Tp &&__t)
          noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
      : value(std::__1::forward<_Tp>(__t)) {
    static_assert(
        __can_bind_reference<_Tp>(),
        "Attempted to construct a reference element in a tuple with an rvalue");
  }

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __tuple_leaf(integral_constant<int, 0>,
                                                  const _Alloc &, _Tp &&__t)
      : value(std::__1::forward<_Tp>(__t)) {
    static_assert(
        __can_bind_reference<_Tp>(),
        "Attempted to construct a reference element in a tuple with an rvalue");
  }

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __tuple_leaf(integral_constant<int, 1>,
                                                  const _Alloc &__a, _Tp &&__t)
      : value(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to uses-allocator construct a reference element in a tuple");
  }

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __tuple_leaf(integral_constant<int, 2>,
                                                  const _Alloc &__a, _Tp &&__t)
      : value(std::__1::forward<_Tp>(__t), __a) {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to uses-allocator construct a reference element in a tuple");
  }

  __tuple_leaf(const __tuple_leaf &__t) = default;
  __tuple_leaf(__tuple_leaf &&__t) = default;

  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) __tuple_leaf &operator=(_Tp &&__t)
      noexcept((is_nothrow_assignable<_Hp &, _Tp>::value)) {
    value = std::__1::forward<_Tp>(__t);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int swap(__tuple_leaf &__t)
      noexcept(__is_nothrow_swappable<__tuple_leaf>::value) {
    std::__1::swap(*this, __t);
    return 0;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) _Hp &get() noexcept {
    return value;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const _Hp &
  get() const noexcept {
    return value;
  }
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true> : private _Hp {

  __tuple_leaf &operator=(const __tuple_leaf &);

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr __tuple_leaf()
      noexcept(is_nothrow_default_constructible<_Hp>::value) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) __tuple_leaf(integral_constant<int, 0>,
                                         const _Alloc &) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) __tuple_leaf(integral_constant<int, 1>,
                                         const _Alloc &__a)
      : _Hp(allocator_arg_t(), __a) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) __tuple_leaf(integral_constant<int, 2>,
                                         const _Alloc &__a)
      : _Hp(__a) {}

  template <class _Tp,
            class = typename enable_if<__lazy_and<
                __lazy_not<is_same<typename decay<_Tp>::type, __tuple_leaf>>,
                is_constructible<_Hp, _Tp>>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit __tuple_leaf(_Tp &&__t)
          noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
      : _Hp(std::__1::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __tuple_leaf(integral_constant<int, 0>,
                                                  const _Alloc &, _Tp &&__t)
      : _Hp(std::__1::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __tuple_leaf(integral_constant<int, 1>,
                                                  const _Alloc &__a, _Tp &&__t)
      : _Hp(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __tuple_leaf(integral_constant<int, 2>,
                                                  const _Alloc &__a, _Tp &&__t)
      : _Hp(std::__1::forward<_Tp>(__t), __a) {}

  __tuple_leaf(__tuple_leaf const &) = default;
  __tuple_leaf(__tuple_leaf &&) = default;

  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) __tuple_leaf &operator=(_Tp &&__t)
      noexcept((is_nothrow_assignable<_Hp &, _Tp>::value)) {
    _Hp::operator=(std::__1::forward<_Tp>(__t));
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int swap(__tuple_leaf &__t)
      noexcept(__is_nothrow_swappable<__tuple_leaf>::value) {
    std::__1::swap(*this, __t);
    return 0;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) _Hp &get() noexcept {
    return static_cast<_Hp &>(*this);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const _Hp &
  get() const noexcept {
    return static_cast<const _Hp &>(*this);
  }
};

template <class... _Tp>
__attribute__((__visibility__("hidden"), __always_inline__)) void __swallow(_Tp &&...) noexcept {}

template <class... _Tp> struct __lazy_all : __all<_Tp::value...> {};

template <class _Tp> struct __all_default_constructible;

template <class... _Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...> {};



template <class _Indx, class... _Tp> struct __tuple_impl;

template <size_t... _Indx, class... _Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>... {
  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr __tuple_impl() noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}


  template <size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl,
            class... _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __tuple_impl(
      __tuple_indices<_Uf...>, __tuple_types<_Tf...>, __tuple_indices<_Ul...>,
      __tuple_types<_Tl...>, _Up &&... __u)
      noexcept((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value && __all<is_nothrow_default_constructible<_Tl>::value...>::value))


      : __tuple_leaf<_Uf, _Tf>(std::__1::forward<_Up>(__u))...,
        __tuple_leaf<_Ul, _Tl>()... {}

  template <class _Alloc, size_t... _Uf, class... _Tf, size_t... _Ul,
            class... _Tl, class... _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __tuple_impl(
      allocator_arg_t, const _Alloc &__a, __tuple_indices<_Uf...>,
      __tuple_types<_Tf...>, __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
      _Up &&... __u)
      : __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
                               std::__1::forward<_Up>(__u))...,
        __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)... {}

  template <class _Tuple, class = typename enable_if<__tuple_constructible<
                              _Tuple, tuple<_Tp...>>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__))
  __tuple_impl(_Tuple &&__t) noexcept((__all<is_nothrow_constructible< _Tp, typename tuple_element< _Indx, typename __make_tuple_types<_Tuple>::type>::type>:: value...>::value))




      : __tuple_leaf<_Indx, _Tp>(
            std::__1::forward<typename tuple_element<
                _Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                std::__1::get<_Indx>(__t)))... {}

  template <class _Alloc, class _Tuple,
            class = typename enable_if<
                __tuple_constructible<_Tuple, tuple<_Tp...>>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) __tuple_impl(allocator_arg_t, const _Alloc &__a,
                                         _Tuple &&__t)
      : __tuple_leaf<_Indx, _Tp>(
            __uses_alloc_ctor<
                _Tp, _Alloc,
                typename tuple_element<
                    _Indx, typename __make_tuple_types<_Tuple>::type>::type>(),
            __a, std::__1::forward<typename tuple_element<
                     _Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                     std::__1::get<_Indx>(__t)))... {}

  template <class _Tuple>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<
      __tuple_assignable<_Tuple, tuple<_Tp...>>::value, __tuple_impl &>::type
  operator=(_Tuple &&__t) noexcept((__all<is_nothrow_assignable< _Tp &, typename tuple_element< _Indx, typename __make_tuple_types<_Tuple>::type>::type>:: value...>::value)) {




    __swallow(__tuple_leaf<_Indx, _Tp>::operator=(
        std::__1::forward<typename tuple_element<
            _Indx, typename __make_tuple_types<_Tuple>::type>::type>(
            std::__1::get<_Indx>(__t)))...);
    return *this;
  }

  __tuple_impl(const __tuple_impl &) = default;
  __tuple_impl(__tuple_impl &&) = default;

  __attribute__((__visibility__("hidden"), __always_inline__))
  __tuple_impl &operator=(const __tuple_impl &__t)
      noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value)) {
    __swallow(__tuple_leaf<_Indx, _Tp>::operator=(
        static_cast<const __tuple_leaf<_Indx, _Tp> &>(__t).get())...);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __tuple_impl &operator=(__tuple_impl &&__t)
      noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value)) {
    __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<_Tp>(
        static_cast<__tuple_leaf<_Indx, _Tp> &>(__t).get()))...);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(__tuple_impl &__t)
      noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
    __swallow(__tuple_leaf<_Indx, _Tp>::swap(
        static_cast<__tuple_leaf<_Indx, _Tp> &>(__t))...);
  }
};

template <class... _Tp> class __attribute__((__visibility__("default"))) tuple {
  typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type,
                       _Tp...>
      base;

  base base_;

  template <class... _Args> struct _PackExpandsToThisTuple : false_type {};

  template <class _Arg>
  struct _PackExpandsToThisTuple<_Arg>
      : is_same<typename __uncvref<_Arg>::type, tuple> {};

  template <bool _MaybeEnable, class _Dummy = void>
  struct _CheckArgsConstructor : __check_tuple_constructor_fail {};

  template <class _Dummy> struct _CheckArgsConstructor<true, _Dummy> {
    template <class... _Args> static constexpr bool __enable_default() {
      return __all<is_default_constructible<_Args>::value...>::value;
    }

    template <class... _Args> static constexpr bool __enable_explicit() {
      return __tuple_constructible<
                 tuple<_Args...>,
                 typename __make_tuple_types<
                     tuple, sizeof...(_Args) < sizeof...(_Tp)
                                ? sizeof...(_Args)
                                : sizeof...(_Tp)>::type>::value &&
             !__tuple_convertible<
                 tuple<_Args...>,
                 typename __make_tuple_types<
                     tuple, sizeof...(_Args) < sizeof...(_Tp)
                                ? sizeof...(_Args)
                                : sizeof...(_Tp)>::type>::value &&
             __all_default_constructible<typename __make_tuple_types<
                 tuple, sizeof...(_Tp), sizeof...(_Args) < sizeof...(_Tp)
                                            ? sizeof...(_Args)
                                            : sizeof...(_Tp)>::type>::value;
    }

    template <class... _Args> static constexpr bool __enable_implicit() {
      return __tuple_convertible<
                 tuple<_Args...>,
                 typename __make_tuple_types<
                     tuple, sizeof...(_Args) < sizeof...(_Tp)
                                ? sizeof...(_Args)
                                : sizeof...(_Tp)>::type>::value &&
             __all_default_constructible<typename __make_tuple_types<
                 tuple, sizeof...(_Tp), sizeof...(_Args) < sizeof...(_Tp)
                                            ? sizeof...(_Args)
                                            : sizeof...(_Tp)>::type>::value;
    }
  };

  template <bool _MaybeEnable, bool = sizeof...(_Tp) == 1, class _Dummy = void>
  struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};

  template <class _Dummy>
  struct _CheckTupleLikeConstructor<true, false, _Dummy> {
    template <class _Tuple> static constexpr bool __enable_implicit() {
      return __tuple_convertible<_Tuple, tuple>::value;
    }

    template <class _Tuple> static constexpr bool __enable_explicit() {
      return __tuple_constructible<_Tuple, tuple>::value &&
             !__tuple_convertible<_Tuple, tuple>::value;
    }
  };

  template <class _Dummy>
  struct _CheckTupleLikeConstructor<true, true, _Dummy> {



    template <class _Tuple>
    using _PreferTupleLikeConstructor = __lazy_or<


        is_same<typename __uncvref<_Tuple>::type, tuple>,
        __lazy_and<__lazy_not<is_constructible<_Tp..., _Tuple>>,
                   __lazy_not<is_convertible<_Tuple, _Tp...>>>>;

    template <class _Tuple> static constexpr bool __enable_implicit() {
      return __lazy_and<__tuple_convertible<_Tuple, tuple>,
                        _PreferTupleLikeConstructor<_Tuple>>::value;
    }

    template <class _Tuple> static constexpr bool __enable_explicit() {
      return __lazy_and<__tuple_constructible<_Tuple, tuple>,
                        _PreferTupleLikeConstructor<_Tuple>,
                        __lazy_not<__tuple_convertible<_Tuple, tuple>>>::value;
    }
  };

  template <size_t _Jp, class... _Up>
  friend
      typename tuple_element<_Jp, tuple<_Up...>>::type &
      get(tuple<_Up...> &) noexcept;
  template <size_t _Jp, class... _Up>
  friend const typename tuple_element<
      _Jp, tuple<_Up...>>::type &
  get(const tuple<_Up...> &) noexcept;
  template <size_t _Jp, class... _Up>
  friend
      typename tuple_element<_Jp, tuple<_Up...>>::type &&
      get(tuple<_Up...> &&) noexcept;
  template <size_t _Jp, class... _Up>
  friend const typename tuple_element<
      _Jp, tuple<_Up...>>::type &&
  get(const tuple<_Up...> &&) noexcept;

public:
  template <bool _Dummy = true,
            class = typename enable_if<_CheckArgsConstructor<
                _Dummy>::template __enable_default<_Tp...>()>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr tuple() noexcept(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}


  tuple(tuple const &) = default;
  tuple(tuple &&) = default;

  template <class _AllocArgT, class _Alloc, bool _Dummy = true,
            class = typename enable_if<__lazy_and<
                is_same<allocator_arg_t, _AllocArgT>,
                __lazy_all<__dependent_type<is_default_constructible<_Tp>,
                                            _Dummy>...>>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple(_AllocArgT, _Alloc const &__a)
      : base_(allocator_arg_t(), __a, __tuple_indices<>(), __tuple_types<>(),
              typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
              __tuple_types<_Tp...>()) {}

  template <
      bool _Dummy = true,
      typename enable_if<
          _CheckArgsConstructor<_Dummy>::template __enable_implicit<_Tp...>(),
          bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
  tuple(const _Tp &... __t)
      noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
      : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
              typename __make_tuple_indices<0>::type(),
              typename __make_tuple_types<tuple, 0>::type(), __t...) {}

  template <
      bool _Dummy = true,
      typename enable_if<
          _CheckArgsConstructor<_Dummy>::template __enable_explicit<_Tp...>(),
          bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit tuple(
      const _Tp &... __t)
      noexcept((__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
      : base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
              typename __make_tuple_indices<0>::type(),
              typename __make_tuple_types<tuple, 0>::type(), __t...) {}

  template <
      class _Alloc, bool _Dummy = true,
      typename enable_if<
          _CheckArgsConstructor<_Dummy>::template __enable_implicit<_Tp...>(),
          bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple(allocator_arg_t, const _Alloc &__a,
                                  const _Tp &... __t)
      : base_(allocator_arg_t(), __a,
              typename __make_tuple_indices<sizeof...(_Tp)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
              typename __make_tuple_indices<0>::type(),
              typename __make_tuple_types<tuple, 0>::type(), __t...) {}

  template <
      class _Alloc, bool _Dummy = true,
      typename enable_if<
          _CheckArgsConstructor<_Dummy>::template __enable_explicit<_Tp...>(),
          bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit tuple(allocator_arg_t, const _Alloc &__a,
                                           const _Tp &... __t)
      : base_(allocator_arg_t(), __a,
              typename __make_tuple_indices<sizeof...(_Tp)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
              typename __make_tuple_indices<0>::type(),
              typename __make_tuple_types<tuple, 0>::type(), __t...) {}

  template <class... _Up,
            typename enable_if<
                _CheckArgsConstructor<sizeof...(_Up) <= sizeof...(_Tp) &&
                                      !_PackExpandsToThisTuple<_Up...>::value>::
                    template __enable_implicit<_Up...>(),
                bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
  tuple(_Up &&... __u) noexcept((is_nothrow_constructible< base, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up...>::value))







      : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
              typename __make_tuple_indices<sizeof...(_Tp),
                                            sizeof...(_Up)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Tp),
                                          sizeof...(_Up)>::type(),
              std::__1::forward<_Up>(__u)...) {}

  template <class... _Up,
            typename enable_if<
                _CheckArgsConstructor<sizeof...(_Up) <= sizeof...(_Tp) &&
                                      !_PackExpandsToThisTuple<_Up...>::value>::
                    template __enable_explicit<_Up...>(),
                bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit tuple(_Up &&... __u)
          noexcept((is_nothrow_constructible< base, typename __make_tuple_indices<sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Up)>::type, typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type, typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type, _Up...>::value))







      : base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
              typename __make_tuple_indices<sizeof...(_Tp),
                                            sizeof...(_Up)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Tp),
                                          sizeof...(_Up)>::type(),
              std::__1::forward<_Up>(__u)...) {}

  template <class _Alloc, class... _Up,
            typename enable_if<
                _CheckArgsConstructor<sizeof...(_Up) == sizeof...(_Tp) &&
                                      !_PackExpandsToThisTuple<_Up...>::value>::
                    template __enable_implicit<_Up...>(),
                bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple(allocator_arg_t, const _Alloc &__a,
                                  _Up &&... __u)
      : base_(allocator_arg_t(), __a,
              typename __make_tuple_indices<sizeof...(_Up)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
              typename __make_tuple_indices<sizeof...(_Tp),
                                            sizeof...(_Up)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Tp),
                                          sizeof...(_Up)>::type(),
              std::__1::forward<_Up>(__u)...) {}

  template <class _Alloc, class... _Up,
            typename enable_if<
                _CheckArgsConstructor<sizeof...(_Up) == sizeof...(_Tp) &&
                                      !_PackExpandsToThisTuple<_Up...>::value>::
                    template __enable_explicit<_Up...>(),
                bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit tuple(allocator_arg_t, const _Alloc &__a,
                                           _Up &&... __u)
      : base_(allocator_arg_t(), __a,
              typename __make_tuple_indices<sizeof...(_Up)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
              typename __make_tuple_indices<sizeof...(_Tp),
                                            sizeof...(_Up)>::type(),
              typename __make_tuple_types<tuple, sizeof...(_Tp),
                                          sizeof...(_Up)>::type(),
              std::__1::forward<_Up>(__u)...) {}

  template <class _Tuple,
            typename enable_if<
                _CheckTupleLikeConstructor<
                    __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value &&
                    !_PackExpandsToThisTuple<_Tuple>::value>::
                    template __enable_implicit<_Tuple>(),
                bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple(_Tuple &&__t)
      noexcept((is_nothrow_constructible<base, _Tuple>::value))
      : base_(std::__1::forward<_Tuple>(__t)) {}

  template <class _Tuple,
            typename enable_if<
                _CheckTupleLikeConstructor<
                    __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value &&
                    !_PackExpandsToThisTuple<_Tuple>::value>::
                    template __enable_explicit<_Tuple>(),
                bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit tuple(_Tuple &&__t)
          noexcept((is_nothrow_constructible<base, _Tuple>::value))
      : base_(std::__1::forward<_Tuple>(__t)) {}

  template <
      class _Alloc, class _Tuple,
      typename enable_if<_CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::
                                 value>::template __enable_implicit<_Tuple>(),
                         bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple(allocator_arg_t, const _Alloc &__a,
                                  _Tuple &&__t)
      : base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

  template <
      class _Alloc, class _Tuple,
      typename enable_if<_CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::
                                 value>::template __enable_explicit<_Tuple>(),
                         bool>::type = false>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit tuple(allocator_arg_t, const _Alloc &__a,
                                           _Tuple &&__t)
      : base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

  using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;
  using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;

  __attribute__((__visibility__("hidden"), __always_inline__))
  tuple &operator=(typename conditional<_CanCopyAssign::value, tuple,
                                        __nat>::type const &__t)
      noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::value)) {
    base_.operator=(__t.base_);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  tuple &operator=(
      typename conditional<_CanMoveAssign::value, tuple, __nat>::type &&__t)
      noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::value)) {
    base_.operator=(static_cast<base &&>(__t.base_));
    return *this;
  }

  template <class _Tuple, class = typename enable_if<
                              __tuple_assignable<_Tuple, tuple>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple &operator=(_Tuple &&__t)
      noexcept((is_nothrow_assignable<base &, _Tuple>::value)) {
    base_.operator=(std::__1::forward<_Tuple>(__t));
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(tuple &__t)
      noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
    base_.swap(__t.base_);
  }
};

template <> class __attribute__((__visibility__("default"))) tuple<> {
public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr tuple() noexcept {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple(allocator_arg_t, const _Alloc &) noexcept {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple(allocator_arg_t, const _Alloc &,
                                  const tuple &) noexcept {}
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple(array<_Up, 0>) noexcept {}
  template <class _Alloc, class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) tuple(allocator_arg_t, const _Alloc &,
                                  array<_Up, 0>) noexcept {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(tuple &) noexcept {}
};

template <class... _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__all<__is_swappable<_Tp>::value...>::value, void>::type
    swap(tuple<_Tp...> &__t, tuple<_Tp...> &__u)
        noexcept(__all<__is_nothrow_swappable<_Tp>::value...>::value) {
  __t.swap(__u);
}



template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename tuple_element<_Ip, tuple<_Tp...>>::type &
    get(tuple<_Tp...> &__t) noexcept {
  typedef typename tuple_element<_Ip, tuple<_Tp...>>::type type;
  return static_cast<__tuple_leaf<_Ip, type> &>(__t.base_).get();
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  const typename tuple_element<
        _Ip, tuple<_Tp...>>::type &
    get(const tuple<_Tp...> &__t) noexcept {
  typedef typename tuple_element<_Ip, tuple<_Tp...>>::type type;
  return static_cast<const __tuple_leaf<_Ip, type> &>(__t.base_).get();
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename tuple_element<_Ip, tuple<_Tp...>>::type &&
    get(tuple<_Tp...> &&__t) noexcept {
  typedef typename tuple_element<_Ip, tuple<_Tp...>>::type type;
  return static_cast<type &&>(
      static_cast<__tuple_leaf<_Ip, type> &&>(__t.base_).get());
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  const typename tuple_element<
        _Ip, tuple<_Tp...>>::type &&
    get(const tuple<_Tp...> &&__t) noexcept {
  typedef typename tuple_element<_Ip, tuple<_Tp...>>::type type;
  return static_cast<const type &&>(
      static_cast<const __tuple_leaf<_Ip, type> &&>(__t.base_).get());
}
template <class... _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) tuple<_Tp &...>
tie(_Tp &... __t) noexcept {
  return tuple<_Tp &...>(__t...);
}

template <class _Up> struct __ignore_t {
  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) const __ignore_t &operator=(_Tp &&) const {
    return *this;
  }
};

namespace {
const __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}

template <class _Tp> struct __make_tuple_return_impl { typedef _Tp type; };

template <class _Tp> struct __make_tuple_return_impl<reference_wrapper<_Tp>> {
  typedef _Tp &type;
};

template <class _Tp> struct __make_tuple_return {
  typedef
      typename __make_tuple_return_impl<typename decay<_Tp>::type>::type type;
};

template <class... _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    tuple<typename __make_tuple_return<_Tp>::type...>
    make_tuple(_Tp &&... __t) {
  return tuple<typename __make_tuple_return<_Tp>::type...>(
      std::__1::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) tuple<_Tp &&...>
forward_as_tuple(_Tp &&... __t) noexcept {
  return tuple<_Tp &&...>(std::__1::forward<_Tp>(__t)...);
}

template <size_t _Ip> struct __tuple_equal {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Up &__y) {
    return __tuple_equal<_Ip - 1>()(__x, __y) &&
           std::__1::get<_Ip - 1>(__x) == std::__1::get<_Ip - 1>(__y);
  }
};

template <> struct __tuple_equal<0> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &, const _Up &) {
    return true;
  }
};

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return !(__x == __y);
}

template <size_t _Ip> struct __tuple_less {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Up &__y) {
    const size_t __idx = tuple_size<_Tp>::value - _Ip;
    if (std::__1::get<__idx>(__x) < std::__1::get<__idx>(__y))
      return true;
    if (std::__1::get<__idx>(__y) < std::__1::get<__idx>(__x))
      return false;
    return __tuple_less<_Ip - 1>()(__x, __y);
  }
};

template <> struct __tuple_less<0> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &, const _Up &) {
    return false;
  }
};

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return __y < __x;
}

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return !(__x < __y);
}

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return !(__y < __x);
}



template <class _Tp, class _Up> struct __tuple_cat_type;

template <class... _Ttypes, class... _Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...>> {
  typedef tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class... _Tuples>
struct __tuple_cat_return_1 {};

template <class... _Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0> {
  typedef typename __tuple_cat_type<
      tuple<_Types...>, typename __make_tuple_types<typename remove_reference<
                            _Tuple0>::type>::type>::type type;
};

template <class... _Types, class _Tuple0, class _Tuple1, class... _Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1,
                            _Tuples...>
    : public __tuple_cat_return_1<
          typename __tuple_cat_type<
              tuple<_Types...>,
              typename __make_tuple_types<
                  typename remove_reference<_Tuple0>::type>::type>::type,
          __tuple_like<typename remove_reference<_Tuple1>::type>::value,
          _Tuple1, _Tuples...> {};

template <class... _Tuples> struct __tuple_cat_return;

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<
          tuple<>,
          __tuple_like<typename remove_reference<_Tuple0>::type>::value,
          _Tuple0, _Tuples...> {};

template <> struct __tuple_cat_return<> { typedef tuple<> type; };

inline __attribute__((__visibility__("hidden"), __always_inline__)) tuple<>
tuple_cat() {
  return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref_imp;

template <class... _Types, size_t... _I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0> {
  typedef typename remove_reference<_Tuple0>::type _T0;
  typedef tuple<_Types...,
                typename __apply_cv<_Tuple0, typename tuple_element<
                                                 _I0, _T0>::type>::type &&...>
      type;
};

template <class... _Types, size_t... _I0, class _Tuple0, class _Tuple1,
          class... _Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
          tuple<_Types...,
                typename __apply_cv<
                    _Tuple0, typename tuple_element<
                                 _I0, typename remove_reference<
                                          _Tuple0>::type>::type>::type &&...>,
          typename __make_tuple_indices<tuple_size<
              typename remove_reference<_Tuple1>::type>::value>::type,
          _Tuple1, _Tuples...> {};

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<
          tuple<>, typename __make_tuple_indices<tuple_size<
                       typename remove_reference<_Tuple0>::type>::value>::type,
          _Tuple0, _Tuples...> {};

template <class _Types, class _I0, class _J0> struct __tuple_cat;

template <class... _Types, size_t... _I0, size_t... _J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>,
                   __tuple_indices<_J0...>> {
  template <class _Tuple0>
  __attribute__((__visibility__("hidden"), __always_inline__))
      typename __tuple_cat_return_ref<tuple<_Types...> &&, _Tuple0 &&>::type
      operator()(tuple<_Types...> __t, _Tuple0 &&__t0) {
    return forward_as_tuple(std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
                            std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...);
  }

  template <class _Tuple0, class _Tuple1, class... _Tuples>
  __attribute__((__visibility__("hidden"), __always_inline__))
      typename __tuple_cat_return_ref<tuple<_Types...> &&, _Tuple0 &&,
                                      _Tuple1 &&, _Tuples &&...>::type
      operator()(tuple<_Types...> __t, _Tuple0 &&__t0, _Tuple1 &&__t1,
                 _Tuples &&... __tpls) {
    typedef typename remove_reference<_Tuple0>::type _T0;
    typedef typename remove_reference<_Tuple1>::type _T1;
    return __tuple_cat<
        tuple<_Types...,
              typename __apply_cv<
                  _Tuple0, typename tuple_element<_J0, _T0>::type>::type &&...>,
        typename __make_tuple_indices<sizeof...(_Types) +
                                      tuple_size<_T0>::value>::type,
        typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
        forward_as_tuple(std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
                         std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...),
        std::__1::forward<_Tuple1>(__t1), std::__1::forward<_Tuples>(__tpls)...);
  }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename __tuple_cat_return<_Tuple0, _Tuples...>::type
    tuple_cat(_Tuple0 &&__t0, _Tuples &&... __tpls) {
  typedef typename remove_reference<_Tuple0>::type _T0;
  return __tuple_cat<
      tuple<>, __tuple_indices<>,
      typename __make_tuple_indices<tuple_size<_T0>::value>::type>()(
      tuple<>(), std::__1::forward<_Tuple0>(__t0),
      std::__1::forward<_Tuples>(__tpls)...);
}

template <class... _Tp, class _Alloc>
struct __attribute__((__visibility__("default"))) uses_allocator<tuple<_Tp...>, _Alloc> : true_type {
};




template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
pair<_T1, _T2>::pair(piecewise_construct_t, tuple<_Args1...> &__first_args,
                     tuple<_Args2...> &__second_args, __tuple_indices<_I1...>,
                     __tuple_indices<_I2...>)
    : first(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...),
      second(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...) {}
            } }





namespace std { inline namespace __1 {

typedef enum memory_order {
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;


namespace __gcc_atomic {
template <typename _Tp> struct __gcc_atomic_t {







  __attribute__((__visibility__("hidden"), __always_inline__))

  __gcc_atomic_t() noexcept = default;



  constexpr explicit __gcc_atomic_t(_Tp value) noexcept
      : __a_value(value) {}
  _Tp __a_value;
};


template <typename _Tp> _Tp __create();

template <typename _Tp, typename _Td>
typename enable_if<sizeof(_Tp()->__a_value = __create<_Td>()), char>::type
__test_atomic_assignable(int);
template <typename _Tp, typename _Up> __two __test_atomic_assignable(...);

template <typename _Tp, typename _Td> struct __can_assign {
  static const bool value =
      sizeof(__test_atomic_assignable<_Tp, _Td>(1)) == sizeof(char);
};

static inline constexpr int __to_gcc_order(memory_order __order) {

  return __order == memory_order_relaxed
             ? 0
             : (__order == memory_order_acquire
                    ? 2
                    : (__order == memory_order_release
                           ? 3
                           : (__order == memory_order_seq_cst
                                  ? 5
                                  : (__order == memory_order_acq_rel
                                         ? 4
                                         : 1))));
}

static inline constexpr int
__to_gcc_failure_order(memory_order __order) {

  return __order == memory_order_relaxed
             ? 0
             : (__order == memory_order_acquire
                    ? 2
                    : (__order == memory_order_release
                           ? 0
                           : (__order == memory_order_seq_cst
                                  ? 5
                                  : (__order == memory_order_acq_rel
                                         ? 2
                                         : 1))));
}

}

template <typename _Tp>
static inline typename enable_if<
    __gcc_atomic::__can_assign<volatile __gcc_atomic::__gcc_atomic_t < _Tp > *, _Tp>::value>::type
__c11_atomic_init(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp __val) {
  __a->__a_value = __val;
}

template <typename _Tp>
static inline typename enable_if<
    !__gcc_atomic::__can_assign<volatile __gcc_atomic::__gcc_atomic_t < _Tp > *, _Tp>::value &&
    __gcc_atomic::__can_assign<__gcc_atomic::__gcc_atomic_t < _Tp > *, _Tp>::value>::type
__c11_atomic_init(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp __val) {



  volatile char *to = reinterpret_cast<volatile char *>(&__a->__a_value);
  volatile char *end = to + sizeof(_Tp);
  char *from = reinterpret_cast<char *>(&__val);
  while (to != end) {
    *to++ = *from++;
  }
}

template <typename _Tp>
static inline void __c11_atomic_init(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp __val) {
  __a->__a_value = __val;
}

static inline void __c11_atomic_thread_fence(memory_order __order) {
  __atomic_thread_fence(__gcc_atomic::__to_gcc_order(__order));
}

static inline void __c11_atomic_signal_fence(memory_order __order) {
  __atomic_signal_fence(__gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline void __c11_atomic_store(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp __val,
                                      memory_order __order) {
  return __atomic_store(&__a->__a_value, &__val,
                        __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline void __c11_atomic_store(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp __val,
                                      memory_order __order) {
  __atomic_store(&__a->__a_value, &__val,
                 __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_load(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a,
                                    memory_order __order) {
  _Tp __ret;
  __atomic_load(&__a->__a_value, &__ret, __gcc_atomic::__to_gcc_order(__order));
  return __ret;
}

template <typename _Tp>
static inline _Tp __c11_atomic_load(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, memory_order __order) {
  _Tp __ret;
  __atomic_load(&__a->__a_value, &__ret, __gcc_atomic::__to_gcc_order(__order));
  return __ret;
}

template <typename _Tp>
static inline _Tp __c11_atomic_exchange(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a,
                                        _Tp __value, memory_order __order) {
  _Tp __ret;
  __atomic_exchange(&__a->__a_value, &__value, &__ret,
                    __gcc_atomic::__to_gcc_order(__order));
  return __ret;
}

template <typename _Tp>
static inline _Tp __c11_atomic_exchange(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp __value,
                                        memory_order __order) {
  _Tp __ret;
  __atomic_exchange(&__a->__a_value, &__value, &__ret,
                    __gcc_atomic::__to_gcc_order(__order));
  return __ret;
}

template <typename _Tp>
static inline bool __c11_atomic_compare_exchange_strong(
    volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp *__expected, _Tp __value,
    memory_order __success, memory_order __failure) {
  return __atomic_compare_exchange(
      &__a->__a_value, __expected, &__value, false,
      __gcc_atomic::__to_gcc_order(__success),
      __gcc_atomic::__to_gcc_failure_order(__failure));
}

template <typename _Tp>
static inline bool
__c11_atomic_compare_exchange_strong(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp *__expected,
                                     _Tp __value, memory_order __success,
                                     memory_order __failure) {
  return __atomic_compare_exchange(
      &__a->__a_value, __expected, &__value, false,
      __gcc_atomic::__to_gcc_order(__success),
      __gcc_atomic::__to_gcc_failure_order(__failure));
}

template <typename _Tp>
static inline bool
__c11_atomic_compare_exchange_weak(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp *__expected,
                                   _Tp __value, memory_order __success,
                                   memory_order __failure) {
  return __atomic_compare_exchange(
      &__a->__a_value, __expected, &__value, true,
      __gcc_atomic::__to_gcc_order(__success),
      __gcc_atomic::__to_gcc_failure_order(__failure));
}

template <typename _Tp>
static inline bool
__c11_atomic_compare_exchange_weak(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp *__expected,
                                   _Tp __value, memory_order __success,
                                   memory_order __failure) {
  return __atomic_compare_exchange(
      &__a->__a_value, __expected, &__value, true,
      __gcc_atomic::__to_gcc_order(__success),
      __gcc_atomic::__to_gcc_failure_order(__failure));
}

template <typename _Tp> struct __skip_amt {
  enum { value = 1 };
};

template <typename _Tp> struct __skip_amt<_Tp *> {
  enum { value = sizeof(_Tp) };
};



template <typename _Tp> struct __skip_amt<_Tp[]> {};
template <typename _Tp, int n> struct __skip_amt<_Tp[n]> {};

template <typename _Tp, typename _Td>
static inline _Tp __c11_atomic_fetch_add(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a,
                                         _Td __delta, memory_order __order) {
  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp, typename _Td>
static inline _Tp __c11_atomic_fetch_add(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Td __delta,
                                         memory_order __order) {
  return __atomic_fetch_add(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp, typename _Td>
static inline _Tp __c11_atomic_fetch_sub(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a,
                                         _Td __delta, memory_order __order) {
  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp, typename _Td>
static inline _Tp __c11_atomic_fetch_sub(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Td __delta,
                                         memory_order __order) {
  return __atomic_fetch_sub(&__a->__a_value, __delta * __skip_amt<_Tp>::value,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_and(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a,
                                         _Tp __pattern, memory_order __order) {
  return __atomic_fetch_and(&__a->__a_value, __pattern,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_and(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp __pattern,
                                         memory_order __order) {
  return __atomic_fetch_and(&__a->__a_value, __pattern,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_or(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a,
                                        _Tp __pattern, memory_order __order) {
  return __atomic_fetch_or(&__a->__a_value, __pattern,
                           __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_or(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp __pattern,
                                        memory_order __order) {
  return __atomic_fetch_or(&__a->__a_value, __pattern,
                           __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_xor(volatile __gcc_atomic::__gcc_atomic_t < _Tp > * __a,
                                         _Tp __pattern, memory_order __order) {
  return __atomic_fetch_xor(&__a->__a_value, __pattern,
                            __gcc_atomic::__to_gcc_order(__order));
}

template <typename _Tp>
static inline _Tp __c11_atomic_fetch_xor(__gcc_atomic::__gcc_atomic_t < _Tp > * __a, _Tp __pattern,
                                         memory_order __order) {
  return __atomic_fetch_xor(&__a->__a_value, __pattern,
                            __gcc_atomic::__to_gcc_order(__order));
}


template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp kill_dependency(_Tp __y) noexcept {
  return __y;
}
template <class _Tp,
          bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base
{
  mutable __gcc_atomic::__gcc_atomic_t < _Tp > __a_;






  __attribute__((__visibility__("hidden"), __always_inline__))
  bool is_lock_free() const volatile noexcept {



    return __atomic_is_lock_free(sizeof(_Tp), 0);

  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool is_lock_free() const noexcept {
    return static_cast<__atomic_base const volatile *>(this)->is_lock_free();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void store(_Tp __d,
             memory_order __m = memory_order_seq_cst) volatile noexcept {
    __c11_atomic_store(&__a_, __d, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept {
    __c11_atomic_store(&__a_, __d, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp load(memory_order __m = memory_order_seq_cst) const volatile noexcept {
    return __c11_atomic_load(&__a_, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp load(memory_order __m = memory_order_seq_cst) const noexcept {
    return __c11_atomic_load(&__a_, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  operator _Tp() const volatile noexcept { return load(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  operator _Tp() const noexcept { return load(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp exchange(_Tp __d,
               memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_exchange(&__a_, __d, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_exchange(&__a_, __d, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool compare_exchange_weak(_Tp &__e, _Tp __d, memory_order __s,
                             memory_order __f) volatile noexcept {
    return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool compare_exchange_weak(_Tp &__e, _Tp __d, memory_order __s,
                             memory_order __f) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool compare_exchange_strong(_Tp &__e, _Tp __d, memory_order __s,
                               memory_order __f) volatile noexcept {
    return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool compare_exchange_strong(_Tp &__e, _Tp __d, memory_order __s,
                               memory_order __f) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool compare_exchange_weak(
      _Tp &__e, _Tp __d,
      memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool
  compare_exchange_weak(_Tp &__e, _Tp __d,
                        memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool compare_exchange_strong(
      _Tp &__e, _Tp __d,
      memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool
  compare_exchange_strong(_Tp &__e, _Tp __d,
                          memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))

  __atomic_base() noexcept = default;




  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr __atomic_base(_Tp __d) noexcept : __a_(__d) {}

  __atomic_base(const __atomic_base &) = delete;
  __atomic_base &operator=(const __atomic_base &) = delete;
  __atomic_base &operator=(const __atomic_base &) volatile = delete;






};
template <class _Tp>
struct __atomic_base<_Tp, true> : public __atomic_base<_Tp, false> {
  typedef __atomic_base<_Tp, false> __base;
  __attribute__((__visibility__("hidden"), __always_inline__))
  __atomic_base() noexcept = default; __attribute__((__visibility__("hidden"), __always_inline__))
      constexpr __atomic_base(_Tp __d) noexcept : __base(__d) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_add(_Tp __op,
                memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_fetch_add(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_fetch_add(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_sub(_Tp __op,
                memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_fetch_sub(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_fetch_sub(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_and(_Tp __op,
                memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_fetch_and(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_fetch_and(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_or(_Tp __op,
               memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_fetch_or(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_fetch_or(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_xor(_Tp __op,
                memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_fetch_xor(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_fetch_xor(&this->__a_, __op, __m);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator++(int)volatile noexcept { return fetch_add(_Tp(1)); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator++(int)noexcept { return fetch_add(_Tp(1)); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator--(int)volatile noexcept { return fetch_sub(_Tp(1)); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator--(int)noexcept { return fetch_sub(_Tp(1)); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator++() volatile noexcept { return fetch_add(_Tp(1)) + _Tp(1); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator++() noexcept { return fetch_add(_Tp(1)) + _Tp(1); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator--() volatile noexcept { return fetch_sub(_Tp(1)) - _Tp(1); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator--() noexcept { return fetch_sub(_Tp(1)) - _Tp(1); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator+=(_Tp __op) volatile noexcept { return fetch_add(__op) + __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator+=(_Tp __op) noexcept { return fetch_add(__op) + __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator-=(_Tp __op) volatile noexcept { return fetch_sub(__op) - __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator-=(_Tp __op) noexcept { return fetch_sub(__op) - __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator&=(_Tp __op) volatile noexcept { return fetch_and(__op) & __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator&=(_Tp __op) noexcept { return fetch_and(__op) & __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator|=(_Tp __op) volatile noexcept { return fetch_or(__op) | __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator|=(_Tp __op) noexcept { return fetch_or(__op) | __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator^=(_Tp __op) volatile noexcept { return fetch_xor(__op) ^ __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator^=(_Tp __op) noexcept { return fetch_xor(__op) ^ __op; }
};



template <class _Tp> struct atomic : public __atomic_base<_Tp> {
  typedef __atomic_base<_Tp> __base;
  __attribute__((__visibility__("hidden"), __always_inline__))
  atomic() noexcept = default; __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
      atomic(_Tp __d) noexcept : __base(__d) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator=(_Tp __d) volatile noexcept {
    __base::store(__d);
    return __d;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp operator=(_Tp __d) noexcept {
    __base::store(__d);
    return __d;
  }
};



template <class _Tp> struct atomic<_Tp *> : public __atomic_base<_Tp *> {
  typedef __atomic_base<_Tp *> __base;
  __attribute__((__visibility__("hidden"), __always_inline__))
  atomic() noexcept = default; __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
      atomic(_Tp *__d) noexcept : __base(__d) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator=(_Tp *__d) volatile noexcept {
    __base::store(__d);
    return __d;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator=(_Tp *__d) noexcept {
    __base::store(__d);
    return __d;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *fetch_add(ptrdiff_t __op,
                 memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_fetch_add(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *fetch_add(ptrdiff_t __op,
                 memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_fetch_add(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *fetch_sub(ptrdiff_t __op,
                 memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_fetch_sub(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *fetch_sub(ptrdiff_t __op,
                 memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_fetch_sub(&this->__a_, __op, __m);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator++(int)volatile noexcept { return fetch_add(1); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator++(int)noexcept { return fetch_add(1); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator--(int)volatile noexcept { return fetch_sub(1); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator--(int)noexcept { return fetch_sub(1); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator++() volatile noexcept { return fetch_add(1) + 1; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator++() noexcept { return fetch_add(1) + 1; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator--() volatile noexcept { return fetch_sub(1) - 1; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator--() noexcept { return fetch_sub(1) - 1; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator+=(ptrdiff_t __op) volatile noexcept {
    return fetch_add(__op) + __op;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator+=(ptrdiff_t __op) noexcept { return fetch_add(__op) + __op; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator-=(ptrdiff_t __op) volatile noexcept {
    return fetch_sub(__op) - __op;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *operator-=(ptrdiff_t __op) noexcept { return fetch_sub(__op) - __op; }
};



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_is_lock_free(const volatile atomic<_Tp> *__o) noexcept {
  return __o->is_lock_free();
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_is_lock_free(const atomic<_Tp> *__o) noexcept {
  return __o->is_lock_free();
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void atomic_init(volatile atomic<_Tp> *__o,
                                                  _Tp __d) noexcept {
  __c11_atomic_init(&__o->__a_, __d);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void atomic_init(atomic<_Tp> *__o,
                                                  _Tp __d) noexcept {
  __c11_atomic_init(&__o->__a_, __d);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void atomic_store(volatile atomic<_Tp> *__o,
                                                   _Tp __d) noexcept {
  __o->store(__d);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void atomic_store(atomic<_Tp> *__o,
                                                   _Tp __d) noexcept {
  __o->store(__d);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
atomic_store_explicit(volatile atomic<_Tp> *__o, _Tp __d,
                      memory_order __m) noexcept {
  __o->store(__d, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
atomic_store_explicit(atomic<_Tp> *__o, _Tp __d, memory_order __m) noexcept {
  __o->store(__d, __m);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
atomic_load(const volatile atomic<_Tp> *__o) noexcept {
  return __o->load();
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
atomic_load(const atomic<_Tp> *__o) noexcept {
  return __o->load();
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp atomic_load_explicit(
    const volatile atomic<_Tp> *__o, memory_order __m) noexcept {
  return __o->load(__m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
atomic_load_explicit(const atomic<_Tp> *__o, memory_order __m) noexcept {
  return __o->load(__m);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp atomic_exchange(volatile atomic<_Tp> *__o,
                                                     _Tp __d) noexcept {
  return __o->exchange(__d);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp atomic_exchange(atomic<_Tp> *__o,
                                                     _Tp __d) noexcept {
  return __o->exchange(__d);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp atomic_exchange_explicit(
    volatile atomic<_Tp> *__o, _Tp __d, memory_order __m) noexcept {
  return __o->exchange(__d, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp atomic_exchange_explicit(
    atomic<_Tp> *__o, _Tp __d, memory_order __m) noexcept {
  return __o->exchange(__d, __m);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_weak(volatile atomic<_Tp> *__o, _Tp *__e,
                             _Tp __d) noexcept {
  return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_weak(atomic<_Tp> *__o, _Tp *__e, _Tp __d) noexcept {
  return __o->compare_exchange_weak(*__e, __d);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_strong(volatile atomic<_Tp> *__o, _Tp *__e,
                               _Tp __d) noexcept {
  return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_strong(atomic<_Tp> *__o, _Tp *__e, _Tp __d) noexcept {
  return __o->compare_exchange_strong(*__e, __d);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp> *__o, _Tp *__e,
                                      _Tp __d, memory_order __s,
                                      memory_order __f) noexcept {
  return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_weak_explicit(atomic<_Tp> *__o, _Tp *__e, _Tp __d,
                                      memory_order __s,
                                      memory_order __f) noexcept {
  return __o->compare_exchange_weak(*__e, __d, __s, __f);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp> *__o, _Tp *__e,
                                        _Tp __d, memory_order __s,
                                        memory_order __f) noexcept {
  return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_strong_explicit(atomic<_Tp> *__o, _Tp *__e, _Tp __d,
                                        memory_order __s,
                                        memory_order __f) noexcept {
  return __o->compare_exchange_strong(*__e, __d, __s, __f);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_add(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_add(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
atomic_fetch_add(volatile atomic<_Tp *> *__o, ptrdiff_t __op) noexcept {
  return __o->fetch_add(__op);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
atomic_fetch_add(atomic<_Tp *> *__o, ptrdiff_t __op) noexcept {
  return __o->fetch_add(__op);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_add_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                              memory_order __m) noexcept {
  return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_add_explicit(atomic<_Tp> *__o, _Tp __op,
                              memory_order __m) noexcept {
  return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
atomic_fetch_add_explicit(volatile atomic<_Tp *> *__o, ptrdiff_t __op,
                          memory_order __m) noexcept {
  return __o->fetch_add(__op, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
atomic_fetch_add_explicit(atomic<_Tp *> *__o, ptrdiff_t __op,
                          memory_order __m) noexcept {
  return __o->fetch_add(__op, __m);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_sub(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_sub(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
atomic_fetch_sub(volatile atomic<_Tp *> *__o, ptrdiff_t __op) noexcept {
  return __o->fetch_sub(__op);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
atomic_fetch_sub(atomic<_Tp *> *__o, ptrdiff_t __op) noexcept {
  return __o->fetch_sub(__op);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_sub_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                              memory_order __m) noexcept {
  return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_sub_explicit(atomic<_Tp> *__o, _Tp __op,
                              memory_order __m) noexcept {
  return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
atomic_fetch_sub_explicit(volatile atomic<_Tp *> *__o, ptrdiff_t __op,
                          memory_order __m) noexcept {
  return __o->fetch_sub(__op, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *
atomic_fetch_sub_explicit(atomic<_Tp *> *__o, ptrdiff_t __op,
                          memory_order __m) noexcept {
  return __o->fetch_sub(__op, __m);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_and(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_and(__op);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_and(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_and(__op);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_and_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                              memory_order __m) noexcept {
  return __o->fetch_and(__op, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_and_explicit(atomic<_Tp> *__o, _Tp __op,
                              memory_order __m) noexcept {
  return __o->fetch_and(__op, __m);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_or(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_or(__op);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_or(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_or(__op);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_or_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                             memory_order __m) noexcept {
  return __o->fetch_or(__op, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_or_explicit(atomic<_Tp> *__o, _Tp __op,
                             memory_order __m) noexcept {
  return __o->fetch_or(__op, __m);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_xor(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_xor(__op);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_xor(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_xor(__op);
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_xor_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                              memory_order __m) noexcept {
  return __o->fetch_xor(__op, __m);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                       _Tp>::type
    atomic_fetch_xor_explicit(atomic<_Tp> *__o, _Tp __op,
                              memory_order __m) noexcept {
  return __o->fetch_xor(__op, __m);
}



typedef struct atomic_flag {
  __gcc_atomic::__gcc_atomic_t < bool > __a_;

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool
  test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __c11_atomic_exchange(&__a_, true, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool test_and_set(memory_order __m = memory_order_seq_cst) noexcept {
    return __c11_atomic_exchange(&__a_, true, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear(memory_order __m = memory_order_seq_cst) volatile noexcept {
    __c11_atomic_store(&__a_, false, __m);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear(memory_order __m = memory_order_seq_cst) noexcept {
    __c11_atomic_store(&__a_, false, __m);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))

  atomic_flag() noexcept = default;




  __attribute__((__visibility__("hidden"), __always_inline__))
  atomic_flag(bool __b) noexcept : __a_(__b) {}


  atomic_flag(const atomic_flag &) = delete;
  atomic_flag &operator=(const atomic_flag &) = delete;
  atomic_flag &operator=(const atomic_flag &) volatile = delete;






} atomic_flag;

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_flag_test_and_set(volatile atomic_flag *__o) noexcept {
  return __o->test_and_set();
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_flag_test_and_set(atomic_flag *__o) noexcept {
  return __o->test_and_set();
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_flag_test_and_set_explicit(volatile atomic_flag *__o,
                                  memory_order __m) noexcept {
  return __o->test_and_set(__m);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_flag_test_and_set_explicit(atomic_flag *__o,
                                  memory_order __m) noexcept {
  return __o->test_and_set(__m);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void
atomic_flag_clear(volatile atomic_flag *__o) noexcept {
  __o->clear();
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void
atomic_flag_clear(atomic_flag *__o) noexcept {
  __o->clear();
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void
atomic_flag_clear_explicit(volatile atomic_flag *__o,
                           memory_order __m) noexcept {
  __o->clear(__m);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void
atomic_flag_clear_explicit(atomic_flag *__o, memory_order __m) noexcept {
  __o->clear(__m);
}



inline __attribute__((__visibility__("hidden"), __always_inline__)) void
atomic_thread_fence(memory_order __m) noexcept {
  __c11_atomic_thread_fence(__m);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void
atomic_signal_fence(memory_order __m) noexcept {
  __c11_atomic_signal_fence(__m);
}



typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;

typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;

typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

typedef atomic<int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic<int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic<int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic<int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;

typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;






} }




namespace std { inline namespace __1 {

template <class _ValueType>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ValueType
__libcpp_relaxed_load(_ValueType const *__value) {



  return __atomic_load_n(__value, 0);



}

template <class _ValueType>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ValueType
__libcpp_acquire_load(_ValueType const *__value) {


  return __atomic_load_n(__value, 2);



}



template <class _Tp> class allocator;

template <> class __attribute__((__visibility__("default"))) allocator<void> {
public:
  typedef void *pointer;
  typedef const void *const_pointer;
  typedef void value_type;

  template <class _Up> struct rebind { typedef allocator<_Up> other; };
};

template <> class __attribute__((__visibility__("default"))) allocator<const void> {
public:
  typedef const void *pointer;
  typedef const void *const_pointer;
  typedef const void value_type;

  template <class _Up> struct rebind { typedef allocator<_Up> other; };
};



template <class _Tp> struct __has_element_type {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::element_type * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr> struct __pointer_traits_element_type<_Ptr, true> {
  typedef typename _Ptr::element_type type;
};



template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true> {
  typedef typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false> {
  typedef _Tp type;
};
template <class _Tp> struct __has_difference_type {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::difference_type * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type {
  typedef ptrdiff_t type;
};

template <class _Ptr> struct __pointer_traits_difference_type<_Ptr, true> {
  typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up> struct __has_rebind {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Xp> static __two __test(...);
  template <class _Xp>
  static char __test(typename _Xp::template rebind<_Up> * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind {

  typedef typename _Tp::template rebind<_Up> type;



};



template <template <class, class...> class _Sp, class _Tp, class... _Args,
          class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true> {

  typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;



};

template <template <class, class...> class _Sp, class _Tp, class... _Args,
          class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false> {
  typedef _Sp<_Up, _Args...> type;
};
template <class _Ptr> struct __attribute__((__visibility__("default"))) pointer_traits {
  typedef _Ptr pointer;
  typedef typename __pointer_traits_element_type<pointer>::type element_type;
  typedef
      typename __pointer_traits_difference_type<pointer>::type difference_type;


  template <class _Up>
  using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;






private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  static pointer
  pointer_to(typename conditional<is_void<element_type>::value, __nat,
                                  element_type>::type &__r) {
    return pointer::pointer_to(__r);
  }
};

template <class _Tp> struct __attribute__((__visibility__("default"))) pointer_traits<_Tp *> {
  typedef _Tp *pointer;
  typedef _Tp element_type;
  typedef ptrdiff_t difference_type;


  template <class _Up> using rebind = _Up *;




private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  static pointer
  pointer_to(typename conditional<is_void<element_type>::value, __nat,
                                  element_type>::type &__r) noexcept {
    return std::__1::addressof(__r);
  }
};

template <class _From, class _To> struct __rebind_pointer {

  typedef typename pointer_traits<_From>::template rebind<_To> type;



};



namespace __has_pointer_type_imp {
template <class _Up> static __two __test(...);
template <class _Up> static char __test(typename _Up::pointer * = 0);
}

template <class _Tp>
struct __has_pointer_type
    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(
                                         0)) == 1> {};

namespace __pointer_type_imp {

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type {
  typedef typename _Dp::pointer type;
};

template <class _Tp, class _Dp> struct __pointer_type<_Tp, _Dp, false> {
  typedef _Tp *type;
};

}

template <class _Tp, class _Dp> struct __pointer_type {
  typedef typename __pointer_type_imp::__pointer_type<
      _Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp> struct __has_const_pointer {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::const_pointer * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Ptr, class _Alloc,
          bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer {
  typedef typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false> {

  typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;



};

template <class _Tp> struct __has_void_pointer {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::void_pointer * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer {
  typedef typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc> struct __void_pointer<_Ptr, _Alloc, false> {

  typedef typename pointer_traits<_Ptr>::template rebind<void> type;



};

template <class _Tp> struct __has_const_void_pointer {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up>
  static char __test(typename _Up::const_void_pointer * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Ptr, class _Alloc,
          bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer {
  typedef typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false> {

  typedef typename pointer_traits<_Ptr>::template rebind<const void> type;




};

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *__to_raw_pointer(_Tp *__p) noexcept {
  return __p;
}

template <class _Pointer>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename pointer_traits<_Pointer>::element_type *
    __to_raw_pointer(_Pointer __p) noexcept {
  return std::__1::__to_raw_pointer(__p.operator->());
}

template <class _Tp> struct __has_size_type {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::size_type * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type {
  typedef typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true> {
  typedef typename _Alloc::size_type type;
};

template <class _Tp> struct __has_propagate_on_container_copy_assignment {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up>
  static char
  __test(typename _Up::propagate_on_container_copy_assignment * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc,
          bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment {
  typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true> {
  typedef typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp> struct __has_propagate_on_container_move_assignment {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up>
  static char
  __test(typename _Up::propagate_on_container_move_assignment * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc,
          bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment {
  typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true> {
  typedef typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp> struct __has_propagate_on_container_swap {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up>
  static char __test(typename _Up::propagate_on_container_swap * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap {
  typedef false_type type;
};

template <class _Alloc> struct __propagate_on_container_swap<_Alloc, true> {
  typedef typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp> struct __has_is_always_equal {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::is_always_equal * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal {
  typedef typename std::__1::is_empty<_Alloc>::type type;
};

template <class _Alloc> struct __is_always_equal<_Alloc, true> {
  typedef typename _Alloc::is_always_equal type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Xp> static __two __test(...);
  template <class _Xp>
  static char __test(typename _Xp::template rebind<_Up>::other * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up> struct __has_rebind_other<_Tp, _Up, false> {
  static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind {
  typedef typename _Tp::template rebind<_Up>::other type;
};



template <template <class, class...> class _Alloc, class _Tp, class... _Args,
          class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true> {
  typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;
};

template <template <class, class...> class _Alloc, class _Tp, class... _Args,
          class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false> {
  typedef _Alloc<_Up, _Args...> type;
};
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto __has_allocate_hint_test(_Alloc &&__a, _SizeType &&__sz,
                              _ConstVoidPtr &&__p)
    -> decltype(__a.allocate(__sz, __p), true_type());

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto __has_allocate_hint_test(const _Alloc &__a, _SizeType &&__sz,
                              _ConstVoidPtr &&__p) -> false_type;

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : integral_constant<bool,
                        is_same<decltype(__has_allocate_hint_test(
                                    declval<_Alloc>(), declval<_SizeType>(),
                                    declval<_ConstVoidPtr>())),
                                true_type>::value> {};
template <class _Alloc, class _Tp, class... _Args>
decltype(std::__1::declval<_Alloc>().construct(std::__1::declval<_Tp *>(),
                                            std::__1::declval<_Args>()...),
         true_type())
__has_construct_test(_Alloc &&__a, _Tp *__p, _Args &&... __args);

template <class _Alloc, class _Pointer, class... _Args>
false_type __has_construct_test(const _Alloc &__a, _Pointer &&__p,
                                _Args &&... __args);

template <class _Alloc, class _Pointer, class... _Args>
struct __has_construct
    : integral_constant<bool,
                        is_same<decltype(__has_construct_test(
                                    declval<_Alloc>(), declval<_Pointer>(),
                                    declval<_Args>()...)),
                                true_type>::value> {};

template <class _Alloc, class _Pointer>
auto __has_destroy_test(_Alloc &&__a, _Pointer &&__p)
    -> decltype(__a.destroy(__p), true_type());

template <class _Alloc, class _Pointer>
auto __has_destroy_test(const _Alloc &__a, _Pointer &&__p) -> false_type;

template <class _Alloc, class _Pointer>
struct __has_destroy
    : integral_constant<bool,
                        is_same<decltype(__has_destroy_test(
                                    declval<_Alloc>(), declval<_Pointer>())),
                                true_type>::value> {};

template <class _Alloc>
auto __has_max_size_test(_Alloc &&__a) -> decltype(__a.max_size(), true_type());

template <class _Alloc>
auto __has_max_size_test(const volatile _Alloc &__a) -> false_type;

template <class _Alloc>
struct __has_max_size
    : integral_constant<
          bool, is_same<decltype(__has_max_size_test(declval<_Alloc &>())),
                        true_type>::value> {};

template <class _Alloc>
auto __has_select_on_container_copy_construction_test(_Alloc &&__a)
    -> decltype(__a.select_on_container_copy_construction(), true_type());

template <class _Alloc>
auto __has_select_on_container_copy_construction_test(
    const volatile _Alloc &__a) -> false_type;

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : integral_constant<
          bool,
          is_same<decltype(__has_select_on_container_copy_construction_test(
                      declval<_Alloc &>())),
                  true_type>::value> {};
template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type {
  typedef typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
  typedef typename _Alloc::difference_type type;
};

template <class _Alloc> struct __attribute__((__visibility__("default"))) allocator_traits {
  typedef _Alloc allocator_type;
  typedef typename allocator_type::value_type value_type;

  typedef typename __pointer_type<value_type, allocator_type>::type pointer;
  typedef typename __const_pointer<value_type, pointer, allocator_type>::type
      const_pointer;
  typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
  typedef typename __const_void_pointer<pointer, allocator_type>::type
      const_void_pointer;

  typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type
      difference_type;
  typedef typename __size_type<allocator_type, difference_type>::type size_type;

  typedef
      typename __propagate_on_container_copy_assignment<allocator_type>::type
          propagate_on_container_copy_assignment;
  typedef
      typename __propagate_on_container_move_assignment<allocator_type>::type
          propagate_on_container_move_assignment;
  typedef typename __propagate_on_container_swap<allocator_type>::type
      propagate_on_container_swap;
  typedef typename __is_always_equal<allocator_type>::type is_always_equal;


  template <class _Tp>
  using rebind_alloc =
      typename __allocator_traits_rebind<allocator_type, _Tp>::type;
  template <class _Tp>
  using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static pointer allocate(allocator_type &__a, size_type __n) {
    return __a.allocate(__n);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  static pointer allocate(allocator_type &__a, size_type __n,
                          const_void_pointer __hint) {
    return allocate(
        __a, __n, __hint,
        __has_allocate_hint<allocator_type, size_type, const_void_pointer>());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  static void deallocate(allocator_type &__a, pointer __p,
                         size_type __n) noexcept {
    __a.deallocate(__p, __n);
  }


  template <class _Tp, class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) static void construct(allocator_type &__a, _Tp *__p,
                                                  _Args &&... __args) {
    __construct(__has_construct<allocator_type, _Tp *, _Args...>(), __a, __p,
                std::__1::forward<_Args>(__args)...);
  }
  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) static void destroy(allocator_type &__a, _Tp *__p) {
    __destroy(__has_destroy<allocator_type, _Tp *>(), __a, __p);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_type max_size(const allocator_type &__a) noexcept {
    return __max_size(__has_max_size<const allocator_type>(), __a);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  static allocator_type
  select_on_container_copy_construction(const allocator_type &__a) {
    return select_on_container_copy_construction(
        __has_select_on_container_copy_construction<const allocator_type>(),
        __a);
  }

  template <class _Ptr>
  __attribute__((__visibility__("hidden"), __always_inline__)) static void
  __construct_forward(allocator_type &__a, _Ptr __begin1, _Ptr __end1,
                      _Ptr &__begin2) {
    for (; __begin1 != __end1; ++__begin1, ++__begin2)
      construct(__a, std::__1::__to_raw_pointer(__begin2),
                std::__1::move_if_noexcept(*__begin1));
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) static typename enable_if<
      (is_same<allocator_type, allocator<_Tp>>::value ||
       !__has_construct<allocator_type, _Tp *, _Tp>::value) &&
          is_trivially_move_constructible<_Tp>::value,
      void>::type
  __construct_forward(allocator_type &__a, _Tp *__begin1, _Tp *__end1,
                      _Tp *&__begin2) {
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
      std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
      __begin2 += _Np;
    }
  }

  template <class _Iter, class _Ptr>
  __attribute__((__visibility__("hidden"), __always_inline__)) static void
  __construct_range_forward(allocator_type &__a, _Iter __begin1, _Iter __end1,
                            _Ptr &__begin2) {
    for (; __begin1 != __end1; ++__begin1, (void)++__begin2)
      construct(__a, std::__1::__to_raw_pointer(__begin2), *__begin1);
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) static typename enable_if<
      (is_same<allocator_type, allocator<_Tp>>::value ||
       !__has_construct<allocator_type, _Tp *, _Tp>::value) &&
          is_trivially_move_constructible<_Tp>::value,
      void>::type
  __construct_range_forward(allocator_type &__a, _Tp *__begin1, _Tp *__end1,
                            _Tp *&__begin2) {
    typedef typename remove_const<_Tp>::type _Vp;
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
      std::__1::memcpy(const_cast<_Vp *>(__begin2), __begin1, _Np * sizeof(_Tp));
      __begin2 += _Np;
    }
  }

  template <class _Ptr>
  __attribute__((__visibility__("hidden"), __always_inline__)) static void
  __construct_backward(allocator_type &__a, _Ptr __begin1, _Ptr __end1,
                       _Ptr &__end2) {
    while (__end1 != __begin1) {
      construct(__a, std::__1::__to_raw_pointer(__end2 - 1),
                std::__1::move_if_noexcept(*--__end1));
      --__end2;
    }
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) static typename enable_if<
      (is_same<allocator_type, allocator<_Tp>>::value ||
       !__has_construct<allocator_type, _Tp *, _Tp>::value) &&
          is_trivially_move_constructible<_Tp>::value,
      void>::type
  __construct_backward(allocator_type &__a, _Tp *__begin1, _Tp *__end1,
                       _Tp *&__end2) {
    ptrdiff_t _Np = __end1 - __begin1;
    __end2 -= _Np;
    if (_Np > 0)
      std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  static pointer allocate(allocator_type &__a, size_type __n,
                          const_void_pointer __hint, true_type) {
    return __a.allocate(__n, __hint);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  static pointer allocate(allocator_type &__a, size_type __n,
                          const_void_pointer, false_type) {
    return __a.allocate(__n);
  }


  template <class _Tp, class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) static void
  __construct(true_type, allocator_type &__a, _Tp *__p, _Args &&... __args) {
    __a.construct(__p, std::__1::forward<_Args>(__args)...);
  }
  template <class _Tp, class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) static void
  __construct(false_type, allocator_type &, _Tp *__p, _Args &&... __args) {
    ::new ((void *)__p) _Tp(std::__1::forward<_Args>(__args)...);
  }


  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) static void
  __destroy(true_type, allocator_type &__a, _Tp *__p) {
    __a.destroy(__p);
  }
  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) static void __destroy(false_type, allocator_type &,
                                                  _Tp *__p) {
    __p->~_Tp();
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_type __max_size(true_type, const allocator_type &__a) {
    return __a.max_size();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_type __max_size(false_type, const allocator_type &) {
    return numeric_limits<size_type>::max() / sizeof(value_type);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  static allocator_type
  select_on_container_copy_construction(true_type, const allocator_type &__a) {
    return __a.select_on_container_copy_construction();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  static allocator_type
  select_on_container_copy_construction(false_type, const allocator_type &__a) {
    return __a;
  }
};

template <class _Traits, class _Tp> struct __rebind_alloc_helper {

  typedef typename _Traits::template rebind_alloc<_Tp> type;



};



template <class _Tp> class __attribute__((__visibility__("default"))) allocator {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp *pointer;
  typedef const _Tp *const_pointer;
  typedef _Tp &reference;
  typedef const _Tp &const_reference;
  typedef _Tp value_type;

  typedef true_type propagate_on_container_move_assignment;
  typedef true_type is_always_equal;

  template <class _Up> struct rebind { typedef allocator<_Up> other; };

  __attribute__((__visibility__("hidden"), __always_inline__)) allocator() noexcept {}
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up> &) noexcept {}
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer address(reference __x) const noexcept {
    return std::__1::addressof(__x);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_pointer
  address(const_reference __x) const noexcept {
    return std::__1::addressof(__x);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer
  allocate(size_type __n, allocator<void>::const_pointer = 0) {
    if (__n > max_size())
      __throw_length_error("allocator<T>::allocate(size_t n)"
                           " 'n' exceeds maximum supported size");
    return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) noexcept {
    std::__1::__deallocate((void *)__p);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type max_size() const noexcept {
    return size_type(~0) / sizeof(_Tp);
  }


  template <class _Up, class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) void construct(_Up *__p, _Args &&... __args) {
    ::new ((void *)__p) _Up(std::__1::forward<_Args>(__args)...);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) { __p->~_Tp(); }
};

template <class _Tp> class __attribute__((__visibility__("default"))) allocator<const _Tp> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp *pointer;
  typedef const _Tp *const_pointer;
  typedef const _Tp &reference;
  typedef const _Tp &const_reference;
  typedef const _Tp value_type;

  typedef true_type propagate_on_container_move_assignment;
  typedef true_type is_always_equal;

  template <class _Up> struct rebind { typedef allocator<_Up> other; };

  __attribute__((__visibility__("hidden"), __always_inline__)) allocator() noexcept {}
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) allocator(const allocator<_Up> &) noexcept {}
  __attribute__((__visibility__("hidden"), __always_inline__)) const_pointer
  address(const_reference __x) const noexcept {
    return std::__1::addressof(__x);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer
  allocate(size_type __n, allocator<void>::const_pointer = 0) {
    if (__n > max_size())
      __throw_length_error("allocator<const T>::allocate(size_t n)"
                           " 'n' exceeds maximum supported size");
    return static_cast<pointer>(std::__1::__allocate(__n * sizeof(_Tp)));
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void deallocate(pointer __p, size_type) noexcept {
    std::__1::__deallocate((void *)__p);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type max_size() const noexcept {
    return size_type(~0) / sizeof(_Tp);
  }


  template <class _Up, class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) void construct(_Up *__p, _Args &&... __args) {
    ::new ((void *)__p) _Up(std::__1::forward<_Args>(__args)...);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void destroy(pointer __p) { __p->~_Tp(); }
};

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const allocator<_Tp> &, const allocator<_Up> &) noexcept {
  return true;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const allocator<_Tp> &, const allocator<_Up> &) noexcept {
  return false;
}

template <class _OutputIterator, class _Tp>
class __attribute__((__visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag,
                      _Tp,
                      ptrdiff_t,
                      _Tp *,
                      raw_storage_iterator<_OutputIterator, _Tp>
                          &>
{
private:
  _OutputIterator __x_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit raw_storage_iterator(_OutputIterator __x)
      : __x_(__x) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) raw_storage_iterator &operator*() { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) raw_storage_iterator &
  operator=(const _Tp &__element) {
    ::new (&*__x_) _Tp(__element);
    return *this;
  }






  __attribute__((__visibility__("hidden"), __always_inline__)) raw_storage_iterator &operator++() {
    ++__x_;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) raw_storage_iterator operator++(int) {
    raw_storage_iterator __t(*this);
    ++__x_;
    return __t;
  }



};

template <class _Tp>
pair<_Tp *, ptrdiff_t> get_temporary_buffer(ptrdiff_t __n) noexcept {
  pair<_Tp *, ptrdiff_t> __r(0, 0);
  const ptrdiff_t __m =
      (~ptrdiff_t(0) ^
       ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1))) /
      sizeof(_Tp);
  if (__n > __m)
    __n = __m;
  while (__n > 0) {
    __r.first = static_cast<_Tp *>(::operator new(__n * sizeof(_Tp), nothrow));
    if (__r.first) {
      __r.second = __n;
      break;
    }
    __n /= 2;
  }
  return __r;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
return_temporary_buffer(_Tp *__p) noexcept {
  ::operator delete(__p);
}

template <class _Tp> struct auto_ptr_ref { _Tp *__ptr_; };

template <class _Tp> class __attribute__((__visibility__("default"))) auto_ptr {
private:
  _Tp *__ptr_;

public:
  typedef _Tp element_type;

  __attribute__((__visibility__("hidden"), __always_inline__)) explicit auto_ptr(_Tp *__p = 0) throw()
      : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr &__p) throw()
      : __ptr_(__p.release()) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr<_Up> &__p) throw()
      : __ptr_(__p.release()) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) auto_ptr &operator=(auto_ptr &__p) throw() {
    reset(__p.release());
    return *this;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) auto_ptr &operator=(auto_ptr<_Up> &__p) throw() {
    reset(__p.release());
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) auto_ptr &operator=(auto_ptr_ref<_Tp> __p) throw() {
    reset(__p.__ptr_);
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) ~auto_ptr() throw() { delete __ptr_; }

  __attribute__((__visibility__("hidden"), __always_inline__)) _Tp &operator*() const throw() { return *__ptr_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *operator->() const throw() { return __ptr_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *get() const throw() { return __ptr_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *release() throw() {
    _Tp *__t = __ptr_;
    __ptr_ = 0;
    return __t;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void reset(_Tp *__p = 0) throw() {
    if (__ptr_ != __p)
      delete __ptr_;
    __ptr_ = __p;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) auto_ptr(auto_ptr_ref<_Tp> __p) throw()
      : __ptr_(__p.__ptr_) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) operator auto_ptr_ref<_Up>() throw() {
    auto_ptr_ref<_Up> __t;
    __t.__ptr_ = release();
    return __t;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) operator auto_ptr<_Up>() throw() {
    return auto_ptr<_Up>(release());
  }
};

template <> class __attribute__((__visibility__("default"))) auto_ptr<void> {
public:
  typedef void element_type;
};

template <class _T1, class _T2,
          bool = is_same<typename remove_cv<_T1>::type,
                         typename remove_cv<_T2>::type>::value,
          bool = is_empty<_T1>::value && !__libcpp_is_final<_T1>::value,
          bool = is_empty<_T2>::value && !__libcpp_is_final<_T2>::value>
struct __libcpp_compressed_pair_switch;

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {
  enum { value = 0 };
};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false> {
  enum { value = 1 };
};

template <class _T1, class _T2, bool IsSame>
struct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true> {
  enum { value = 2 };
};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true> {
  enum { value = 3 };
};

template <class _T1, class _T2>
struct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true> {
  enum { value = 1 };
};

template <class _T1, class _T2,
          unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>
class __libcpp_compressed_pair_imp;

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 0> {
private:
  _T1 __first_;
  _T2 __second_;

public:
  typedef _T1 _T1_param;
  typedef _T2 _T2_param;

  typedef typename remove_reference<_T1>::type &_T1_reference;
  typedef typename remove_reference<_T2>::type &_T2_reference;

  typedef const typename remove_reference<_T1>::type &_T1_const_reference;
  typedef const typename remove_reference<_T2>::type &_T2_const_reference;

  __attribute__((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp()
      : __first_(), __second_() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(
      _T1_param __t1)
      : __first_(std::__1::forward<_T1_param>(__t1)), __second_() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(
      _T2_param __t2)
      : __first_(), __second_(std::__1::forward<_T2_param>(__t2)) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1,
                                                         _T2_param __t2)
      : __first_(std::__1::forward<_T1_param>(__t1)),
        __second_(std::__1::forward<_T2_param>(__t2)) {}
  template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
  __attribute__((__visibility__("hidden"), __always_inline__))
  __libcpp_compressed_pair_imp(piecewise_construct_t __pc,
                               tuple<_Args1...> __first_args,
                               tuple<_Args2...> __second_args,
                               __tuple_indices<_I1...>, __tuple_indices<_I2...>)
      : __first_(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...),
        __second_(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...) {}



  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_reference first() noexcept { return __first_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const noexcept {
    return __first_;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_reference second() noexcept {
    return __second_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const noexcept {
    return __second_;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void
  swap(__libcpp_compressed_pair_imp &__x) noexcept(__is_nothrow_swappable<_T1>::value &&__is_nothrow_swappable<_T2>::value) {

    using std::__1::swap;
    swap(__first_, __x.__first_);
    swap(__second_, __x.__second_);
  }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 1> : private _T1 {
private:
  _T2 __second_;

public:
  typedef _T1 _T1_param;
  typedef _T2 _T2_param;

  typedef _T1 &_T1_reference;
  typedef typename remove_reference<_T2>::type &_T2_reference;

  typedef const _T1 &_T1_const_reference;
  typedef const typename remove_reference<_T2>::type &_T2_const_reference;

  __attribute__((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() : __second_() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(
      _T1_param __t1)
      : _T1(std::__1::forward<_T1_param>(__t1)), __second_() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(
      _T2_param __t2)
      : __second_(std::__1::forward<_T2_param>(__t2)) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1,
                                                         _T2_param __t2)
      : _T1(std::__1::forward<_T1_param>(__t1)),
        __second_(std::__1::forward<_T2_param>(__t2)) {}
  template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
  __attribute__((__visibility__("hidden"), __always_inline__))
  __libcpp_compressed_pair_imp(piecewise_construct_t __pc,
                               tuple<_Args1...> __first_args,
                               tuple<_Args2...> __second_args,
                               __tuple_indices<_I1...>, __tuple_indices<_I2...>)
      : _T1(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...),
        __second_(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...) {}



  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_reference first() noexcept { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const noexcept {
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_reference second() noexcept {
    return __second_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const noexcept {
    return __second_;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void
  swap(__libcpp_compressed_pair_imp &__x) noexcept(__is_nothrow_swappable<_T1>::value &&__is_nothrow_swappable<_T2>::value) {

    using std::__1::swap;
    swap(__second_, __x.__second_);
  }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 2> : private _T2 {
private:
  _T1 __first_;

public:
  typedef _T1 _T1_param;
  typedef _T2 _T2_param;

  typedef typename remove_reference<_T1>::type &_T1_reference;
  typedef _T2 &_T2_reference;

  typedef const typename remove_reference<_T1>::type &_T1_const_reference;
  typedef const _T2 &_T2_const_reference;

  __attribute__((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() : __first_() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(
      _T1_param __t1)
      : __first_(std::__1::forward<_T1_param>(__t1)) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(
      _T2_param __t2)
      : _T2(std::__1::forward<_T2_param>(__t2)), __first_() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1,
                                                         _T2_param __t2)
      noexcept(is_nothrow_move_constructible<_T1>::value &&is_nothrow_move_constructible<_T2>::value)

      : _T2(std::__1::forward<_T2_param>(__t2)),
        __first_(std::__1::forward<_T1_param>(__t1)) {}
  template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
  __attribute__((__visibility__("hidden"), __always_inline__))
  __libcpp_compressed_pair_imp(piecewise_construct_t __pc,
                               tuple<_Args1...> __first_args,
                               tuple<_Args2...> __second_args,
                               __tuple_indices<_I1...>, __tuple_indices<_I2...>)
      : _T2(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...),
        __first_(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...)

  {}



  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_reference first() noexcept { return __first_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const noexcept {
    return __first_;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_reference second() noexcept { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const noexcept {
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void
  swap(__libcpp_compressed_pair_imp &__x) noexcept(__is_nothrow_swappable<_T1>::value &&__is_nothrow_swappable<_T2>::value) {

    using std::__1::swap;
    swap(__first_, __x.__first_);
  }
};

template <class _T1, class _T2>
class __libcpp_compressed_pair_imp<_T1, _T2, 3> : private _T1, private _T2 {
public:
  typedef _T1 _T1_param;
  typedef _T2 _T2_param;

  typedef _T1 &_T1_reference;
  typedef _T2 &_T2_reference;

  typedef const _T1 &_T1_const_reference;
  typedef const _T2 &_T2_const_reference;

  __attribute__((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(
      _T1_param __t1)
      : _T1(std::__1::forward<_T1_param>(__t1)) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __libcpp_compressed_pair_imp(
      _T2_param __t2)
      : _T2(std::__1::forward<_T2_param>(__t2)) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) __libcpp_compressed_pair_imp(_T1_param __t1,
                                                         _T2_param __t2)
      : _T1(std::__1::forward<_T1_param>(__t1)),
        _T2(std::__1::forward<_T2_param>(__t2)) {}
  template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
  __attribute__((__visibility__("hidden"), __always_inline__))
  __libcpp_compressed_pair_imp(piecewise_construct_t __pc,
                               tuple<_Args1...> __first_args,
                               tuple<_Args2...> __second_args,
                               __tuple_indices<_I1...>, __tuple_indices<_I2...>)
      : _T1(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...),
        _T2(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...) {}



  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_reference first() noexcept { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const noexcept {
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_reference second() noexcept { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const noexcept {
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void
  swap(__libcpp_compressed_pair_imp &) noexcept(__is_nothrow_swappable<_T1>::value &&__is_nothrow_swappable<_T2>::value) {

  }
};

template <class _T1, class _T2>
class __compressed_pair : private __libcpp_compressed_pair_imp<_T1, _T2> {
  typedef __libcpp_compressed_pair_imp<_T1, _T2> base;

public:
  typedef typename base::_T1_param _T1_param;
  typedef typename base::_T2_param _T2_param;

  typedef typename base::_T1_reference _T1_reference;
  typedef typename base::_T2_reference _T2_reference;

  typedef typename base::_T1_const_reference _T1_const_reference;
  typedef typename base::_T2_const_reference _T2_const_reference;

  __attribute__((__visibility__("hidden"), __always_inline__)) __compressed_pair() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T1_param __t1)
      : base(std::__1::forward<_T1_param>(__t1)) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __compressed_pair(_T2_param __t2)
      : base(std::__1::forward<_T2_param>(__t2)) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) __compressed_pair(_T1_param __t1, _T2_param __t2)
      : base(std::__1::forward<_T1_param>(__t1), std::__1::forward<_T2_param>(__t2)) {
  }
  template <class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"), __always_inline__)) __compressed_pair(piecewise_construct_t __pc,
                                              tuple<_Args1...> __first_args,
                                              tuple<_Args2...> __second_args)
      : base(__pc, std::__1::move(__first_args), std::__1::move(__second_args),
             typename __make_tuple_indices<sizeof...(_Args1)>::type(),
             typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}



  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_reference first() noexcept {
    return base::first();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T1_const_reference first() const noexcept {
    return base::first();
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_reference second() noexcept {
    return base::second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) _T2_const_reference second() const noexcept {
    return base::second();
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void swap(__compressed_pair &__x) noexcept(__is_nothrow_swappable<_T1>::value &&__is_nothrow_swappable<_T2>::value) {

    base::swap(__x);
  }
};

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(__compressed_pair<_T1, _T2> &__x,
                                           __compressed_pair<_T1, _T2> &__y)
    noexcept(__is_nothrow_swappable<_T1>::value &&__is_nothrow_swappable<_T2>::value) {

  __x.swap(__y);
}



template <
    class _Ptr1, class _Ptr2,
    bool = is_same<
        typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,
        typename remove_cv<
            typename pointer_traits<_Ptr2>::element_type>::type>::value>
struct __same_or_less_cv_qualified_imp : is_convertible<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false> : false_type {};

template <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||
                                           is_same<_Ptr1, _Ptr2>::value ||
                                           __has_element_type<_Ptr1>::value>
struct __same_or_less_cv_qualified
    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};

template <class _Ptr1, class _Ptr2>
struct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false> : false_type {};



template <class _Tp> struct __attribute__((__visibility__("default"))) default_delete {

  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr default_delete() noexcept =
      default;



  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) default_delete(
      const default_delete<_Up> &,
      typename enable_if<is_convertible<_Up *, _Tp *>::value>::type * =
          0) noexcept {}
  __attribute__((__visibility__("hidden"), __always_inline__)) void operator()(_Tp *__ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete incomplete type");
    delete __ptr;
  }
};

template <class _Tp> struct __attribute__((__visibility__("default"))) default_delete<_Tp[]> {
public:

  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr default_delete() noexcept =
      default;



  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) default_delete(
      const default_delete<_Up[]> &,
      typename enable_if<__same_or_less_cv_qualified<_Up *, _Tp *>::value>::type
          * = 0) noexcept {}
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) void operator()(
      _Up *__ptr,
      typename enable_if<__same_or_less_cv_qualified<_Up *, _Tp *>::value>::type
          * = 0) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete void type");
    delete[] __ptr;
  }
};

template <class _Tp, class _Dp = default_delete<_Tp>>
class __attribute__((__visibility__("default"))) unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;
  struct __nat {
    int __for_bool_;
  };

  typedef typename remove_reference<deleter_type>::type &_Dp_reference;
  typedef const typename remove_reference<deleter_type>::type
      &_Dp_const_reference;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr unique_ptr() noexcept
      : __ptr_(pointer()) {
    static_assert(!is_pointer<deleter_type>::value,
                  "unique_ptr constructed with null function pointer deleter");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr unique_ptr(nullptr_t) noexcept
      : __ptr_(pointer()) {
    static_assert(!is_pointer<deleter_type>::value,
                  "unique_ptr constructed with null function pointer deleter");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(pointer __p) noexcept
      : __ptr_(std::__1::move(__p)) {
    static_assert(!is_pointer<deleter_type>::value,
                  "unique_ptr constructed with null function pointer deleter");
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_ptr(pointer __p,
             typename conditional<
                 is_reference<deleter_type>::value, deleter_type,
                 typename add_lvalue_reference<const deleter_type>::type>::type
                 __d) noexcept : __ptr_(__p, __d) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_ptr(pointer __p,
             typename remove_reference<deleter_type>::type &&__d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) unique_ptr(unique_ptr &&__u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }
  template <class _Up, class _Ep>
  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_ptr(unique_ptr<_Up, _Ep> &&__u,
             typename enable_if<
                 !is_array<_Up>::value &&
                     is_convertible<typename unique_ptr<_Up, _Ep>::pointer,
                                    pointer>::value &&
                     is_convertible<_Ep, deleter_type>::value &&
                     (!is_reference<deleter_type>::value ||
                      is_same<deleter_type, _Ep>::value),
                 __nat>::type = __nat()) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {}

  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_ptr(auto_ptr<_Up> &&__p,
             typename enable_if<is_convertible<_Up *, _Tp *>::value &&
                                    is_same<_Dp, default_delete<_Tp>>::value,
                                __nat>::type = __nat()) noexcept
      : __ptr_(__p.release()) {}

  __attribute__((__visibility__("hidden"), __always_inline__)) unique_ptr &operator=(unique_ptr &&__u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<
      !is_array<_Up>::value &&
          is_convertible<typename unique_ptr<_Up, _Ep>::pointer,
                         pointer>::value &&
          is_assignable<deleter_type &, _Ep &&>::value,
      unique_ptr &>::type
  operator=(unique_ptr<_Up, _Ep> &&__u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) ~unique_ptr() { reset(); }

  __attribute__((__visibility__("hidden"), __always_inline__)) unique_ptr &operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type
  operator*() const {
    return *__ptr_.first();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer get() const noexcept {
    return __ptr_.first();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr &__u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};

template <class _Tp, class _Dp>
class __attribute__((__visibility__("default"))) unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;
  struct __nat {
    int __for_bool_;
  };

  typedef typename remove_reference<deleter_type>::type &_Dp_reference;
  typedef const typename remove_reference<deleter_type>::type
      &_Dp_const_reference;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr unique_ptr() noexcept
      : __ptr_(pointer()) {
    static_assert(!is_pointer<deleter_type>::value,
                  "unique_ptr constructed with null function pointer deleter");
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr unique_ptr(nullptr_t) noexcept
      : __ptr_(pointer()) {
    static_assert(!is_pointer<deleter_type>::value,
                  "unique_ptr constructed with null function pointer deleter");
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit unique_ptr(
      _Pp __p,
      typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value,
                         __nat>::type = __nat()) noexcept : __ptr_(__p) {
    static_assert(!is_pointer<deleter_type>::value,
                  "unique_ptr constructed with null function pointer deleter");
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) unique_ptr(
      _Pp __p,
      typename conditional<
          is_reference<deleter_type>::value, deleter_type,
          typename add_lvalue_reference<const deleter_type>::type>::type __d,
      typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value,
                         __nat>::type = __nat()) noexcept : __ptr_(__p, __d) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_ptr(nullptr_t,
             typename conditional<
                 is_reference<deleter_type>::value, deleter_type,
                 typename add_lvalue_reference<const deleter_type>::type>::type
                 __d) noexcept : __ptr_(pointer(), __d) {}

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) unique_ptr(
      _Pp __p, typename remove_reference<deleter_type>::type &&__d,
      typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value,
                         __nat>::type = __nat()) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_ptr(nullptr_t,
             typename remove_reference<deleter_type>::type &&__d) noexcept
      : __ptr_(pointer(), std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) unique_ptr(unique_ptr &&__u) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) unique_ptr &operator=(unique_ptr &&__u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep>
  __attribute__((__visibility__("hidden"), __always_inline__)) unique_ptr(
      unique_ptr<_Up, _Ep> &&__u,
      typename enable_if<
          is_array<_Up>::value &&
              __same_or_less_cv_qualified<
                  typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&
              is_convertible<_Ep, deleter_type>::value &&
              (!is_reference<deleter_type>::value ||
               is_same<deleter_type, _Ep>::value),
          __nat>::type = __nat()) noexcept
      : __ptr_(__u.release(), std::__1::forward<deleter_type>(__u.get_deleter())) {
  }

  template <class _Up, class _Ep>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<
      is_array<_Up>::value &&
          __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer,
                                      pointer>::value &&
          is_assignable<deleter_type &, _Ep &&>::value,
      unique_ptr &>::type
  operator=(unique_ptr<_Up, _Ep> &&__u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) ~unique_ptr() { reset(); }

  __attribute__((__visibility__("hidden"), __always_inline__)) unique_ptr &operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) typename add_lvalue_reference<_Tp>::type
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer get() const noexcept {
    return __ptr_.first();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) _Dp_reference get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) _Dp_const_reference get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) pointer release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__))
      typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value,
                         void>::type
      reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void swap(unique_ptr &__u) {
    __ptr_.swap(__u.__ptr_);
  }

private:
};

template <class _Tp, class _Dp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_swappable<_Dp>::value, void>::type
    swap(unique_ptr<_Tp, _Dp> &__x, unique_ptr<_Tp, _Dp> &__y) noexcept {
  __x.swap(__y);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return __x.get() == __y.get();
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return !(__x == __y);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  typedef typename unique_ptr<_T2, _D2>::pointer _P2;
  typedef typename common_type<_P1, _P2>::type _Vp;
  return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return __y < __x;
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return !(__y < __x);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return !(__x < __y);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const unique_ptr<_T1, _D1> &__x, nullptr_t) noexcept {
  return !__x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(nullptr_t, const unique_ptr<_T1, _D1> &__x) noexcept {
  return !__x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const unique_ptr<_T1, _D1> &__x, nullptr_t) noexcept {
  return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1> &__x) noexcept {
  return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator<(const unique_ptr<_T1, _D1> &__x,
                                                nullptr_t) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(nullptr_t, const unique_ptr<_T1, _D1> &__x) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator>(const unique_ptr<_T1, _D1> &__x,
                                                nullptr_t) {
  return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(nullptr_t, const unique_ptr<_T1, _D1> &__x) {
  return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const unique_ptr<_T1, _D1> &__x, nullptr_t) {
  return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1> &__x) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const unique_ptr<_T1, _D1> &__x, nullptr_t) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1> &__x) {
  return !(nullptr < __x);
}
template <class _Size>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Size __loadword(const void *__p) {
  _Size __r;
  std::memcpy(&__r, __p, sizeof(__r));
  return __r;
}




template <class _Size, size_t = sizeof(_Size) * 8>
struct __murmur2_or_cityhash;

template <class _Size> struct __murmur2_or_cityhash<_Size, 32> {
  _Size operator()(const void *__key, _Size __len);
};


template <class _Size>
_Size __murmur2_or_cityhash<_Size, 32>::
operator()(const void *__key,
           _Size __len) {
  const _Size __m = 0x5bd1e995;
  const _Size __r = 24;
  _Size __h = __len;
  const unsigned char *__data = static_cast<const unsigned char *>(__key);
  for (; __len >= 4; __data += 4, __len -= 4) {
    _Size __k = __loadword<_Size>(__data);
    __k *= __m;
    __k ^= __k >> __r;
    __k *= __m;
    __h *= __m;
    __h ^= __k;
  }
  switch (__len) {
  case 3:
    __h ^= __data[2] << 16;
  case 2:
    __h ^= __data[1] << 8;
  case 1:
    __h ^= __data[0];
    __h *= __m;
  }
  __h ^= __h >> 13;
  __h *= __m;
  __h ^= __h >> 15;
  return __h;
}

template <class _Size> struct __murmur2_or_cityhash<_Size, 64> {
  _Size operator()(const void *__key, _Size __len);

private:

  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val
                        : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) { return __val ^ (__val >> 47); }

  static _Size __hash_len_16(_Size __u, _Size __v) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char *__s, _Size __len) {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^
             __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y =
          static_cast<uint32_t>(__a) + (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }



  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(_Size __w, _Size __x,
                                                          _Size __y, _Size __z,
                                                          _Size __a,
                                                          _Size __b) {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }


  static pair<_Size, _Size>
  __weak_hash_len_32_with_seeds(const char *__s, _Size __a, _Size __b) {
    return __weak_hash_len_32_with_seeds(
        __loadword<_Size>(__s), __loadword<_Size>(__s + 8),
        __loadword<_Size>(__s + 16), __loadword<_Size>(__s + 24), __a, __b);
  }


  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};


template <class _Size>
_Size __murmur2_or_cityhash<_Size, 64>::
operator()(const void *__key,
           _Size __len) {
  const char *__s = static_cast<const char *>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }



  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y =
      __loadword<_Size>(__s + __len - 16) + __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                            __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v =
      __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w =
      __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);


  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x =
        __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v =
        __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(__hash_len_16(__v.first, __w.first) +
                           __shift_mix(__y) * __k1 + __z,
                       __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      size_t __a;
    } __u;
    __u.__a = 0;
    __u.__t = __v;
    return __u.__a;
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      size_t __a;
    } __u;
    __u.__t = __v;
    return __u.__a;
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
        size_t __c;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
        size_t __c;
        size_t __d;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp>
struct __attribute__((__visibility__("default"))) hash<_Tp *>
    : public unary_function<_Tp *, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(_Tp *__v) const noexcept {
    union {
      _Tp *__t;
      size_t __a;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp, class _Dp>
struct __attribute__((__visibility__("default"))) hash<unique_ptr<_Tp, _Dp>> {
  typedef unique_ptr<_Tp, _Dp> argument_type;
  typedef size_t result_type;
  __attribute__((__visibility__("hidden"), __always_inline__))
  result_type operator()(const argument_type &__ptr) const noexcept {
    typedef typename argument_type::pointer pointer;
    return hash<pointer>()(__ptr.get());
  }
};

struct __destruct_n {
private:
  size_t size;

  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) void __process(_Tp *__p, false_type) noexcept {
    for (size_t __i = 0; __i < size; ++__i, ++__p)
      __p->~_Tp();
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) void __process(_Tp *, true_type) noexcept {}

  __attribute__((__visibility__("hidden"), __always_inline__)) void __incr(false_type) noexcept { ++size; }
  __attribute__((__visibility__("hidden"), __always_inline__)) void __incr(true_type) noexcept {}

  __attribute__((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, false_type) noexcept {
    size = __s;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void __set(size_t, true_type) noexcept {}

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __destruct_n(size_t __s) noexcept
      : size(__s) {}

  template <class _Tp> __attribute__((__visibility__("hidden"), __always_inline__)) void __incr(_Tp *) noexcept {
    __incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) void __set(size_t __s, _Tp *) noexcept {
    __set(__s,
          integral_constant<bool, is_trivially_destructible<_Tp>::value>());
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) void operator()(_Tp *__p) noexcept {
    __process(__p,
              integral_constant<bool, is_trivially_destructible<_Tp>::value>());
  }
};

template <class _Alloc> class __allocator_destructor {
  typedef allocator_traits<_Alloc> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::size_type size_type;

private:
  _Alloc &__alloc_;
  size_type __s_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) __allocator_destructor(_Alloc &__a,
                                                   size_type __s) noexcept
      : __alloc_(__a),
        __s_(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator()(pointer __p) noexcept {
    __alloc_traits::deallocate(__alloc_, __p, __s_);
  }
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator uninitialized_copy(_InputIterator __f, _InputIterator __l,
                                    _ForwardIterator __r) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

  _ForwardIterator __s = __r;
  try {

    for (; __f != __l; ++__f, (void)++__r)
      ::new (static_cast<void *>(std::__1::addressof(*__r))) value_type(*__f);

  } catch (...) {
    for (; __s != __r; ++__s)
      __s->~value_type();
    throw;
  }

  return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator uninitialized_copy_n(_InputIterator __f, _Size __n,
                                      _ForwardIterator __r) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

  _ForwardIterator __s = __r;
  try {

    for (; __n > 0; ++__f, (void)++__r, (void)--__n)
      ::new (static_cast<void *>(std::__1::addressof(*__r))) value_type(*__f);

  } catch (...) {
    for (; __s != __r; ++__s)
      __s->~value_type();
    throw;
  }

  return __r;
}

template <class _ForwardIterator, class _Tp>
void uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l,
                        const _Tp &__x) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

  _ForwardIterator __s = __f;
  try {

    for (; __f != __l; ++__f)
      ::new (static_cast<void *>(std::__1::addressof(*__f))) value_type(__x);

  } catch (...) {
    for (; __s != __f; ++__s)
      __s->~value_type();
    throw;
  }

}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator uninitialized_fill_n(_ForwardIterator __f, _Size __n,
                                      const _Tp &__x) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

  _ForwardIterator __s = __f;
  try {

    for (; __n > 0; ++__f, (void)--__n)
      ::new (static_cast<void *>(std::__1::addressof(*__f))) value_type(__x);

  } catch (...) {
    for (; __s != __f; ++__s)
      __s->~value_type();
    throw;
  }

  return __f;
}
class __attribute__((__visibility__("default"))) bad_weak_ptr : public std::exception {
public:
  virtual ~bad_weak_ptr() noexcept;
  virtual const char *what() const noexcept;
};

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void __throw_bad_weak_ptr() {

  throw bad_weak_ptr();



}

template <class _Tp> class __attribute__((__visibility__("default"))) weak_ptr;

class __attribute__((__visibility__("default"))) __shared_count {
  __shared_count(const __shared_count &);
  __shared_count &operator=(const __shared_count &);

protected:
  long __shared_owners_;
  virtual ~__shared_count();

private:
  virtual void __on_zero_shared() noexcept = 0;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __shared_count(long __refs = 0) noexcept
      : __shared_owners_(__refs) {}

  void __add_shared() noexcept;
  bool __release_shared() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  long use_count() const noexcept {
    return __libcpp_relaxed_load(&__shared_owners_) + 1;
  }
};

class __attribute__((__visibility__("default"))) __shared_weak_count : private __shared_count {
  long __shared_weak_owners_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __shared_weak_count(long __refs = 0) noexcept
      : __shared_count(__refs),
        __shared_weak_owners_(__refs) {}

protected:
  virtual ~__shared_weak_count();

public:
  void __add_shared() noexcept;
  void __add_weak() noexcept;
  void __release_shared() noexcept;
  void __release_weak() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  long use_count() const noexcept { return __shared_count::use_count(); }
  __shared_weak_count *lock() noexcept;






  virtual const void *__get_deleter(const type_info &) const noexcept;

private:
  virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer : public __shared_weak_count {
  __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
      : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)),
                std::__1::move(__a)) {}





private:
  virtual void __on_zero_shared() noexcept;
  virtual void __on_zero_shared_weak() noexcept;
};
template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept {
  __data_.first().second()(__data_.first().first());
  __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept {
  typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type
      _Al;
  typedef allocator_traits<_Al> _ATraits;
  typedef pointer_traits<typename _ATraits::pointer> _PTraits;

  _Al __a(__data_.second());
  __data_.second().~_Alloc();
  __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace : public __shared_weak_count {
  __compressed_pair<_Alloc, _Tp> __data_;

public:


  __attribute__((__visibility__("hidden"), __always_inline__))
  __shared_ptr_emplace(_Alloc __a) : __data_(std::__1::move(__a)) {}

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) __shared_ptr_emplace(_Alloc __a, _Args &&... __args)
      : __data_(piecewise_construct, std::__1::forward_as_tuple(__a),
                std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)) {}
private:
  virtual void __on_zero_shared() noexcept;
  virtual void __on_zero_shared_weak() noexcept;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  _Tp *get() noexcept { return &__data_.second(); }
};

template <class _Tp, class _Alloc>
void __shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() noexcept {
  __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void __shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() noexcept {
  typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type
      _Al;
  typedef allocator_traits<_Al> _ATraits;
  typedef pointer_traits<typename _ATraits::pointer> _PTraits;
  _Al __a(__data_.first());
  __data_.first().~_Alloc();
  __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp> class __attribute__((__visibility__("default"))) enable_shared_from_this;

template <class _Tp> class __attribute__((__visibility__("default"))) shared_ptr {
public:
  typedef _Tp element_type;



private:
  element_type *__ptr_;
  __shared_weak_count *__cntrl_;

  struct __nat {
    int __for_bool_;
  };

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr shared_ptr() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr shared_ptr(nullptr_t) noexcept;
  template <class _Yp>
  explicit shared_ptr(
      _Yp *__p, typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                   __nat>::type = __nat());
  template <class _Yp, class _Dp>
  shared_ptr(_Yp *__p, _Dp __d,
             typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                __nat>::type = __nat());
  template <class _Yp, class _Dp, class _Alloc>
  shared_ptr(_Yp *__p, _Dp __d, _Alloc __a,
             typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                __nat>::type = __nat());
  template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
  template <class _Dp, class _Alloc>
  shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
  template <class _Yp>
  __attribute__((__visibility__("hidden"), __always_inline__)) shared_ptr(const shared_ptr<_Yp> &__r,
                                       element_type *__p) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  shared_ptr(const shared_ptr &__r) noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"), __always_inline__)) shared_ptr(
      const shared_ptr<_Yp> &__r,
      typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type =
          __nat()) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  shared_ptr(shared_ptr &&__r) noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"), __always_inline__)) shared_ptr(
      shared_ptr<_Yp> &&__r,
      typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type =
          __nat()) noexcept;

  template <class _Yp>
  explicit shared_ptr(const weak_ptr<_Yp> &__r,
                      typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                                         __nat>::type = __nat());

  template <class _Yp>
  shared_ptr(auto_ptr<_Yp> &&__r,
             typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                __nat>::type = __nat());







  template <class _Yp, class _Dp>
  shared_ptr(unique_ptr<_Yp, _Dp> &&,
             typename enable_if<
                 !is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
                     is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                                    element_type *>::value,
                 __nat>::type = __nat());
  template <class _Yp, class _Dp>
  shared_ptr(unique_ptr<_Yp, _Dp> &&,
             typename enable_if<
                 is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
                     is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                                    element_type *>::value,
                 __nat>::type = __nat());
  ~shared_ptr();

  __attribute__((__visibility__("hidden"), __always_inline__))
  shared_ptr &operator=(const shared_ptr &__r) noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     shared_ptr &>::type __attribute__((__visibility__("hidden"), __always_inline__))
  operator=(const shared_ptr<_Yp> &__r) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  shared_ptr &operator=(shared_ptr &&__r) noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     shared_ptr<_Tp> &>::type __attribute__((__visibility__("hidden"), __always_inline__))
  operator=(shared_ptr<_Yp> &&__r);
  template <class _Yp>
  __attribute__((__visibility__("hidden"), __always_inline__))
      typename enable_if<!is_array<_Yp>::value &&
                             is_convertible<_Yp *, element_type *>::value,
                         shared_ptr>::type &
      operator=(auto_ptr<_Yp> &&__r);
  template <class _Yp, class _Dp>
  typename enable_if<!is_array<_Yp>::value &&
                         is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                                        element_type *>::value,
                     shared_ptr &>::type

      __attribute__((__visibility__("hidden"), __always_inline__))
      operator=(unique_ptr<_Yp, _Dp> &&__r);





  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(shared_ptr &__r) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  void reset() noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type
      __attribute__((__visibility__("hidden"), __always_inline__))
      reset(_Yp *__p);
  template <class _Yp, class _Dp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type
      __attribute__((__visibility__("hidden"), __always_inline__))
      reset(_Yp *__p, _Dp __d);
  template <class _Yp, class _Dp, class _Alloc>
  typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type
      __attribute__((__visibility__("hidden"), __always_inline__))
      reset(_Yp *__p, _Dp __d, _Alloc __a);

  __attribute__((__visibility__("hidden"), __always_inline__))
  element_type *get() const noexcept { return __ptr_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  typename add_lvalue_reference<element_type>::type
  operator*() const noexcept {
    return *__ptr_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  element_type *operator->() const noexcept { return __ptr_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  long use_count() const noexcept {
    return __cntrl_ ? __cntrl_->use_count() : 0;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool unique() const noexcept { return use_count() == 1; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit operator bool() const noexcept { return get() != 0; }
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  owner_before(shared_ptr<_Up> const &__p) const {
    return __cntrl_ < __p.__cntrl_;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool owner_before(weak_ptr<_Up> const &__p) const {
    return __cntrl_ < __p.__cntrl_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool __owner_equivalent(const shared_ptr &__p) const {
    return __cntrl_ == __p.__cntrl_;
  }
  template <class... _Args>
  static shared_ptr<_Tp> make_shared(_Args &&... __args);

  template <class _Alloc, class... _Args>
  static shared_ptr<_Tp> allocate_shared(const _Alloc &__a, _Args &&... __args);
private:
  template <class _Yp, class _OrigPtr>
  __attribute__((__visibility__("hidden"), __always_inline__)) void
  __enable_weak_this(const enable_shared_from_this<_Yp> *__e,
                     _OrigPtr *__ptr) noexcept {
    typedef typename remove_cv<_Yp>::type _RawYp;
    if (__e && __e->__weak_this_.expired()) {
      __e->__weak_this_ = shared_ptr<_RawYp>(
          *this, const_cast<_RawYp *>(static_cast<const _Yp *>(__ptr)));
    }
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __enable_weak_this(const volatile void *,
                          const volatile void *) noexcept {}

  template <class _Up> friend class __attribute__((__visibility__("default"))) shared_ptr;
  template <class _Up> friend class __attribute__((__visibility__("default"))) weak_ptr;
};

template <class _Tp>
inline constexpr shared_ptr<_Tp>::shared_ptr() noexcept : __ptr_(0),
                                                                   __cntrl_(0) {
}

template <class _Tp>
inline constexpr shared_ptr<_Tp>::shared_ptr(nullptr_t) noexcept
    : __ptr_(0),
      __cntrl_(0) {}

template <class _Tp>
template <class _Yp>
shared_ptr<_Tp>::shared_ptr(
    _Yp *__p, typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                 __nat>::type)
    : __ptr_(__p) {
  unique_ptr<_Yp> __hold(__p);
  typedef __shared_ptr_pointer<_Yp *, default_delete<_Yp>, allocator<_Yp>>
      _CntrlBlk;
  __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());
  __hold.release();
  __enable_weak_this(__p, __p);
}

template <class _Tp>
template <class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(
    _Yp *__p, _Dp __d,
    typename enable_if<is_convertible<_Yp *, element_type *>::value,
                       __nat>::type)
    : __ptr_(__p) {

  try {

    typedef __shared_ptr_pointer<_Yp *, _Dp, allocator<_Yp>> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());
    __enable_weak_this(__p, __p);

  } catch (...) {
    __d(__p);
    throw;
  }

}

template <class _Tp>
template <class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d) : __ptr_(0) {

  try {

    typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp>> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());

  } catch (...) {
    __d(__p);
    throw;
  }

}

template <class _Tp>
template <class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(
    _Yp *__p, _Dp __d, _Alloc __a,
    typename enable_if<is_convertible<_Yp *, element_type *>::value,
                       __nat>::type)
    : __ptr_(__p) {

  try {

    typedef __shared_ptr_pointer<_Yp *, _Dp, _Alloc> _CntrlBlk;
    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new (static_cast<void *>(std::__1::addressof(*__hold2.get())))
        _CntrlBlk(__p, __d, __a);
    __cntrl_ = std::__1::addressof(*__hold2.release());
    __enable_weak_this(__p, __p);

  } catch (...) {
    __d(__p);
    throw;
  }

}

template <class _Tp>
template <class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a) : __ptr_(0) {

  try {

    typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new (static_cast<void *>(std::__1::addressof(*__hold2.get())))
        _CntrlBlk(__p, __d, __a);
    __cntrl_ = std::__1::addressof(*__hold2.release());

  } catch (...) {
    __d(__p);
    throw;
  }

}

template <class _Tp>
template <class _Yp>
inline shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp> &__r,
                                   element_type *__p) noexcept
    : __ptr_(__p),
      __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_shared();
}

template <class _Tp>
inline shared_ptr<_Tp>::shared_ptr(const shared_ptr &__r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_shared();
}

template <class _Tp>
template <class _Yp>
inline shared_ptr<_Tp>::shared_ptr(
    const shared_ptr<_Yp> &__r,
    typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type)
    noexcept : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_shared();
}



template <class _Tp>
inline shared_ptr<_Tp>::shared_ptr(shared_ptr &&__r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

template <class _Tp>
template <class _Yp>
inline shared_ptr<_Tp>::shared_ptr(
    shared_ptr<_Yp> &&__r,
    typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type)
    noexcept : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}



template <class _Tp>
template <class _Yp>

shared_ptr<_Tp>::shared_ptr(
    auto_ptr<_Yp> &&__r,




    typename enable_if<is_convertible<_Yp *, element_type *>::value,
                       __nat>::type)
    : __ptr_(__r.get()) {
  typedef __shared_ptr_pointer<_Yp *, default_delete<_Yp>, allocator<_Yp>>
      _CntrlBlk;
  __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
  __enable_weak_this(__r.get(), __r.get());
  __r.release();
}

template <class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(
    unique_ptr<_Yp, _Dp> &&__r,




    typename enable_if<
        !is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                           element_type *>::value,
        __nat>::type)
    : __ptr_(__r.get()) {





  {
    typedef __shared_ptr_pointer<_Yp *, _Dp, allocator<_Yp>> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());
    __enable_weak_this(__r.get(), __r.get());
  }
  __r.release();
}

template <class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(
    unique_ptr<_Yp, _Dp> &&__r,




    typename enable_if<
        is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                           element_type *>::value,
        __nat>::type)
    : __ptr_(__r.get()) {





  {
    typedef __shared_ptr_pointer<
        _Yp *, reference_wrapper<typename remove_reference<_Dp>::type>,
        allocator<_Yp>>
        _CntrlBlk;
    __cntrl_ =
        new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());
    __enable_weak_this(__r.get(), __r.get());
  }
  __r.release();
}



template <class _Tp>
template <class... _Args>
shared_ptr<_Tp> shared_ptr<_Tp>::make_shared(_Args &&... __args) {
  typedef __shared_ptr_emplace<_Tp, allocator<_Tp>> _CntrlBlk;
  typedef allocator<_CntrlBlk> _A2;
  typedef __allocator_destructor<_A2> _D2;
  _A2 __a2;
  unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
  ::new (__hold2.get()) _CntrlBlk(__a2, std::__1::forward<_Args>(__args)...);
  shared_ptr<_Tp> __r;
  __r.__ptr_ = __hold2.get()->get();
  __r.__cntrl_ = __hold2.release();
  __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
  return __r;
}

template <class _Tp>
template <class _Alloc, class... _Args>
shared_ptr<_Tp> shared_ptr<_Tp>::allocate_shared(const _Alloc &__a,
                                                 _Args &&... __args) {
  typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
  typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
  typedef __allocator_destructor<_A2> _D2;
  _A2 __a2(__a);
  unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
  ::new (static_cast<void *>(std::__1::addressof(*__hold2.get())))
      _CntrlBlk(__a, std::__1::forward<_Args>(__args)...);
  shared_ptr<_Tp> __r;
  __r.__ptr_ = __hold2.get()->get();
  __r.__cntrl_ = std::__1::addressof(*__hold2.release());
  __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
  return __r;
}
template <class _Tp> shared_ptr<_Tp>::~shared_ptr() {
  if (__cntrl_)
    __cntrl_->__release_shared();
}

template <class _Tp>
inline shared_ptr<_Tp> &shared_ptr<_Tp>::
operator=(const shared_ptr &__r) noexcept {
  shared_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                          shared_ptr<_Tp> &>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp> &__r) noexcept {
  shared_ptr(__r).swap(*this);
  return *this;
}



template <class _Tp>
inline shared_ptr<_Tp> &shared_ptr<_Tp>::operator=(shared_ptr &&__r) noexcept {
  shared_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                          shared_ptr<_Tp> &>::type
shared_ptr<_Tp>::operator=(shared_ptr<_Yp> &&__r) {
  shared_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<!is_array<_Yp>::value &&
                              is_convertible<_Yp *, _Tp *>::value,
                          shared_ptr<_Tp>>::type &
shared_ptr<_Tp>::operator=(auto_ptr<_Yp> &&__r) {
  shared_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp, class _Dp>
inline typename enable_if<
    !is_array<_Yp>::value &&
        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp *>::value,
    shared_ptr<_Tp> &>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> &&__r) {
  shared_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}
template <class _Tp>
inline void shared_ptr<_Tp>::swap(shared_ptr &__r) noexcept {
  std::__1::swap(__ptr_, __r.__ptr_);
  std::__1::swap(__cntrl_, __r.__cntrl_);
}

template <class _Tp> inline void shared_ptr<_Tp>::reset() noexcept {
  shared_ptr().swap(*this);
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, void>::type
shared_ptr<_Tp>::reset(_Yp *__p) {
  shared_ptr(__p).swap(*this);
}

template <class _Tp>
template <class _Yp, class _Dp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, void>::type
shared_ptr<_Tp>::reset(_Yp *__p, _Dp __d) {
  shared_ptr(__p, __d).swap(*this);
}

template <class _Tp>
template <class _Yp, class _Dp, class _Alloc>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value, void>::type
shared_ptr<_Tp>::reset(_Yp *__p, _Dp __d, _Alloc __a) {
  shared_ptr(__p, __d, __a).swap(*this);
}



template <class _Tp, class... _Args>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<!is_array<_Tp>::value, shared_ptr<_Tp>>::type
    make_shared(_Args &&... __args) {
  return shared_ptr<_Tp>::make_shared(std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Alloc, class... _Args>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<!is_array<_Tp>::value, shared_ptr<_Tp>>::type
    allocate_shared(const _Alloc &__a, _Args &&... __args) {
  return shared_ptr<_Tp>::allocate_shared(__a,
                                          std::__1::forward<_Args>(__args)...);
}
template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return __x.get() == __y.get();
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return !(__x == __y);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  typedef typename common_type<_Tp *, _Up *>::type _Vp;
  return less<_Vp>()(__x.get(), __y.get());
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return __y < __x;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return !(__y < __x);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return !(__x < __y);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator==(const shared_ptr<_Tp> &__x,
                                                 nullptr_t) noexcept {
  return !__x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return !__x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator!=(const shared_ptr<_Tp> &__x,
                                                 nullptr_t) noexcept {
  return static_cast<bool>(__x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return static_cast<bool>(__x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator<(const shared_ptr<_Tp> &__x,
                                                nullptr_t) noexcept {
  return less<_Tp *>()(__x.get(), nullptr);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return less<_Tp *>()(nullptr, __x.get());
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator>(const shared_ptr<_Tp> &__x,
                                                nullptr_t) noexcept {
  return nullptr < __x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return __x < nullptr;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator<=(const shared_ptr<_Tp> &__x,
                                                 nullptr_t) noexcept {
  return !(nullptr < __x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return !(__x < nullptr);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator>=(const shared_ptr<_Tp> &__x,
                                                 nullptr_t) noexcept {
  return !(__x < nullptr);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return !(nullptr < __x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(shared_ptr<_Tp> &__x,
                                           shared_ptr<_Tp> &__y) noexcept {
  __x.swap(__y);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value,
                       shared_ptr<_Tp>>::type
    static_pointer_cast(const shared_ptr<_Up> &__r) noexcept {
  return shared_ptr<_Tp>(__r, static_cast<_Tp *>(__r.get()));
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value,
                       shared_ptr<_Tp>>::type
    dynamic_pointer_cast(const shared_ptr<_Up> &__r) noexcept {
  _Tp *__p = dynamic_cast<_Tp *>(__r.get());
  return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template <class _Tp, class _Up>
typename enable_if<is_array<_Tp>::value == is_array<_Up>::value,
                   shared_ptr<_Tp>>::type
const_pointer_cast(const shared_ptr<_Up> &__r) noexcept {
  typedef typename remove_extent<_Tp>::type _RTp;
  return shared_ptr<_Tp>(__r, const_cast<_RTp *>(__r.get()));
}
template <class _Tp> class __attribute__((__visibility__("default"))) weak_ptr {
public:
  typedef _Tp element_type;

private:
  element_type *__ptr_;
  __shared_weak_count *__cntrl_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr weak_ptr() noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"), __always_inline__)) weak_ptr(
      shared_ptr<_Yp> const &__r,
      typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type =
          0) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  weak_ptr(weak_ptr const &__r) noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"), __always_inline__)) weak_ptr(
      weak_ptr<_Yp> const &__r,
      typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type =
          0) noexcept;


  __attribute__((__visibility__("hidden"), __always_inline__))
  weak_ptr(weak_ptr &&__r) noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"), __always_inline__)) weak_ptr(
      weak_ptr<_Yp> &&__r,
      typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type =
          0) noexcept;

  ~weak_ptr();

  __attribute__((__visibility__("hidden"), __always_inline__))
  weak_ptr &operator=(weak_ptr const &__r) noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     weak_ptr &>::type __attribute__((__visibility__("hidden"), __always_inline__))
  operator=(weak_ptr<_Yp> const &__r) noexcept;



  __attribute__((__visibility__("hidden"), __always_inline__))
  weak_ptr &operator=(weak_ptr &&__r) noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     weak_ptr &>::type __attribute__((__visibility__("hidden"), __always_inline__))
  operator=(weak_ptr<_Yp> &&__r) noexcept;



  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     weak_ptr &>::type __attribute__((__visibility__("hidden"), __always_inline__))
  operator=(shared_ptr<_Yp> const &__r) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(weak_ptr &__r) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  void reset() noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  long use_count() const noexcept {
    return __cntrl_ ? __cntrl_->use_count() : 0;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool expired() const noexcept {
    return __cntrl_ == 0 || __cntrl_->use_count() == 0;
  }
  shared_ptr<_Tp> lock() const noexcept;
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  owner_before(const shared_ptr<_Up> &__r) const {
    return __cntrl_ < __r.__cntrl_;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool owner_before(const weak_ptr<_Up> &__r) const {
    return __cntrl_ < __r.__cntrl_;
  }

  template <class _Up> friend class __attribute__((__visibility__("default"))) weak_ptr;
  template <class _Up> friend class __attribute__((__visibility__("default"))) shared_ptr;
};

template <class _Tp>
inline constexpr weak_ptr<_Tp>::weak_ptr() noexcept : __ptr_(0),
                                                               __cntrl_(0) {}

template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr const &__r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp>
inline weak_ptr<_Tp>::weak_ptr(
    shared_ptr<_Yp> const &__r,
    typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type)
    noexcept : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp>
inline weak_ptr<_Tp>::weak_ptr(
    weak_ptr<_Yp> const &__r,
    typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type)
    noexcept : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}



template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr &&__r) noexcept
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

template <class _Tp>
template <class _Yp>
inline weak_ptr<_Tp>::weak_ptr(
    weak_ptr<_Yp> &&__r,
    typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat *>::type)
    noexcept : __ptr_(__r.__ptr_),
                __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}



template <class _Tp> weak_ptr<_Tp>::~weak_ptr() {
  if (__cntrl_)
    __cntrl_->__release_weak();
}

template <class _Tp>
inline weak_ptr<_Tp> &weak_ptr<_Tp>::operator=(weak_ptr const &__r) noexcept {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                          weak_ptr<_Tp> &>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const &__r) noexcept {
  weak_ptr(__r).swap(*this);
  return *this;
}



template <class _Tp>
inline weak_ptr<_Tp> &weak_ptr<_Tp>::operator=(weak_ptr &&__r) noexcept {
  weak_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                          weak_ptr<_Tp> &>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> &&__r) noexcept {
  weak_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}



template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                          weak_ptr<_Tp> &>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const &__r) noexcept {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp> inline void weak_ptr<_Tp>::swap(weak_ptr &__r) noexcept {
  std::__1::swap(__ptr_, __r.__ptr_);
  std::__1::swap(__cntrl_, __r.__cntrl_);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(weak_ptr<_Tp> &__x,
                                           weak_ptr<_Tp> &__y) noexcept {
  __x.swap(__y);
}

template <class _Tp> inline void weak_ptr<_Tp>::reset() noexcept {
  weak_ptr().swap(*this);
}

template <class _Tp>
template <class _Yp>
shared_ptr<_Tp>::shared_ptr(
    const weak_ptr<_Yp> &__r,
    typename enable_if<is_convertible<_Yp *, _Tp *>::value, __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_) {
  if (__cntrl_ == 0)
    __throw_bad_weak_ptr();
}

template <class _Tp> shared_ptr<_Tp> weak_ptr<_Tp>::lock() const noexcept {
  shared_ptr<_Tp> __r;
  __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
  if (__r.__cntrl_)
    __r.__ptr_ = __ptr_;
  return __r;
}




template <class _Tp> struct owner_less;


template <class _Tp>
struct __attribute__((__visibility__("default"))) owner_less<shared_ptr<_Tp>>
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool> {
  typedef bool result_type;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(shared_ptr<_Tp> const &__x,
                  shared_ptr<_Tp> const &__y) const {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(shared_ptr<_Tp> const &__x, weak_ptr<_Tp> const &__y) const {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(weak_ptr<_Tp> const &__x, shared_ptr<_Tp> const &__y) const {
    return __x.owner_before(__y);
  }
};

template <class _Tp>
struct __attribute__((__visibility__("default"))) owner_less<weak_ptr<_Tp>>
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool> {
  typedef bool result_type;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(weak_ptr<_Tp> const &__x, weak_ptr<_Tp> const &__y) const {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(shared_ptr<_Tp> const &__x, weak_ptr<_Tp> const &__y) const {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(weak_ptr<_Tp> const &__x, shared_ptr<_Tp> const &__y) const {
    return __x.owner_before(__y);
  }
};
template <class _Tp> class __attribute__((__visibility__("default"))) enable_shared_from_this {
  mutable weak_ptr<_Tp> __weak_this_;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
  enable_shared_from_this() noexcept {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  enable_shared_from_this(enable_shared_from_this const &) noexcept {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  enable_shared_from_this &
  operator=(enable_shared_from_this const &) noexcept {
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~enable_shared_from_this() {}

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  shared_ptr<_Tp> shared_from_this() { return shared_ptr<_Tp>(__weak_this_); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  shared_ptr<_Tp const> shared_from_this() const {
    return shared_ptr<const _Tp>(__weak_this_);
  }
  template <class _Up> friend class shared_ptr;
};

template <class _Tp> struct __attribute__((__visibility__("default"))) hash<shared_ptr<_Tp>> {
  typedef shared_ptr<_Tp> argument_type;
  typedef size_t result_type;
  __attribute__((__visibility__("hidden"), __always_inline__))
  result_type operator()(const argument_type &__ptr) const noexcept {
    return hash<_Tp *>()(__ptr.get());
  }
};

template <class _CharT, class _Traits, class _Yp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, shared_ptr<_Yp> const &__p);



class __attribute__((__visibility__("default"))) __sp_mut {
  void *__lx;

public:
  void lock() noexcept;
  void unlock() noexcept;

private:
  constexpr __sp_mut(void *) noexcept;
  __sp_mut(const __sp_mut &);
  __sp_mut &operator=(const __sp_mut &);

  friend __attribute__((__visibility__("default"))) __sp_mut &__get_sp_mut(const void *);
};

__attribute__((__visibility__("default"))) __sp_mut &__get_sp_mut(const void *);

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_is_lock_free(const shared_ptr<_Tp> *) {
  return false;
}

template <class _Tp> shared_ptr<_Tp> atomic_load(const shared_ptr<_Tp> *__p) {
  __sp_mut &__m = __get_sp_mut(__p);
  __m.lock();
  shared_ptr<_Tp> __q = *__p;
  __m.unlock();
  return __q;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) shared_ptr<_Tp>
atomic_load_explicit(const shared_ptr<_Tp> *__p, memory_order) {
  return atomic_load(__p);
}

template <class _Tp>
void atomic_store(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) {
  __sp_mut &__m = __get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
atomic_store_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, memory_order) {
  atomic_store(__p, __r);
}

template <class _Tp>
shared_ptr<_Tp> atomic_exchange(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) {
  __sp_mut &__m = __get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
  return __r;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r,
                         memory_order) {
  return atomic_exchange(__p, __r);
}

template <class _Tp>
bool atomic_compare_exchange_strong(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v,
                                    shared_ptr<_Tp> __w) {
  shared_ptr<_Tp> __temp_ptr;
  __sp_mut &__m = __get_sp_mut(__p);
  __m.lock();
  if (__p->__owner_equivalent(*__v)) {
    std::__1::swap(__temp_ptr, *__p);
    *__p = __w;
    __m.unlock();
    return true;
  }
  std::__1::swap(__temp_ptr, *__v);
  *__v = *__p;
  __m.unlock();
  return false;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_weak(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v,
                             shared_ptr<_Tp> __w) {
  return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool atomic_compare_exchange_strong_explicit(
    shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w,
    memory_order, memory_order) {
  return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
atomic_compare_exchange_weak_explicit(shared_ptr<_Tp> *__p,
                                      shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w,
                                      memory_order, memory_order) {
  return atomic_compare_exchange_weak(__p, __v, __w);
}




enum class pointer_safety{relaxed, preferred, strict};


__attribute__((__visibility__("default"))) void declare_reachable(void *__p);
__attribute__((__visibility__("default"))) void declare_no_pointers(char *__p, size_t __n);
__attribute__((__visibility__("default"))) void undeclare_no_pointers(char *__p, size_t __n);
__attribute__((__visibility__("default"))) pointer_safety get_pointer_safety() noexcept;
__attribute__((__visibility__("default"))) void *__undeclare_reachable(void *__p);

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp *undeclare_reachable(_Tp *__p) {
  return static_cast<_Tp *>(__undeclare_reachable(__p));
}

__attribute__((__visibility__("default"))) void *align(size_t __align, size_t __sz, void *&__ptr,
                             size_t &__space);


template <typename _Alloc>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void __swap_allocator(_Alloc &__a1,
                                                       _Alloc &__a2)



    noexcept(__is_nothrow_swappable<_Alloc>::value)

{
  __swap_allocator(
      __a1, __a2,
      integral_constant<bool, std::__1::allocator_traits<_Alloc>::
                                  propagate_on_container_swap::value>());
}

template <typename _Alloc>
__attribute__((__visibility__("hidden"), __always_inline__)) void __swap_allocator(_Alloc &__a1, _Alloc &__a2,
                                                true_type)



    noexcept(__is_nothrow_swappable<_Alloc>::value)

{
  using std::__1::swap;
  swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void __swap_allocator(_Alloc &, _Alloc &,
                                                       false_type) noexcept {}

template <typename _Alloc, typename _Traits = allocator_traits<_Alloc>>
struct __noexcept_move_assign_container
    : public integral_constant<
          bool, _Traits::propagate_on_container_move_assignment::value



                    && is_nothrow_move_assignable<_Alloc>::value

          > {
};


template <class _Tp, class _Alloc> struct __temp_value {
  typedef allocator_traits<_Alloc> _Traits;

  typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
  _Alloc &__a;

  _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
  _Tp &get() { return *__addr(); }

  template <class... _Args>
  __temp_value(_Alloc &__alloc, _Args &&... __args) : __a(__alloc) {
    _Traits::construct(__a, __addr(), std::__1::forward<_Args>(__args)...);
  }

  ~__temp_value() { _Traits::destroy(__a, __addr()); }
};


} }









namespace std { inline namespace __1 {




template <class _T1, class _T2 = _T1> struct __equal_to {
  __attribute__((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1 &__x,
                                            const _T1 &__y) const {
    return __x == __y;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1 &__x,
                                            const _T2 &__y) const {
    return __x == __y;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2 &__x,
                                            const _T1 &__y) const {
    return __x == __y;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool operator()(const _T2 &__x,
                                            const _T2 &__y) const {
    return __x == __y;
  }
};

template <class _T1> struct __equal_to<_T1, _T1> {
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x == __y;
  }
};

template <class _T1> struct __equal_to<const _T1, _T1> {
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x == __y;
  }
};

template <class _T1> struct __equal_to<_T1, const _T1> {
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x == __y;
  }
};

template <class _T1, class _T2 = _T1> struct __less {
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x < __y;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T1 &__x, const _T2 &__y) const {
    return __x < __y;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T2 &__x, const _T1 &__y) const {
    return __x < __y;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T2 &__x, const _T2 &__y) const {
    return __x < __y;
  }
};

template <class _T1> struct __less<_T1, _T1> {
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x < __y;
  }
};

template <class _T1> struct __less<const _T1, _T1> {
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x < __y;
  }
};

template <class _T1> struct __less<_T1, const _T1> {
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x < __y;
  }
};

template <class _Predicate> class __negate {
private:
  _Predicate __p_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) __negate() {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __negate(_Predicate __p) : __p_(__p) {}

  template <class _T1>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1 &__x) {
    return !__p_(__x);
  }

  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool operator()(const _T1 &__x, const _T2 &__y) {
    return !__p_(__x, __y);
  }
};
inline __attribute__((__visibility__("hidden"), __always_inline__)) unsigned __ctz(unsigned __x) {
  return static_cast<unsigned>(__builtin_ctz(__x));
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long __ctz(unsigned long __x) {
  return static_cast<unsigned long>(__builtin_ctzl(__x));
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long long
__ctz(unsigned long long __x) {
  return static_cast<unsigned long long>(__builtin_ctzll(__x));
}


inline __attribute__((__visibility__("hidden"), __always_inline__)) unsigned __clz(unsigned __x) {
  return static_cast<unsigned>(__builtin_clz(__x));
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long __clz(unsigned long __x) {
  return static_cast<unsigned long>(__builtin_clzl(__x));
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long long
__clz(unsigned long long __x) {
  return static_cast<unsigned long long>(__builtin_clzll(__x));
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned __x) {
  return __builtin_popcount(__x);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long __x) {
  return __builtin_popcountl(__x);
}
inline __attribute__((__visibility__("hidden"), __always_inline__)) int __pop_count(unsigned long long __x) {
  return __builtin_popcountll(__x);
}



template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      return false;
  return true;
}



template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return true;
  return false;
}



template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return false;
  return true;
}



template <class _InputIterator, class _Function>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Function for_each(_InputIterator __first,
                                                    _InputIterator __last,
                                                    _Function __f) {
  for (; __first != __last; ++__first)
    __f(*__first);
  return (__f);
}



template <class _InputIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _InputIterator find(_InputIterator __first,
                                                     _InputIterator __last,
                                                     const _Tp &__value_) {
  for (; __first != __last; ++__first)
    if (*__first == __value_)
      break;
  return __first;
}



template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _InputIterator find_if(_InputIterator __first,
                                                        _InputIterator __last,
                                                        _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      break;
  return __first;
}



template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      break;
  return __first;
}



template <class _BinaryPredicate, class _ForwardIterator1,
          class _ForwardIterator2>
_ForwardIterator1 __find_end(_ForwardIterator1 __first1,
                             _ForwardIterator1 __last1,
                             _ForwardIterator2 __first2,
                             _ForwardIterator2 __last2, _BinaryPredicate __pred,
                             forward_iterator_tag, forward_iterator_tag) {

  _ForwardIterator1 __r = __last1;
  if (__first2 == __last2)
    return __r;
  while (true) {
    while (true) {
      if (__first1 == __last1)
        return __r;
      if (__pred(*__first1, *__first2))
        break;
      ++__first1;
    }

    _ForwardIterator1 __m1 = __first1;
    _ForwardIterator2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2) {

        __r = __first1;
        ++__first1;
        break;
      }
      if (++__m1 == __last1)
        return __r;
      if (!__pred(*__m1, *__m2))
      {
        ++__first1;
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _BidirectionalIterator1,
          class _BidirectionalIterator2>
_BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2,
           _BinaryPredicate __pred, bidirectional_iterator_tag,
           bidirectional_iterator_tag) {

  if (__first2 == __last2)
    return __last1;
  _BidirectionalIterator1 __l1 = __last1;
  _BidirectionalIterator2 __l2 = __last2;
  --__l2;
  while (true) {


    while (true) {
      if (__first1 == __l1)
        return __last1;
      if (__pred(*--__l1, *__l2))
        break;
    }

    _BidirectionalIterator1 __m1 = __l1;
    _BidirectionalIterator2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)

        return __m1;
      if (__m1 == __first1)
        return __last1;
      if (!__pred(*--__m1,
                  *--__m2))
      {
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _RandomAccessIterator1,
          class _RandomAccessIterator2>
                              _RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2,
           _BinaryPredicate __pred, random_access_iterator_tag,
           random_access_iterator_tag) {


  typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 =
      __last2 - __first2;
  if (__len2 == 0)
    return __last1;
  typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 =
      __last1 - __first1;
  if (__len1 < __len2)
    return __last1;
  const _RandomAccessIterator1 __s =
      __first1 + (__len2 - 1);
  _RandomAccessIterator1 __l1 = __last1;
  _RandomAccessIterator2 __l2 = __last2;
  --__l2;
  while (true) {
    while (true) {
      if (__s == __l1)
        return __last1;
      if (__pred(*--__l1, *__l2))
        break;
    }
    _RandomAccessIterator1 __m1 = __l1;
    _RandomAccessIterator2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;


      if (!__pred(*--__m1, *--__m2)) {
        break;
      }
    }
  }
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2,
         _BinaryPredicate __pred) {
  return std::__1::__find_end<
      typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first1, __last1, __first2, __last2, __pred,
      typename iterator_traits<_ForwardIterator1>::iterator_category(),
      typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::find_end(__first1, __last1, __first2, __last2,
                         __equal_to<__v1, __v2>());
}



template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
                              _ForwardIterator1
__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                   _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1)
    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
      if (__pred(*__first1, *__j))
        return __first1;
  return __last1;
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2,
              _BinaryPredicate __pred) {
  return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2,
                                   __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2,
                                   __equal_to<__v1, __v2>());
}



template <class _ForwardIterator, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
              _BinaryPredicate __pred) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (__pred(*__first, *__i))
        return __first;
      __first = __i;
    }
  }
  return __last;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type __v;
  return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}



template <class _InputIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp &__value_) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (*__first == __value_)
      ++__r;
  return __r;
}



template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      ++__r;
  return __r;
}



template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return true;
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool equal(_InputIterator1 __first1,
                                            _InputIterator1 __last1,
                                            _InputIterator2 __first2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}
template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                    _ForwardIterator2 __first2, _BinaryPredicate __pred) {

  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      goto __not_done;
  return true;
__not_done:

  typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
  _D1 __l1 = std::__1::distance(__first1, __last1);
  if (__l1 == _D1(1))
    return false;
  _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);


  for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i) {

    for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)
      if (__pred(*__j, *__i))
        goto __next_iter;
    {

      _D1 __c2 = 0;
      for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
        if (__pred(*__i, *__j))
          ++__c2;
      if (__c2 == 0)
        return false;

      _D1 __c1 = 1;
      for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
        if (__pred(*__i, *__j))
          ++__c1;
      if (__c1 != __c2)
        return false;
    }
  __next_iter:;
  }
  return true;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::is_permutation(__first1, __last1, __first2,
                               __equal_to<__v1, __v2>());
}
template <class _BinaryPredicate, class _ForwardIterator1,
          class _ForwardIterator2>
pair<_ForwardIterator1, _ForwardIterator1>
__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2,
         _BinaryPredicate __pred, forward_iterator_tag, forward_iterator_tag) {
  if (__first2 == __last2)
    return make_pair(__first1,
                     __first1);
  while (true) {


    while (true) {
      if (__first1 == __last1)
        return make_pair(__last1, __last1);
      if (__pred(*__first1, *__first2))
        break;
      ++__first1;
    }

    _ForwardIterator1 __m1 = __first1;
    _ForwardIterator2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)

        return make_pair(__first1, __m1);
      if (++__m1 == __last1)
        return make_pair(__last1, __last1);
      if (!__pred(*__m1,
                  *__m2))
      {
        ++__first1;
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _RandomAccessIterator1,
          class _RandomAccessIterator2>

    pair<_RandomAccessIterator1, _RandomAccessIterator1>
    __search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
             _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2,
             _BinaryPredicate __pred, random_access_iterator_tag,
             random_access_iterator_tag) {
  typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
  typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;


  const _D2 __len2 = __last2 - __first2;
  if (__len2 == 0)
    return make_pair(__first1, __first1);
  const _D1 __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return make_pair(__last1, __last1);
  const _RandomAccessIterator1 __s =
      __last1 - (__len2 - 1);
  while (true) {

    while (true) {
      if (__first1 == __s)
        return make_pair(__last1, __last1);
      if (__pred(*__first1, *__first2))
        break;
      ++__first1;
    }
    _RandomAccessIterator1 __m1 = __first1;
    _RandomAccessIterator2 __m2 = __first2;

    while (true) {
      if (++__m2 == __last2)
        return make_pair(__first1, __first1 + __len2);
      ++__m1;

      if (!__pred(*__m1, *__m2)) {
        ++__first1;
        break;
      }
    }
  }
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred) {
  return std::__1::__search<typename add_lvalue_reference<_BinaryPredicate>::type>(
             __first1, __last1, __first2, __last2, __pred,
             typename iterator_traits<_ForwardIterator1>::iterator_category(),
             typename iterator_traits<_ForwardIterator2>::iterator_category())
      .first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::search(__first1, __last1, __first2, __last2,
                       __equal_to<__v1, __v2>());
}



template <class _BinaryPredicate, class _ForwardIterator, class _Size,
          class _Tp>
_ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last,
                            _Size __count, const _Tp &__value_,
                            _BinaryPredicate __pred, forward_iterator_tag) {
  if (__count <= 0)
    return __first;
  while (true) {


    while (true) {
      if (__first == __last)
        return __last;
      if (__pred(*__first, __value_))
        break;
      ++__first;
    }

    _ForwardIterator __m = __first;
    _Size __c(0);
    while (true) {
      if (++__c == __count)

        return __first;
      if (++__m == __last)
        return __last;
      if (!__pred(
              *__m,
              __value_))
      {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size,
          class _Tp>
_RandomAccessIterator __search_n(_RandomAccessIterator __first,
                                 _RandomAccessIterator __last, _Size __count,
                                 const _Tp &__value_, _BinaryPredicate __pred,
                                 random_access_iterator_tag) {
  if (__count <= 0)
    return __first;
  _Size __len = static_cast<_Size>(__last - __first);
  if (__len < __count)
    return __last;
  const _RandomAccessIterator __s =
      __last - (__count - 1);
  while (true) {


    while (true) {
      if (__first >= __s)
        return __last;
      if (__pred(*__first, __value_))
        break;
      ++__first;
    }

    _RandomAccessIterator __m = __first;
    _Size __c(0);
    while (true) {
      if (++__c == __count)

        return __first;
      ++__m;

      if (!__pred(
              *__m,
              __value_))
      {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _ForwardIterator, class _Size, class _Tp,
          class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count,
         const _Tp &__value_, _BinaryPredicate __pred) {
  return std::__1::__search_n<
      typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first, __last, __convert_to_integral(__count), __value_, __pred,
      typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count,
         const _Tp &__value_) {
  typedef typename iterator_traits<_ForwardIterator>::value_type __v;
  return std::__1::search_n(__first, __last, __convert_to_integral(__count),
                         __value_, __equal_to<__v, _Tp>());
}


template <class _Iter>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Iter __unwrap_iter(_Iter __i) {
  return __i;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type
    __unwrap_iter(move_iterator<_Tp *> __i) {
  return __i.base();
}



template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type
    __unwrap_iter(__wrap_iter<_Tp *> __i) {
  return __i.base();
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator __copy(
    _InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  for (; __first != __last; ++__first, (void)++__result)
    *__result = *__first;
  return __result;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value &&
                           is_trivially_copy_assignable<_Up>::value,
                       _Up *>::type
    __copy(_Tp *__first, _Tp *__last, _Up *__result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  if (__n > 0)
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
  return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last),
                       __unwrap_iter(__result));
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last,
                _OutputIterator __result) {
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value &&
                           is_trivially_copy_assignable<_Up>::value,
                       _Up *>::type
    __copy_backward(_Tp *__first, _Tp *__last, _Up *__result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  if (__n > 0) {
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
  }
  return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result) {
  return std::__1::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last),
                                __unwrap_iter(__result));
}



template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
        _Predicate __pred) {
  for (; __first != __last; ++__first) {
    if (__pred(*__first)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}



template <class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_input_iterator<_InputIterator>::value &&
                           !__is_random_access_iterator<_InputIterator>::value,
                       _OutputIterator>::type
    copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {
  typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  if (__n > 0) {
    *__result = *__first;
    ++__result;
    for (--__n; __n > 0; --__n) {
      ++__first;
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_random_access_iterator<_InputIterator>::value,
                       _OutputIterator>::type
    copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {
  typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  return std::__1::copy(__first, __first + __n, __result);
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator __move(
    _InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  for (; __first != __last; ++__first, (void)++__result)
    *__result = std::__1::move(*__first);
  return __result;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value &&
                           is_trivially_copy_assignable<_Up>::value,
                       _Up *>::type
    __move(_Tp *__first, _Tp *__last, _Up *__result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  if (__n > 0)
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
  return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last),
                       __unwrap_iter(__result));
}



template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator __move_backward(
    _InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  while (__first != __last)
    *--__result = std::__1::move(*--__last);
  return __result;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value &&
                           is_trivially_copy_assignable<_Up>::value,
                       _Up *>::type
    __move_backward(_Tp *__first, _Tp *__last, _Up *__result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  if (__n > 0) {
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
  }
  return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result) {
  return std::__1::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last),
                                __unwrap_iter(__result));
}







template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
transform(_InputIterator __first, _InputIterator __last,
          _OutputIterator __result, _UnaryOperation __op) {
  for (; __first != __last; ++__first, (void)++__result)
    *__result = __op(*__first);
  return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _BinaryOperation>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator transform(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _OutputIterator __result, _BinaryOperation __binary_op) {
  for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
    *__result = __binary_op(*__first1, *__first2);
  return __result;
}



template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
replace(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp &__old_value, const _Tp &__new_value) {
  for (; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}



template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
           const _Tp &__new_value) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      *__first = __new_value;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator replace_copy(
    _InputIterator __first, _InputIterator __last, _OutputIterator __result,
    const _Tp &__old_value, const _Tp &__new_value) {
  for (; __first != __last; ++__first, (void)++__result)
    if (*__first == __old_value)
      *__result = __new_value;
    else
      *__result = *__first;
  return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate,
          class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator replace_copy_if(
    _InputIterator __first, _InputIterator __last, _OutputIterator __result,
    _Predicate __pred, const _Tp &__new_value) {
  for (; __first != __last; ++__first, (void)++__result)
    if (__pred(*__first))
      *__result = __new_value;
    else
      *__result = *__first;
  return __result;
}



template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp &__value_) {
  for (; __n > 0; ++__first, (void)--__n)
    *__first = __value_;
  return __first;
}

template <class _Tp, class _Size, class _Up>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_integral<_Tp>::value && sizeof(_Tp) == 1 &&
                           !is_same<_Tp, bool>::value &&
                           is_integral<_Up>::value && sizeof(_Up) == 1,
                       _Tp *>::type
    __fill_n(_Tp *__first, _Size __n, _Up __value_) {
  if (__n > 0)
    std::__1::memset(__first, (unsigned char)__value_, (size_t)(__n));
  return __first + __n;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator fill_n(_OutputIterator __first,
                                                        _Size __n,
                                                        const _Tp &__value_) {
  return std::__1::__fill_n(__first, __convert_to_integral(__n), __value_);
}



template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_,
       forward_iterator_tag) {
  for (; __first != __last; ++__first)
    *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last,
       const _Tp &__value_, random_access_iterator_tag) {
  std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) {
  std::__1::__fill(
      __first, __last, __value_,
      typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Generator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen) {
  for (; __first != __last; ++__first)
    *__first = __gen();
}



template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen) {
  typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  for (; __n > 0; ++__first, (void)--__n)
    *__first = __gen();
  return __first;
}



template <class _ForwardIterator, class _Tp>
_ForwardIterator remove(_ForwardIterator __first, _ForwardIterator __last,
                        const _Tp &__value_) {
  __first = std::__1::find(__first, __last, __value_);
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (!(*__i == __value_)) {
        *__first = std::__1::move(*__i);
        ++__first;
      }
    }
  }
  return __first;
}



template <class _ForwardIterator, class _Predicate>
_ForwardIterator remove_if(_ForwardIterator __first, _ForwardIterator __last,
                           _Predicate __pred) {
  __first = std::__1::find_if<_ForwardIterator,
                           typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred);
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (!__pred(*__i)) {
        *__first = std::__1::move(*__i);
        ++__first;
      }
    }
  }
  return __first;
}



template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last,
            _OutputIterator __result, const _Tp &__value_) {
  for (; __first != __last; ++__first) {
    if (!(*__first == __value_)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}



template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last,
               _OutputIterator __result, _Predicate __pred) {
  for (; __first != __last; ++__first) {
    if (!__pred(*__first)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}



template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last,
                        _BinaryPredicate __pred) {
  __first = std::__1::adjacent_find<
      _ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first, __last, __pred);
  if (__first != __last) {


    _ForwardIterator __i = __first;
    for (++__i; ++__i != __last;)
      if (!__pred(*__first, *__i))
        *++__first = std::__1::move(*__i);
    ++__first;
  }
  return __first;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type __v;
  return std::__1::unique(__first, __last, __equal_to<__v>());
}



template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
_OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last,
                              _OutputIterator __result, _BinaryPredicate __pred,
                              input_iterator_tag, output_iterator_tag) {
  if (__first != __last) {
    typename iterator_traits<_InputIterator>::value_type __t(*__first);
    *__result = __t;
    ++__result;
    while (++__first != __last) {
      if (!__pred(__t, *__first)) {
        __t = *__first;
        *__result = __t;
        ++__result;
      }
    }
  }
  return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
_OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
                              _OutputIterator __result, _BinaryPredicate __pred,
                              forward_iterator_tag, output_iterator_tag) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    *__result = *__i;
    ++__result;
    while (++__first != __last) {
      if (!__pred(*__i, *__first)) {
        *__result = *__first;
        ++__result;
        __i = __first;
      }
    }
  }
  return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
_ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last,
                               _ForwardIterator __result,
                               _BinaryPredicate __pred, input_iterator_tag,
                               forward_iterator_tag) {
  if (__first != __last) {
    *__result = *__first;
    while (++__first != __last)
      if (!__pred(*__result, *__first))
        *++__result = *__first;
    ++__result;
  }
  return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last,
            _OutputIterator __result, _BinaryPredicate __pred) {
  return std::__1::__unique_copy<
      typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first, __last, __result, __pred,
      typename iterator_traits<_InputIterator>::iterator_category(),
      typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator unique_copy(
    _InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  typedef typename iterator_traits<_InputIterator>::value_type __v;
  return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}



template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void __reverse(_BidirectionalIterator __first,
                                                _BidirectionalIterator __last,
                                                bidirectional_iterator_tag) {
  while (__first != __last) {
    if (__first == --__last)
      break;
    std::__1::iter_swap(__first, __last);
    ++__first;
  }
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void __reverse(_RandomAccessIterator __first,
                                                _RandomAccessIterator __last,
                                                random_access_iterator_tag) {
  if (__first != __last)
    for (; __first < --__last; ++__first)
      std::__1::iter_swap(__first, __last);
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void reverse(_BidirectionalIterator __first,
                                              _BidirectionalIterator __last) {
  std::__1::__reverse(
      __first, __last,
      typename iterator_traits<_BidirectionalIterator>::iterator_category());
}



template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
             _OutputIterator __result) {
  for (; __first != __last; ++__result)
    *__result = *--__last;
  return __result;
}



template <class _ForwardIterator>
_ForwardIterator __rotate_left(_ForwardIterator __first,
                               _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
  value_type __tmp = std::__1::move(*__first);
  _ForwardIterator __lm1 = std::__1::move(std::__1::next(__first), __last, __first);
  *__lm1 = std::__1::move(__tmp);
  return __lm1;
}

template <class _BidirectionalIterator>
_BidirectionalIterator __rotate_right(_BidirectionalIterator __first,
                                      _BidirectionalIterator __last) {
  typedef
      typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  _BidirectionalIterator __lm1 = std::__1::prev(__last);
  value_type __tmp = std::__1::move(*__lm1);
  _BidirectionalIterator __fp1 = std::__1::move_backward(__first, __lm1, __last);
  *__first = std::__1::move(__tmp);
  return __fp1;
}

template <class _ForwardIterator>
_ForwardIterator __rotate_forward(_ForwardIterator __first,
                                  _ForwardIterator __middle,
                                  _ForwardIterator __last) {
  _ForwardIterator __i = __middle;
  while (true) {
    swap(*__first, *__i);
    ++__first;
    if (++__i == __last)
      break;
    if (__first == __middle)
      __middle = __i;
  }
  _ForwardIterator __r = __first;
  if (__first != __middle) {
    __i = __middle;
    while (true) {
      swap(*__first, *__i);
      ++__first;
      if (++__i == __last) {
        if (__first == __middle)
          break;
        __i = __middle;
      } else if (__first == __middle)
        __middle = __i;
    }
  }
  return __r;
}

template <typename _Integral>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Integral __algo_gcd(_Integral __x,
                                                      _Integral __y) {
  do {
    _Integral __t = __x % __y;
    __x = __y;
    __y = __t;
  } while (__y);
  return __x;
}

template <typename _RandomAccessIterator>
_RandomAccessIterator __rotate_gcd(_RandomAccessIterator __first,
                                   _RandomAccessIterator __middle,
                                   _RandomAccessIterator __last) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;

  const difference_type __m1 = __middle - __first;
  const difference_type __m2 = __last - __middle;
  if (__m1 == __m2) {
    std::__1::swap_ranges(__first, __middle, __middle);
    return __middle;
  }
  const difference_type __g = std::__1::__algo_gcd(__m1, __m2);
  for (_RandomAccessIterator __p = __first + __g; __p != __first;) {
    value_type __t(std::__1::move(*--__p));
    _RandomAccessIterator __p1 = __p;
    _RandomAccessIterator __p2 = __p1 + __m1;
    do {
      *__p1 = std::__1::move(*__p2);
      __p1 = __p2;
      const difference_type __d = __last - __p2;
      if (__m1 < __d)
        __p2 += __m1;
      else
        __p2 = __first + (__m1 - __d);
    } while (__p2 != __p);
    *__p1 = std::__1::move(__t);
  }
  return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle,
         _ForwardIterator __last, std::__1::forward_iterator_tag) {
  typedef
      typename std::__1::iterator_traits<_ForwardIterator>::value_type value_type;
  if (std::__1::is_trivially_move_assignable<value_type>::value) {
    if (std::__1::next(__first) == __middle)
      return std::__1::__rotate_left(__first, __last);
  }
  return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle,
         _BidirectionalIterator __last, std::__1::bidirectional_iterator_tag) {
  typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type
      value_type;
  if (std::__1::is_trivially_move_assignable<value_type>::value) {
    if (std::__1::next(__first) == __middle)
      return std::__1::__rotate_left(__first, __last);
    if (std::__1::next(__middle) == __last)
      return std::__1::__rotate_right(__first, __last);
  }
  return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle,
         _RandomAccessIterator __last, std::__1::random_access_iterator_tag) {
  typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type
      value_type;
  if (std::__1::is_trivially_move_assignable<value_type>::value) {
    if (std::__1::next(__first) == __middle)
      return std::__1::__rotate_left(__first, __last);
    if (std::__1::next(__middle) == __last)
      return std::__1::__rotate_right(__first, __last);
    return std::__1::__rotate_gcd(__first, __middle, __last);
  }
  return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle,
       _ForwardIterator __last) {
  if (__first == __middle)
    return __last;
  if (__middle == __last)
    return __first;
  return std::__1::__rotate(
      __first, __middle, __last,
      typename std::__1::iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
            _ForwardIterator __last, _OutputIterator __result) {
  return std::__1::copy(__first, __middle,
                     std::__1::copy(__middle, __last, __result));
}



template <class _ForwardIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last,
            _Compare __comp) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last)
      if (__comp(*__i, *__first))
        __first = __i;
  }
  return __first;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::__1::min_element(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const _Tp &
min(const _Tp &__a, const _Tp &__b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const _Tp &
min(const _Tp &__a, const _Tp &__b) {
  return std::__1::min(__a, __b, __less<_Tp>());
}



template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
min(initializer_list<_Tp> __t, _Compare __comp) {
  return *std::__1::min_element(__t.begin(), __t.end(), __comp);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
min(initializer_list<_Tp> __t) {
  return *std::__1::min_element(__t.begin(), __t.end(), __less<_Tp>());
}





template <class _ForwardIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last,
            _Compare __comp) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last)
      if (__comp(*__first, *__i))
        __first = __i;
  }
  return __first;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::__1::max_element(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const _Tp &
max(const _Tp &__a, const _Tp &__b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const _Tp &
max(const _Tp &__a, const _Tp &__b) {
  return std::__1::max(__a, __b, __less<_Tp>());
}



template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
max(initializer_list<_Tp> __t, _Compare __comp) {
  return *std::__1::max_element(__t.begin(), __t.end(), __comp);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
max(initializer_list<_Tp> __t) {
  return *std::__1::max_element(__t.begin(), __t.end(), __less<_Tp>());
}
template <class _ForwardIterator, class _Compare>
                              std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last,
               _Compare __comp) {
  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last) {
    if (++__first != __last) {
      if (__comp(*__first, *__result.first))
        __result.first = __first;
      else
        __result.second = __first;
      while (++__first != __last) {
        _ForwardIterator __i = __first;
        if (++__first == __last) {
          if (__comp(*__i, *__result.first))
            __result.first = __i;
          else if (!__comp(*__i, *__result.second))
            __result.second = __i;
          break;
        } else {
          if (__comp(*__first, *__i)) {
            if (__comp(*__first, *__result.first))
              __result.first = __first;
            if (!__comp(*__i, *__result.second))
              __result.second = __i;
          } else {
            if (__comp(*__i, *__result.first))
              __result.first = __i;
            if (!__comp(*__first, *__result.second))
              __result.second = __first;
          }
        }
      }
    }
  }
  return __result;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  std::pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::__1::minmax_element(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  pair<const _Tp &, const _Tp &>
    minmax(const _Tp &__a, const _Tp &__b, _Compare __comp) {
  return __comp(__b, __a) ? pair<const _Tp &, const _Tp &>(__b, __a)
                          : pair<const _Tp &, const _Tp &>(__a, __b);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  pair<const _Tp &, const _Tp &>
    minmax(const _Tp &__a, const _Tp &__b) {
  return std::__1::minmax(__a, __b, __less<_Tp>());
}



template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t, _Compare __comp) {
  typedef typename initializer_list<_Tp>::const_iterator _Iter;
  _Iter __first = __t.begin();
  _Iter __last = __t.end();
  std::pair<_Tp, _Tp> __result(*__first, *__first);

  ++__first;
  if (__t.size() % 2 == 0) {
    if (__comp(*__first, __result.first))
      __result.first = *__first;
    else
      __result.second = *__first;
    ++__first;
  }

  while (__first != __last) {
    _Tp __prev = *__first++;
    if (__comp(*__first, __prev)) {
      if (__comp(*__first, __result.first))
        __result.first = *__first;
      if (!__comp(__prev, __result.second))
        __result.second = __prev;
    } else {
      if (__comp(__prev, __result.first))
        __result.first = __prev;
      if (!__comp(*__first, __result.second))
        __result.second = *__first;
    }

    __first++;
  }
  return __result;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t) {
  return std::__1::minmax(__t, __less<_Tp>());
}







template <unsigned long long _Xp, size_t _Rp> struct __log2_imp {
  static const size_t value = _Xp & ((unsigned long long)(1) << _Rp)
                                  ? _Rp
                                  : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp> struct __log2_imp<_Xp, 0> {
  static const size_t value = 0;
};

template <size_t _Rp> struct __log2_imp<0, _Rp> {
  static const size_t value = _Rp + 1;
};

template <class _UI, _UI _Xp> struct __log2_ {
  static const size_t value =
      __log2_imp<_Xp, sizeof(_UI) * 8 - 1>::value;
};

template <class _Engine, class _UIntType> class __independent_bits_engine {
public:

  typedef _UIntType result_type;

private:
  typedef typename _Engine::result_type _Engine_result_type;
  typedef
      typename conditional<sizeof(_Engine_result_type) <= sizeof(result_type),
                           result_type, _Engine_result_type>::type
          _Working_result_type;

  _Engine &__e_;
  size_t __w_;
  size_t __w0_;
  size_t __n_;
  size_t __n0_;
  _Working_result_type __y0_;
  _Working_result_type __y1_;
  _Engine_result_type __mask0_;
  _Engine_result_type __mask1_;





  static constexpr const _Working_result_type _Rp =
      _Engine::max() - _Engine::min() + _Working_result_type(1);

  static constexpr const size_t __m =
      __log2_<_Working_result_type, _Rp>::value;
  static constexpr const size_t _WDt =
      numeric_limits<_Working_result_type>::digits;
  static constexpr const size_t _EDt =
      numeric_limits<_Engine_result_type>::digits;

public:

  __independent_bits_engine(_Engine &__e, size_t __w);


  result_type operator()() {
    return __eval(integral_constant<bool, _Rp != 0>());
  }

private:
  result_type __eval(false_type);
  result_type __eval(true_type);
};

template <class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>::__independent_bits_engine(
    _Engine &__e, size_t __w)
    : __e_(__e), __w_(__w) {
  __n_ = __w_ / __m + (__w_ % __m != 0);
  __w0_ = __w_ / __n_;
  if (_Rp == 0)
    __y0_ = _Rp;
  else if (__w0_ < _WDt)
    __y0_ = (_Rp >> __w0_) << __w0_;
  else
    __y0_ = 0;
  if (_Rp - __y0_ > __y0_ / __n_) {
    ++__n_;
    __w0_ = __w_ / __n_;
    if (__w0_ < _WDt)
      __y0_ = (_Rp >> __w0_) << __w0_;
    else
      __y0_ = 0;
  }
  __n0_ = __n_ - __w_ % __n_;
  if (__w0_ < _WDt - 1)
    __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
  else
    __y1_ = 0;
  __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_)
                       : _Engine_result_type(0);
  __mask1_ = __w0_ < _EDt - 1 ? _Engine_result_type(~0) >> (_EDt - (__w0_ + 1))
                              : _Engine_result_type(~0);
}

template <class _Engine, class _UIntType>
inline _UIntType
    __independent_bits_engine<_Engine, _UIntType>::__eval(false_type) {
  return static_cast<result_type>(__e_() & __mask0_);
}

template <class _Engine, class _UIntType>
_UIntType __independent_bits_engine<_Engine, _UIntType>::__eval(true_type) {
  result_type _Sp = 0;
  for (size_t __k = 0; __k < __n0_; ++__k) {
    _Engine_result_type __u;
    do {
      __u = __e_() - _Engine::min();
    } while (__u >= __y0_);
    if (__w0_ < _WDt)
      _Sp <<= __w0_;
    else
      _Sp = 0;
    _Sp += __u & __mask0_;
  }
  for (size_t __k = __n0_; __k < __n_; ++__k) {
    _Engine_result_type __u;
    do {
      __u = __e_() - _Engine::min();
    } while (__u >= __y1_);
    if (__w0_ < _WDt - 1)
      _Sp <<= __w0_ + 1;
    else
      _Sp = 0;
    _Sp += __u & __mask1_;
  }
  return _Sp;
}



template <class _IntType = int> class uniform_int_distribution {
public:

  typedef _IntType result_type;

  class param_type {
    result_type __a_;
    result_type __b_;

  public:
    typedef uniform_int_distribution distribution_type;

    explicit param_type(result_type __a = 0,
                        result_type __b = numeric_limits<result_type>::max())
        : __a_(__a), __b_(__b) {}

    result_type a() const { return __a_; }
    result_type b() const { return __b_; }

    friend bool operator==(const param_type &__x, const param_type &__y) {
      return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;
    }
    friend bool operator!=(const param_type &__x, const param_type &__y) {
      return !(__x == __y);
    }
  };

private:
  param_type __p_;

public:

  explicit uniform_int_distribution(
      result_type __a = 0, result_type __b = numeric_limits<result_type>::max())
      : __p_(param_type(__a, __b)) {}
  explicit uniform_int_distribution(const param_type &__p) : __p_(__p) {}
  void reset() {}


  template <class _URNG> result_type operator()(_URNG &__g) {
    return (*this)(__g, __p_);
  }
  template <class _URNG>
  result_type operator()(_URNG &__g, const param_type &__p);


  result_type a() const { return __p_.a(); }
  result_type b() const { return __p_.b(); }

  param_type param() const { return __p_; }
  void param(const param_type &__p) { __p_ = __p; }

  result_type min() const { return a(); }
  result_type max() const { return b(); }

  friend bool operator==(const uniform_int_distribution &__x,
                         const uniform_int_distribution &__y) {
    return __x.__p_ == __y.__p_;
  }
  friend bool operator!=(const uniform_int_distribution &__x,
                         const uniform_int_distribution &__y) {
    return !(__x == __y);
  }
};

template <class _IntType>
template <class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG &__g,
                                               const param_type &__p) {
  typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                               uint32_t, uint64_t>::type _UIntType;
  const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);
  if (_Rp == 1)
    return __p.a();
  const size_t _Dt = numeric_limits<_UIntType>::digits;
  typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
  if (_Rp == 0)
    return static_cast<result_type>(_Eng(__g, _Dt)());
  size_t __w = _Dt - __clz(_Rp) - 1;
  if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
    ++__w;
  _Eng __e(__g, __w);
  _UIntType __u;
  do {
    __u = __e();
  } while (__u >= _Rp);
  return static_cast<result_type>(__u + __p.a());
}

class __attribute__((__visibility__("default"))) __rs_default;

__attribute__((__visibility__("default"))) __rs_default __rs_get();

class __attribute__((__visibility__("default"))) __rs_default {
  static unsigned __c_;

  __rs_default();

public:
  typedef uint_fast32_t result_type;

  static const result_type _Min = 0;
  static const result_type _Max = 0xFFFFFFFF;

  __rs_default(const __rs_default &);
  ~__rs_default();

  result_type operator()();

  static constexpr result_type min() { return _Min; }
  static constexpr result_type max() { return _Max; }

  friend __attribute__((__visibility__("default"))) __rs_default __rs_get();
};

__attribute__((__visibility__("default"))) __rs_default __rs_get();

template <class _RandomAccessIterator>
void random_shuffle(_RandomAccessIterator __first,
                    _RandomAccessIterator __last) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef uniform_int_distribution<ptrdiff_t> _Dp;
  typedef typename _Dp::param_type _Pp;
  difference_type __d = __last - __first;
  if (__d > 1) {
    _Dp __uid;
    __rs_default __g = __rs_get();
    for (--__last, --__d; __first < __last; ++__first, --__d) {
      difference_type __i = __uid(__g, _Pp(0, __d));
      if (__i != difference_type(0))
        swap(*__first, *(__first + __i));
    }
  }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
void random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

                    _RandomNumberGenerator &&__rand)



{
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  difference_type __d = __last - __first;
  if (__d > 1) {
    for (--__last; __first < __last; ++__first, --__d) {
      difference_type __i = __rand(__d);
      swap(*__first, *(__first + __i));
    }
  }
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"), __always_inline__)) _SampleIterator
__sample(_PopulationIterator __first, _PopulationIterator __last,
         _SampleIterator __out, _Distance __n,
         _UniformRandomNumberGenerator &__g, input_iterator_tag) {

  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void)++__k)
    __out[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void)++__k) {
    _Distance __r = std::__1::uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __out[__r] = *__first;
  }
  return __out + std::__1::min(__n, __k);
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"), __always_inline__)) _SampleIterator
__sample(_PopulationIterator __first, _PopulationIterator __last,
         _SampleIterator __out, _Distance __n,
         _UniformRandomNumberGenerator &__g, forward_iterator_tag) {
  _Distance __unsampled_sz = std::__1::distance(__first, __last);
  for (__n = std::__1::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r =
        std::__1::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__out++ = *__first;
      --__n;
    }
  }
  return __out;
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"), __always_inline__)) _SampleIterator __sample(
    _PopulationIterator __first, _PopulationIterator __last,
    _SampleIterator __out, _Distance __n, _UniformRandomNumberGenerator &__g) {
  typedef typename iterator_traits<_PopulationIterator>::iterator_category
      _PopCategory;
  typedef typename iterator_traits<_PopulationIterator>::difference_type
      _Difference;
  static_assert(
      __is_forward_iterator<_PopulationIterator>::value ||
          __is_random_access_iterator<_SampleIterator>::value,
      "SampleIterator must meet the requirements of RandomAccessIterator");
  typedef typename common_type<_Distance, _Difference>::type _CommonType;
  ((void)0);
  return std::__1::__sample(__first, __last, __out, _CommonType(__n), __g,
                         _PopCategory());
}
template <class _RandomAccessIterator, class _UniformRandomNumberGenerator>
void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

             _UniformRandomNumberGenerator &&__g)



{
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef uniform_int_distribution<ptrdiff_t> _Dp;
  typedef typename _Dp::param_type _Pp;
  difference_type __d = __last - __first;
  if (__d > 1) {
    _Dp __uid;
    for (--__last, --__d; __first < __last; ++__first, --__d) {
      difference_type __i = __uid(__g, _Pp(0, __d));
      if (__i != difference_type(0))
        swap(*__first, *(__first + __i));
    }
  }
}

template <class _InputIterator, class _Predicate>
bool is_partitioned(_InputIterator __first, _InputIterator __last,
                    _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      break;
  if (__first == __last)
    return true;
  ++__first;
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return false;
  return true;
}



template <class _Predicate, class _ForwardIterator>
_ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last,
                             _Predicate __pred, forward_iterator_tag) {
  while (true) {
    if (__first == __last)
      return __first;
    if (!__pred(*__first))
      break;
    ++__first;
  }
  for (_ForwardIterator __p = __first; ++__p != __last;) {
    if (__pred(*__p)) {
      swap(*__first, *__p);
      ++__first;
    }
  }
  return __first;
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
            _Predicate __pred, bidirectional_iterator_tag) {
  while (true) {
    while (true) {
      if (__first == __last)
        return __first;
      if (!__pred(*__first))
        break;
      ++__first;
    }
    do {
      if (__first == --__last)
        return __first;
    } while (!__pred(*__last));
    swap(*__first, *__last);
    ++__first;
  }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator partition(
    _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred,
      typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _InputIterator, class _OutputIterator1, class _OutputIterator2,
          class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred) {
  for (; __first != __last; ++__first) {
    if (__pred(*__first)) {
      *__out_true = *__first;
      ++__out_true;
    } else {
      *__out_false = *__first;
      ++__out_false;
    }
  }
  return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}



template <class _ForwardIterator, class _Predicate>
_ForwardIterator partition_point(_ForwardIterator __first,
                                 _ForwardIterator __last, _Predicate __pred) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  difference_type __len = std::__1::distance(__first, __last);
  while (__len != 0) {
    difference_type __l2 = __len / 2;
    _ForwardIterator __m = __first;
    std::__1::advance(__m, __l2);
    if (__pred(*__m)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else
      __len = __l2;
  }
  return __first;
}



template <class _Predicate, class _ForwardIterator, class _Distance,
          class _Pair>
_ForwardIterator __stable_partition(_ForwardIterator __first,
                                    _ForwardIterator __last, _Predicate __pred,
                                    _Distance __len, _Pair __p,
                                    forward_iterator_tag __fit) {


  if (__len == 1)
    return __first;
  if (__len == 2) {
    _ForwardIterator __m = __first;
    if (__pred(*++__m)) {
      swap(*__first, *__m);
      return __m;
    }
    return __first;
  }
  if (__len <= __p.second) {
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h(__p.first, __d);



    value_type *__t = __p.first;
    ::new (__t) value_type(std::__1::move(*__first));
    __d.__incr((value_type *)0);
    ++__t;
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (__pred(*__i)) {
        *__first = std::__1::move(*__i);
        ++__first;
      } else {
        ::new (__t) value_type(std::__1::move(*__i));
        __d.__incr((value_type *)0);
        ++__t;
      }
    }



    __i = __first;
    for (value_type *__t2 = __p.first; __t2 < __t; ++__t2, ++__i)
      *__i = std::__1::move(*__t2);


    return __first;
  }


  _ForwardIterator __m = __first;
  _Distance __len2 = __len / 2;
  std::__1::advance(__m, __len2);



  typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
  _ForwardIterator __first_false =
      __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);




  _ForwardIterator __m1 = __m;
  _ForwardIterator __second_false = __last;
  _Distance __len_half = __len - __len2;
  while (__pred(*__m1)) {
    if (++__m1 == __last)
      goto __second_half_done;
    --__len_half;
  }


  __second_false = __stable_partition<_PredRef>(__m1, __last, __pred,
                                                __len_half, __p, __fit);
__second_half_done:


  return std::__1::rotate(__first_false, __m, __second_false);


}

struct __return_temporary_buffer {
  template <class _Tp>
  __attribute__((__visibility__("hidden"), __always_inline__)) void operator()(_Tp *__p) const {
    std::__1::return_temporary_buffer(__p);
  }
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator __stable_partition(_ForwardIterator __first,
                                    _ForwardIterator __last, _Predicate __pred,
                                    forward_iterator_tag) {
  const unsigned __alloc_limit =
      3;

  while (true) {
    if (__first == __last)
      return __first;
    if (!__pred(*__first))
      break;
    ++__first;
  }


  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
  difference_type __len = std::__1::distance(__first, __last);
  pair<value_type *, ptrdiff_t> __p(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len >= __alloc_limit) {
    __p = std::__1::get_temporary_buffer<value_type>(__len);
    __h.reset(__p.first);
  }
  return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance,
          class _Pair>
_BidirectionalIterator __stable_partition(_BidirectionalIterator __first,
                                          _BidirectionalIterator __last,
                                          _Predicate __pred, _Distance __len,
                                          _Pair __p,
                                          bidirectional_iterator_tag __bit) {



  if (__len == 2) {
    swap(*__first, *__last);
    return __last;
  }
  if (__len == 3) {
    _BidirectionalIterator __m = __first;
    if (__pred(*++__m)) {
      swap(*__first, *__m);
      swap(*__m, *__last);
      return __last;
    }
    swap(*__m, *__last);
    swap(*__first, *__m);
    return __m;
  }
  if (__len <= __p.second) {
    typedef
        typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h(__p.first, __d);



    value_type *__t = __p.first;
    ::new (__t) value_type(std::__1::move(*__first));
    __d.__incr((value_type *)0);
    ++__t;
    _BidirectionalIterator __i = __first;
    while (++__i != __last) {
      if (__pred(*__i)) {
        *__first = std::__1::move(*__i);
        ++__first;
      } else {
        ::new (__t) value_type(std::__1::move(*__i));
        __d.__incr((value_type *)0);
        ++__t;
      }
    }

    *__first = std::__1::move(*__i);
    __i = ++__first;



    for (value_type *__t2 = __p.first; __t2 < __t; ++__t2, ++__i)
      *__i = std::__1::move(*__t2);


    return __first;
  }


  _BidirectionalIterator __m = __first;
  _Distance __len2 = __len / 2;
  std::__1::advance(__m, __len2);




  _BidirectionalIterator __m1 = __m;
  _BidirectionalIterator __first_false = __first;
  _Distance __len_half = __len2;
  while (!__pred(*--__m1)) {
    if (__m1 == __first)
      goto __first_half_done;
    --__len_half;
  }


  typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
  __first_false = __stable_partition<_PredRef>(__first, __m1, __pred,
                                               __len_half, __p, __bit);
__first_half_done:




  __m1 = __m;
  _BidirectionalIterator __second_false = __last;
  ++__second_false;
  __len_half = __len - __len2;
  while (__pred(*__m1)) {
    if (++__m1 == __last)
      goto __second_half_done;
    --__len_half;
  }


  __second_false = __stable_partition<_PredRef>(__m1, __last, __pred,
                                                __len_half, __p, __bit);
__second_half_done:


  return std::__1::rotate(__first_false, __m, __second_false);


}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator __stable_partition(_BidirectionalIterator __first,
                                          _BidirectionalIterator __last,
                                          _Predicate __pred,
                                          bidirectional_iterator_tag) {
  typedef typename iterator_traits<_BidirectionalIterator>::difference_type
      difference_type;
  typedef
      typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  const difference_type __alloc_limit =
      4;

  while (true) {
    if (__first == __last)
      return __first;
    if (!__pred(*__first))
      break;
    ++__first;
  }



  do {
    if (__first == --__last)
      return __first;
  } while (!__pred(*__last));




  difference_type __len = std::__1::distance(__first, __last) + 1;
  pair<value_type *, ptrdiff_t> __p(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len >= __alloc_limit) {
    __p = std::__1::get_temporary_buffer<value_type>(__len);
    __h.reset(__p.first);
  }
  return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator stable_partition(
    _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred) {
  return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred,
      typename iterator_traits<_ForwardIterator>::iterator_category());
}



template <class _ForwardIterator, class _Compare>
_ForwardIterator is_sorted_until(_ForwardIterator __first,
                                 _ForwardIterator __last, _Compare __comp) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (__comp(*__i, *__first))
        return __i;
      __first = __i;
    }
  }
  return __last;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last) {
  return std::__1::is_sorted_until(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _ForwardIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool is_sorted(_ForwardIterator __first,
                                                _ForwardIterator __last) {
  return std::__1::is_sorted(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}





template <class _Compare, class _ForwardIterator>
unsigned __sort3(_ForwardIterator __x, _ForwardIterator __y,
                 _ForwardIterator __z, _Compare __c) {
  unsigned __r = 0;
  if (!__c(*__y, *__x))
  {
    if (!__c(*__z, *__y))
      return __r;

    swap(*__y, *__z);
    __r = 1;
    if (__c(*__y, *__x))
    {
      swap(*__x, *__y);
      __r = 2;
    }
    return __r;
  }
  if (__c(*__z, *__y))
  {
    swap(*__x, *__z);
    __r = 1;
    return __r;
  }
  swap(*__x, *__y);
  __r = 1;
  if (__c(*__z, *__y))
  {
    swap(*__y, *__z);
    __r = 2;
  }
  return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned __sort4(_ForwardIterator __x1, _ForwardIterator __x2,
                 _ForwardIterator __x3, _ForwardIterator __x4, _Compare __c) {
  unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
  if (__c(*__x4, *__x3)) {
    swap(*__x3, *__x4);
    ++__r;
    if (__c(*__x3, *__x2)) {
      swap(*__x2, *__x3);
      ++__r;
      if (__c(*__x2, *__x1)) {
        swap(*__x1, *__x2);
        ++__r;
      }
    }
  }
  return __r;
}



template <class _Compare, class _ForwardIterator>
unsigned __sort5(_ForwardIterator __x1, _ForwardIterator __x2,
                 _ForwardIterator __x3, _ForwardIterator __x4,
                 _ForwardIterator __x5, _Compare __c) {
  unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
  if (__c(*__x5, *__x4)) {
    swap(*__x4, *__x5);
    ++__r;
    if (__c(*__x4, *__x3)) {
      swap(*__x3, *__x4);
      ++__r;
      if (__c(*__x3, *__x2)) {
        swap(*__x2, *__x3);
        ++__r;
        if (__c(*__x2, *__x1)) {
          swap(*__x1, *__x2);
          ++__r;
        }
      }
    }
  }
  return __r;
}


template <class _Compare, class _BirdirectionalIterator>
void __selection_sort(_BirdirectionalIterator __first,
                      _BirdirectionalIterator __last, _Compare __comp) {
  _BirdirectionalIterator __lm1 = __last;
  for (--__lm1; __first != __lm1; ++__first) {
    _BirdirectionalIterator __i =
        std::__1::min_element<_BirdirectionalIterator,
                           typename add_lvalue_reference<_Compare>::type>(
            __first, __last, __comp);
    if (__i != __first)
      swap(*__first, *__i);
  }
}

template <class _Compare, class _BirdirectionalIterator>
void __insertion_sort(_BirdirectionalIterator __first,
                      _BirdirectionalIterator __last, _Compare __comp) {
  typedef
      typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
  if (__first != __last) {
    _BirdirectionalIterator __i = __first;
    for (++__i; __i != __last; ++__i) {
      _BirdirectionalIterator __j = __i;
      value_type __t(std::__1::move(*__j));
      for (_BirdirectionalIterator __k = __i;
           __k != __first && __comp(__t, *--__k); --__j)
        *__j = std::__1::move(*__k);
      *__j = std::__1::move(__t);
    }
  }
}

template <class _Compare, class _RandomAccessIterator>
void __insertion_sort_3(_RandomAccessIterator __first,
                        _RandomAccessIterator __last, _Compare __comp) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  _RandomAccessIterator __j = __first + 2;
  __sort3<_Compare>(__first, __first + 1, __j, __comp);
  for (_RandomAccessIterator __i = __j + 1; __i != __last; ++__i) {
    if (__comp(*__i, *__j)) {
      value_type __t(std::__1::move(*__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = std::__1::move(*__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::__1::move(__t);
    }
    __j = __i;
  }
}

template <class _Compare, class _RandomAccessIterator>
bool __insertion_sort_incomplete(_RandomAccessIterator __first,
                                 _RandomAccessIterator __last,
                                 _Compare __comp) {
  switch (__last - __first) {
  case 0:
  case 1:
    return true;
  case 2:
    if (__comp(*--__last, *__first))
      swap(*__first, *__last);
    return true;
  case 3:
    std::__1::__sort3<_Compare>(__first, __first + 1, --__last, __comp);
    return true;
  case 4:
    std::__1::__sort4<_Compare>(__first, __first + 1, __first + 2, --__last,
                             __comp);
    return true;
  case 5:
    std::__1::__sort5<_Compare>(__first, __first + 1, __first + 2, __first + 3,
                             --__last, __comp);
    return true;
  }
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  _RandomAccessIterator __j = __first + 2;
  __sort3<_Compare>(__first, __first + 1, __j, __comp);
  const unsigned __limit = 8;
  unsigned __count = 0;
  for (_RandomAccessIterator __i = __j + 1; __i != __last; ++__i) {
    if (__comp(*__i, *__j)) {
      value_type __t(std::__1::move(*__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = std::__1::move(*__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::__1::move(__t);
      if (++__count == __limit)
        return ++__i == __last;
    }
    __j = __i;
  }
  return true;
}

template <class _Compare, class _BirdirectionalIterator>
void __insertion_sort_move(
    _BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
    typename iterator_traits<_BirdirectionalIterator>::value_type *__first2,
    _Compare __comp) {
  typedef
      typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
  if (__first1 != __last1) {
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h(__first2, __d);
    value_type *__last2 = __first2;
    ::new (__last2) value_type(std::__1::move(*__first1));
    __d.__incr((value_type *)0);
    for (++__last2; ++__first1 != __last1; ++__last2) {
      value_type *__j2 = __last2;
      value_type *__i2 = __j2;
      if (__comp(*__first1, *--__i2)) {
        ::new (__j2) value_type(std::__1::move(*__i2));
        __d.__incr((value_type *)0);
        for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
          *__j2 = std::__1::move(*__i2);
        *__j2 = std::__1::move(*__first1);
      } else {
        ::new (__j2) value_type(std::__1::move(*__first1));
        __d.__incr((value_type *)0);
      }
    }
    __h.release();
  }
}

template <class _Compare, class _RandomAccessIterator>
void __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
            _Compare __comp) {

  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  const difference_type __limit =
      is_trivially_copy_constructible<value_type>::value &&
              is_trivially_copy_assignable<value_type>::value
          ? 30
          : 6;
  while (true) {
  __restart:
    difference_type __len = __last - __first;
    switch (__len) {
    case 0:
    case 1:
      return;
    case 2:
      if (__comp(*--__last, *__first))
        swap(*__first, *__last);
      return;
    case 3:
      std::__1::__sort3<_Compare>(__first, __first + 1, --__last, __comp);
      return;
    case 4:
      std::__1::__sort4<_Compare>(__first, __first + 1, __first + 2, --__last,
                               __comp);
      return;
    case 5:
      std::__1::__sort5<_Compare>(__first, __first + 1, __first + 2, __first + 3,
                               --__last, __comp);
      return;
    }
    if (__len <= __limit) {
      std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
      return;
    }

    _RandomAccessIterator __m = __first;
    _RandomAccessIterator __lm1 = __last;
    --__lm1;
    unsigned __n_swaps;
    {
      difference_type __delta;
      if (__len >= 1000) {
        __delta = __len / 2;
        __m += __delta;
        __delta /= 2;
        __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m,
                                             __m + __delta, __lm1, __comp);
      } else {
        __delta = __len / 2;
        __m += __delta;
        __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
      }
    }



    _RandomAccessIterator __i = __first;
    _RandomAccessIterator __j = __lm1;




    if (!__comp(*__i, *__m))
    {


      while (true) {
        if (__i == --__j) {



          ++__i;
          __j = __last;
          if (!__comp(*__first,
                      *--__j))
          {
            while (true) {
              if (__i == __j)
                return;
              if (__comp(*__first, *__i)) {
                swap(*__i, *__j);
                ++__n_swaps;
                ++__i;
                break;
              }
              ++__i;
            }
          }


          if (__i == __j)
            return;
          while (true) {
            while (!__comp(*__first, *__i))
              ++__i;
            while (__comp(*__first, *--__j))
              ;
            if (__i >= __j)
              break;
            swap(*__i, *__j);
            ++__n_swaps;
            ++__i;
          }



          __first = __i;
          goto __restart;
        }
        if (__comp(*__j, *__m)) {
          swap(*__i, *__j);
          ++__n_swaps;
          break;

        }
      }
    }

    ++__i;


    if (__i < __j) {


      while (true) {

        while (__comp(*__i, *__m))
          ++__i;

        while (!__comp(*--__j, *__m))
          ;
        if (__i > __j)
          break;
        swap(*__i, *__j);
        ++__n_swaps;


        if (__m == __i)
          __m = __j;
        ++__i;
      }
    }

    if (__i != __m && __comp(*__m, *__i)) {
      swap(*__i, *__m);
      ++__n_swaps;
    }


    if (__n_swaps == 0) {
      bool __fs =
          std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
      if (std::__1::__insertion_sort_incomplete<_Compare>(__i + 1, __last,
                                                       __comp)) {
        if (__fs)
          return;
        __last = __i;
        continue;
      } else {
        if (__fs) {
          __first = ++__i;
          continue;
        }
      }
    }


    if (__i - __first < __last - __i) {
      std::__1::__sort<_Compare>(__first, __i, __comp);

      __first = ++__i;
    } else {
      std::__1::__sort<_Compare>(__i + 1, __last, __comp);

      __last = __i;
    }
  }
}



template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void sort(_RandomAccessIterator __first,
                                           _RandomAccessIterator __last,
                                           _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  __sort<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void sort(_RandomAccessIterator __first,
                                           _RandomAccessIterator __last) {
  std::__1::sort(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void sort(_Tp **__first, _Tp **__last) {
  std::__1::sort((size_t *)__first, (size_t *)__last, __less<size_t>());
}

template <class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void sort(__wrap_iter<_Tp *> __first,
                                           __wrap_iter<_Tp *> __last) {
  std::__1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
sort(__wrap_iter<_Tp *> __first, __wrap_iter<_Tp *> __last, _Compare __comp) {
  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  std::__1::sort<_Tp *, _Comp_ref>(__first.base(), __last.base(), __comp);
}





extern template __attribute__((__visibility__("default"))) void __sort<__less<char> &, char *>( char *, char *, __less<char> &);

extern template __attribute__((__visibility__("default"))) void __sort<__less<wchar_t> &, wchar_t *>( wchar_t *, wchar_t *, __less<wchar_t> &);


extern template __attribute__((__visibility__("default"))) void __sort<__less<signed char> &, signed char *>( signed char *, signed char *, __less<signed char> &);


extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned char> &, unsigned char *>( unsigned char *, unsigned char *, __less<unsigned char> &);


extern template __attribute__((__visibility__("default"))) void __sort<__less<short> &, short *>( short *, short *, __less<short> &);

extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned short> &, unsigned short *>( unsigned short *, unsigned short *, __less<unsigned short> &);


extern template __attribute__((__visibility__("default"))) void __sort<__less<int> &, int *>( int *, int *, __less<int> &);

extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned> &, unsigned *>( unsigned *, unsigned *, __less<unsigned> &);


extern template __attribute__((__visibility__("default"))) void __sort<__less<long> &, long *>( long *, long *, __less<long> &);

extern template __attribute__((__visibility__("default"))) void __sort<__less<unsigned long> &, unsigned long *>( unsigned long *, unsigned long *, __less<unsigned long> &);


extern template __attribute__((__visibility__("default"))) void __sort<__less<long long> &, long long *>( long long *, long long *, __less<long long> &);


extern template __attribute__((__visibility__("default"))) void __sort< __less<unsigned long long> &, unsigned long long *>( unsigned long long *, unsigned long long *, __less<unsigned long long> &);


extern template __attribute__((__visibility__("default"))) void __sort<__less<float> &, float *>( float *, float *, __less<float> &);

extern template __attribute__((__visibility__("default"))) void __sort<__less<double> &, double *>(double *, double *, __less<double> &);


extern template __attribute__((__visibility__("default"))) void __sort<__less<long double> &, long double *>( long double *, long double *, __less<long double> &);



extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<char> &, char *>( char *, char *, __less<char> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<wchar_t> &, wchar_t *>(wchar_t *, wchar_t *, __less<wchar_t> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<signed char> &, signed char *>( signed char *, signed char *, __less<signed char> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<unsigned char> &, unsigned char *>( unsigned char *, unsigned char *, __less<unsigned char> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<short> &, short *>( short *, short *, __less<short> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<unsigned short> &, unsigned short *>( unsigned short *, unsigned short *, __less<unsigned short> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<int> &, int *>( int *, int *, __less<int> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<unsigned> &, unsigned *>(unsigned *, unsigned *, __less<unsigned> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<long> &, long *>( long *, long *, __less<long> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<unsigned long> &, unsigned long *>( unsigned long *, unsigned long *, __less<unsigned long> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<long long> &, long long *>(long long *, long long *, __less<long long> &);



extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<unsigned long long> &, unsigned long long *>( unsigned long long *, unsigned long long *, __less<unsigned long long> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete<__less<float> &, float *>( float *, float *, __less<float> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<double> &, double *>(double *, double *, __less<double> &);


extern template __attribute__((__visibility__("default"))) bool __insertion_sort_incomplete< __less<long double> &, long double *>( long double *, long double *, __less<long double> &);



extern template __attribute__((__visibility__("default"))) unsigned __sort5<__less<long double> &, long double *>( long double *, long double *, long double *, long double *, long double *, __less<long double> &);
template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator __lower_bound(_ForwardIterator __first,
                               _ForwardIterator __last, const _Tp &__value_,
                               _Compare __comp) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  difference_type __len = std::__1::distance(__first, __last);
  while (__len != 0) {
    difference_type __l2 = __len / 2;
    _ForwardIterator __m = __first;
    std::__1::advance(__m, __l2);
    if (__comp(*__m, __value_)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else
      __len = __l2;
  }
  return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_, _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator lower_bound(
    _ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) {
  return std::__1::lower_bound(
      __first, __last, __value_,
      __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator __upper_bound(_ForwardIterator __first,
                               _ForwardIterator __last, const _Tp &__value_,
                               _Compare __comp) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  difference_type __len = std::__1::distance(__first, __last);
  while (__len != 0) {
    difference_type __l2 = __len / 2;
    _ForwardIterator __m = __first;
    std::__1::advance(__m, __l2);
    if (__comp(__value_, *__m))
      __len = __l2;
    else {
      __first = ++__m;
      __len -= __l2 + 1;
    }
  }
  return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_, _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _ForwardIterator upper_bound(
    _ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) {
  return std::__1::upper_bound(
      __first, __last, __value_,
      __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last,
              const _Tp &__value_, _Compare __comp) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  difference_type __len = std::__1::distance(__first, __last);
  while (__len != 0) {
    difference_type __l2 = __len / 2;
    _ForwardIterator __m = __first;
    std::__1::advance(__m, __l2);
    if (__comp(*__m, __value_)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else if (__comp(__value_, *__m)) {
      __last = __m;
      __len = __l2;
    } else {
      _ForwardIterator __mp1 = __m;
      return pair<_ForwardIterator, _ForwardIterator>(
          __lower_bound<_Compare>(__first, __m, __value_, __comp),
          __upper_bound<_Compare>(++__mp1, __last, __value_, __comp));
    }
  }
  return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_, _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_) {
  return std::__1::equal_range(
      __first, __last, __value_,
      __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last,
                const _Tp &__value_, _Compare __comp) {
  __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
  return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
binary_search(_ForwardIterator __first, _ForwardIterator __last,
              const _Tp &__value_, _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);

}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool binary_search(_ForwardIterator __first,
                                                    _ForwardIterator __last,
                                                    const _Tp &__value_) {
  return std::__1::binary_search(
      __first, __last, __value_,
      __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator __merge(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2,
                        _OutputIterator __result, _Compare __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2)
      return std::__1::copy(__first1, __last1, __result);
    if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    } else {
      *__result = *__first1;
      ++__first1;
    }
  }
  return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator merge(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {






  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2,
                                   __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator merge(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return merge(__first1, __last1, __first2, __last2, __result,
               __less<__v1, __v2>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2,
                          _OutputIterator __result, _Compare __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2) {
      std::__1::move(__first1, __last1, __result);
      return;
    }

    if (__comp(*__first2, *__first1)) {
      *__result = std::__1::move(*__first2);
      ++__first2;
    } else {
      *__result = std::__1::move(*__first1);
      ++__first1;
    }
  }

}

template <class _Compare, class _BidirectionalIterator>
void __buffered_inplace_merge(
    _BidirectionalIterator __first, _BidirectionalIterator __middle,
    _BidirectionalIterator __last, _Compare __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type *__buff) {
  typedef
      typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  __destruct_n __d(0);
  unique_ptr<value_type, __destruct_n &> __h2(__buff, __d);
  if (__len1 <= __len2) {
    value_type *__p = __buff;
    for (_BidirectionalIterator __i = __first; __i != __middle;
         __d.__incr((value_type *)0), (void)++__i, ++__p)
      ::new (__p) value_type(std::__1::move(*__i));
    __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);
  } else {
    value_type *__p = __buff;
    for (_BidirectionalIterator __i = __middle; __i != __last;
         __d.__incr((value_type *)0), (void)++__i, ++__p)
      ::new (__p) value_type(std::__1::move(*__i));
    typedef reverse_iterator<_BidirectionalIterator> _RBi;
    typedef reverse_iterator<value_type *> _Rv;
    __half_inplace_merge(_Rv(__p), _Rv(__buff), _RBi(__middle), _RBi(__first),
                         _RBi(__last), __negate<_Compare>(__comp));
  }
}

template <class _Compare, class _BidirectionalIterator>
void __inplace_merge(
    _BidirectionalIterator __first, _BidirectionalIterator __middle,
    _BidirectionalIterator __last, _Compare __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type *__buff,
    ptrdiff_t __buff_size) {
  typedef typename iterator_traits<_BidirectionalIterator>::difference_type
      difference_type;
  while (true) {

    if (__len2 == 0)
      return;
    if (__len1 <= __buff_size || __len2 <= __buff_size)
      return __buffered_inplace_merge<_Compare>(__first, __middle, __last,
                                                __comp, __len1, __len2, __buff);


    for (; true; ++__first, (void)--__len1) {
      if (__len1 == 0)
        return;
      if (__comp(*__middle, *__first))
        break;
    }
    _BidirectionalIterator __m1;
    _BidirectionalIterator __m2;
    difference_type __len11;
    difference_type __len21;

    if (__len1 < __len2) {
      __len21 = __len2 / 2;
      __m2 = __middle;
      std::__1::advance(__m2, __len21);
      __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
      __len11 = std::__1::distance(__first, __m1);
    } else {
      if (__len1 ==
          1) {

        swap(*__first, *__middle);
        return;
      }

      __len11 = __len1 / 2;
      __m1 = __first;
      std::__1::advance(__m1, __len11);
      __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
      __len21 = std::__1::distance(__middle, __m2);
    }
    difference_type __len12 = __len1 - __len11;
    difference_type __len22 = __len2 - __len21;


    __middle = std::__1::rotate(__m1, __middle, __m2);



    if (__len11 + __len21 < __len12 + __len22) {
      __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11,
                                __len21, __buff, __buff_size);


      __first = __middle;
      __middle = __m2;
      __len1 = __len12;
      __len2 = __len22;
    } else {
      __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12,
                                __len22, __buff, __buff_size);


      __last = __middle;
      __middle = __m1;
      __len1 = __len11;
      __len2 = __len21;
    }
  }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle,
              _BidirectionalIterator __last, _Compare __comp) {
  typedef
      typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  typedef typename iterator_traits<_BidirectionalIterator>::difference_type
      difference_type;
  difference_type __len1 = std::__1::distance(__first, __middle);
  difference_type __len2 = std::__1::distance(__middle, __last);
  difference_type __buf_size = std::__1::min(__len1, __len2);
  pair<value_type *, ptrdiff_t> __buf =
      std::__1::get_temporary_buffer<value_type>(__buf_size);
  unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp,
                                           __len1, __len2, __buf.first,
                                           __buf.second);

}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle,
              _BidirectionalIterator __last) {
  std::__1::inplace_merge(
      __first, __middle, __last,
      __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
void __merge_move_construct(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2,
    typename iterator_traits<_InputIterator1>::value_type *__result,
    _Compare __comp) {
  typedef typename iterator_traits<_InputIterator1>::value_type value_type;
  __destruct_n __d(0);
  unique_ptr<value_type, __destruct_n &> __h(__result, __d);
  for (; true; ++__result) {
    if (__first1 == __last1) {
      for (; __first2 != __last2;
           ++__first2, ++__result, __d.__incr((value_type *)0))
        ::new (__result) value_type(std::__1::move(*__first2));
      __h.release();
      return;
    }
    if (__first2 == __last2) {
      for (; __first1 != __last1;
           ++__first1, ++__result, __d.__incr((value_type *)0))
        ::new (__result) value_type(std::__1::move(*__first1));
      __h.release();
      return;
    }
    if (__comp(*__first2, *__first1)) {
      ::new (__result) value_type(std::__1::move(*__first2));
      __d.__incr((value_type *)0);
      ++__first2;
    } else {
      ::new (__result) value_type(std::__1::move(*__first1));
      __d.__incr((value_type *)0);
      ++__first1;
    }
  }
}

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
void __merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2,
                         _OutputIterator __result, _Compare __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2) {
      for (; __first1 != __last1; ++__first1, ++__result)
        *__result = std::__1::move(*__first1);
      return;
    }
    if (__comp(*__first2, *__first1)) {
      *__result = std::__1::move(*__first2);
      ++__first2;
    } else {
      *__result = std::__1::move(*__first1);
      ++__first1;
    }
  }
  for (; __first2 != __last2; ++__first2, ++__result)
    *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void __stable_sort(
    _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len,
    typename iterator_traits<_RandomAccessIterator>::value_type *__buff,
    ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void __stable_sort_move(
    _RandomAccessIterator __first1, _RandomAccessIterator __last1,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len,
    typename iterator_traits<_RandomAccessIterator>::value_type *__first2) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  switch (__len) {
  case 0:
    return;
  case 1:
    ::new (__first2) value_type(std::__1::move(*__first1));
    return;
  case 2:
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h2(__first2, __d);
    if (__comp(*--__last1, *__first1)) {
      ::new (__first2) value_type(std::__1::move(*__last1));
      __d.__incr((value_type *)0);
      ++__first2;
      ::new (__first2) value_type(std::__1::move(*__first1));
    } else {
      ::new (__first2) value_type(std::__1::move(*__first1));
      __d.__incr((value_type *)0);
      ++__first2;
      ::new (__first2) value_type(std::__1::move(*__last1));
    }
    __h2.release();
    return;
  }
  if (__len <= 8) {
    __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
    return;
  }
  typename iterator_traits<_RandomAccessIterator>::difference_type __l2 =
      __len / 2;
  _RandomAccessIterator __m = __first1 + __l2;
  __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
  __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2,
                          __len - __l2);
  __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2,
                                   __comp);
}

template <class _Tp> struct __stable_sort_switch {
  static const unsigned value = 128 * is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void __stable_sort(
    _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len,
    typename iterator_traits<_RandomAccessIterator>::value_type *__buff,
    ptrdiff_t __buff_size) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  switch (__len) {
  case 0:
  case 1:
    return;
  case 2:
    if (__comp(*--__last, *__first))
      swap(*__first, *__last);
    return;
  }
  if (__len <=
      static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
    __insertion_sort<_Compare>(__first, __last, __comp);
    return;
  }
  typename iterator_traits<_RandomAccessIterator>::difference_type __l2 =
      __len / 2;
  _RandomAccessIterator __m = __first + __l2;
  if (__len <= __buff_size) {
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h2(__buff, __d);
    __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
    __d.__set(__l2, (value_type *)0);
    __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2,
                                 __buff + __l2);
    __d.__set(__len, (value_type *)0);
    __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2,
                                  __buff + __len, __first, __comp);







    return;
  }
  __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
  __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff,
                          __buff_size);
  __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2,
                            __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void stable_sort(_RandomAccessIterator __first,
                                                  _RandomAccessIterator __last,
                                                  _Compare __comp) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  difference_type __len = __last - __first;
  pair<value_type *, ptrdiff_t> __buf(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len >
      static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
    __buf = std::__1::get_temporary_buffer<value_type>(__len);
    __h.reset(__buf.first);
  }






  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first,
                           __buf.second);

}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::__1::stable_sort(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator is_heap_until(_RandomAccessIterator __first,
                                    _RandomAccessIterator __last,
                                    _Compare __comp) {
  typedef
      typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type
          difference_type;
  difference_type __len = __last - __first;
  difference_type __p = 0;
  difference_type __c = 1;
  _RandomAccessIterator __pp = __first;
  while (__c < __len) {
    _RandomAccessIterator __cp = __first + __c;
    if (__comp(*__pp, *__cp))
      return __cp;
    ++__c;
    ++__cp;
    if (__c == __len)
      return __last;
    if (__comp(*__pp, *__cp))
      return __cp;
    ++__p;
    ++__pp;
    __c = 2 * __p + 1;
  }
  return __last;
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  return std::__1::is_heap_until(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool is_heap(_RandomAccessIterator __first,
                                              _RandomAccessIterator __last,
                                              _Compare __comp) {
  return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool is_heap(_RandomAccessIterator __first,
                                              _RandomAccessIterator __last) {
  return std::__1::is_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void __sift_up(
    _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  if (__len > 1) {
    __len = (__len - 2) / 2;
    _RandomAccessIterator __ptr = __first + __len;
    if (__comp(*__ptr, *--__last)) {
      value_type __t(std::__1::move(*__last));
      do {
        *__last = std::__1::move(*__ptr);
        __last = __ptr;
        if (__len == 0)
          break;
        __len = (__len - 1) / 2;
        __ptr = __first + __len;
      } while (__comp(*__ptr, __t));
      *__last = std::__1::move(__t);
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void push_heap(_RandomAccessIterator __first,
                                                _RandomAccessIterator __last,
                                                _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void push_heap(_RandomAccessIterator __first,
                                                _RandomAccessIterator __last) {
  std::__1::push_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void __sift_down(
    _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len,
    _RandomAccessIterator __start) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;


  difference_type __child = __start - __first;

  if (__len < 2 || (__len - 2) / 2 < __child)
    return;

  __child = 2 * __child + 1;
  _RandomAccessIterator __child_i = __first + __child;

  if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

    ++__child_i;
    ++__child;
  }


  if (__comp(*__child_i, *__start))

    return;

  value_type __top(std::__1::move(*__start));
  do {

    *__start = std::__1::move(*__child_i);
    __start = __child_i;

    if ((__len - 2) / 2 < __child)
      break;


    __child = 2 * __child + 1;
    __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

      ++__child_i;
      ++__child;
    }


  } while (!__comp(*__child_i, __top));
  *__start = std::__1::move(__top);
}

template <class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void __pop_heap(
    _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  if (__len > 1) {
    swap(*__first, *--__last);
    __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void pop_heap(_RandomAccessIterator __first,
                                               _RandomAccessIterator __last,
                                               _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);

}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void pop_heap(_RandomAccessIterator __first,
                                               _RandomAccessIterator __last) {
  std::__1::pop_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                 _Compare __comp) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  difference_type __n = __last - __first;
  if (__n > 1) {

    for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start) {
      __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void make_heap(_RandomAccessIterator __first,
                                                _RandomAccessIterator __last,
                                                _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  __make_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void make_heap(_RandomAccessIterator __first,
                                                _RandomAccessIterator __last) {
  std::__1::make_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                 _Compare __comp) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  for (difference_type __n = __last - __first; __n > 1; --__last, --__n)
    __pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void sort_heap(_RandomAccessIterator __first,
                                                _RandomAccessIterator __last,
                                                _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  __sort_heap<_Comp_ref>(__first, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void sort_heap(_RandomAccessIterator __first,
                                                _RandomAccessIterator __last) {
  std::__1::sort_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void __partial_sort(_RandomAccessIterator __first,
                    _RandomAccessIterator __middle,
                    _RandomAccessIterator __last, _Compare __comp) {
  __make_heap<_Compare>(__first, __middle, __comp);
  typename iterator_traits<_RandomAccessIterator>::difference_type __len =
      __middle - __first;
  for (_RandomAccessIterator __i = __middle; __i != __last; ++__i) {
    if (__comp(*__i, *__first)) {
      swap(*__i, *__first);
      __sift_down<_Compare>(__first, __middle, __comp, __len, __first);
    }
  }
  __sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle,
             _RandomAccessIterator __last, _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle,
             _RandomAccessIterator __last) {
  std::__1::partial_sort(
      __first, __middle, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first,
                    _RandomAccessIterator __result_last, _Compare __comp) {
  _RandomAccessIterator __r = __result_first;
  if (__r != __result_last) {
    for (; __first != __last && __r != __result_last; (void)++__first, ++__r)
      *__r = *__first;
    __make_heap<_Compare>(__result_first, __r, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len =
        __r - __result_first;
    for (; __first != __last; ++__first)
      if (__comp(*__first, *__result_first)) {
        *__result_first = *__first;
        __sift_down<_Compare>(__result_first, __r, __comp, __len,
                              __result_first);
      }
    __sort_heap<_Compare>(__result_first, __r, __comp);
  }
  return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first,
                  _RandomAccessIterator __result_last, _Compare __comp) {






  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first,
                                        __result_last, __comp);

}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _RandomAccessIterator partial_sort_copy(
    _InputIterator __first, _InputIterator __last,
    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last) {
  return std::__1::partial_sort_copy(
      __first, __last, __result_first, __result_last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _RandomAccessIterator>
void __nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                   _RandomAccessIterator __last, _Compare __comp) {

  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  const difference_type __limit = 7;
  while (true) {
  __restart:
    if (__nth == __last)
      return;
    difference_type __len = __last - __first;
    switch (__len) {
    case 0:
    case 1:
      return;
    case 2:
      if (__comp(*--__last, *__first))
        swap(*__first, *__last);
      return;
    case 3: {
      _RandomAccessIterator __m = __first;
      std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
      return;
    }
    }
    if (__len <= __limit) {
      __selection_sort<_Compare>(__first, __last, __comp);
      return;
    }

    _RandomAccessIterator __m = __first + __len / 2;
    _RandomAccessIterator __lm1 = __last;
    unsigned __n_swaps =
        std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);



    _RandomAccessIterator __i = __first;
    _RandomAccessIterator __j = __lm1;




    if (!__comp(*__i, *__m))
    {


      while (true) {
        if (__i == --__j) {



          ++__i;
          __j = __last;
          if (!__comp(*__first,
                      *--__j))
          {
            while (true) {
              if (__i == __j)
                return;
              if (__comp(*__first, *__i)) {
                swap(*__i, *__j);
                ++__n_swaps;
                ++__i;
                break;
              }
              ++__i;
            }
          }


          if (__i == __j)
            return;
          while (true) {
            while (!__comp(*__first, *__i))
              ++__i;
            while (__comp(*__first, *--__j))
              ;
            if (__i >= __j)
              break;
            swap(*__i, *__j);
            ++__n_swaps;
            ++__i;
          }


          if (__nth < __i)
            return;


          __first = __i;
          goto __restart;
        }
        if (__comp(*__j, *__m)) {
          swap(*__i, *__j);
          ++__n_swaps;
          break;

        }
      }
    }
    ++__i;


    if (__i < __j) {

      while (true) {

        while (__comp(*__i, *__m))
          ++__i;

        while (!__comp(*--__j, *__m))
          ;
        if (__i >= __j)
          break;
        swap(*__i, *__j);
        ++__n_swaps;


        if (__m == __i)
          __m = __j;
        ++__i;
      }
    }

    if (__i != __m && __comp(*__m, *__i)) {
      swap(*__i, *__m);
      ++__n_swaps;
    }

    if (__nth == __i)
      return;
    if (__n_swaps == 0) {

      if (__nth < __i) {

        __j = __m = __first;
        while (++__j != __i) {
          if (__comp(*__j, *__m))

            goto not_sorted;
          __m = __j;
        }

        return;
      } else {

        __j = __m = __i;
        while (++__j != __last) {
          if (__comp(*__j, *__m))

            goto not_sorted;
          __m = __j;
        }

        return;
      }
    }
  not_sorted:

    if (__nth < __i) {

      __last = __i;
    } else {

      __first = ++__i;
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
            _RandomAccessIterator __last, _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  __nth_element<_Comp_ref>(__first, __nth, __last, __comp);

}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
            _RandomAccessIterator __last) {
  std::__1::nth_element(
      __first, __nth, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool __includes(_InputIterator1 __first1, _InputIterator1 __last1,
                _InputIterator2 __first2, _InputIterator2 __last2,
                _Compare __comp) {
  for (; __first2 != __last2; ++__first1) {
    if (__first1 == __last1 || __comp(*__first2, *__first1))
      return false;
    if (!__comp(*__first1, *__first2))
      ++__first2;
  }
  return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
includes(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
includes(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::__1::includes(
      __first1, __last1, __first2, __last2,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                            _InputIterator2 __first2, _InputIterator2 __last2,
                            _OutputIterator __result, _Compare __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2)
      return std::__1::copy(__first1, __last1, __result);
    if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    } else {
      *__result = *__first1;
      if (!__comp(*__first1, *__first2))
        ++__first2;
      ++__first1;
    }
  }
  return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator set_union(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {






  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result,
                                __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator set_union(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result) {
  return std::__1::set_union(
      __first1, __last1, __first2, __last2, __result,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2,
                   _OutputIterator __result, _Compare __comp) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2))
      ++__first1;
    else {
      if (!__comp(*__first2, *__first1)) {
        *__result = *__first1;
        ++__result;
        ++__first1;
      }
      ++__first2;
    }
  }
  return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator set_intersection(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {






  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2,
                                       __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator set_intersection(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result) {
  return std::__1::set_intersection(
      __first1, __last1, __first2, __last2, __result,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2,
                 _OutputIterator __result, _Compare __comp) {
  while (__first1 != __last1) {
    if (__first2 == __last2)
      return std::__1::copy(__first1, __last1, __result);
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__result;
      ++__first1;
    } else {
      if (!__comp(*__first2, *__first1))
        ++__first1;
      ++__first2;
    }
  }
  return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator set_difference(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {






  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2,
                                     __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator set_difference(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result) {
  return std::__1::set_difference(
      __first1, __last1, __first2, __last2, __result,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2,
                           _OutputIterator __result, _Compare __comp) {
  while (__first1 != __last1) {
    if (__first2 == __last2)
      return std::__1::copy(__first1, __last1, __result);
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__result;
      ++__first1;
    } else {
      if (__comp(*__first2, *__first1)) {
        *__result = *__first2;
        ++__result;
      } else
        ++__first1;
      ++__first2;
    }
  }
  return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator set_symmetric_difference(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result, _Compare __comp) {






  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2,
                                               __last2, __result, __comp);

}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator set_symmetric_difference(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2, _OutputIterator __result) {
  return std::__1::set_symmetric_difference(
      __first1, __last1, __first2, __last2, __result,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _InputIterator1, class _InputIterator2>
bool __lexicographical_compare(_InputIterator1 __first1,
                               _InputIterator1 __last1,
                               _InputIterator2 __first2,
                               _InputIterator2 __last2, _Compare __comp) {
  for (; __first2 != __last2; ++__first1, (void)++__first2) {
    if (__first1 == __last1 || __comp(*__first1, *__first2))
      return true;
    if (__comp(*__first2, *__first1))
      return false;
  }
  return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2,
                        _Compare __comp) {






  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2,
                                              __last2, __comp);

}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::__1::lexicographical_compare(
      __first1, __last1, __first2, __last2,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool __next_permutation(_BidirectionalIterator __first,
                        _BidirectionalIterator __last, _Compare __comp) {
  _BidirectionalIterator __i = __last;
  if (__first == __last || __first == --__i)
    return false;
  while (true) {
    _BidirectionalIterator __ip1 = __i;
    if (__comp(*--__i, *__ip1)) {
      _BidirectionalIterator __j = __last;
      while (!__comp(*__i, *--__j))
        ;
      swap(*__i, *__j);
      std::__1::reverse(__ip1, __last);
      return true;
    }
    if (__i == __first) {
      std::__1::reverse(__first, __last);
      return false;
    }
  }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last,
                 _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __next_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
next_permutation(_BidirectionalIterator __first,
                 _BidirectionalIterator __last) {
  return std::__1::next_permutation(
      __first, __last,
      __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}



template <class _Compare, class _BidirectionalIterator>
bool __prev_permutation(_BidirectionalIterator __first,
                        _BidirectionalIterator __last, _Compare __comp) {
  _BidirectionalIterator __i = __last;
  if (__first == __last || __first == --__i)
    return false;
  while (true) {
    _BidirectionalIterator __ip1 = __i;
    if (__comp(*__ip1, *--__i)) {
      _BidirectionalIterator __j = __last;
      while (!__comp(*--__j, *__i))
        ;
      swap(*__i, *__j);
      std::__1::reverse(__ip1, __last);
      return true;
    }
    if (__i == __first) {
      std::__1::reverse(__first, __last);
      return false;
    }
  }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last,
                 _Compare __comp) {





  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __prev_permutation<_Comp_ref>(__first, __last, __comp);

}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
prev_permutation(_BidirectionalIterator __first,
                 _BidirectionalIterator __last) {
  return std::__1::prev_permutation(
      __first, __last,
      __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

} }



namespace std { inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0>
class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp> struct __has_storage_type {
  static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference {
  typedef typename _Cp::__storage_type __storage_type;
  typedef typename _Cp::__storage_pointer __storage_pointer;

  __storage_pointer __seg_;
  __storage_type __mask_;


  friend typename _Cp::__self;



  friend class __bit_const_reference<_Cp>;
  friend class __bit_iterator<_Cp, false>;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) operator bool() const noexcept {
    return static_cast<bool>(*__seg_ & __mask_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool operator~() const noexcept {
    return !static_cast<bool>(*this);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __bit_reference &operator=(bool __x) noexcept {
    if (__x)
      *__seg_ |= __mask_;
    else
      *__seg_ &= ~__mask_;
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __bit_reference &operator=(const __bit_reference &__x) noexcept {
    return operator=(static_cast<bool>(__x));
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void flip() noexcept { *__seg_ ^= __mask_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false>
  operator&() const noexcept {
    return __bit_iterator<_Cp, false>(__seg_,
                                      static_cast<unsigned>(__ctz(__mask_)));
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  __bit_reference(__storage_pointer __s, __storage_type __m) noexcept
      : __seg_(__s),
        __mask_(__m) {}
};

template <class _Cp> class __bit_reference<_Cp, false> {};

template <class _Cp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(__bit_reference<_Cp> __x,
                                           __bit_reference<_Cp> __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(__bit_reference<_Cp> __x,
                                           __bit_reference<_Dp> __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(__bit_reference<_Cp> __x,
                                           bool &__y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(bool &__x,
                                           __bit_reference<_Cp> __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp> class __bit_const_reference {
  typedef typename _Cp::__storage_type __storage_type;
  typedef typename _Cp::__const_storage_pointer __storage_pointer;

  __storage_pointer __seg_;
  __storage_type __mask_;


  friend typename _Cp::__self;



  friend class __bit_iterator<_Cp, true>;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  __bit_const_reference(const __bit_reference<_Cp> &__x) noexcept
      : __seg_(__x.__seg_),
        __mask_(__x.__mask_) {}

  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr operator bool() const noexcept {
    return static_cast<bool>(*__seg_ & __mask_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, true>
  operator&() const noexcept {
    return __bit_iterator<_Cp, true>(__seg_,
                                     static_cast<unsigned>(__ctz(__mask_)));
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr
  __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept
      : __seg_(__s),
        __mask_(__m) {}

  __bit_const_reference &operator=(const __bit_const_reference &__x);
};



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first,
                 typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, _IsConst> _It;
  typedef typename _It::__storage_type __storage_type;
  static const unsigned __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    __storage_type __b = *__first.__seg_ & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    if (__n == __dn)
      return __first + __n;
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    if (*__first.__seg_)
      return _It(__first.__seg_,
                 static_cast<unsigned>(std::__1::__ctz(*__first.__seg_)));

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = *__first.__seg_ & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
  }
  return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first,
                  typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, _IsConst> _It;
  typedef typename _It::__storage_type __storage_type;
  static const unsigned __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    __storage_type __b = ~*__first.__seg_ & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
    if (__n == __dn)
      return __first + __n;
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word) {
    __storage_type __b = ~*__first.__seg_;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
  }

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = ~*__first.__seg_ & __m;
    if (__b)
      return _It(__first.__seg_, static_cast<unsigned>(std::__1::__ctz(__b)));
  }
  return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first,
     __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value_) {
  if (static_cast<bool>(__value_))
    return __find_bool_true(
        __first, static_cast<typename _Cp::size_type>(__last - __first));
  return __find_bool_false(
      __first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first,
                  typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, _IsConst> _It;
  typedef typename _It::__storage_type __storage_type;
  typedef typename _It::difference_type difference_type;
  static const unsigned __bits_per_word = _It::__bits_per_word;
  difference_type __r = 0;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    __r = std::__1::__pop_count(*__first.__seg_ & __m);
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    __r += std::__1::__pop_count(*__first.__seg_);

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __r += std::__1::__pop_count(*__first.__seg_ & __m);
  }
  return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first,
                   typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, _IsConst> _It;
  typedef typename _It::__storage_type __storage_type;
  typedef typename _It::difference_type difference_type;
  static const unsigned __bits_per_word = _It::__bits_per_word;
  difference_type __r = 0;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    __r = std::__1::__pop_count(~*__first.__seg_ & __m);
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    __r += std::__1::__pop_count(~*__first.__seg_);

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __r += std::__1::__pop_count(~*__first.__seg_ & __m);
  }
  return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename __bit_iterator<_Cp, _IsConst>::difference_type
    count(__bit_iterator<_Cp, _IsConst> __first,
          __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value_) {
  if (static_cast<bool>(__value_))
    return __count_bool_true(
        __first, static_cast<typename _Cp::size_type>(__last - __first));
  return __count_bool_false(
      __first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp>
void __fill_n_false(__bit_iterator<_Cp, false> __first,
                    typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, false> _It;
  typedef typename _It::__storage_type __storage_type;
  static const unsigned __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    *__first.__seg_ &= ~__m;
    __n -= __dn;
    ++__first.__seg_;
  }

  __storage_type __nw = __n / __bits_per_word;
  std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), 0,
                __nw * sizeof(__storage_type));
  __n -= __nw * __bits_per_word;

  if (__n > 0) {
    __first.__seg_ += __nw;
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    *__first.__seg_ &= ~__m;
  }
}

template <class _Cp>
void __fill_n_true(__bit_iterator<_Cp, false> __first,
                   typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, false> _It;
  typedef typename _It::__storage_type __storage_type;
  static const unsigned __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    *__first.__seg_ |= __m;
    __n -= __dn;
    ++__first.__seg_;
  }

  __storage_type __nw = __n / __bits_per_word;
  std::__1::memset(std::__1::__to_raw_pointer(__first.__seg_), -1,
                __nw * sizeof(__storage_type));
  __n -= __nw * __bits_per_word;

  if (__n > 0) {
    __first.__seg_ += __nw;
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    *__first.__seg_ |= __m;
  }
}

template <class _Cp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void fill_n(__bit_iterator<_Cp, false> __first,
                                             typename _Cp::size_type __n,
                                             bool __value_) {
  if (__n > 0) {
    if (__value_)
      __fill_n_true(__first, __n);
    else
      __fill_n_false(__first, __n);
  }
}



template <class _Cp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void fill(__bit_iterator<_Cp, false> __first,
                                           __bit_iterator<_Cp, false> __last,
                                           bool __value_) {
  std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first),
                __value_);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false> __copy_aligned(__bit_iterator<_Cp, _IsConst> __first,
                                          __bit_iterator<_Cp, _IsConst> __last,
                                          __bit_iterator<_Cp, false> __result) {
  typedef __bit_iterator<_Cp, _IsConst> _In;
  typedef typename _In::difference_type difference_type;
  typedef typename _In::__storage_type __storage_type;
  static const unsigned __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                           (~__storage_type(0) >> (__clz - __dn));
      __storage_type __b = *__first.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      ++__first.__seg_;

    }


    __storage_type __nw = __n / __bits_per_word;
    std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                   std::__1::__to_raw_pointer(__first.__seg_),
                   __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;
    __result.__seg_ += __nw;

    if (__n > 0) {
      __first.__seg_ += __nw;
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(__n);
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first,
                 __bit_iterator<_Cp, _IsConst> __last,
                 __bit_iterator<_Cp, false> __result) {
  typedef __bit_iterator<_Cp, _IsConst> _In;
  typedef typename _In::difference_type difference_type;
  typedef typename _In::__storage_type __storage_type;
  static const unsigned __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                           (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b = *__first.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __ddn));
      *__result.__seg_ &= ~__m;
      if (__result.__ctz_ > __first.__ctz_)
        *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
      else
        *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
      __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
        __result.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first.__seg_;

    }


    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    __storage_type __m = ~__storage_type(0) << __result.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_) {
      __storage_type __b = *__first.__seg_;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b << __result.__ctz_;
      ++__result.__seg_;
      *__result.__seg_ &= __m;
      *__result.__seg_ |= __b >> __clz_r;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first.__seg_ & __m;
      __storage_type __dn =
          std::__1::min(__n, static_cast<difference_type>(__clz_r));
      __m = (~__storage_type(0) << __result.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __dn));
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b << __result.__ctz_;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b >> __dn;
        __result.__ctz_ = static_cast<unsigned>(__n);
      }
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first,
     __bit_iterator<_Cp, _IsConst> __last,
     __bit_iterator<_Cp, false> __result) {
  if (__first.__ctz_ == __result.__ctz_)
    return __copy_aligned(__first, __last, __result);
  return __copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first,
                        __bit_iterator<_Cp, _IsConst> __last,
                        __bit_iterator<_Cp, false> __result) {
  typedef __bit_iterator<_Cp, _IsConst> _In;
  typedef typename _In::difference_type difference_type;
  typedef typename _In::__storage_type __storage_type;
  static const unsigned __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__last.__ctz_ != 0) {
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
      __n -= __dn;
      unsigned __clz = __bits_per_word - __last.__ctz_;
      __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) &
                           (~__storage_type(0) >> __clz);
      __storage_type __b = *__last.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(
          ((-__dn & (__bits_per_word - 1)) + __result.__ctz_) %
          __bits_per_word);

    }



    __storage_type __nw = __n / __bits_per_word;
    __result.__seg_ -= __nw;
    __last.__seg_ -= __nw;
    std::__1::memmove(std::__1::__to_raw_pointer(__result.__seg_),
                   std::__1::__to_raw_pointer(__last.__seg_),
                   __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
      __storage_type __b = *--__last.__seg_ & __m;
      *--__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first,
                          __bit_iterator<_Cp, _IsConst> __last,
                          __bit_iterator<_Cp, false> __result) {
  typedef __bit_iterator<_Cp, _IsConst> _In;
  typedef typename _In::difference_type difference_type;
  typedef typename _In::__storage_type __storage_type;
  static const unsigned __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__last.__ctz_ != 0) {
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
      __n -= __dn;
      unsigned __clz_l = __bits_per_word - __last.__ctz_;
      __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) &
                           (~__storage_type(0) >> __clz_l);
      __storage_type __b = *__last.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn =
          std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
      if (__ddn > 0) {
        __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) &
              (~__storage_type(0) >> __clz_r);
        *__result.__seg_ &= ~__m;
        if (__result.__ctz_ > __last.__ctz_)
          *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
        else
          *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
        __result.__ctz_ = static_cast<unsigned>(
            ((-__ddn & (__bits_per_word - 1)) + __result.__ctz_) %
            __bits_per_word);
        __dn -= __ddn;
      }
      if (__dn > 0) {

        --__result.__seg_;
        __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
        __m = ~__storage_type(0) << __result.__ctz_;
        *__result.__seg_ &= ~__m;
        __last.__ctz_ -= __dn + __ddn;
        *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
      }

    }



    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    __storage_type __m = ~__storage_type(0) >> __clz_r;
    for (; __n >= __bits_per_word; __n -= __bits_per_word) {
      __storage_type __b = *--__last.__seg_;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b >> __clz_r;
      *--__result.__seg_ &= __m;
      *__result.__seg_ |= __b << __result.__ctz_;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) << (__bits_per_word - __n);
      __storage_type __b = *--__last.__seg_ & __m;
      __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __dn =
          std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
      __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) &
            (~__storage_type(0) >> __clz_r);
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
      __result.__ctz_ = static_cast<unsigned>(
          ((-__dn & (__bits_per_word - 1)) + __result.__ctz_) %
          __bits_per_word);
      __n -= __dn;
      if (__n > 0) {

        --__result.__seg_;
        __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        __m = ~__storage_type(0) << __result.__ctz_;
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |=
            __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
      }
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first,
              __bit_iterator<_Cp, _IsConst> __last,
              __bit_iterator<_Cp, false> __result) {
  if (__last.__ctz_ == __result.__ctz_)
    return __copy_backward_aligned(__first, __last, __result);
  return __copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first,
     __bit_iterator<_Cp, _IsConst> __last,
     __bit_iterator<_Cp, false> __result) {
  return std::__1::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first,
              __bit_iterator<_Cp, _IsConst> __last,
              __bit_iterator<_Cp, false> __result) {
  return std::__1::copy_backward(__first, __last, __result);
}



template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first,
                      __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result) {
  typedef __bit_iterator<__C1, false> _I1;
  typedef typename _I1::difference_type difference_type;
  typedef typename _I1::__storage_type __storage_type;
  static const unsigned __bits_per_word = _I1::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                           (~__storage_type(0) >> (__clz - __dn));
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1;
      *__first.__seg_ |= __b2;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      ++__first.__seg_;

    }


    for (; __n >= __bits_per_word;
         __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
      swap(*__first.__seg_, *__result.__seg_);

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1;
      *__first.__seg_ |= __b2;
      __result.__ctz_ = static_cast<unsigned>(__n);
    }
  }
  return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first,
                        __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result) {
  typedef __bit_iterator<__C1, false> _I1;
  typedef typename _I1::difference_type difference_type;
  typedef typename _I1::__storage_type __storage_type;
  static const unsigned __bits_per_word = _I1::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                           (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __ddn));
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      if (__result.__ctz_ > __first.__ctz_) {
        unsigned __s = __result.__ctz_ - __first.__ctz_;
        *__result.__seg_ |= __b1 << __s;
        *__first.__seg_ |= __b2 >> __s;
      } else {
        unsigned __s = __first.__ctz_ - __result.__ctz_;
        *__result.__seg_ |= __b1 >> __s;
        *__first.__seg_ |= __b2 << __s;
      }
      __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        __b2 = *__result.__seg_ & __m;
        *__result.__seg_ &= ~__m;
        unsigned __s = __first.__ctz_ + __ddn;
        *__result.__seg_ |= __b1 >> __s;
        *__first.__seg_ |= __b2 << __s;
        __result.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first.__seg_;

    }


    __storage_type __m = ~__storage_type(0) << __result.__ctz_;
    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_) {
      __storage_type __b1 = *__first.__seg_;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1 << __result.__ctz_;
      *__first.__seg_ = __b2 >> __result.__ctz_;
      ++__result.__seg_;
      __b2 = *__result.__seg_ & ~__m;
      *__result.__seg_ &= __m;
      *__result.__seg_ |= __b1 >> __clz_r;
      *__first.__seg_ |= __b2 << __clz_r;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __dn));
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1 << __result.__ctz_;
      *__first.__seg_ |= __b2 >> __result.__ctz_;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __b2 = *__result.__seg_ & __m;
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b1 >> __dn;
        *__first.__seg_ |= __b2 << __dn;
        __result.__ctz_ = static_cast<unsigned>(__n);
      }
    }
  }
  return __result;
}

template <class __C1, class __C2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1,
            __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2) {
  if (__first1.__ctz_ == __first2.__ctz_)
    return __swap_ranges_aligned(__first1, __last1, __first2);
  return __swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp> struct __bit_array {
  typedef typename _Cp::difference_type difference_type;
  typedef typename _Cp::__storage_type __storage_type;
  typedef typename _Cp::__storage_pointer __storage_pointer;
  typedef typename _Cp::iterator iterator;
  static const unsigned __bits_per_word = _Cp::__bits_per_word;
  static const unsigned _Np = 4;

  difference_type __size_;
  __storage_type __word_[_Np];

  __attribute__((__visibility__("hidden"), __always_inline__)) static difference_type capacity() {
    return static_cast<difference_type>(_Np * __bits_per_word);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __bit_array(difference_type __s)
      : __size_(__s) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator begin() {
    return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]),
                    0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator end() {
    return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) +
                        __size_ / __bits_per_word,
                    static_cast<unsigned>(__size_ % __bits_per_word));
  }
};

template <class _Cp>
__bit_iterator<_Cp, false> rotate(__bit_iterator<_Cp, false> __first,
                                  __bit_iterator<_Cp, false> __middle,
                                  __bit_iterator<_Cp, false> __last) {
  typedef __bit_iterator<_Cp, false> _I1;
  typedef typename _I1::difference_type difference_type;
  difference_type __d1 = __middle - __first;
  difference_type __d2 = __last - __middle;
  _I1 __r = __first + __d2;
  while (__d1 != 0 && __d2 != 0) {
    if (__d1 <= __d2) {
      if (__d1 <= __bit_array<_Cp>::capacity()) {
        __bit_array<_Cp> __b(__d1);
        std::__1::copy(__first, __middle, __b.begin());
        std::__1::copy(__b.begin(), __b.end(),
                    std::__1::copy(__middle, __last, __first));
        break;
      } else {
        __bit_iterator<_Cp, false> __mp =
            std::__1::swap_ranges(__first, __middle, __middle);
        __first = __middle;
        __middle = __mp;
        __d2 -= __d1;
      }
    } else {
      if (__d2 <= __bit_array<_Cp>::capacity()) {
        __bit_array<_Cp> __b(__d2);
        std::__1::copy(__middle, __last, __b.begin());
        std::__1::copy_backward(__b.begin(), __b.end(),
                             std::__1::copy_backward(__first, __middle, __last));
        break;
      } else {
        __bit_iterator<_Cp, false> __mp = __first + __d2;
        std::__1::swap_ranges(__first, __mp, __middle);
        __first = __mp;
        __d1 -= __d2;
      }
    }
  }
  return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
bool __equal_unaligned(__bit_iterator<_Cp, _IC1> __first1,
                       __bit_iterator<_Cp, _IC1> __last1,
                       __bit_iterator<_Cp, _IC2> __first2) {
  typedef __bit_iterator<_Cp, _IC1> _It;
  typedef typename _It::difference_type difference_type;
  typedef typename _It::__storage_type __storage_type;
  static const unsigned __bits_per_word = _It::__bits_per_word;
  difference_type __n = __last1 - __first1;
  if (__n > 0) {

    if (__first1.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first1.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first1.__ctz_) &
                           (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b = *__first1.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __first2.__ctz_;
      __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __first2.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __ddn));
      if (__first2.__ctz_ > __first1.__ctz_) {
        if ((*__first2.__seg_ & __m) !=
            (__b << (__first2.__ctz_ - __first1.__ctz_)))
          return false;
      } else {
        if ((*__first2.__seg_ & __m) !=
            (__b >> (__first1.__ctz_ - __first2.__ctz_)))
          return false;
      }
      __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
      __first2.__ctz_ =
          static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
          return false;
        __first2.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first1.__seg_;

    }


    unsigned __clz_r = __bits_per_word - __first2.__ctz_;
    __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_) {
      __storage_type __b = *__first1.__seg_;
      if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
        return false;
      ++__first2.__seg_;
      if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
        return false;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first1.__seg_ & __m;
      __storage_type __dn =
          std::__1::min(__n, static_cast<difference_type>(__clz_r));
      __m = (~__storage_type(0) << __first2.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __dn));
      if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
        return false;
      __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
      __first2.__ctz_ =
          static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if ((*__first2.__seg_ & __m) != (__b >> __dn))
          return false;
      }
    }
  }
  return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool __equal_aligned(__bit_iterator<_Cp, _IC1> __first1,
                     __bit_iterator<_Cp, _IC1> __last1,
                     __bit_iterator<_Cp, _IC2> __first2) {
  typedef __bit_iterator<_Cp, _IC1> _It;
  typedef typename _It::difference_type difference_type;
  typedef typename _It::__storage_type __storage_type;
  static const unsigned __bits_per_word = _It::__bits_per_word;
  difference_type __n = __last1 - __first1;
  if (__n > 0) {

    if (__first1.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first1.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first1.__ctz_) &
                           (~__storage_type(0) >> (__clz - __dn));
      if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
        return false;
      ++__first2.__seg_;
      ++__first1.__seg_;


    }



    for (; __n >= __bits_per_word;
         __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
      if (*__first2.__seg_ != *__first1.__seg_)
        return false;

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
        return false;
    }
  }
  return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
      __bit_iterator<_Cp, _IC2> __first2) {
  if (__first1.__ctz_ == __first2.__ctz_)
    return __equal_aligned(__first1, __last1, __first2);
  return __equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst, typename _Cp::__storage_type>
class __bit_iterator {
public:
  typedef typename _Cp::difference_type difference_type;
  typedef bool value_type;
  typedef __bit_iterator pointer;
  typedef typename conditional<_IsConst, __bit_const_reference<_Cp>,
                               __bit_reference<_Cp>>::type reference;
  typedef random_access_iterator_tag iterator_category;

private:
  typedef typename _Cp::__storage_type __storage_type;
  typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                               typename _Cp::__storage_pointer>::type
      __storage_pointer;
  static const unsigned __bits_per_word = _Cp::__bits_per_word;

  __storage_pointer __seg_;
  unsigned __ctz_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator() noexcept




  {
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __bit_iterator(const __bit_iterator<_Cp, false> &__it) noexcept
      : __seg_(__it.__seg_),
        __ctz_(__it.__ctz_) {}

  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator*() const noexcept {
    return reference(__seg_, __storage_type(1) << __ctz_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator &operator++() {
    if (__ctz_ != __bits_per_word - 1)
      ++__ctz_;
    else {
      __ctz_ = 0;
      ++__seg_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator operator++(int) {
    __bit_iterator __tmp = *this;
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator &operator--() {
    if (__ctz_ != 0)
      --__ctz_;
    else {
      __ctz_ = __bits_per_word - 1;
      --__seg_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator operator--(int) {
    __bit_iterator __tmp = *this;
    --(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator &operator+=(difference_type __n) {
    if (__n >= 0)
      __seg_ += (__n + __ctz_) / __bits_per_word;
    else
      __seg_ +=
          static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1) /
          static_cast<difference_type>(__bits_per_word);
    __n &= (__bits_per_word - 1);
    __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator &operator-=(difference_type __n) {
    return *this += -__n;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator
  operator+(difference_type __n) const {
    __bit_iterator __t(*this);
    __t += __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __bit_iterator
  operator-(difference_type __n) const {
    __bit_iterator __t(*this);
    __t -= __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  friend __bit_iterator operator+(difference_type __n,
                                  const __bit_iterator &__it) {
    return __it + __n;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  friend difference_type operator-(const __bit_iterator &__x,
                                   const __bit_iterator &__y) {
    return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ -
           __y.__ctz_;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const {
    return *(*this + __n);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool operator==(const __bit_iterator &__x,
                                                   const __bit_iterator &__y) {
    return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool operator!=(const __bit_iterator &__x,
                                                   const __bit_iterator &__y) {
    return !(__x == __y);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool operator<(const __bit_iterator &__x,
                                                  const __bit_iterator &__y) {
    return __x.__seg_ < __y.__seg_ ||
           (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool operator>(const __bit_iterator &__x,
                                                  const __bit_iterator &__y) {
    return __y < __x;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool operator<=(const __bit_iterator &__x,
                                                   const __bit_iterator &__y) {
    return !(__y < __x);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool operator>=(const __bit_iterator &__x,
                                                   const __bit_iterator &__y) {
    return !(__x < __y);
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  __bit_iterator(__storage_pointer __s, unsigned __ctz) noexcept
      : __seg_(__s),
        __ctz_(__ctz) {}


  friend typename _Cp::__self;



  friend class __bit_reference<_Cp>;
  friend class __bit_const_reference<_Cp>;
  friend class __bit_iterator<_Cp, true>;
  template <class _Dp> friend struct __bit_array;
  template <class _Dp>
  friend void __fill_n_false(__bit_iterator<_Dp, false> __first,
                             typename _Dp::size_type __n);
  template <class _Dp>
  friend void __fill_n_true(__bit_iterator<_Dp, false> __first,
                            typename _Dp::size_type __n);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                 __bit_iterator<_Dp, _IC> __last,
                 __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                   __bit_iterator<_Dp, _IC> __last,
                   __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                         __bit_iterator<_Dp, _IC> __last,
                                         __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                          __bit_iterator<_Dp, _IC> __last,
                          __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                            __bit_iterator<_Dp, _IC> __last,
                            __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  copy_backward(__bit_iterator<_Dp, _IC> __first,
                __bit_iterator<_Dp, _IC> __last,
                __bit_iterator<_Dp, false> __result);
  template <class __C1, class __C2>
  friend __bit_iterator<__C2, false>
      __swap_ranges_aligned(__bit_iterator<__C1, false>,
                            __bit_iterator<__C1, false>,
                            __bit_iterator<__C2, false>);
  template <class __C1, class __C2>
  friend __bit_iterator<__C2, false>
      __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                              __bit_iterator<__C1, false>,
                              __bit_iterator<__C2, false>);
  template <class __C1, class __C2>
  friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                 __bit_iterator<__C1, false>,
                                                 __bit_iterator<__C2, false>);
  template <class _Dp>
  friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                           __bit_iterator<_Dp, false>,
                                           __bit_iterator<_Dp, false>);
  template <class _Dp, bool _IC1, bool _IC2>
  friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                              __bit_iterator<_Dp, _IC1>,
                              __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC1, bool _IC2>
  friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                __bit_iterator<_Dp, _IC1>,
                                __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC1, bool _IC2>
  friend bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>,
                    __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                   typename _Dp::size_type);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                    typename _Dp::size_type);
  template <class _Dp, bool _IC>
  friend typename __bit_iterator<_Dp, _IC>::difference_type
      __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
  template <class _Dp, bool _IC>
  friend typename __bit_iterator<_Dp, _IC>::difference_type
      __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }




#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
    }


#pragma checkout(resume)







#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
  struct __fpos_t {
    long int __fpos_elem[8];
    };

  typedef struct __fpos_t fpos_t;
#pragma map (vprintf, "\174\174VPRNT")
#pragma map (vfprintf, "\174\174VFPRT")



#pragma map (vsprintf, "\174\174VSPRT")
 void clearerr (FILE *);
    int fclose (FILE *);
    int feof (FILE *);
    int ferror (FILE *);
    int fflush (FILE *);
    int fgetc (FILE *);
    int fgetpos (FILE * , fpos_t * );
    char *fgets (char * , int, FILE * );
    FILE *fopen (const char * ,
                    const char * );
    int fprintf (FILE * ,
                       const char * , ...);
    int fputc (int, FILE *);
    int fputs (const char * , FILE * );
    size_t fread (void * , size_t,
                    size_t, FILE * );
    FILE *freopen (const char * ,
                      const char * , FILE * );
    int fscanf (FILE * ,
                      const char * , ...);
    int fseek (FILE *, long int, int);
    int fsetpos (FILE *, const fpos_t *);
    long int ftell (FILE *);
   size_t fwrite (const void * , size_t, size_t,
                     FILE * );
    int getc (FILE *);
    int getchar (void);
    char *gets (char *);
    void perror (const char *);
    int printf (const char * , ...);
    int putc (int, FILE *);
    int putchar (int);
    int puts (const char *);
    int remove (const char *);
    int rename (const char *, const char *);
    void rewind (FILE *);
    int scanf (const char * , ...);
    void setbuf (FILE * , char * );
    int setvbuf (FILE * , char * ,
                      int, size_t);

      int sprintf (char * ,
                         const char * , ...);

    int sscanf (const char * ,
                     const char * , ...);
    FILE *tmpfile (void);
    char *tmpnam (char *);
    int ungetc (int, FILE *);
    int vfprintf (FILE * ,
                        const char * , ___valist);
    int vprintf (const char * , ___valist);
    int vsprintf (char * ,
                        const char * , ___valist);
         off_t ftello (FILE *);
         int fseeko (FILE *, off_t, int);
    inline int getc(FILE *p) {return (--(p)->__fp->__countIn >= 0 ? *(p)->__fp->__bufPtr++ : ((p)->__fp->__fcb_orientation == 0 ? (p)->__fp->__fcb_orientation = 1 : (p)->__fp->__fcb_orientation, ((p)->__fp->__fcbgetc)((p)->__fp)));}
    inline int getchar(void) {return (--(( *((__FILEP * const) (*(_Gtab(2))) ) ))->__fp->__countIn >= 0 ? *(( *((__FILEP * const) (*(_Gtab(2))) ) ))->__fp->__bufPtr++ : ((( *((__FILEP * const) (*(_Gtab(2))) ) ))->__fp->__fcb_orientation == 0 ? (( *((__FILEP * const) (*(_Gtab(2))) ) ))->__fp->__fcb_orientation = 1 : (( *((__FILEP * const) (*(_Gtab(2))) ) ))->__fp->__fcb_orientation, ((( *((__FILEP * const) (*(_Gtab(2))) ) ))->__fp->__fcbgetc)((( *((__FILEP * const) (*(_Gtab(2))) ) ))->__fp)));}
    inline int putc(int c, FILE *p) {return (( *((int *)(_Gtab(1))) ) = (c), (!(( *((__cusp * const) (*(_Gtab(5))) ) )[(char)(( *((int *)(_Gtab(1))) ))] & 0x20) || !(p)->__fp->__cntlinterpret) && --(p)->__fp->__countOut >= 0 ? (*(p)->__fp->__bufPtr++ = (unsigned char)( *((int *)(_Gtab(1))) )) : ((p)->__fp->__fcb_orientation == 0 ? (p)->__fp->__fcb_orientation = 1 : (p)->__fp->__fcb_orientation, ((p)->__fp->__fcbputc)((unsigned char)( *((int *)(_Gtab(1))) ),(p)->__fp)));}
    inline int putchar(int c) {return (( *((int *)(_Gtab(1))) ) = ((c)), (!(( *((__cusp * const) (*(_Gtab(5))) ) )[(char)(( *((int *)(_Gtab(1))) ))] & 0x20) || !(( *((__FILEP * const) (*(_Gtab(3))) ) ))->__fp->__cntlinterpret) && --(( *((__FILEP * const) (*(_Gtab(3))) ) ))->__fp->__countOut >= 0 ? (*(( *((__FILEP * const) (*(_Gtab(3))) ) ))->__fp->__bufPtr++ = (unsigned char)( *((int *)(_Gtab(1))) )) : ((( *((__FILEP * const) (*(_Gtab(3))) ) ))->__fp->__fcb_orientation == 0 ? (( *((__FILEP * const) (*(_Gtab(3))) ) ))->__fp->__fcb_orientation = 1 : (( *((__FILEP * const) (*(_Gtab(3))) ) ))->__fp->__fcb_orientation, ((( *((__FILEP * const) (*(_Gtab(3))) ) ))->__fp->__fcbputc)((unsigned char)( *((int *)(_Gtab(1))) ),(( *((__FILEP * const) (*(_Gtab(3))) ) ))->__fp)));}
      struct __S99struc
        {
             unsigned char __S99RBLN;
             unsigned char __S99VERB;
             unsigned short __S99FLAG1;

             unsigned short __S99ERROR;
             unsigned short __S99INFO;
             void *__ptr32 __S99TXTPP;

             void *__ptr32 __S99S99X;

             unsigned int __S99FLAG2;


        };

      typedef struct __S99struc __S99parms;



    struct __S99rbx
          {
        char __S99EID[6];
        unsigned char __S99EVER;
        unsigned char __S99EOPTS;
        unsigned char __S99ESUBP;
        unsigned char __S99EKEY;
        unsigned char __S99EMGSV;
        unsigned char __S99ENMSG;
        void *__ptr32 __S99ECPPL;
        char __reserved;
        char __S99ERES;
        unsigned char __S99ERCO;
        unsigned char __S99ERCF;
        int __S99EWRC;
        void *__ptr32 __S99EMSGP;
        unsigned short __S99EERR;
        unsigned short __S99EINFO;
        int __reserv2;
        };

     typedef struct __S99rbx __S99rbx_t;

     struct __S99emparms {
        unsigned char __EMFUNCT;
        unsigned char __EMIDNUM;
        unsigned char __EMNMSGBK;
        unsigned char __filler1;
        void *__ptr32 __EMS99RBP;
        int __EMRETCOD;
        void *__ptr32 __EMCPPLP;
        void *__ptr32 __EMBUFP;
        int __reserv1;
        int __reserv2;
        };

       typedef struct __S99emparms __S99emparms_t;






    typedef enum {
       __disk = 0,
       __terminal = 1,
       __printer = 2,
       __tape = 3,
       __tdq = 5,
       __dummy = 6,


       __msgfile = 7,


       __memory = 8,
       __hfs = 9,
       __hiperspace = 10,


       __msgrtn = 11,


       __other = 0xff
    } __device_t;
    struct __fileData {
         unsigned int __recfmF : 1,
                        __recfmV : 1,
                        __recfmU : 1,
                        __recfmS : 1,
                        __recfmBlk : 1,
                        __recfmASA : 1,
                        __recfmM : 1,
                        __dsorgPO : 1,
                        __dsorgPDSmem : 1,
                        __dsorgPDSdir : 1,
                        __dsorgPS : 1,
                        __dsorgConcat : 1,
                        __dsorgMem : 1,
                        __dsorgHiper : 1,
                        __dsorgTemp: 1,
                        __dsorgVSAM: 1,


                        __dsorgHFS : 1,




                        __openmode : 2,
                        __modeflag : 4,
                        __dsorgPDSE : 1,

                        __vsamRLS : 3,

                        __vsamEA : 1,
                        __recfmB : 1,
                        __reserve2 : 3;




         __device_t __device;
         unsigned long __blksize,
                        __maxreclen;
         union {
           struct {
             unsigned short __vsam_type;
             unsigned long __vsam_keylen;
             unsigned long __vsam_RKP;
           } __vsam;

           struct {
             unsigned short __disk_vsam_type;
             unsigned char __disk_access_method;
             unsigned char __disk_noseek_to_seek;
             long __disk_reserve[2];
           } __disk;

         } __device_specific;
         char * __dsname;
         void * __reserve4;
    };

    typedef struct __fileData fldata_t;
      int svc99 (__S99parms *);
      int flocate (FILE *, const void *, size_t, int);
      int fdelrec (FILE *);
      size_t fupdate (const void *, size_t, FILE *);
      int clrmemf (int);
      int fldata (FILE *, char *, fldata_t *);
    typedef struct {




              unsigned long __fill,
                            __recnum;

    } __rrds_key_type;






      typedef struct __amrctype {
       union {
               int __error;


          struct {
            unsigned short __syscode,
                           __rc;
          } __abend;
          struct {
             unsigned char __fdbk_fill,
                           __rc,
                           __ftncd,
                           __fdbk;
          } __feedback;
          struct {
             unsigned short __svc99_info,
                            __svc99_error;
          } __alloc;
       } __code;
       unsigned int __RBA;





       unsigned int __last_op;
       struct {
        unsigned int __len_fill;
        unsigned int __len;
        char __str[120];
        unsigned int __parmr0;
        unsigned int __parmr1;
        unsigned int __fill2[2];
        char __str2[64];

       } __msg;


       unsigned char __rplfdbwd[4];





       unsigned long long __XRBA;





       unsigned char __amrc_noseek_to_seek;

       char __amrc_pad[23];


    } __amrc_type;



    typedef __amrc_type *__amrc_ptr;




    typedef struct __amrc2type {
             int __error2;
             char __pad__error2[4];
        FILE *__fileptr;
             int __reserved[6];
    } __amrc2_type;



    typedef __amrc2_type *__amrc2_ptr;
        FILE *fdopen(int, const char *);
        int fileno(FILE *);
        char *ctermid(char *);
         char *cuserid(char *);
          int getopt(int, char * const [], const char *);
         int getw(FILE *);
         int putw(int, FILE *);


       extern char *optarg;
       extern int optind, opterr, optopt;
       int pclose(FILE *);
       FILE *popen(const char *, const char *);
       char *tempnam(const char *, const char *);
#pragma map (vsnprintf, "\174\174VSNPT2")
#pragma map (vsnprintf2, "\174\174VSNPT2")
#pragma map (vfscanf, "\174\174VFSC2")
#pragma map (vscanf, "\174\174VSC2")
#pragma map (vsscanf, "\174\174VSSC2")
 int snprintf (char *, size_t, const char *, ...);



      int vsnprintf (char *, size_t, const char *, va_list);



      int vfscanf (FILE * , const char * , va_list );


      int vscanf (const char * , va_list );

      int vsscanf (const char * , const char * , va_list );
      int putc_unlocked (int,FILE *);
      int putchar_unlocked (int);
      int getc_unlocked (FILE *);
      int getchar_unlocked (void);
      void flockfile (FILE *);
      int ftrylockfile (FILE *);
      void funlockfile (FILE *);
#pragma map (__snprtf, "\174\174SNPRTF")


 int __snprtf (char *, size_t, const char *, ...);
    }


#pragma checkout(resume)


namespace std { inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::fclose;
using ::fflush;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;

using ::vfprintf;
using ::vfscanf;
using ::vsscanf;

using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::putc;
using ::ungetc;
using ::fread;
using ::fwrite;
using ::fgetpos;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;


using ::fopen;
using ::freopen;
using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;



using ::getchar;


using ::gets;

using ::scanf;
using ::vscanf;



using ::printf;
using ::putchar;
using ::puts;
using ::vprintf;


} }





#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
      } extern "C++" {
        inline int isalnum(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x0800));}
        inline int isalpha(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x0100));}
        inline int iscntrl(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x0020));}
        inline int isdigit(int _E) {return ((( *((__cusp * const)_Gtab(13)) )[(_E)] & 0x0002));}
        inline int isgraph(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x0200));}
        inline int islower(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x0040));}
        inline int isprint(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x0400));}
        inline int ispunct(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x0010));}
        inline int isspace(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x0008));}
        inline int isupper(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x0080));}
        inline int isxdigit(int _E) {return ((( *((__cusp * const)_Gtab(13)) )[(_E)] & 0x0001));}
        inline int tolower(int _E) {return (((short)(( *((__cusp * const) (*(_Gtab(5))) ) )[(_E) + 514])));}
        inline int toupper(int _E) {return (((short)(( *((__cusp * const) (*(_Gtab(5))) ) )[(_E) + 257])));}
        inline int isblank(int _E) {return ((( *((__cusp * const) (*(_Gtab(5))) ) )[(_E)] & 0x1000u));}

      } extern "C" {
        int isascii (int);
        int toascii (int);
        int _toupper (int);
        int _tolower (int);
     }


#pragma checkout(resume)





#pragma map(isascii, "\174\174ISAS2")


namespace std { inline namespace __1 {
using ::isalnum;
using ::isalpha;
using ::isblank;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;

} }




#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
  typedef int wctrans_t;







  wctrans_t wctrans (const char *);
  wint_t towctrans (wint_t,wctrans_t);
    extern "C++" {
      inline int iswblank(wint_t c) {return (( *((int *)(_Gtab(1))) )=(c),((( *((int *)(_Gtab(1))) ))<256?(( *((__cusp * const) (*(_Gtab(5))) ) )[( *((int *)(_Gtab(1))) )] & 0x1000u):(((((char * const) (*(_Gtab(21)))) == 0) || (((char * const) (*(_Gtab(21))))[( *((int *)(_Gtab(1))) )>>8] == 0)) ? 0 : ((unsigned int * const) (*(_Gtab(22))))[(((char * const) (*(_Gtab(21)))) [( *((int *)(_Gtab(1))) )>>8]*256)+(( *((int *)(_Gtab(1))) )&0x00ff)] & 0x1000u)));}
    }







      }


#pragma checkout(resume)


namespace std { inline namespace __1 {

using ::wint_t;
using ::wctrans_t;
using ::wctype_t;
using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::iswctype;
using ::wctype;
using ::towlower;
using ::towupper;
using ::towctrans;
using ::wctrans;

} }


namespace std { inline namespace __1 {

using ::mbstate_t;
using ::size_t;
using ::tm;
using ::wint_t;
using ::FILE;
using ::fwprintf;
using ::fwscanf;
using ::swprintf;
using ::vfwprintf;
using ::vswprintf;

using ::swscanf;
using ::vfwscanf;
using ::vswscanf;

using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::getwc;
using ::putwc;
using ::ungetwc;
using ::wcstod;

using ::wcstof;
using ::wcstold;

using ::wcstol;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::wcscpy;
using ::wcsncpy;
using ::wcscat;
using ::wcsncat;
using ::wcscmp;
using ::wcscoll;
using ::wcsncmp;
using ::wcsxfrm;
using ::wcschr;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsstr;
using ::wmemchr;
using ::wcscspn;
using ::wcslen;
using ::wcsspn;
using ::wcstok;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wcsftime;
using ::btowc;
using ::wctob;
using ::mbsinit;
using ::mbrlen;
using ::mbrtowc;
using ::wcrtomb;
using ::mbsrtowcs;
using ::wcsrtombs;


using ::getwchar;

using ::vwscanf;

using ::wscanf;



using ::putwchar;
using ::vwprintf;
using ::wprintf;


} }







namespace std { inline namespace __1 {



template <class _CharT> struct __attribute__((__visibility__("default"))) char_traits {
  typedef _CharT char_type;
  typedef int int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1,
                                          char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1,
                                          char_type __c2) noexcept {
    return __c1 < __c2;
  }

  static int compare(const char_type *__s1, const char_type *__s2, size_t __n);
  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_t length(const char_type *__s);
  __attribute__((__visibility__("hidden"), __always_inline__))
  static const char_type *find(const char_type *__s, size_t __n,
                               const char_type &__a);
  static char_type *move(char_type *__s1, const char_type *__s2, size_t __n);
  __attribute__((__visibility__("hidden"), __always_inline__))
  static char_type *copy(char_type *__s1, const char_type *__s2, size_t __n);
  __attribute__((__visibility__("hidden"), __always_inline__))
  static char_type *assign(char_type *__s, size_t __n, char_type __a);

  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type
  to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type
  to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                                   int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept {
    return int_type((-1));
  }
};

template <class _CharT>
int char_traits<_CharT>::compare(const char_type *__s1, const char_type *__s2,
                                 size_t __n) {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

template <class _CharT>
inline size_t char_traits<_CharT>::length(const char_type *__s) {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

template <class _CharT>
inline const _CharT *char_traits<_CharT>::find(const char_type *__s, size_t __n,
                                               const char_type &__a) {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return 0;
}

template <class _CharT>
_CharT *char_traits<_CharT>::move(char_type *__s1, const char_type *__s2,
                                  size_t __n) {
  char_type *__r = __s1;
  if (__s1 < __s2) {
    for (; __n; --__n, ++__s1, ++__s2)
      assign(*__s1, *__s2);
  } else if (__s2 < __s1) {
    __s1 += __n;
    __s2 += __n;
    for (; __n; --__n)
      assign(*--__s1, *--__s2);
  }
  return __r;
}

template <class _CharT>
inline _CharT *char_traits<_CharT>::copy(char_type *__s1, const char_type *__s2,
                                         size_t __n) {
  ((void)0);

  char_type *__r = __s1;
  for (; __n; --__n, ++__s1, ++__s2)
    assign(*__s1, *__s2);
  return __r;
}

template <class _CharT>
inline _CharT *char_traits<_CharT>::assign(char_type *__s, size_t __n,
                                           char_type __a) {
  char_type *__r = __s;
  for (; __n; --__n, ++__s)
    assign(*__s, __a);
  return __r;
}



template <> struct __attribute__((__visibility__("default"))) char_traits<char> {
  typedef char char_type;
  typedef int int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1,
                                          char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1,
                                          char_type __c2) noexcept {
    return (unsigned char)__c1 < (unsigned char)__c2;
  }

  static inline int compare(const char_type *__s1, const char_type *__s2,
                            size_t __n) noexcept {
    return __n == 0 ? 0 : memcmp(__s1, __s2, __n);
  }
  static inline size_t length(const char_type *__s) noexcept {
    return strlen(__s);
  }
  static inline const char_type *find(const char_type *__s, size_t __n,
                                      const char_type &__a) noexcept {
    return __n == 0 ? 0
                    : (const char_type *)memchr(__s, to_int_type(__a), __n);
  }
  static inline char_type *move(char_type *__s1, const char_type *__s2,
                                size_t __n) noexcept {
    return __n == 0 ? __s1 : (char_type *)memmove(__s1, __s2, __n);
  }
  static inline char_type *copy(char_type *__s1, const char_type *__s2,
                                size_t __n) noexcept {
    ((void)0);

    return __n == 0 ? __s1 : (char_type *)memcpy(__s1, __s2, __n);
  }
  static inline char_type *assign(char_type *__s, size_t __n,
                                  char_type __a) noexcept {
    return __n == 0 ? __s : (char_type *)memset(__s, to_int_type(__a), __n);
  }

  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type
  to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type
  to_int_type(char_type __c) noexcept {
    return int_type((unsigned char)__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                                   int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept {
    return int_type((-1));
  }
};



template <> struct __attribute__((__visibility__("default"))) char_traits<wchar_t> {
  typedef wchar_t char_type;
  typedef wint_t int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1,
                                          char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1,
                                          char_type __c2) noexcept {
    return __c1 < __c2;
  }

  static inline int compare(const char_type *__s1, const char_type *__s2,
                            size_t __n) noexcept {
    return __n == 0 ? 0 : wmemcmp(__s1, __s2, __n);
  }
  static inline size_t length(const char_type *__s) noexcept {
    return wcslen(__s);
  }
  static inline const char_type *find(const char_type *__s, size_t __n,
                                      const char_type &__a) noexcept {
    return __n == 0 ? 0 : (const char_type *)wmemchr(__s, __a, __n);
  }
  static inline char_type *move(char_type *__s1, const char_type *__s2,
                                size_t __n) noexcept {
    return __n == 0 ? __s1 : (char_type *)wmemmove(__s1, __s2, __n);
  }
  static inline char_type *copy(char_type *__s1, const char_type *__s2,
                                size_t __n) noexcept {
    ((void)0);

    return __n == 0 ? __s1 : (char_type *)wmemcpy(__s1, __s2, __n);
  }
  static inline char_type *assign(char_type *__s, size_t __n,
                                  char_type __a) noexcept {
    return __n == 0 ? __s : (char_type *)wmemset(__s, __a, __n);
  }

  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type
  to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type
  to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                                   int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept {
    return int_type(-1);
  }
};



template <> struct __attribute__((__visibility__("default"))) char_traits<char16_t> {
  typedef char16_t char_type;
  typedef uint_least16_t int_type;
  typedef streamoff off_type;
  typedef u16streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1,
                                          char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1,
                                          char_type __c2) noexcept {
    return __c1 < __c2;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  static int compare(const char_type *__s1, const char_type *__s2,
                     size_t __n) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_t length(const char_type *__s) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static const char_type *find(const char_type *__s, size_t __n,
                               const char_type &__a) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static char_type *move(char_type *__s1, const char_type *__s2,
                         size_t __n) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static char_type *copy(char_type *__s1, const char_type *__s2,
                         size_t __n) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static char_type *assign(char_type *__s, size_t __n, char_type __a) noexcept;

  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type
  to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type
  to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                                   int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept {
    return int_type(0xFFFF);
  }
};

inline int char_traits<char16_t>::compare(const char_type *__s1,
                                          const char_type *__s2,
                                          size_t __n) noexcept {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

inline size_t char_traits<char16_t>::length(const char_type *__s) noexcept {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

inline const char16_t *
char_traits<char16_t>::find(const char_type *__s, size_t __n,
                            const char_type &__a) noexcept {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return 0;
}

inline char16_t *char_traits<char16_t>::move(char_type *__s1,
                                             const char_type *__s2,
                                             size_t __n) noexcept {
  char_type *__r = __s1;
  if (__s1 < __s2) {
    for (; __n; --__n, ++__s1, ++__s2)
      assign(*__s1, *__s2);
  } else if (__s2 < __s1) {
    __s1 += __n;
    __s2 += __n;
    for (; __n; --__n)
      assign(*--__s1, *--__s2);
  }
  return __r;
}

inline char16_t *char_traits<char16_t>::copy(char_type *__s1,
                                             const char_type *__s2,
                                             size_t __n) noexcept {
  ((void)0);

  char_type *__r = __s1;
  for (; __n; --__n, ++__s1, ++__s2)
    assign(*__s1, *__s2);
  return __r;
}

inline char16_t *char_traits<char16_t>::assign(char_type *__s, size_t __n,
                                               char_type __a) noexcept {
  char_type *__r = __s;
  for (; __n; --__n, ++__s)
    assign(*__s, __a);
  return __r;
}

template <> struct __attribute__((__visibility__("default"))) char_traits<char32_t> {
  typedef char32_t char_type;
  typedef uint_least32_t int_type;
  typedef streamoff off_type;
  typedef u32streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1,
                                          char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1,
                                          char_type __c2) noexcept {
    return __c1 < __c2;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  static int compare(const char_type *__s1, const char_type *__s2,
                     size_t __n) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_t length(const char_type *__s) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static const char_type *find(const char_type *__s, size_t __n,
                               const char_type &__a) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static char_type *move(char_type *__s1, const char_type *__s2,
                         size_t __n) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static char_type *copy(char_type *__s1, const char_type *__s2,
                         size_t __n) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static char_type *assign(char_type *__s, size_t __n, char_type __a) noexcept;

  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type
  to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type
  to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                                   int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept {
    return int_type(0xFFFFFFFF);
  }
};

inline int char_traits<char32_t>::compare(const char_type *__s1,
                                          const char_type *__s2,
                                          size_t __n) noexcept {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

inline size_t char_traits<char32_t>::length(const char_type *__s) noexcept {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

inline const char32_t *
char_traits<char32_t>::find(const char_type *__s, size_t __n,
                            const char_type &__a) noexcept {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return 0;
}

inline char32_t *char_traits<char32_t>::move(char_type *__s1,
                                             const char_type *__s2,
                                             size_t __n) noexcept {
  char_type *__r = __s1;
  if (__s1 < __s2) {
    for (; __n; --__n, ++__s1, ++__s2)
      assign(*__s1, *__s2);
  } else if (__s2 < __s1) {
    __s1 += __n;
    __s2 += __n;
    for (; __n; --__n)
      assign(*--__s1, *--__s2);
  }
  return __r;
}

inline char32_t *char_traits<char32_t>::copy(char_type *__s1,
                                             const char_type *__s2,
                                             size_t __n) noexcept {
  ((void)0);

  char_type *__r = __s1;
  for (; __n; --__n, ++__s1, ++__s2)
    assign(*__s1, *__s2);
  return __r;
}

inline char32_t *char_traits<char32_t>::assign(char_type *__s, size_t __n,
                                               char_type __a) noexcept {
  char_type *__r = __s;
  for (; __n; --__n, ++__s)
    assign(*__s, __a);
  return __r;
}






template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_find(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept {
  if (__pos >= __sz)
    return __npos;
  const _CharT *__r = _Traits::find(__p + __pos, __sz - __pos, __c);
  if (__r == 0)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_find(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos,
           _SizeT __n) noexcept {
  if (__pos > __sz || __sz - __pos < __n)
    return __npos;
  if (__n == 0)
    return __pos;
  const _CharT *__r = std::__1::__search(__p + __pos, __p + __sz, __s, __s + __n,
                                      _Traits::eq, random_access_iterator_tag(),
                                      random_access_iterator_tag())
                          .first;
  if (__r == __p + __sz)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}



template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz, _CharT __c,
            _SizeT __pos) noexcept {
  if (__sz < 1)
    return __npos;
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT *__ps = __p + __pos; __ps != __p;) {
    if (_Traits::eq(*--__ps, __c))
      return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_rfind(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos,
            _SizeT __n) noexcept {
  __pos = std::__1::min(__pos, __sz);
  if (__n < __sz - __pos)
    __pos += __n;
  else
    __pos = __sz;
  const _CharT *__r = std::__1::__find_end(
      __p, __p + __pos, __s, __s + __n, _Traits::eq,
      random_access_iterator_tag(), random_access_iterator_tag());
  if (__n > 0 && __r == __p + __pos)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_find_first_of(const _CharT *__p, _SizeT __sz, const _CharT *__s,
                    _SizeT __pos, _SizeT __n) noexcept {
  if (__pos >= __sz || __n == 0)
    return __npos;
  const _CharT *__r = std::__1::__find_first_of_ce(__p + __pos, __p + __sz, __s,
                                                __s + __n, _Traits::eq);
  if (__r == __p + __sz)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_find_last_of(const _CharT *__p, _SizeT __sz, const _CharT *__s,
                   _SizeT __pos, _SizeT __n) noexcept {
  if (__n != 0) {
    if (__pos < __sz)
      ++__pos;
    else
      __pos = __sz;
    for (const _CharT *__ps = __p + __pos; __ps != __p;) {
      const _CharT *__r = _Traits::find(__s, __n, *--__ps);
      if (__r)
        return static_cast<_SizeT>(__ps - __p);
    }
  }
  return __npos;
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz, const _CharT *__s,
                        _SizeT __pos, _SizeT __n) noexcept {
  if (__pos < __sz) {
    const _CharT *__pe = __p + __sz;
    for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps)
      if (_Traits::find(__s, __n, *__ps) == 0)
        return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz, _CharT __c,
                        _SizeT __pos) noexcept {
  if (__pos < __sz) {
    const _CharT *__pe = __p + __sz;
    for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps)
      if (!_Traits::eq(*__ps, __c))
        return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}


template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz, const _CharT *__s,
                       _SizeT __pos, _SizeT __n) noexcept {
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT *__ps = __p + __pos; __ps != __p;)
    if (_Traits::find(__s, __n, *--__ps) == 0)
      return static_cast<_SizeT>(__ps - __p);
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT __attribute__((__visibility__("hidden"), __always_inline__))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz, _CharT __c,
                       _SizeT __pos) noexcept {
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT *__ps = __p + __pos; __ps != __p;)
    if (!_Traits::eq(*--__ps, __c))
      return static_cast<_SizeT>(__ps - __p);
  return __npos;
}

template <class _Ptr>
inline __attribute__((__visibility__("hidden"), __always_inline__)) size_t __do_string_hash(_Ptr __p, _Ptr __e) {
  typedef typename iterator_traits<_Ptr>::value_type value_type;
  return __murmur2_or_cityhash<size_t>()(__p, (__e - __p) * sizeof(value_type));
}

template <class _CharT, class _Iter, class _Traits = char_traits<_CharT>>
struct __quoted_output_proxy {
  _Iter __first;
  _Iter __last;
  _CharT __delim;
  _CharT __escape;

  __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)
      : __first(__f), __last(__l), __delim(__d), __escape(__e) {}

};

} }


namespace std { inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__visibility__("default"))) basic_string_view {
public:

  typedef _Traits traits_type;
  typedef _CharT value_type;
  typedef const _CharT *pointer;
  typedef const _CharT *const_pointer;
  typedef const _CharT &reference;
  typedef const _CharT &const_reference;
  typedef const_pointer const_iterator;
  typedef const_iterator iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef const_reverse_iterator reverse_iterator;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  static constexpr const size_type npos = -1;


  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) basic_string_view() noexcept
      : __data(nullptr),
        __size(0) {}

  constexpr __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string_view(const basic_string_view &) noexcept = default;

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string_view &operator=(const basic_string_view &) noexcept = default;

  constexpr __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string_view(const _CharT *__s, size_type __len)
      : __data(__s), __size(__len) {




  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string_view(const _CharT *__s)
      : __data(__s), __size(_Traits::length(__s)) {}


  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator
  begin() const noexcept {
    return cbegin();
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator
  end() const noexcept {
    return cend();
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator
  cbegin() const noexcept {
    return __data;
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator
  cend() const noexcept {
    return __data + __size;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(cend());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(cbegin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(cend());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(cbegin());
  }


  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) size_type size() const noexcept {
    return __size;
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  length() const noexcept {
    return __size;
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  max_size() const noexcept {
    return numeric_limits<size_type>::max();
  }

  constexpr bool __attribute__((__visibility__("hidden"), __always_inline__)) empty() const noexcept {
    return __size == 0;
  }


  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) const_reference
  operator[](size_type __pos) const noexcept {
    return __data[__pos];
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) const_reference
  at(size_type __pos) const {
    return __pos >= size()
               ? (__throw_out_of_range("string_view::at"), __data[0])
               : __data[__pos];
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) const_reference front() const {
    return ((void)0),
           __data[0];
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) const_reference back() const {
    return ((void)0),
           __data[__size - 1];
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) const_pointer
  data() const noexcept {
    return __data;
  }


                                __attribute__((__visibility__("hidden"), __always_inline__)) void
  clear() noexcept {
    __data = nullptr;
    __size = 0;
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) void
  remove_prefix(size_type __n) noexcept {
    ((void)0);

    __data += __n;
    __size -= __n;
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) void
  remove_suffix(size_type __n) noexcept {
    ((void)0);

    __size -= __n;
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) void
  swap(basic_string_view &__other) noexcept {
    const value_type *__p = __data;
    __data = __other.__data;
    __other.__data = __p;

    size_type __sz = __size;
    __size = __other.__size;
    __other.__size = __sz;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type copy(_CharT *__s, size_type __n, size_type __pos = 0) const {
    if (__pos > size())
      __throw_out_of_range("string_view::copy");
    size_type __rlen = std::__1::min(__n, size() - __pos);
    copy_n(begin() + __pos, __rlen, __s);
    return __rlen;
  }

  constexpr __attribute__((__visibility__("hidden"), __always_inline__)) basic_string_view
  substr(size_type __pos = 0, size_type __n = npos) const {
    return __pos > size() ? (__throw_out_of_range("string_view::substr"),
                             basic_string_view())
                          : basic_string_view(data() + __pos,
                                              std::__1::min(__n, size() - __pos));
  }

                                int
  compare(basic_string_view __sv) const noexcept {
    size_type __rlen = std::__1::min(size(), __sv.size());
    int __retval = _Traits::compare(data(), __sv.data(), __rlen);
    if (__retval == 0)
      __retval = size() == __sv.size() ? 0 : (size() < __sv.size() ? -1 : 1);
    return __retval;
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) int
  compare(size_type __pos1, size_type __n1, basic_string_view __sv) const {
    return substr(__pos1, __n1).compare(__sv);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) int
  compare(size_type __pos1, size_type __n1, basic_string_view _sv,
          size_type __pos2, size_type __n2) const {
    return substr(__pos1, __n1).compare(_sv.substr(__pos2, __n2));
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) int
  compare(const _CharT *__s) const noexcept {
    return compare(basic_string_view(__s));
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) int
  compare(size_type __pos1, size_type __n1, const _CharT *__s) const {
    return substr(__pos1, __n1).compare(basic_string_view(__s));
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) int
  compare(size_type __pos1, size_type __n1, const _CharT *__s,
          size_type __n2) const {
    return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
  }


                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find(basic_string_view __s, size_type __pos = 0) const noexcept {
    ((void)0);

    return __str_find<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find(_CharT __c, size_type __pos = 0) const noexcept {
    return __str_find<value_type, size_type, traits_type, npos>(data(), size(),
                                                                __c, __pos);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);

    return __str_find<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find(const _CharT *__s, size_type __pos = 0) const {
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  rfind(basic_string_view __s, size_type __pos = npos) const noexcept {
    ((void)0);

    return __str_rfind<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  rfind(_CharT __c, size_type __pos = npos) const noexcept {
    return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(),
                                                                 __c, __pos);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  rfind(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);

    return __str_rfind<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  rfind(const _CharT *__s, size_type __pos = npos) const {
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept {
    ((void)0);

    return __str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_first_of(_CharT __c, size_type __pos = 0) const noexcept {
    return find(__c, __pos);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_first_of(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);

    return __str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_first_of(const _CharT *__s, size_type __pos = 0) const {
    ((void)0);

    return __str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_last_of(basic_string_view __s, size_type __pos = npos) const noexcept {
    ((void)0);

    return __str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_last_of(_CharT __c, size_type __pos = npos) const noexcept {
    return rfind(__c, __pos);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_last_of(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);

    return __str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_last_of(const _CharT *__s, size_type __pos = npos) const {
    ((void)0);

    return __str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_first_not_of(basic_string_view __s,
                    size_type __pos = 0) const noexcept {
    ((void)0);

    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept {
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __c, __pos);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);

    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_first_not_of(const _CharT *__s, size_type __pos = 0) const {
    ((void)0);

    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }


                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_last_not_of(basic_string_view __s,
                   size_type __pos = npos) const noexcept {
    ((void)0);

    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept {
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __c, __pos);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);

    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

                                __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  find_last_not_of(const _CharT *__s, size_type __pos = npos) const {
    ((void)0);

    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }

private:
  const value_type *__data;
  size_type __size;
};



template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(basic_string_view<_CharT, _Traits> __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(basic_string_view<_CharT, _Traits> __lhs,
           typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs)
    noexcept {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(basic_string_view<_CharT, _Traits> __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return true;
  return __lhs.compare(__rhs) != 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(basic_string_view<_CharT, _Traits> __lhs,
           typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs)
    noexcept {
  if (__lhs.size() != __rhs.size())
    return true;
  return __lhs.compare(__rhs) != 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return true;
  return __lhs.compare(__rhs) != 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(basic_string_view<_CharT, _Traits> __lhs,
          basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(basic_string_view<_CharT, _Traits> __lhs,
          typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs)
    noexcept {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
          basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) < 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(basic_string_view<_CharT, _Traits> __lhs,
          basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) > 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(basic_string_view<_CharT, _Traits> __lhs,
          typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs)
    noexcept {
  return __lhs.compare(__rhs) > 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
          basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) > 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(basic_string_view<_CharT, _Traits> __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) <= 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(basic_string_view<_CharT, _Traits> __lhs,
           typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs)
    noexcept {
  return __lhs.compare(__rhs) <= 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) <= 0;
}


template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(basic_string_view<_CharT, _Traits> __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) >= 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(basic_string_view<_CharT, _Traits> __lhs,
           typename common_type<basic_string_view<_CharT, _Traits>>::type __rhs)
    noexcept {
  return __lhs.compare(__rhs) >= 0;
}

template <class _CharT, class _Traits>
                              __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) >= 0;
}

typedef basic_string_view<char> string_view;
typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;
typedef basic_string_view<wchar_t> wstring_view;


template <class _CharT, class _Traits>
struct __attribute__((__visibility__("default"))) hash<basic_string_view<_CharT, _Traits>>
    : public unary_function<basic_string_view<_CharT, _Traits>, size_t> {
  size_t
  operator()(const basic_string_view<_CharT, _Traits> __val) const noexcept;
};

template <class _CharT, class _Traits>
size_t hash<basic_string_view<_CharT, _Traits>>::
operator()(const basic_string_view<_CharT, _Traits> __val) const noexcept {
  return __do_string_hash(__val.data(), __val.data() + __val.size());
}
} }








namespace std { inline namespace __1 {



template <class _StateT> class __attribute__((__visibility__("default"))) fpos {
private:
  _StateT __st_;
  streamoff __off_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) fpos(streamoff __off = streamoff())
      : __st_(), __off_(__off) {}

  __attribute__((__visibility__("hidden"), __always_inline__)) operator streamoff() const { return __off_; }

  __attribute__((__visibility__("hidden"), __always_inline__)) _StateT state() const { return __st_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) void state(_StateT __st) { __st_ = __st; }

  __attribute__((__visibility__("hidden"), __always_inline__)) fpos &operator+=(streamoff __off) {
    __off_ += __off;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) fpos operator+(streamoff __off) const {
    fpos __t(*this);
    __t += __off;
    return __t;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) fpos &operator-=(streamoff __off) {
    __off_ -= __off;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) fpos operator-(streamoff __off) const {
    fpos __t(*this);
    __t -= __off;
    return __t;
  }
};

template <class _StateT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) streamoff operator-(const fpos<_StateT> &__x,
                                                     const fpos<_StateT> &__y) {
  return streamoff(__x) - streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator==(const fpos<_StateT> &__x,
                                                 const fpos<_StateT> &__y) {
  return streamoff(__x) == streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator!=(const fpos<_StateT> &__x,
                                                 const fpos<_StateT> &__y) {
  return streamoff(__x) != streamoff(__y);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__x,
          const basic_string<_CharT, _Traits, _Allocator> &__y);

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT *__x,
          const basic_string<_CharT, _Traits, _Allocator> &__y);

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT, _Traits, _Allocator> &__y);

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__x,
          const _CharT *__y);

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, _CharT __y);

template <bool> class __attribute__((__visibility__("default"))) __basic_string_common {
protected:
  [[noreturn]] void __throw_length_error() const;
  [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void __basic_string_common<__b>::__throw_length_error() const {
  std::__1::__throw_length_error("basic_string");
}

template <bool __b>
void __basic_string_common<__b>::__throw_out_of_range() const {
  std::__1::__throw_out_of_range("basic_string");
}





extern template class __basic_string_common<true>;
template <class _Iter, bool = __is_forward_iterator<_Iter>::value>
struct __libcpp_string_gets_noexcept_iterator_impl
    : public integral_constant<bool, ((noexcept(++(declval<_Iter &>())) && is_nothrow_assignable<_Iter &, _Iter>::value && noexcept(declval<_Iter>() == declval<_Iter>()) && noexcept(*declval<_Iter>())))> {};





template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false>
    : public false_type {};


template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator
    : public integral_constant<bool, (__libcpp_is_trivial_iterator<_Iter>::value || __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value)> {};



template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view
    : public integral_constant<bool, ((is_convertible<const _Tp &, basic_string_view<_CharT, _Traits>>::value && !is_convertible<const _Tp &, const _CharT *>::value))> {};
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__visibility__("default"))) basic_string : private __basic_string_common<true> {
public:
  typedef basic_string __self;
  typedef basic_string_view<_CharT, _Traits> __self_view;
  typedef _Traits traits_type;
  typedef typename traits_type::char_type value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;

  static_assert(is_pod<value_type>::value,
                "Character type of basic_string must be a POD");
  static_assert((is_same<_CharT, value_type>::value),
                "traits_type::char_type must be the same type as CharT");
  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");




  typedef __wrap_iter<pointer> iterator;
  typedef __wrap_iter<const_pointer> const_iterator;

  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
  struct __long {
    size_type __cap_;
    size_type __size_;
    pointer __data_;
  };


  enum {__short_mask = 0x80};
  enum {__long_mask = ~(size_type(~0) >> 1)};





  enum {__min_cap = (sizeof(__long) - 1) / sizeof(value_type) > 2
                        ? (sizeof(__long) - 1) / sizeof(value_type)
                        : 2};

  struct __short {
    union {
      unsigned char __size_;
      value_type __lx;
    };
    value_type __data_[__min_cap];
  };



  union __ulx {
    __long __lx;
    __short __lxx;
  };

  enum { __n_words = sizeof(__ulx) / sizeof(size_type) };

  struct __raw {
    size_type __words[__n_words];
  };

  struct __rep {
    union {
      __long __l;
      __short __s;
      __raw __r;
    };
  };

  __compressed_pair<__rep, allocator_type> __r_;

public:
  static const size_type npos = -1;

  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string()
      noexcept(is_nothrow_default_constructible<allocator_type>::value);

  __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_string(const allocator_type &__a)

      noexcept(is_nothrow_copy_constructible<allocator_type>::value);




  basic_string(const basic_string &__str);
  basic_string(const basic_string &__str, const allocator_type &__a);


  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(basic_string &&__str)

      noexcept(is_nothrow_move_constructible<allocator_type>::value);




  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(basic_string &&__str, const allocator_type &__a);

  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string(const value_type *__s);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(const value_type *__s, const allocator_type &__a);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(const value_type *__s, size_type __n);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(const value_type *__s, size_type __n, const allocator_type &__a);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(size_type __n, value_type __c);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(size_type __n, value_type __c, const allocator_type &__a);
  basic_string(const basic_string &__str, size_type __pos, size_type __n,
               const allocator_type &__a = allocator_type());
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(const basic_string &__str, size_type __pos,
               const allocator_type &__a = allocator_type());
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_string(__self_view __sv);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(__self_view __sv, const allocator_type &__a);
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string(_InputIterator __first,
                                         _InputIterator __last);
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string(_InputIterator __first,
                                         _InputIterator __last,
                                         const allocator_type &__a);

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(initializer_list<value_type> __il);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string(initializer_list<value_type> __il, const allocator_type &__a);


  ~basic_string();

  __attribute__((__visibility__("hidden"), __always_inline__))
  operator __self_view() const noexcept { return __self_view(data(), size()); }

  basic_string &operator=(const basic_string &__str);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &operator=(__self_view __sv) { return assign(__sv); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &operator=(basic_string &&__str) noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));


  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string &operator=(const value_type *__s) {
    return assign(__s);
  }
  basic_string &operator=(value_type __c);

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &operator=(initializer_list<value_type> __il) {
    return assign(__il.begin(), __il.size());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator begin() noexcept { return iterator(__get_pointer()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator begin() const noexcept {
    return const_iterator(__get_pointer());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator end() noexcept { return iterator(__get_pointer() + size()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator end() const noexcept {
    return const_iterator(__get_pointer() + size());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crend() const noexcept { return rend(); }

  __attribute__((__visibility__("hidden"), __always_inline__)) size_type size() const noexcept {
    return __is_long() ? __get_long_size() : __get_short_size();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type length() const noexcept {
    return size();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type max_size() const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type capacity() const noexcept {
    return (__is_long() ? __get_long_cap()
                        : static_cast<size_type>(__min_cap)) -
           1;
  }

  void resize(size_type __n, value_type __c);
  __attribute__((__visibility__("hidden"), __always_inline__)) void resize(size_type __n) {
    resize(__n, value_type());
  }

  void reserve(size_type res_arg = 0);
  __attribute__((__visibility__("hidden"), __always_inline__))
  void shrink_to_fit() noexcept { reserve(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) bool empty() const noexcept { return size() == 0; }

  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference
  operator[](size_type __pos) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __pos) noexcept;

  const_reference at(size_type __n) const;
  reference at(size_type __n);

  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string &
  operator+=(const basic_string &__str) {
    return append(__str);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string &operator+=(__self_view __sv) {
    return append(__sv);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string &operator+=(const value_type *__s) {
    return append(__s);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string &operator+=(value_type __c) {
    push_back(__c);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string &
  operator+=(initializer_list<value_type> __il) {
    return append(__il);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &append(const basic_string &__str);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &append(__self_view __sv) {
    return append(__sv.data(), __sv.size());
  }
  basic_string &append(const basic_string &__str, size_type __pos,
                       size_type __n = npos);
  template <class _Tp>
  typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  append(const _Tp &__t, size_type __pos, size_type __n = npos);
  basic_string &append(const value_type *__s, size_type __n);
  basic_string &append(const value_type *__s);
  basic_string &append(size_type __n, value_type __c);
  template <class _InputIterator>
  typename enable_if<
      __is_exactly_input_iterator<_InputIterator>::value ||
          !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
      basic_string &>::type
  append(_InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<
      __is_forward_iterator<_ForwardIterator>::value &&
          __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
      basic_string &>::type
  append(_ForwardIterator __first, _ForwardIterator __last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &append(initializer_list<value_type> __il) {
    return append(__il.begin(), __il.size());
  }


  void push_back(value_type __c);
  __attribute__((__visibility__("hidden"), __always_inline__))
  void pop_back();
  __attribute__((__visibility__("hidden"), __always_inline__)) reference front();
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference front() const;
  __attribute__((__visibility__("hidden"), __always_inline__)) reference back();
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference back() const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &assign(__self_view __sv) {
    return assign(__sv.data(), __sv.size());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &assign(const basic_string &__str) { return *this = __str; }

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &assign(basic_string &&str) noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {

    *this = std::__1::move(str);
    return *this;
  }

  basic_string &assign(const basic_string &__str, size_type __pos,
                       size_type __n = npos);
  template <class _Tp>
  typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  assign(const _Tp &__t, size_type pos, size_type n = npos);
  basic_string &assign(const value_type *__s, size_type __n);
  basic_string &assign(const value_type *__s);
  basic_string &assign(size_type __n, value_type __c);
  template <class _InputIterator>
  typename enable_if<
      __is_exactly_input_iterator<_InputIterator>::value ||
          !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
      basic_string &>::type
  assign(_InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<
      __is_forward_iterator<_ForwardIterator>::value &&
          __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
      basic_string &>::type
  assign(_ForwardIterator __first, _ForwardIterator __last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &assign(initializer_list<value_type> __il) {
    return assign(__il.begin(), __il.size());
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &insert(size_type __pos1, const basic_string &__str);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &insert(size_type __pos1, __self_view __sv) {
    return insert(__pos1, __sv.data(), __sv.size());
  }
  template <class _Tp>
  typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  insert(size_type __pos1, const _Tp &__t, size_type __pos2,
         size_type __n = npos);
  basic_string &insert(size_type __pos1, const basic_string &__str,
                       size_type __pos2, size_type __n = npos);
  basic_string &insert(size_type __pos, const value_type *__s, size_type __n);
  basic_string &insert(size_type __pos, const value_type *__s);
  basic_string &insert(size_type __pos, size_type __n, value_type __c);
  iterator insert(const_iterator __pos, value_type __c);
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __pos, size_type __n, value_type __c);
  template <class _InputIterator>
  typename enable_if<
      __is_exactly_input_iterator<_InputIterator>::value ||
          !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
      iterator>::type
  insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<
      __is_forward_iterator<_ForwardIterator>::value &&
          __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
      iterator>::type
  insert(const_iterator __pos, _ForwardIterator __first,
         _ForwardIterator __last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __pos, initializer_list<value_type> __il) {
    return insert(__pos, __il.begin(), __il.end());
  }


  basic_string &erase(size_type __pos = 0, size_type __n = npos);
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __pos);
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &replace(size_type __pos1, size_type __n1,
                        const basic_string &__str);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &replace(size_type __pos1, size_type __n1, __self_view __sv) {
    return replace(__pos1, __n1, __sv.data(), __sv.size());
  }
  basic_string &replace(size_type __pos1, size_type __n1,
                        const basic_string &__str, size_type __pos2,
                        size_type __n2 = npos);
  template <class _Tp>
  typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  replace(size_type __pos1, size_type __n1, const _Tp &__t, size_type __pos2,
          size_type __n2 = npos);
  basic_string &replace(size_type __pos, size_type __n1, const value_type *__s,
                        size_type __n2);
  basic_string &replace(size_type __pos, size_type __n1, const value_type *__s);
  basic_string &replace(size_type __pos, size_type __n1, size_type __n2,
                        value_type __c);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &replace(const_iterator __i1, const_iterator __i2,
                        const basic_string &__str);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &replace(const_iterator __i1, const_iterator __i2,
                        __self_view __sv) {
    return replace(__i1 - begin(), __i2 - __i1, __sv);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &replace(const_iterator __i1, const_iterator __i2,
                        const value_type *__s, size_type __n);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &replace(const_iterator __i1, const_iterator __i2,
                        const value_type *__s);
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &replace(const_iterator __i1, const_iterator __i2, size_type __n,
                        value_type __c);
  template <class _InputIterator>
  typename enable_if<__is_input_iterator<_InputIterator>::value,
                     basic_string &>::type
  replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1,
          _InputIterator __j2);

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string &replace(const_iterator __i1, const_iterator __i2,
                        initializer_list<value_type> __il) {
    return replace(__i1, __i2, __il.begin(), __il.end());
  }


  size_type copy(value_type *__s, size_type __n, size_type __pos = 0) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string substr(size_type __pos = 0, size_type __n = npos) const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(basic_string &__str)



      noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value);



  __attribute__((__visibility__("hidden"), __always_inline__))
  const value_type *c_str() const noexcept { return data(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const value_type *data() const noexcept {
    return std::__1::__to_raw_pointer(__get_pointer());
  }







  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type get_allocator() const noexcept { return __alloc(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find(const basic_string &__str,
                 size_type __pos = 0) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find(__self_view __sv, size_type __pos = 0) const noexcept;
  size_type find(const value_type *__s, size_type __pos,
                 size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find(const value_type *__s, size_type __pos = 0) const noexcept;
  size_type find(value_type __c, size_type __pos = 0) const noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type rfind(const basic_string &__str,
                  size_type __pos = npos) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type rfind(__self_view __sv, size_type __pos = 0) const noexcept;
  size_type rfind(const value_type *__s, size_type __pos,
                  size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type rfind(const value_type *__s,
                  size_type __pos = npos) const noexcept;
  size_type rfind(value_type __c, size_type __pos = npos) const noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_first_of(const basic_string &__str,
                          size_type __pos = 0) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_first_of(__self_view __sv,
                          size_type __pos = 0) const noexcept;
  size_type find_first_of(const value_type *__s, size_type __pos,
                          size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_first_of(const value_type *__s,
                          size_type __pos = 0) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_first_of(value_type __c, size_type __pos = 0) const noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_last_of(const basic_string &__str,
                         size_type __pos = npos) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_last_of(__self_view __sv, size_type __pos = 0) const noexcept;
  size_type find_last_of(const value_type *__s, size_type __pos,
                         size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_last_of(const value_type *__s,
                         size_type __pos = npos) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_last_of(value_type __c,
                         size_type __pos = npos) const noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_first_not_of(const basic_string &__str,
                              size_type __pos = 0) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_first_not_of(__self_view __sv,
                              size_type __pos = 0) const noexcept;
  size_type find_first_not_of(const value_type *__s, size_type __pos,
                              size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_first_not_of(const value_type *__s,
                              size_type __pos = 0) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_first_not_of(value_type __c,
                              size_type __pos = 0) const noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_last_not_of(const basic_string &__str,
                             size_type __pos = npos) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_last_not_of(__self_view __sv,
                             size_type __pos = 0) const noexcept;
  size_type find_last_not_of(const value_type *__s, size_type __pos,
                             size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_last_not_of(const value_type *__s,
                             size_type __pos = npos) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type find_last_not_of(value_type __c,
                             size_type __pos = npos) const noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  int compare(const basic_string &__str) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  int compare(__self_view __sv) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  int compare(size_type __pos1, size_type __n1, __self_view __sv) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  int compare(size_type __pos1, size_type __n1,
              const basic_string &__str) const;
  int compare(size_type __pos1, size_type __n1, const basic_string &__str,
              size_type __pos2, size_type __n2 = npos) const;
  template <class _Tp>
  inline __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type
  compare(size_type __pos1, size_type __n1, const _Tp &__t, size_type __pos2,
          size_type __n2 = npos) const;
  int compare(const value_type *__s) const noexcept;
  int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
  int compare(size_type __pos1, size_type __n1, const value_type *__s,
              size_type __n2) const;

  __attribute__((__visibility__("hidden"), __always_inline__)) bool __invariants() const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool __is_long() const noexcept {
    return bool(__r_.first().__s.__size_ & __short_mask);
  }
private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type &__alloc() noexcept { return __r_.second(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const allocator_type &__alloc() const noexcept { return __r_.second(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __set_short_size(size_type __s) noexcept

  {
    __r_.first().__s.__size_ = (unsigned char)(__s);
  }






  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type __get_short_size() const noexcept

  {
    return __r_.first().__s.__size_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __set_long_size(size_type __s) noexcept {
    __r_.first().__l.__size_ = __s;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type __get_long_size() const noexcept {
    return __r_.first().__l.__size_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __set_size(size_type __s) noexcept {
    if (__is_long())
      __set_long_size(__s);
    else
      __set_short_size(__s);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __set_long_cap(size_type __s) noexcept {
    __r_.first().__l.__cap_ = __long_mask | __s;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type __get_long_cap() const noexcept {
    return __r_.first().__l.__cap_ & size_type(~__long_mask);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __set_long_pointer(pointer __p) noexcept {
    __r_.first().__l.__data_ = __p;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pointer __get_long_pointer() noexcept { return __r_.first().__l.__data_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_pointer __get_long_pointer() const noexcept {
    return __r_.first().__l.__data_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pointer __get_short_pointer() noexcept {
    return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_pointer __get_short_pointer() const noexcept {
    return pointer_traits<const_pointer>::pointer_to(
        __r_.first().__s.__data_[0]);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pointer __get_pointer() noexcept {
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_pointer __get_pointer() const noexcept {
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __zero() noexcept {
    size_type(&__a)[__n_words] = __r_.first().__r.__words;
    for (unsigned __i = 0; __i < __n_words; ++__i)
      __a[__i] = 0;
  }

  template <size_type __a>
  static __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  __align_it(size_type __s) noexcept {
    return (__s + (__a - 1)) & ~(__a - 1);
  }
  enum { __alignment = 16 };
  static __attribute__((__visibility__("hidden"), __always_inline__)) size_type
  __recommend(size_type __s) noexcept {
    return (__s < __min_cap ? static_cast<size_type>(__min_cap)
                            : __align_it < sizeof(value_type) < __alignment
                                  ? __alignment / sizeof(value_type)
                                  : 1 > (__s + 1)) -
           1;
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void
  __init(const value_type *__s, size_type __sz, size_type __reserve);
  inline __attribute__((__visibility__("hidden"), __always_inline__)) void
  __init(const value_type *__s, size_type __sz);
  inline __attribute__((__visibility__("hidden"), __always_inline__)) void __init(size_type __n,
                                                               value_type __c);

  template <class _InputIterator>
  inline __attribute__((__visibility__("hidden"), __always_inline__))
      typename enable_if<__is_exactly_input_iterator<_InputIterator>::value,
                         void>::type
      __init(_InputIterator __first, _InputIterator __last);

  template <class _ForwardIterator>
  inline __attribute__((__visibility__("hidden"), __always_inline__))
      typename enable_if<__is_forward_iterator<_ForwardIterator>::value,
                         void>::type
      __init(_ForwardIterator __first, _ForwardIterator __last);

  void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                 size_type __n_copy, size_type __n_del, size_type __n_add = 0);
  void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap,
                             size_type __old_sz, size_type __n_copy,
                             size_type __n_del, size_type __n_add,
                             const value_type *__p_new_stuff);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __erase_to_end(size_type __pos);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const basic_string &__str) {
    __copy_assign_alloc(
        __str,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const basic_string &__str, true_type) {
    if (__alloc() != __str.__alloc()) {
      clear();
      shrink_to_fit();
    }
    __alloc() = __str.__alloc();
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const basic_string &, false_type) noexcept {}


  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign(basic_string &__str, false_type)
      noexcept(__alloc_traits::is_always_equal::value);
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign(basic_string &__str, true_type)



      noexcept(is_nothrow_move_assignable<allocator_type>::value);



  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(basic_string &__str) noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value) {


    __move_assign_alloc(
        __str,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_move_assignment::value>());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(basic_string &__c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::__1::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(basic_string &, false_type) noexcept {}

  __attribute__((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
  __attribute__((__visibility__("hidden"), __always_inline__)) void __invalidate_iterators_past(size_type);

  friend basic_string operator+<>(const basic_string &, const basic_string &);
  friend basic_string operator+<>(const value_type *, const basic_string &);
  friend basic_string operator+<>(value_type, const basic_string &);
  friend basic_string operator+<>(const basic_string &, const value_type *);
  friend basic_string operator+<>(const basic_string &, value_type);
};

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators() {



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type



                                                                       ) {
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string()
    noexcept(is_nothrow_default_constructible<allocator_type>::value) {



  __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const allocator_type &__a)

    noexcept(is_nothrow_copy_constructible<allocator_type>::value)



    : __r_(__a) {



  __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type *__s,
                                                       size_type __sz,
                                                       size_type __reserve) {
  if (__reserve > max_size())
    this->__throw_length_error();
  pointer __p;
  if (__reserve < __min_cap) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    size_type __cap = __recommend(__reserve);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
  traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type *__s,
                                                       size_type __sz) {
  if (__sz > max_size())
    this->__throw_length_error();
  pointer __p;
  if (__sz < __min_cap) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    size_type __cap = __recommend(__sz);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__1::__to_raw_pointer(__p), __s, __sz);
  traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type *__s) {
  ((void)0);
  __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const value_type *__s, const allocator_type &__a)
    : __r_(__a) {
  ((void)0);

  __init(__s, traits_type::length(__s));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type *__s,
                                                        size_type __n) {
  ((void)0);

  __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const value_type *__s, size_type __n, const allocator_type &__a)
    : __r_(__a) {
  ((void)0);

  __init(__s, __n);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string &__str)
    : __r_(__alloc_traits::select_on_container_copy_construction(
          __str.__alloc())) {
  if (!__str.__is_long())
    __r_.first().__r = __str.__r_.first().__r;
  else
    __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()),
           __str.__get_long_size());



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string &__str, const allocator_type &__a)
    : __r_(__a) {
  if (!__str.__is_long())
    __r_.first().__r = __str.__r_.first().__r;
  else
    __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()),
           __str.__get_long_size());



}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string &&__str)

    noexcept(is_nothrow_move_constructible<allocator_type>::value)



    : __r_(std::__1::move(__str.__r_)) {
  __str.__zero();





}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    basic_string &&__str, const allocator_type &__a)
    : __r_(__a) {
  if (__str.__is_long() && __a != __str.__alloc())
    __init(std::__1::__to_raw_pointer(__str.__get_long_pointer()),
           __str.__get_long_size());
  else {
    __r_.first().__r = __str.__r_.first().__r;
    __str.__zero();
  }





}



template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n,
                                                       value_type __c) {
  if (__n > max_size())
    this->__throw_length_error();
  pointer __p;
  if (__n < __min_cap) {
    __set_short_size(__n);
    __p = __get_short_pointer();
  } else {
    size_type __cap = __recommend(__n);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__n);
  }
  traits_type::assign(std::__1::__to_raw_pointer(__p), __n, __c);
  traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n,
                                                        value_type __c) {
  __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    size_type __n, value_type __c, const allocator_type &__a)
    : __r_(__a) {
  __init(__n, __c);



}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string &__str, size_type __pos, size_type __n,
    const allocator_type &__a)
    : __r_(__a) {
  size_type __str_sz = __str.size();
  if (__pos > __str_sz)
    this->__throw_out_of_range();
  __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string &__str, size_type __pos, const allocator_type &__a)
    : __r_(__a) {
  size_type __str_sz = __str.size();
  if (__pos > __str_sz)
    this->__throw_out_of_range();
  __init(__str.data() + __pos, __str_sz - __pos);



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(__self_view __sv) {
  __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    __self_view __sv, const allocator_type &__a)
    : __r_(__a) {
  __init(__sv.data(), __sv.size());



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if<__is_exactly_input_iterator<_InputIterator>::value,
                   void>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first,
                                                  _InputIterator __last) {
  __zero();

  try {

    for (; __first != __last; ++__first)
      push_back(*__first);

  } catch (...) {
    if (__is_long())
      __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
                                 __get_long_cap());
    throw;
  }

}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first,
                                                  _ForwardIterator __last) {
  size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__sz > max_size())
    this->__throw_length_error();
  pointer __p;
  if (__sz < __min_cap) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    size_type __cap = __recommend(__sz);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__sz);
  }
  for (; __first != __last; ++__first, (void)++__p)
    traits_type::assign(*__p, *__first);
  traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first,
                                                        _InputIterator __last) {
  __init(__first, __last);



}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    _InputIterator __first, _InputIterator __last, const allocator_type &__a)
    : __r_(__a) {
  __init(__first, __last);



}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<value_type> __il) {
  __init(__il.begin(), __il.end());



}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<value_type> __il, const allocator_type &__a)
    : __r_(__a) {
  __init(__il.begin(), __il.end());



}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string() {



  if (__is_long())
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
                               __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace(
    size_type __old_cap, size_type __delta_cap, size_type __old_sz,
    size_type __n_copy, size_type __n_del, size_type __n_add,
    const value_type *__p_new_stuff) {
  size_type __ms = max_size();
  if (__delta_cap > __ms - __old_cap - 1)
    this->__throw_length_error();
  pointer __old_p = __get_pointer();
  size_type __cap =
      __old_cap < __ms / 2 - __alignment
          ? __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap))
          : __ms - 1;
  pointer __p = __alloc_traits::allocate(__alloc(), __cap + 1);
  __invalidate_all_iterators();
  if (__n_copy != 0)
    traits_type::copy(std::__1::__to_raw_pointer(__p),
                      std::__1::__to_raw_pointer(__old_p), __n_copy);
  if (__n_add != 0)
    traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy, __p_new_stuff,
                      __n_add);
  size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
  if (__sec_cp_sz != 0)
    traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                      std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del,
                      __sec_cp_sz);
  if (__old_cap + 1 != __min_cap)
    __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
  __set_long_pointer(__p);
  __set_long_cap(__cap + 1);
  __old_sz = __n_copy + __n_add + __sec_cp_sz;
  __set_long_size(__old_sz);
  traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__grow_by(
    size_type __old_cap, size_type __delta_cap, size_type __old_sz,
    size_type __n_copy, size_type __n_del, size_type __n_add) {
  size_type __ms = max_size();
  if (__delta_cap > __ms - __old_cap)
    this->__throw_length_error();
  pointer __old_p = __get_pointer();
  size_type __cap =
      __old_cap < __ms / 2 - __alignment
          ? __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap))
          : __ms - 1;
  pointer __p = __alloc_traits::allocate(__alloc(), __cap + 1);
  __invalidate_all_iterators();
  if (__n_copy != 0)
    traits_type::copy(std::__1::__to_raw_pointer(__p),
                      std::__1::__to_raw_pointer(__old_p), __n_copy);
  size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
  if (__sec_cp_sz != 0)
    traits_type::copy(std::__1::__to_raw_pointer(__p) + __n_copy + __n_add,
                      std::__1::__to_raw_pointer(__old_p) + __n_copy + __n_del,
                      __sec_cp_sz);
  if (__old_cap + 1 != __min_cap)
    __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
  __set_long_pointer(__p);
  __set_long_cap(__cap + 1);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type *__s,
                                                  size_type __n) {
  ((void)0);
  size_type __cap = capacity();
  if (__cap >= __n) {
    value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
    traits_type::move(__p, __s, __n);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    __invalidate_iterators_past(__n);
  } else {
    size_type __sz = size();
    __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n,
                                                  value_type __c) {
  size_type __cap = capacity();
  if (__cap < __n) {
    size_type __sz = size();
    __grow_by(__cap, __n - __cap, __sz, 0, __sz);
  } else
    __invalidate_iterators_past(__n);
  value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
  traits_type::assign(__p, __n, __c);
  traits_type::assign(__p[__n], value_type());
  __set_size(__n);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c) {
  pointer __p;
  if (__is_long()) {
    __p = __get_long_pointer();
    __set_long_size(1);
  } else {
    __p = __get_short_pointer();
    __set_short_size(1);
  }
  traits_type::assign(*__p, __c);
  traits_type::assign(*++__p, value_type());
  __invalidate_iterators_past(1);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::
operator=(const basic_string &__str) {
  if (this != &__str) {
    __copy_assign_alloc(__str);
    assign(__str.data(), __str.size());
  }
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string &__str,
                                                         false_type)
    noexcept(__alloc_traits::is_always_equal::value) {
  if (__alloc() != __str.__alloc())
    assign(__str);
  else
    __move_assign(__str, true_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string &__str,
                                                         true_type)



    noexcept(is_nothrow_move_assignable<allocator_type>::value)

{
  clear();
  shrink_to_fit();
  __r_.first() = __str.__r_.first();
  __move_assign_alloc(__str);
  __str.__zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::operator=(basic_string &&__str)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {

  __move_assign(
      __str,
      integral_constant<
          bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if<
    __is_exactly_input_iterator<_InputIterator>::value ||
        !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first,
                                                  _InputIterator __last) {
  const basic_string ___temp(__first, __last, __alloc());
  assign(___temp.data(), ___temp.size());
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_forward_iterator<_ForwardIterator>::value &&
        __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first,
                                                  _ForwardIterator __last) {
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  size_type __cap = capacity();
  if (__cap < __n) {
    size_type __sz = size();
    __grow_by(__cap, __n - __cap, __sz, 0, __sz);
  } else
    __invalidate_iterators_past(__n);
  pointer __p = __get_pointer();
  for (; __first != __last; ++__first, ++__p)
    traits_type::assign(*__p, *__first);
  traits_type::assign(*__p, value_type());
  __set_size(__n);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string &__str,
                                                  size_type __pos,
                                                  size_type __n) {
  size_type __sz = __str.size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp &__t,
                                                  size_type __pos,
                                                  size_type __n) {
  __self_view __sv = __t;
  size_type __sz = __sv.size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  return assign(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type *__s) {
  ((void)0);
  return assign(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const value_type *__s,
                                                  size_type __n) {
  ((void)0);
  size_type __cap = capacity();
  size_type __sz = size();
  if (__cap - __sz >= __n) {
    if (__n) {
      value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
      traits_type::copy(__p + __sz, __s, __n);
      __sz += __n;
      __set_size(__sz);
      traits_type::assign(__p[__sz], value_type());
    }
  } else
    __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n,
                                                  value_type __c) {
  if (__n) {
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz < __n)
      __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
    pointer __p = __get_pointer();
    traits_type::assign(std::__1::__to_raw_pointer(__p) + __sz, __n, __c);
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c) {
  bool __is_short = !__is_long();
  size_type __cap;
  size_type __sz;
  if (__is_short) {
    __cap = __min_cap - 1;
    __sz = __get_short_size();
  } else {
    __cap = __get_long_cap() - 1;
    __sz = __get_long_size();
  }
  if (__sz == __cap) {
    __grow_by(__cap, 1, __sz, __sz, 0);
    __is_short = !__is_long();
  }
  pointer __p;
  if (__is_short) {
    __p = __get_short_pointer() + __sz;
    __set_short_size(__sz + 1);
  } else {
    __p = __get_long_pointer() + __sz;
    __set_long_size(__sz + 1);
  }
  traits_type::assign(*__p, __c);
  traits_type::assign(*++__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if<
    __is_exactly_input_iterator<_InputIterator>::value ||
        !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first,
                                                  _InputIterator __last) {
  const basic_string ___temp(__first, __last, __alloc());
  append(___temp.data(), ___temp.size());
  return *this;
}

template <class _Tp>
bool __ptr_in_range(const _Tp *__p, const _Tp *__first, const _Tp *__last) {
  return __first <= __p && __p < __last;
}

template <class _Tp1, class _Tp2>
bool __ptr_in_range(const _Tp1 *__p, const _Tp2 *__first, const _Tp2 *__last) {
  return false;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_forward_iterator<_ForwardIterator>::value &&
        __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first,
                                                  _ForwardIterator __last) {
  size_type __sz = size();
  size_type __cap = capacity();
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n) {
    if (__ptr_in_range(&*__first, data(), data() + size())) {
      const basic_string ___temp(__first, __last, __alloc());
      append(___temp.data(), ___temp.size());
    } else {
      if (__cap - __sz < __n)
        __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
      pointer __p = __get_pointer() + __sz;
      for (; __first != __last; ++__p, ++__first)
        traits_type::assign(*__p, *__first);
      traits_type::assign(*__p, value_type());
      __set_size(__sz + __n);
    }
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string &__str) {
  return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string &__str,
                                                  size_type __pos,
                                                  size_type __n) {
  size_type __sz = __str.size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp &__t,
                                                  size_type __pos,
                                                  size_type __n) {
  __self_view __sv = __t;
  size_type __sz = __sv.size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  return append(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const value_type *__s) {
  ((void)0);
  return append(__s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos,
                                                  const value_type *__s,
                                                  size_type __n) {
  ((void)0);
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  size_type __cap = capacity();
  if (__cap - __sz >= __n) {
    if (__n) {
      value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
      size_type __n_move = __sz - __pos;
      if (__n_move != 0) {
        if (__p + __pos <= __s && __s < __p + __sz)
          __s += __n;
        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
      }
      traits_type::move(__p + __pos, __s, __n);
      __sz += __n;
      __set_size(__sz);
      traits_type::assign(__p[__sz], value_type());
    }
  } else
    __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos,
                                                  size_type __n,
                                                  value_type __c) {
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  if (__n) {
    size_type __cap = capacity();
    value_type *__p;
    if (__cap - __sz >= __n) {
      __p = std::__1::__to_raw_pointer(__get_pointer());
      size_type __n_move = __sz - __pos;
      if (__n_move != 0)
        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
    } else {
      __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
      __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n, __c);
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if<
    __is_exactly_input_iterator<_InputIterator>::value ||
        !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos,
                                                  _InputIterator __first,
                                                  _InputIterator __last) {





  const basic_string ___temp(__first, __last, __alloc());
  return insert(__pos, ___temp.data(), ___temp.data() + ___temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_forward_iterator<_ForwardIterator>::value &&
        __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos,
                                                  _ForwardIterator __first,
                                                  _ForwardIterator __last) {





  size_type __ip = static_cast<size_type>(__pos - begin());
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n) {
    if (__ptr_in_range(&*__first, data(), data() + size())) {
      const basic_string ___temp(__first, __last, __alloc());
      return insert(__pos, ___temp.data(), ___temp.data() + ___temp.size());
    }

    size_type __sz = size();
    size_type __cap = capacity();
    value_type *__p;
    if (__cap - __sz >= __n) {
      __p = std::__1::__to_raw_pointer(__get_pointer());
      size_type __n_move = __sz - __ip;
      if (__n_move != 0)
        traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
    } else {
      __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
      __p = std::__1::__to_raw_pointer(__get_long_pointer());
    }
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
    for (__p += __ip; __first != __last; ++__p, ++__first)
      traits_type::assign(*__p, *__first);
  }
  return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1,
                                                  const basic_string &__str) {
  return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1,
                                                  const basic_string &__str,
                                                  size_type __pos2,
                                                  size_type __n) {
  size_type __str_sz = __str.size();
  if (__pos2 > __str_sz)
    this->__throw_out_of_range();
  return insert(__pos1, __str.data() + __pos2,
                std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1,
                                                  const _Tp &__t,
                                                  size_type __pos2,
                                                  size_type __n) {
  __self_view __sv = __t;
  size_type __str_sz = __sv.size();
  if (__pos2 > __str_sz)
    this->__throw_out_of_range();
  return insert(__pos1, __sv.data() + __pos2,
                std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos,
                                                  const value_type *__s) {
  ((void)0);
  return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos,
                                                  value_type __c) {
  size_type __ip = static_cast<size_type>(__pos - begin());
  size_type __sz = size();
  size_type __cap = capacity();
  value_type *__p;
  if (__cap == __sz) {
    __grow_by(__cap, 1, __sz, __ip, 0, 1);
    __p = std::__1::__to_raw_pointer(__get_long_pointer());
  } else {
    __p = std::__1::__to_raw_pointer(__get_pointer());
    size_type __n_move = __sz - __ip;
    if (__n_move != 0)
      traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
  }
  traits_type::assign(__p[__ip], __c);
  traits_type::assign(__p[++__sz], value_type());
  __set_size(__sz);
  return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
    basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos,
                                                      size_type __n,
                                                      value_type __c) {






  difference_type __p = __pos - begin();
  insert(static_cast<size_type>(__p), __n, __c);
  return begin() + __p;
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos,
                                                   size_type __n1,
                                                   const value_type *__s,
                                                   size_type __n2) {
  ((void)0);

  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  __n1 = std::__1::min(__n1, __sz - __pos);
  size_type __cap = capacity();
  if (__cap - __sz + __n1 >= __n2) {
    value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
    if (__n1 != __n2) {
      size_type __n_move = __sz - __pos - __n1;
      if (__n_move != 0) {
        if (__n1 > __n2) {
          traits_type::move(__p + __pos, __s, __n2);
          traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
          goto __finish;
        }
        if (__p + __pos < __s && __s < __p + __sz) {
          if (__p + __pos + __n1 <= __s)
            __s += __n2 - __n1;
          else
          {
            traits_type::move(__p + __pos, __s, __n1);
            __pos += __n1;
            __s += __n2;
            __n2 -= __n1;
            __n1 = 0;
          }
        }
        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
      }
    }
    traits_type::move(__p + __pos, __s, __n2);
  __finish:
    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
  } else
    __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1,
                          __n2, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos,
                                                   size_type __n1,
                                                   size_type __n2,
                                                   value_type __c) {
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  __n1 = std::__1::min(__n1, __sz - __pos);
  size_type __cap = capacity();
  value_type *__p;
  if (__cap - __sz + __n1 >= __n2) {
    __p = std::__1::__to_raw_pointer(__get_pointer());
    if (__n1 != __n2) {
      size_type __n_move = __sz - __pos - __n1;
      if (__n_move != 0)
        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
    }
  } else {
    __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
    __p = std::__1::__to_raw_pointer(__get_long_pointer());
  }
  traits_type::assign(__p + __pos, __n2, __c);
  __sz += __n2 - __n1;
  __set_size(__sz);
  __invalidate_iterators_past(__sz);
  traits_type::assign(__p[__sz], value_type());
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if<__is_input_iterator<_InputIterator>::value,
                   basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   _InputIterator __j1,
                                                   _InputIterator __j2) {
  const basic_string ___temp(__j1, __j2, __alloc());
  return this->replace(__i1, __i2, ___temp);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string &__str) {
  return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string &__str,
                                                   size_type __pos2,
                                                   size_type __n2) {
  size_type __str_sz = __str.size();
  if (__pos2 > __str_sz)
    this->__throw_out_of_range();
  return replace(__pos1, __n1, __str.data() + __pos2,
                 std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp &__t,
                                                   size_type __pos2,
                                                   size_type __n2) {
  __self_view __sv = __t;
  size_type __str_sz = __sv.size();
  if (__pos2 > __str_sz)
    this->__throw_out_of_range();
  return replace(__pos1, __n1, __sv.data() + __pos2,
                 std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos,
                                                   size_type __n1,
                                                   const value_type *__s) {
  ((void)0);
  return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   const basic_string &__str) {
  return replace(static_cast<size_type>(__i1 - begin()),
                 static_cast<size_type>(__i2 - __i1), __str.data(),
                 __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   const value_type *__s,
                                                   size_type __n) {
  return replace(static_cast<size_type>(__i1 - begin()),
                 static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   const value_type *__s) {
  return replace(static_cast<size_type>(__i1 - begin()),
                 static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   size_type __n,
                                                   value_type __c) {
  return replace(static_cast<size_type>(__i1 - begin()),
                 static_cast<size_type>(__i2 - __i1), __n, __c);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos,
                                                 size_type __n) {
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  if (__n) {
    value_type *__p = std::__1::__to_raw_pointer(__get_pointer());
    __n = std::__1::min(__n, __sz - __pos);
    size_type __n_move = __sz - __pos - __n;
    if (__n_move != 0)
      traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
    __sz -= __n;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
    basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos) {





  ((void)0);


  iterator __b = begin();
  size_type __r = static_cast<size_type>(__pos - __b);
  erase(__r, 1);
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::iterator
    basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first,
                                                     const_iterator __last) {






  ((void)0);

  iterator __b = begin();
  size_type __r = static_cast<size_type>(__first - __b);
  erase(__r, static_cast<size_type>(__last - __first));
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_string<_CharT, _Traits, _Allocator>::pop_back() {
  ((void)0);
  size_type __sz;
  if (__is_long()) {
    __sz = __get_long_size() - 1;
    __set_long_size(__sz);
    traits_type::assign(*(__get_long_pointer() + __sz), value_type());
  } else {
    __sz = __get_short_size() - 1;
    __set_short_size(__sz);
    traits_type::assign(*(__get_short_pointer() + __sz), value_type());
  }
  __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_string<_CharT, _Traits, _Allocator>::clear() noexcept {
  __invalidate_all_iterators();
  if (__is_long()) {
    traits_type::assign(*__get_long_pointer(), value_type());
    __set_long_size(0);
  } else {
    traits_type::assign(*__get_short_pointer(), value_type());
    __set_short_size(0);
  }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos) {
  if (__is_long()) {
    traits_type::assign(*(__get_long_pointer() + __pos), value_type());
    __set_long_size(__pos);
  } else {
    traits_type::assign(*(__get_short_pointer() + __pos), value_type());
    __set_short_size(__pos);
  }
  __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n,
                                                       value_type __c) {
  size_type __sz = size();
  if (__n > __sz)
    append(__n - __sz, __c);
  else
    __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::max_size() const noexcept {
  size_type __m = __alloc_traits::max_size(__alloc());

  return (__m <= ~__long_mask ? __m : __m / 2) - __alignment;



}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg) {
  if (__res_arg > max_size())
    this->__throw_length_error();
  size_type __cap = capacity();
  size_type __sz = size();
  __res_arg = std::__1::max(__res_arg, __sz);
  __res_arg = __recommend(__res_arg);
  if (__res_arg != __cap) {
    pointer __new_data, __p;
    bool __was_long, __now_long;
    if (__res_arg == __min_cap - 1) {
      __was_long = true;
      __now_long = false;
      __new_data = __get_short_pointer();
      __p = __get_long_pointer();
    } else {
      if (__res_arg > __cap)
        __new_data = __alloc_traits::allocate(__alloc(), __res_arg + 1);
      else {

        try {

          __new_data = __alloc_traits::allocate(__alloc(), __res_arg + 1);

        } catch (...) {
          return;
        }




      }
      __now_long = true;
      __was_long = __is_long();
      __p = __get_pointer();
    }
    traits_type::copy(std::__1::__to_raw_pointer(__new_data),
                      std::__1::__to_raw_pointer(__p), size() + 1);
    if (__was_long)
      __alloc_traits::deallocate(__alloc(), __p, __cap + 1);
    if (__now_long) {
      __set_long_cap(__res_arg + 1);
      __set_long_size(__sz);
      __set_long_pointer(__new_data);
    } else
      __set_short_size(__sz);
    __invalidate_all_iterators();
  }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::const_reference
        basic_string<_CharT, _Traits, _Allocator>::
        operator[](size_type __pos) const noexcept {
  ((void)0);
  return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::reference
        basic_string<_CharT, _Traits, _Allocator>::
        operator[](size_type __pos) noexcept {
  ((void)0);
  return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::reference
    basic_string<_CharT, _Traits, _Allocator>::front() {
  ((void)0);
  return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::const_reference
    basic_string<_CharT, _Traits, _Allocator>::front() const {
  ((void)0);
  return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::reference
    basic_string<_CharT, _Traits, _Allocator>::back() {
  ((void)0);
  return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::const_reference
    basic_string<_CharT, _Traits, _Allocator>::back() const {
  ((void)0);
  return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type *__s, size_type __n,
                                                size_type __pos) const {
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  size_type __rlen = std::__1::min(__n, __sz - __pos);
  traits_type::copy(__s, data() + __pos, __rlen);
  return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos,
                                                  size_type __n) const {
  return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_string<_CharT, _Traits, _Allocator>::swap(basic_string &__str)



    noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value)


{







  std::__1::swap(__r_.first(), __str.__r_.first());
  __swap_allocator(__alloc(), __str.__alloc());
}



template <class _Traits> struct __attribute__((__visibility__("hidden"))) __traits_eq {
  typedef typename _Traits::char_type char_type;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(const char_type &__x, const char_type &__y) noexcept {
    return _Traits::eq(__x, __y);
  }
};

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type *__s,
                                                size_type __pos,
                                                size_type __n) const noexcept {
  ((void)0);

  return __str_find<value_type, size_type, traits_type, npos>(data(), size(),
                                                              __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find(
        const basic_string &__str, size_type __pos) const noexcept {
  return __str_find<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find(
        __self_view __sv, size_type __pos) const noexcept {
  return __str_find<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find(
        const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_find<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(
    value_type __c, size_type __pos) const noexcept {
  return __str_find<value_type, size_type, traits_type, npos>(data(), size(),
                                                              __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(
    const value_type *__s, size_type __pos, size_type __n) const noexcept {
  ((void)0);

  return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(),
                                                               __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::rfind(
        const basic_string &__str, size_type __pos) const noexcept {
  return __str_rfind<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::rfind(
        __self_view __sv, size_type __pos) const noexcept {
  return __str_rfind<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::rfind(
        const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_rfind<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(
    value_type __c, size_type __pos) const noexcept {
  return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(),
                                                               __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(
    const value_type *__s, size_type __pos, size_type __n) const noexcept {
  ((void)0);

  return __str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_of(
        const basic_string &__str, size_type __pos) const noexcept {
  return __str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_of(
        __self_view __sv, size_type __pos) const noexcept {
  return __str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_of(
        const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_of(
        value_type __c, size_type __pos) const noexcept {
  return find(__c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(
    const value_type *__s, size_type __pos, size_type __n) const noexcept {
  ((void)0);

  return __str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_of(
        const basic_string &__str, size_type __pos) const noexcept {
  return __str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_of(
        __self_view __sv, size_type __pos) const noexcept {
  return __str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_of(
        const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_of(
        value_type __c, size_type __pos) const noexcept {
  return rfind(__c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    const value_type *__s, size_type __pos, size_type __n) const noexcept {
  ((void)0);

  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
        const basic_string &__str, size_type __pos) const noexcept {
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
        __self_view __sv, size_type __pos) const noexcept {
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
        const value_type *__s, size_type __pos) const noexcept {
  ((void)0);

  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
        value_type __c, size_type __pos) const noexcept {
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    const value_type *__s, size_type __pos, size_type __n) const noexcept {
  ((void)0);

  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
        const basic_string &__str, size_type __pos) const noexcept {
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
        __self_view __sv, size_type __pos) const noexcept {
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
        const value_type *__s, size_type __pos) const noexcept {
  ((void)0);

  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
        value_type __c, size_type __pos) const noexcept {
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __c, __pos);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) int
basic_string<_CharT, _Traits, _Allocator>::compare(
    __self_view __sv) const noexcept {
  size_t __lhs_sz = size();
  size_t __rhs_sz = __sv.size();
  int __result =
      traits_type::compare(data(), __sv.data(), std::__1::min(__lhs_sz, __rhs_sz));
  if (__result != 0)
    return __result;
  if (__lhs_sz < __rhs_sz)
    return -1;
  if (__lhs_sz > __rhs_sz)
    return 1;
  return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) int
basic_string<_CharT, _Traits, _Allocator>::compare(
    const basic_string &__str) const noexcept {
  return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                       size_type __n1,
                                                       const value_type *__s,
                                                       size_type __n2) const {
  ((void)0);

  size_type __sz = size();
  if (__pos1 > __sz || __n2 == npos)
    this->__throw_out_of_range();
  size_type __rlen = std::__1::min(__n1, __sz - __pos1);
  int __r =
      traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
  if (__r == 0) {
    if (__rlen < __n2)
      __r = -1;
    else if (__rlen > __n2)
      __r = 1;
  }
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) int
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   __self_view __sv) const {
  return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) int
basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const basic_string &__str) const {
  return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp &__t,
                                                   size_type __pos2,
                                                   size_type __n2) const {
  __self_view __sv = __t;
  return __self_view(*this)
      .substr(__pos1, __n1)
      .compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const basic_string &__str,
    size_type __pos2, size_type __n2) const {
  return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(
    const value_type *__s) const noexcept {
  ((void)0);
  return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const value_type *__s) const {
  ((void)0);
  return compare(__pos1, __n1, __s, traits_type::length(__s));
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
basic_string<_CharT, _Traits, _Allocator>::__invariants() const {
  if (size() > capacity())
    return false;
  if (capacity() < __min_cap - 1)
    return false;
  if (data() == 0)
    return false;
  if (data()[size()] != value_type(0))
    return false;
  return true;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  size_t __lhs_sz = __lhs.size();
  return __lhs_sz == __rhs.size() &&
         _Traits::compare(__lhs.data(), __rhs.data(), __lhs_sz) == 0;
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool operator==(
    const basic_string<char, char_traits<char>, _Allocator> &__lhs,
    const basic_string<char, char_traits<char>, _Allocator> &__rhs) noexcept {
  size_t __lhs_sz = __lhs.size();
  if (__lhs_sz != __rhs.size())
    return false;
  const char *__lp = __lhs.data();
  const char *__rp = __rhs.data();
  if (__lhs.__is_long())
    return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
  for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
    if (*__lp != *__rp)
      return false;
  return true;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  typedef basic_string<_CharT, _Traits, _Allocator> _String;
  ((void)0);

  size_t __lhs_len = _Traits::length(__lhs);
  if (__lhs_len != __rhs.size())
    return false;
  return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) noexcept {
  typedef basic_string<_CharT, _Traits, _Allocator> _String;
  ((void)0);

  size_t __rhs_len = _Traits::length(__rhs);
  if (__rhs_len != __lhs.size())
    return false;
  return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__lhs == __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__lhs == __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) noexcept {
  return !(__lhs == __rhs);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const _CharT *__rhs) noexcept {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const _CharT *__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return __rhs.compare(__lhs) > 0;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return __rhs < __lhs;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const _CharT *__rhs) noexcept {
  return __rhs < __lhs;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const _CharT *__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return __rhs < __lhs;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__rhs < __lhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) noexcept {
  return !(__rhs < __lhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__rhs < __lhs);
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__lhs < __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) noexcept {
  return !(__lhs < __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__lhs < __rhs);
}



template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz =
      __lhs.size();
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz =
      __rhs.size();
  __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
  __r.append(__rhs.data(), __rhs_sz);
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT *__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz =
      _Traits::length(__lhs);
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz =
      __rhs.size();
  __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
  __r.append(__rhs.data(), __rhs_sz);
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz =
      __rhs.size();
  __r.__init(&__lhs, 1, 1 + __rhs_sz);
  __r.append(__rhs.data(), __rhs_sz);
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const _CharT *__rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz =
      __lhs.size();
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz =
      _Traits::length(__rhs);
  __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
  __r.append(__rhs, __rhs_sz);
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          _CharT __rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz =
      __lhs.size();
  __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
  __r.push_back(__rhs);
  return __r;
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) {
  return std::__1::move(__lhs.append(__rhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          basic_string<_CharT, _Traits, _Allocator> &&__rhs) {
  return std::__1::move(__rhs.insert(0, __lhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs,
          basic_string<_CharT, _Traits, _Allocator> &&__rhs) {
  return std::__1::move(__lhs.append(__rhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT *__lhs,
          basic_string<_CharT, _Traits, _Allocator> &&__rhs) {
  return std::__1::move(__rhs.insert(0, __lhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, basic_string<_CharT, _Traits, _Allocator> &&__rhs) {
  __rhs.insert(__rhs.begin(), __lhs);
  return std::__1::move(__rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs,
          const _CharT *__rhs) {
  return std::__1::move(__lhs.append(__rhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs, _CharT __rhs) {
  __lhs.push_back(__rhs);
  return std::__1::move(__lhs);
}





template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(basic_string<_CharT, _Traits, _Allocator> &__lhs,
     basic_string<_CharT, _Traits, _Allocator> &__rhs)
    noexcept(noexcept(__lhs.swap(__rhs))) {
  __lhs.swap(__rhs);
}



typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;



__attribute__((__visibility__("default"))) int stoi(const string &__str, size_t *__idx = 0,
                          int __base = 10);
__attribute__((__visibility__("default"))) long stol(const string &__str, size_t *__idx = 0,
                           int __base = 10);
__attribute__((__visibility__("default"))) unsigned long stoul(const string &__str, size_t *__idx = 0,
                                     int __base = 10);
__attribute__((__visibility__("default"))) long long stoll(const string &__str, size_t *__idx = 0,
                                 int __base = 10);
__attribute__((__visibility__("default"))) unsigned long long stoull(const string &__str,
                                           size_t *__idx = 0, int __base = 10);

__attribute__((__visibility__("default"))) float stof(const string &__str, size_t *__idx = 0);
__attribute__((__visibility__("default"))) double stod(const string &__str, size_t *__idx = 0);
__attribute__((__visibility__("default"))) long double stold(const string &__str, size_t *__idx = 0);

__attribute__((__visibility__("default"))) string to_string(int __val);
__attribute__((__visibility__("default"))) string to_string(unsigned __val);
__attribute__((__visibility__("default"))) string to_string(long __val);
__attribute__((__visibility__("default"))) string to_string(unsigned long __val);
__attribute__((__visibility__("default"))) string to_string(long long __val);
__attribute__((__visibility__("default"))) string to_string(unsigned long long __val);
__attribute__((__visibility__("default"))) string to_string(float __val);
__attribute__((__visibility__("default"))) string to_string(double __val);
__attribute__((__visibility__("default"))) string to_string(long double __val);

__attribute__((__visibility__("default"))) int stoi(const wstring &__str, size_t *__idx = 0,
                          int __base = 10);
__attribute__((__visibility__("default"))) long stol(const wstring &__str, size_t *__idx = 0,
                           int __base = 10);
__attribute__((__visibility__("default"))) unsigned long stoul(const wstring &__str, size_t *__idx = 0,
                                     int __base = 10);
__attribute__((__visibility__("default"))) long long stoll(const wstring &__str, size_t *__idx = 0,
                                 int __base = 10);
__attribute__((__visibility__("default"))) unsigned long long stoull(const wstring &__str,
                                           size_t *__idx = 0, int __base = 10);

__attribute__((__visibility__("default"))) float stof(const wstring &__str, size_t *__idx = 0);
__attribute__((__visibility__("default"))) double stod(const wstring &__str, size_t *__idx = 0);
__attribute__((__visibility__("default"))) long double stold(const wstring &__str, size_t *__idx = 0);

__attribute__((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned long long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long double __val);

template <class _CharT, class _Traits, class _Allocator>
const typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::npos;

template <class _CharT, class _Traits, class _Allocator>
struct __attribute__((__visibility__("default"))) hash<basic_string<_CharT, _Traits, _Allocator>>
    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t> {
  size_t operator()(
      const basic_string<_CharT, _Traits, _Allocator> &__val) const noexcept;
};

template <class _CharT, class _Traits, class _Allocator>
size_t hash<basic_string<_CharT, _Traits, _Allocator>>::operator()(
    const basic_string<_CharT, _Traits, _Allocator> &__val) const noexcept {
  return __do_string_hash(__val.data(), __val.data() + __val.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           const basic_string<_CharT, _Traits, _Allocator> &__str);

template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is,
           basic_string<_CharT, _Traits, _Allocator> &__str);

template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str);



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str);
extern template class basic_string<char>;

extern template class basic_string<wchar_t>;

extern template string operator+ <char, char_traits<char>, allocator<char>>(char const *, string const &);



} }


namespace std { inline namespace __1 {

template <size_t _N_words, size_t _Size> class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size>> {
  static const bool value = true;
};

template <size_t _N_words, size_t _Size> class __bitset {
public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef size_type __storage_type;

protected:
  typedef __bitset __self;
  typedef __storage_type *__storage_pointer;
  typedef const __storage_type *__const_storage_pointer;
  static const unsigned __bits_per_word =
      static_cast<unsigned>(sizeof(__storage_type) * 8);

  friend class __bit_reference<__bitset>;
  friend class __bit_const_reference<__bitset>;
  friend class __bit_iterator<__bitset, false>;
  friend class __bit_iterator<__bitset, true>;
  friend struct __bit_array<__bitset>;

  __storage_type __first_[_N_words];

  typedef __bit_reference<__bitset> reference;
  typedef __bit_const_reference<__bitset> const_reference;
  typedef __bit_iterator<__bitset, false> iterator;
  typedef __bit_iterator<__bitset, true> const_iterator;

  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr __bitset() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit constexpr __bitset(unsigned long long __v) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) noexcept {
    return reference(__first_ + __pos / __bits_per_word,
                     __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr const_reference
  __make_ref(size_t __pos) const noexcept {
    return const_reference(__first_ + __pos / __bits_per_word,
                           __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) noexcept {
    return iterator(__first_ + __pos / __bits_per_word,
                    __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator
  __make_iter(size_t __pos) const noexcept {
    return const_iterator(__first_ + __pos / __bits_per_word,
                          __pos % __bits_per_word);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator&=(const __bitset &__v) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator|=(const __bitset &__v) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator^=(const __bitset &__v) noexcept;

  void flip() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const {
    return to_ulong(integral_constant < bool,
                    _Size<sizeof(unsigned long) * 8>());
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const {
    return to_ullong(integral_constant < bool,
                     _Size<sizeof(unsigned long long) * 8>());
  }

  bool all() const noexcept;
  bool any() const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t __hash_code() const noexcept;

private:





  unsigned long to_ulong(false_type) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  unsigned long to_ulong(true_type) const;
  unsigned long long to_ullong(false_type) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  unsigned long long to_ullong(true_type) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  unsigned long long to_ullong(true_type, false_type) const;
  unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline constexpr __bitset<_N_words, _Size>::__bitset() noexcept

    : __first_ {
  0
}

{



}
template <size_t _N_words, size_t _Size>
inline constexpr
__bitset<_N_words, _Size>::__bitset(unsigned long long __v) noexcept


    : __first_ {
  __v
}
{




}

template <size_t _N_words, size_t _Size>
inline void __bitset<_N_words, _Size>::
operator&=(const __bitset &__v) noexcept {
  for (size_type __i = 0; __i < _N_words; ++__i)
    __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline void __bitset<_N_words, _Size>::
operator|=(const __bitset &__v) noexcept {
  for (size_type __i = 0; __i < _N_words; ++__i)
    __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline void __bitset<_N_words, _Size>::
operator^=(const __bitset &__v) noexcept {
  for (size_type __i = 0; __i < _N_words; ++__i)
    __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void __bitset<_N_words, _Size>::flip() noexcept {

  size_type __n = _Size;
  __storage_pointer __p = __first_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    *__p = ~*__p;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = *__p & __m;
    *__p &= ~__m;
    *__p |= ~__b & __m;
  }
}

template <size_t _N_words, size_t _Size>
unsigned long __bitset<_N_words, _Size>::to_ulong(false_type) const {
  const_iterator __e = __make_iter(_Size);
  const_iterator __i =
      std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
  if (__i != __e)
    __throw_overflow_error("bitset to_ulong overflow error");

  return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline unsigned long __bitset<_N_words, _Size>::to_ulong(true_type) const {
  return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long __bitset<_N_words, _Size>::to_ullong(false_type) const {
  const_iterator __e = __make_iter(_Size);
  const_iterator __i = std::__1::find(
      __make_iter(sizeof(unsigned long long) * 8), __e, true);
  if (__i != __e)
    __throw_overflow_error("bitset to_ullong overflow error");

  return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline unsigned long long
    __bitset<_N_words, _Size>::to_ullong(true_type) const {
  return to_ullong(true_type(),
                   integral_constant<bool, sizeof(__storage_type) <
                                               sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline unsigned long long
    __bitset<_N_words, _Size>::to_ullong(true_type, false_type) const {
  return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long __bitset<_N_words, _Size>::to_ullong(true_type,
                                                        true_type) const {
  unsigned long long __r = __first_[0];
  for (std::size_t __i = 1;
       __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
    __r |= static_cast<unsigned long long>(__first_[__i])
           << (sizeof(__storage_type) * 8);
  return __r;
}

template <size_t _N_words, size_t _Size>
bool __bitset<_N_words, _Size>::all() const noexcept {

  size_type __n = _Size;
  __const_storage_pointer __p = __first_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    if (~*__p)
      return false;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    if (~*__p & __m)
      return false;
  }
  return true;
}

template <size_t _N_words, size_t _Size>
bool __bitset<_N_words, _Size>::any() const noexcept {

  size_type __n = _Size;
  __const_storage_pointer __p = __first_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    if (*__p)
      return true;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    if (*__p & __m)
      return true;
  }
  return false;
}

template <size_t _N_words, size_t _Size>
inline size_t __bitset<_N_words, _Size>::__hash_code() const noexcept {
  size_t __h = 0;
  for (size_type __i = 0; __i < _N_words; ++__i)
    __h ^= __first_[__i];
  return __h;
}

template <size_t _Size> class __bitset<1, _Size> {
public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef size_type __storage_type;

protected:
  typedef __bitset __self;
  typedef __storage_type *__storage_pointer;
  typedef const __storage_type *__const_storage_pointer;
  static const unsigned __bits_per_word =
      static_cast<unsigned>(sizeof(__storage_type) * 8);

  friend class __bit_reference<__bitset>;
  friend class __bit_const_reference<__bitset>;
  friend class __bit_iterator<__bitset, false>;
  friend class __bit_iterator<__bitset, true>;
  friend struct __bit_array<__bitset>;

  __storage_type __first_;

  typedef __bit_reference<__bitset> reference;
  typedef __bit_const_reference<__bitset> const_reference;
  typedef __bit_iterator<__bitset, false> iterator;
  typedef __bit_iterator<__bitset, true> const_iterator;

  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr __bitset() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit constexpr __bitset(unsigned long long __v) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t __pos) noexcept {
    return reference(&__first_, __storage_type(1) << __pos);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr const_reference
  __make_ref(size_t __pos) const noexcept {
    return const_reference(&__first_, __storage_type(1) << __pos);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t __pos) noexcept {
    return iterator(&__first_ + __pos / __bits_per_word,
                    __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator
  __make_iter(size_t __pos) const noexcept {
    return const_iterator(&__first_ + __pos / __bits_per_word,
                          __pos % __bits_per_word);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator&=(const __bitset &__v) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator|=(const __bitset &__v) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator^=(const __bitset &__v) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  void flip() noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  unsigned long to_ulong() const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  unsigned long long to_ullong() const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool all() const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool any() const noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t __hash_code() const noexcept;
};

template <size_t _Size>
inline constexpr __bitset<1, _Size>::__bitset() noexcept
    : __first_(0) {}

template <size_t _Size>
inline constexpr
__bitset<1, _Size>::__bitset(unsigned long long __v) noexcept
    : __first_(static_cast<__storage_type>(__v)) {}

template <size_t _Size>
inline void __bitset<1, _Size>::operator&=(const __bitset &__v) noexcept {
  __first_ &= __v.__first_;
}

template <size_t _Size>
inline void __bitset<1, _Size>::operator|=(const __bitset &__v) noexcept {
  __first_ |= __v.__first_;
}

template <size_t _Size>
inline void __bitset<1, _Size>::operator^=(const __bitset &__v) noexcept {
  __first_ ^= __v.__first_;
}

template <size_t _Size> inline void __bitset<1, _Size>::flip() noexcept {
  __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
  __first_ = ~__first_;
  __first_ &= __m;
}

template <size_t _Size>
inline unsigned long __bitset<1, _Size>::to_ulong() const {
  return __first_;
}

template <size_t _Size>
inline unsigned long long __bitset<1, _Size>::to_ullong() const {
  return __first_;
}

template <size_t _Size> inline bool __bitset<1, _Size>::all() const noexcept {
  __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
  return !(~__first_ & __m);
}

template <size_t _Size> inline bool __bitset<1, _Size>::any() const noexcept {
  __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
  return __first_ & __m;
}

template <size_t _Size>
inline size_t __bitset<1, _Size>::__hash_code() const noexcept {
  return __first_;
}

template <> class __bitset<0, 0> {
public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef size_type __storage_type;

protected:
  typedef __bitset __self;
  typedef __storage_type *__storage_pointer;
  typedef const __storage_type *__const_storage_pointer;
  static const unsigned __bits_per_word =
      static_cast<unsigned>(sizeof(__storage_type) * 8);

  friend class __bit_reference<__bitset>;
  friend class __bit_const_reference<__bitset>;
  friend class __bit_iterator<__bitset, false>;
  friend class __bit_iterator<__bitset, true>;
  friend struct __bit_array<__bitset>;

  typedef __bit_reference<__bitset> reference;
  typedef __bit_const_reference<__bitset> const_reference;
  typedef __bit_iterator<__bitset, false> iterator;
  typedef __bit_iterator<__bitset, true> const_iterator;

  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr __bitset() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit constexpr __bitset(unsigned long long) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__)) reference __make_ref(size_t) noexcept {
    return reference(0, 1);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
      constexpr const_reference __make_ref(size_t) const noexcept {
    return const_reference(0, 1);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __make_iter(size_t) noexcept {
    return iterator(0, 0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator __make_iter(size_t) const noexcept {
    return const_iterator(0, 0);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void operator&=(const __bitset &) noexcept {}
  __attribute__((__visibility__("hidden"), __always_inline__)) void operator|=(const __bitset &) noexcept {}
  __attribute__((__visibility__("hidden"), __always_inline__)) void operator^=(const __bitset &) noexcept {}

  __attribute__((__visibility__("hidden"), __always_inline__)) void flip() noexcept {}

  __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long to_ulong() const { return 0; }
  __attribute__((__visibility__("hidden"), __always_inline__)) unsigned long long to_ullong() const { return 0; }

  __attribute__((__visibility__("hidden"), __always_inline__)) bool all() const noexcept { return true; }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool any() const noexcept { return false; }

  __attribute__((__visibility__("hidden"), __always_inline__)) size_t __hash_code() const noexcept { return 0; }
};

inline constexpr __bitset<0, 0>::__bitset() noexcept {}

inline constexpr
__bitset<0, 0>::__bitset(unsigned long long) noexcept {}

template <size_t _Size> class __attribute__((__visibility__("default"))) bitset;
template <size_t _Size> struct hash<bitset<_Size>>;

template <size_t _Size>
class __attribute__((__visibility__("default"))) bitset
    : private __bitset<
          _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1,
          _Size> {
public:
  static const unsigned __n_words =
      _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
  typedef __bitset<__n_words, _Size> base;

public:
  typedef typename base::reference reference;
  typedef typename base::const_reference const_reference;


  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bitset() noexcept {}
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
  bitset(unsigned long long __v) noexcept : base(__v) {}
  template <class _CharT>
  explicit bitset(
      const _CharT *__str,
      typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
      _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
  template <class _CharT, class _Traits, class _Allocator>
  explicit bitset(
      const basic_string<_CharT, _Traits, _Allocator> &__str,
      typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos = 0,
      typename basic_string<_CharT, _Traits, _Allocator>::size_type __n =
          (basic_string<_CharT, _Traits, _Allocator>::npos),
      _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));


  __attribute__((__visibility__("hidden"), __always_inline__))
  bitset &operator&=(const bitset &__rhs) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bitset &operator|=(const bitset &__rhs) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bitset &operator^=(const bitset &__rhs) noexcept;
  bitset &operator<<=(size_t __pos) noexcept;
  bitset &operator>>=(size_t __pos) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bitset &set() noexcept;
  bitset &set(size_t __pos, bool __val = true);
  __attribute__((__visibility__("hidden"), __always_inline__))
  bitset &reset() noexcept;
  bitset &reset(size_t __pos);
  __attribute__((__visibility__("hidden"), __always_inline__))
  bitset operator~() const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bitset &flip() noexcept;
  bitset &flip(size_t __pos);


  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr const_reference
  operator[](size_t __p) const {
    return base::__make_ref(__p);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator[](size_t __p) {
    return base::__make_ref(__p);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  unsigned long to_ulong() const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  unsigned long long to_ullong() const;
  template <class _CharT, class _Traits, class _Allocator>
  basic_string<_CharT, _Traits, _Allocator>
  to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
  template <class _CharT, class _Traits>
  __attribute__((__visibility__("hidden"), __always_inline__)) basic_string<_CharT, _Traits, allocator<_CharT>>
  to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
  template <class _CharT>
  __attribute__((__visibility__("hidden"), __always_inline__))
      basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>
      to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_string<char, char_traits<char>, allocator<char>>
  to_string(char __zero = '0', char __one = '1') const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t count() const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr size_t size() const noexcept {
    return _Size;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator==(const bitset &__rhs) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator!=(const bitset &__rhs) const noexcept;
  bool test(size_t __pos) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool all() const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool any() const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) bool none() const noexcept { return !any(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bitset operator<<(size_t __pos) const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bitset operator>>(size_t __pos) const noexcept;

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t __hash_code() const noexcept { return base::__hash_code(); }

  friend struct hash<bitset>;
};

template <size_t _Size>
template <class _CharT>
bitset<_Size>::bitset(const _CharT *__str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one) {
  size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
  for (size_t __i = 0; __i < __rlen; ++__i)
    if (__str[__i] != __zero && __str[__i] != __one)
      __throw_invalid_argument("bitset string ctor has invalid argument");

  size_t _Mp = std::__1::min(__rlen, _Size);
  size_t __i = 0;
  for (; __i < _Mp; ++__i) {
    _CharT __c = __str[_Mp - 1 - __i];
    if (__c == __zero)
      (*this)[__i] = false;
    else
      (*this)[__i] = true;
  }
  std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(
    const basic_string<_CharT, _Traits, _Allocator> &__str,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type __n,
    _CharT __zero, _CharT __one) {
  if (__pos > __str.size())
    __throw_out_of_range("bitset string pos out of range");

  size_t __rlen = std::__1::min(__n, __str.size() - __pos);
  for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
    if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
      __throw_invalid_argument("bitset string ctor has invalid argument");

  size_t _Mp = std::__1::min(__rlen, _Size);
  size_t __i = 0;
  for (; __i < _Mp; ++__i) {
    _CharT __c = __str[__pos + _Mp - 1 - __i];
    if (_Traits::eq(__c, __zero))
      (*this)[__i] = false;
    else
      (*this)[__i] = true;
  }
  std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline bitset<_Size> &bitset<_Size>::operator&=(const bitset &__rhs) noexcept {
  base::operator&=(__rhs);
  return *this;
}

template <size_t _Size>
inline bitset<_Size> &bitset<_Size>::operator|=(const bitset &__rhs) noexcept {
  base::operator|=(__rhs);
  return *this;
}

template <size_t _Size>
inline bitset<_Size> &bitset<_Size>::operator^=(const bitset &__rhs) noexcept {
  base::operator^=(__rhs);
  return *this;
}

template <size_t _Size>
bitset<_Size> &bitset<_Size>::operator<<=(size_t __pos) noexcept {
  __pos = std::__1::min(__pos, _Size);
  std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos),
                       base::__make_iter(_Size));
  std::__1::fill_n(base::__make_iter(0), __pos, false);
  return *this;
}

template <size_t _Size>
bitset<_Size> &bitset<_Size>::operator>>=(size_t __pos) noexcept {
  __pos = std::__1::min(__pos, _Size);
  std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size),
              base::__make_iter(0));
  std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
  return *this;
}

template <size_t _Size> inline bitset<_Size> &bitset<_Size>::set() noexcept {
  std::__1::fill_n(base::__make_iter(0), _Size, true);
  return *this;
}

template <size_t _Size>
bitset<_Size> &bitset<_Size>::set(size_t __pos, bool __val) {
  if (__pos >= _Size)
    __throw_out_of_range("bitset set argument out of range");

  (*this)[__pos] = __val;
  return *this;
}

template <size_t _Size> inline bitset<_Size> &bitset<_Size>::reset() noexcept {
  std::__1::fill_n(base::__make_iter(0), _Size, false);
  return *this;
}

template <size_t _Size> bitset<_Size> &bitset<_Size>::reset(size_t __pos) {
  if (__pos >= _Size)
    __throw_out_of_range("bitset reset argument out of range");

  (*this)[__pos] = false;
  return *this;
}

template <size_t _Size>
inline bitset<_Size> bitset<_Size>::operator~() const noexcept {
  bitset __x(*this);
  __x.flip();
  return __x;
}

template <size_t _Size> inline bitset<_Size> &bitset<_Size>::flip() noexcept {
  base::flip();
  return *this;
}

template <size_t _Size> bitset<_Size> &bitset<_Size>::flip(size_t __pos) {
  if (__pos >= _Size)
    __throw_out_of_range("bitset flip argument out of range");

  reference r = base::__make_ref(__pos);
  r = ~r;
  return *this;
}

template <size_t _Size> inline unsigned long bitset<_Size>::to_ulong() const {
  return base::to_ulong();
}

template <size_t _Size>
inline unsigned long long bitset<_Size>::to_ullong() const {
  return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const {
  basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
  for (size_t __i = 0; __i < _Size; ++__i) {
    if ((*this)[__i])
      __r[_Size - 1 - __i] = __one;
  }
  return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline basic_string<_CharT, _Traits, allocator<_CharT>>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const {
  return to_string<_CharT, _Traits, allocator<_CharT>>(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline basic_string<_CharT, char_traits<_CharT>, allocator<_CharT>>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const {
  return to_string<_CharT, char_traits<_CharT>, allocator<_CharT>>(__zero,
                                                                   __one);
}

template <size_t _Size>
inline basic_string<char, char_traits<char>, allocator<char>>
bitset<_Size>::to_string(char __zero, char __one) const {
  return to_string<char, char_traits<char>, allocator<char>>(__zero, __one);
}

template <size_t _Size> inline size_t bitset<_Size>::count() const noexcept {
  return static_cast<size_t>(
      std::__1::count(base::__make_iter(0), base::__make_iter(_Size), true));
}

template <size_t _Size>
inline bool bitset<_Size>::operator==(const bitset &__rhs) const noexcept {
  return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size),
                      __rhs.__make_iter(0));
}

template <size_t _Size>
inline bool bitset<_Size>::operator!=(const bitset &__rhs) const noexcept {
  return !(*this == __rhs);
}

template <size_t _Size> bool bitset<_Size>::test(size_t __pos) const {
  if (__pos >= _Size)
    __throw_out_of_range("bitset test argument out of range");

  return (*this)[__pos];
}

template <size_t _Size> inline bool bitset<_Size>::all() const noexcept {
  return base::all();
}

template <size_t _Size> inline bool bitset<_Size>::any() const noexcept {
  return base::any();
}

template <size_t _Size>
inline bitset<_Size> bitset<_Size>::operator<<(size_t __pos) const noexcept {
  bitset __r = *this;
  __r <<= __pos;
  return __r;
}

template <size_t _Size>
inline bitset<_Size> bitset<_Size>::operator>>(size_t __pos) const noexcept {
  bitset __r = *this;
  __r >>= __pos;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bitset<_Size>
operator&(const bitset<_Size> &__x, const bitset<_Size> &__y)noexcept {
  bitset<_Size> __r = __x;
  __r &= __y;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bitset<_Size>
operator|(const bitset<_Size> &__x, const bitset<_Size> &__y) noexcept {
  bitset<_Size> __r = __x;
  __r |= __y;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bitset<_Size>
operator^(const bitset<_Size> &__x, const bitset<_Size> &__y) noexcept {
  bitset<_Size> __r = __x;
  __r ^= __y;
  return __r;
}

template <size_t _Size>
struct __attribute__((__visibility__("default"))) hash<bitset<_Size>>
    : public unary_function<bitset<_Size>, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(const bitset<_Size> &__bs) const noexcept {
    return __bs.__hash_code();
  }
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is,
                                           bitset<_Size> &__x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os,
                                           const bitset<_Size> &__x);

} }


#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
  struct __lconv_a {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;

          char *left_parenthesis;
          char *right_parenthesis;







           char int_p_cs_precedes;
           char int_p_sep_by_space;
           char int_n_cs_precedes;
           char int_n_sep_by_space;
           char int_p_sign_posn;
           char int_n_sign_posn;

  };
  struct __lconv_e {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;



        char *left_parenthesis;

        char *right_parenthesis;

        char *debit_sign;
        char *credit_sign;
           char int_p_cs_precedes;
           char int_p_sep_by_space;
           char int_n_cs_precedes;
           char int_n_sep_by_space;
           char int_p_sign_posn;
           char int_n_sign_posn;

  };
  struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;



        char *left_parenthesis;

        char *right_parenthesis;

        char *debit_sign;
        char *credit_sign;
           char int_p_cs_precedes;
           char int_p_sep_by_space;
           char int_n_cs_precedes;
           char int_n_sep_by_space;
           char int_p_sign_posn;
           char int_n_sign_posn;

  };





    struct dtconv {
          char *abbrev_month_names[12];
          char *month_names[12];
          char *abbrev_day_names[7];
          char *day_names[7];
          char *date_time_format;
          char *date_format;
          char *time_format;
          char *am_string;
          char *pm_string;
          char *time_format_ampm;
          char *iso_std8601_2000;
    };
#pragma map(localdtconv, "\174\174LCLDTC")
#pragma map(localedtconv, "\174\174LCLDTC")







 struct dtconv *localdtconv(void);
         struct dtconv *localedtconv(void);
     char *setlocale(int, const char *);
     struct lconv *localeconv(void);
  }


#pragma checkout(resume)



#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {


#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
    int sched_yield (void);
    struct sched_param {
      int sched_priority;
    };




    }

#pragma checkout(resume)
#pragma map (pthread_attr_destroy, "\174\174PT3AD")
#pragma map (pthread_attr_getdetachstate, "\174\174PT3AGD")
#pragma map (pthread_attr_getstacksize, "\174\174PT3AGS")
#pragma map (pthread_attr_init, "\174\174PT3AI")
#pragma map (pthread_attr_setdetachstate, "\174\174PT3ASD")
#pragma map (pthread_attr_setstacksize, "\174\174PT3ASS")
#pragma map (pthread_cancel, "\174\174PT3CAN")
#pragma map (pthread_cond_broadcast, "\174\174PT3CB")
#pragma map (pthread_cond_destroy, "\174\174PT3CD")
#pragma map (pthread_cond_init, "\174\174PT3CI")
#pragma map (pthread_cond_signal, "\174\174PT3CS")
#pragma map (pthread_cond_timedwait, "\174\174PT3CT")
#pragma map (pthread_cond_wait, "\174\174PT3CW")
#pragma map (pthread_condattr_destroy, "\174\174PT3DD")
#pragma map (pthread_condattr_getpshared, "\174\174PT3CGP")
#pragma map (pthread_condattr_init, "\174\174PT3DI")
#pragma map (pthread_condattr_setpshared, "\174\174PT3CSP")
#pragma map (pthread_create, "\174\174PT3C")
#pragma map (pthread_detach, "\174\174PT3D")
#pragma map (pthread_getspecific, "\174\174PT8GS")
#pragma map (pthread_join, "\174\174PT3J")
#pragma map (pthread_key_create, "\174\174PT3KC")
#pragma map (pthread_mutex_destroy, "\174\174PT3MD")
#pragma map (pthread_mutex_init, "\174\174PT3MI")
#pragma map (pthread_mutex_lock, "\174\174PT3ML")
#pragma map (pthread_mutex_trylock, "\174\174PT3MT")
#pragma map (pthread_mutex_unlock, "\174\174PT3MU")
#pragma map (pthread_mutexattr_destroy, "\174\174PT3XS")
#pragma map (pthread_mutexattr_getpshared, "\174\174P3MPG")
#pragma map (pthread_mutexattr_gettype, "\174\174PT3TG")
#pragma map (pthread_mutexattr_init, "\174\174PT3XI")
#pragma map (pthread_mutexattr_setpshared, "\174\174P3MPS")
#pragma map (pthread_mutexattr_settype, "\174\174PT3TS")
#pragma map (pthread_once, "\174\174PT3O")
#pragma map (pthread_rwlock_destroy, "\174\174P3R\174D")
#pragma map (pthread_rwlock_init, "\174\174P3R\174I")
#pragma map (pthread_rwlock_rdlock, "\174\174P3RRL")
#pragma map (pthread_rwlock_tryrdlock, "\174\174P3RTR")
#pragma map (pthread_rwlock_trywrlock, "\174\174P3RTW")
#pragma map (pthread_rwlock_unlock, "\174\174P3R\174U")
#pragma map (pthread_rwlock_wrlock, "\174\174P3RWL")
#pragma map (pthread_rwlockattr_destroy, "\174\174P3RAD")
#pragma map (pthread_rwlockattr_getpshared, "\174\174P3RAG")
#pragma map (pthread_rwlockattr_init, "\174\174P3RAI")
#pragma map (pthread_rwlockattr_setpshared, "\174\174P3RAS")
#pragma map (pthread_setspecific, "\174\174PT3SS")


 int pthread_attr_destroy (pthread_attr_t *);
      int pthread_attr_init (pthread_attr_t *);
      int pthread_attr_setstacksize (pthread_attr_t *, size_t);
      int pthread_cancel (pthread_t);
      void pthread_cleanup_pop (int);
      void pthread_cleanup_push (void (*) (void *), void *);
      int pthread_cond_broadcast (pthread_cond_t *);
      int pthread_cond_destroy (pthread_cond_t *);
      int pthread_cond_signal (pthread_cond_t *);
      int pthread_cond_timedwait (pthread_cond_t *, pthread_mutex_t *, const struct timespec *);


      int pthread_cond_wait (pthread_cond_t *, pthread_mutex_t *);

      int pthread_condattr_destroy (pthread_condattr_t *);
      int pthread_condattr_setpshared (pthread_condattr_t *, int);
      int pthread_condattr_init (pthread_condattr_t *);
      int pthread_equal (pthread_t, pthread_t);
      void pthread_exit (void *);
      int pthread_getconcurrency (void);
      int pthread_join (pthread_t, void **);
      int pthread_key_create (pthread_key_t *, void (*) (void *));
      int pthread_key_delete (pthread_key_t);
      int pthread_mutex_destroy (pthread_mutex_t *);
      int pthread_mutex_lock (pthread_mutex_t *);
      int pthread_mutex_trylock (pthread_mutex_t *);
      int pthread_mutex_unlock (pthread_mutex_t *);
      int pthread_mutexattr_destroy (pthread_mutexattr_t *);
      int pthread_mutexattr_getpshared (const pthread_mutexattr_t *, int *);

      int pthread_mutexattr_gettype (const pthread_mutexattr_t *, int *);

      int pthread_mutexattr_init (pthread_mutexattr_t *);
      int pthread_mutexattr_setpshared (pthread_mutexattr_t *, int);
      int pthread_mutexattr_settype (pthread_mutexattr_t *, int);
      int pthread_once (pthread_once_t *, void (*)(void));
      int pthread_rwlock_destroy (pthread_rwlock_t *);
      int pthread_rwlock_rdlock (pthread_rwlock_t *);
      int pthread_rwlock_tryrdlock (pthread_rwlock_t *);
      int pthread_rwlock_trywrlock (pthread_rwlock_t *);
      int pthread_rwlock_unlock (pthread_rwlock_t *);
      int pthread_rwlock_wrlock (pthread_rwlock_t *);
      int pthread_rwlockattr_destroy (pthread_rwlockattr_t *);
      int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *, int *);

      int pthread_rwlockattr_init (pthread_rwlockattr_t *);
      int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *, int);

      pthread_t pthread_self (void);
      int pthread_setcancelstate (int, int *);
      int pthread_setcanceltype (int, int *);
      int pthread_setconcurrency (int);
      void pthread_testcancel (void);



      int pthread_atfork (void (*)(void), void (*)(void), void(*)(void));

      int pthread_attr_getguardsize (const pthread_attr_t *, size_t *);

      int pthread_attr_getschedparam (const pthread_attr_t *, struct sched_param *);


      int pthread_attr_getstack (const pthread_attr_t *, void **, size_t *);


      int pthread_attr_getstackaddr (const pthread_attr_t *, void **);

      int pthread_attr_setguardsize (pthread_attr_t *, size_t);
      int pthread_attr_setschedparam (pthread_attr_t *, const struct sched_param *);


      int pthread_attr_setstack (pthread_attr_t *, void *, size_t);
      int pthread_attr_setstackaddr (pthread_attr_t *, void *);



      int pthread_attr_getdetachstate (const pthread_attr_t *, int *);

      int pthread_attr_getstacksize (const pthread_attr_t *, size_t *);

      int pthread_attr_setdetachstate (pthread_attr_t *, int);
      int pthread_cond_init (pthread_cond_t *, const pthread_condattr_t *);


      int pthread_condattr_getpshared (const pthread_condattr_t *, int *);

      int pthread_create (pthread_t *, const pthread_attr_t *, void *(*)(void *), void *);


      int pthread_detach (pthread_t);
      void * pthread_getspecific (pthread_key_t);
      int pthread_mutex_init (pthread_mutex_t *, const pthread_mutexattr_t *);


      int pthread_rwlock_init (pthread_rwlock_t *, const pthread_rwlockattr_t *);


      int pthread_setspecific (pthread_key_t, const void *);
    }
#pragma checkout(resume)








namespace std { inline namespace __1 {


typedef pthread_mutex_t __libcpp_mutex_t;


inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_recursive_mutex_init(__libcpp_mutex_t *__m);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_mutex_lock(__libcpp_mutex_t *__m);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_mutex_trylock(__libcpp_mutex_t *__m);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_mutex_unlock(__libcpp_mutex_t *__m);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_mutex_destroy(__libcpp_mutex_t *__m);


typedef pthread_cond_t __libcpp_condvar_t;

inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_signal(__libcpp_condvar_t *__cv);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               timespec *__ts);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv);


typedef pthread_t __libcpp_thread_id;
inline __attribute__((__visibility__("hidden"), __always_inline__))
bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2);
inline __attribute__((__visibility__("hidden"), __always_inline__))
bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);


typedef pthread_t __libcpp_thread_t;
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg);
inline __attribute__((__visibility__("hidden"), __always_inline__))
__libcpp_thread_id __libcpp_thread_get_current_id();
inline __attribute__((__visibility__("hidden"), __always_inline__))
__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_thread_join(__libcpp_thread_t *__t);
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_thread_detach(__libcpp_thread_t *__t);
inline __attribute__((__visibility__("hidden"), __always_inline__))
void __libcpp_thread_yield();


typedef pthread_key_t __libcpp_tls_key;
inline __attribute__((__visibility__("hidden"), __always_inline__))
int __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *));
inline __attribute__((__visibility__("hidden"), __always_inline__))
void *__libcpp_tls_get(__libcpp_tls_key __key);
inline __attribute__((__visibility__("hidden"), __always_inline__))
void __libcpp_tls_set(__libcpp_tls_key __key, void *__p);




int __libcpp_recursive_mutex_init(__libcpp_mutex_t *__m) {
  pthread_mutexattr_t attr;
  int __ec = pthread_mutexattr_init(&attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&attr, 1);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutex_init(__m, &attr);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&attr);
  if (__ec) {
    pthread_mutex_destroy(__m);
    return __ec;
  }
  return 0;
}

int __libcpp_mutex_lock(__libcpp_mutex_t *__m) {
  return pthread_mutex_lock(__m);
}

int __libcpp_mutex_trylock(__libcpp_mutex_t *__m) {
  return pthread_mutex_trylock(__m);
}

int __libcpp_mutex_unlock(__libcpp_mutex_t *__m) {
  return pthread_mutex_unlock(__m);
}

int __libcpp_mutex_destroy(__libcpp_mutex_t *__m) {
  return pthread_mutex_destroy(__m);
}


int __libcpp_condvar_signal(__libcpp_condvar_t *__cv) {
  return pthread_cond_signal(__cv);
}

int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv) {
  return pthread_cond_broadcast(__cv);
}

int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m) {
  return pthread_cond_wait(__cv, __m);
}

int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               timespec *__ts) {
  return pthread_cond_timedwait(__cv, __m, __ts);
}

int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv) {
  return pthread_cond_destroy(__cv);
}


bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2) {
  return pthread_equal(t1, t2) != 0;
}


bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2) {

  return t1.__ < t2.__;



}


int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg) {
  return pthread_create(__t, 0, __func, __arg);
}

__libcpp_thread_id __libcpp_thread_get_current_id() { return pthread_self(); }

__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t) {
  return *__t;
}

int __libcpp_thread_join(__libcpp_thread_t *__t) {
  return pthread_join(*__t, 0);
}

int __libcpp_thread_detach(__libcpp_thread_t *__t) {
  return pthread_detach(*__t);
}

void __libcpp_thread_yield() { sched_yield(); }


int __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *)) {
  return pthread_key_create(__key, __at_exit);
}

void *__libcpp_tls_get(__libcpp_tls_key __key) {
  return pthread_getspecific(__key);
}

void __libcpp_tls_set(__libcpp_tls_key __key, void *__p) {
  pthread_setspecific(__key, __p);
}



} }


namespace std { inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;
using ::clock;
using ::difftime;
using ::mktime;
using ::time;

using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;

using ::strftime;

} }



namespace std { inline namespace __1 {



template <intmax_t _Xp, intmax_t _Yp> struct __static_gcd {
  static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp> struct __static_gcd<_Xp, 0> {
  static const intmax_t value = _Xp;
};

template <> struct __static_gcd<0, 0> { static const intmax_t value = 1; };



template <intmax_t _Xp, intmax_t _Yp> struct __static_lcm {
  static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp> struct __static_abs {
  static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp> struct __static_sign {
  static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, 1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  static_assert(_Xp <= max - _Yp, "overflow in __ll_add");

public:
  static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, 0> {
public:
  static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, -1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  static_assert(min - _Yp <= _Xp, "overflow in __ll_add");

public:
  static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, 1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");

public:
  static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, 0> {
public:
  static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, -1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");

public:
  static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_mul {
  static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
  static const intmax_t min = nan + 1;
  static const intmax_t max = -min;
  static const intmax_t __a_x = __static_abs<_Xp>::value;
  static const intmax_t __a_y = __static_abs<_Yp>::value;

  static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y,
                "overflow in __ll_mul");

public:
  static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp> class __ll_mul<0, _Yp> {
public:
  static const intmax_t value = 0;
};

template <intmax_t _Xp> class __ll_mul<_Xp, 0> {
public:
  static const intmax_t value = 0;
};

template <> class __ll_mul<0, 0> {
public:
  static const intmax_t value = 0;
};


template <intmax_t _Xp, intmax_t _Yp> class __ll_div {
  static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
  static const intmax_t min = nan + 1;
  static const intmax_t max = -min;

  static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");

public:
  static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1> class __attribute__((__visibility__("default"))) ratio {
  static_assert(__static_abs<_Num>::value >= 0,
                "ratio numerator is out of range");
  static_assert(_Den != 0, "ratio divide by 0");
  static_assert(__static_abs<_Den>::value > 0,
                "ratio denominator is out of range");
  static constexpr const intmax_t __na = __static_abs<_Num>::value;
  static constexpr const intmax_t __da = __static_abs<_Den>::value;
  static constexpr const intmax_t __s =
      __static_sign<_Num>::value * __static_sign<_Den>::value;
  static constexpr const intmax_t __gcd =
      __static_gcd<__na, __da>::value;

public:
  static constexpr const intmax_t num = __s * __na / __gcd;
  static constexpr const intmax_t den = __da / __gcd;

  typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den>
struct __is_ratio<ratio<_Num, _Den>> : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio<10LL, 1LL> deca;
typedef ratio<100LL, 1LL> hecto;
typedef ratio<1000LL, 1LL> kilo;
typedef ratio<1000000LL, 1LL> mega;
typedef ratio<1000000000LL, 1LL> giga;
typedef ratio<1000000000000LL, 1LL> tera;
typedef ratio<1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2> struct __ratio_multiply {
private:
  static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
  static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;

public:
  typedef typename ratio<
      __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
      __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value>::type
      type;
};



template <class _R1, class _R2>
using ratio_multiply = typename __ratio_multiply<_R1, _R2>::type;
template <class _R1, class _R2> struct __ratio_divide {
private:
  static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
  static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

public:
  typedef typename ratio<
      __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
      __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::type
      type;
};



template <class _R1, class _R2>
using ratio_divide = typename __ratio_divide<_R1, _R2>::type;
template <class _R1, class _R2> struct __ratio_add {
private:
  static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
  static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

public:
  typedef typename ratio_multiply<
      ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
      ratio<__ll_add<
                __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                __ll_mul<_R2::num / __gcd_n1_n2,
                         _R1::den / __gcd_d1_d2>::value>::value,
            _R2::den>>::type type;
};



template <class _R1, class _R2>
using ratio_add = typename __ratio_add<_R1, _R2>::type;
template <class _R1, class _R2> struct __ratio_subtract {
private:
  static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
  static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

public:
  typedef typename ratio_multiply<
      ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
      ratio<__ll_sub<
                __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                __ll_mul<_R2::num / __gcd_n1_n2,
                         _R1::den / __gcd_d1_d2>::value>::value,
            _R2::den>>::type type;
};



template <class _R1, class _R2>
using ratio_subtract = typename __ratio_subtract<_R1, _R2>::type;
template <class _R1, class _R2>
struct __attribute__((__visibility__("default"))) ratio_equal
    : public integral_constant<bool, ((_R1::num == _R2::num && _R1::den == _R2::den))> {};


template <class _R1, class _R2>
struct __attribute__((__visibility__("default"))) ratio_not_equal
    : public integral_constant<bool, ((!ratio_equal<_R1, _R2>::value))> {};



template <
    class _R1, class _R2, bool _Odd = false, intmax_t _Q1 = _R1::num / _R1::den,
    intmax_t _M1 = _R1::num % _R1::den, intmax_t _Q2 = _R2::num / _R2::den,
    intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1 {
  static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0> {
  static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2> {
  static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0> {
  static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
          intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2> {
  static const bool value =
      __ratio_less1<ratio<_R1::den, _M1>, ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
          intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less {
  static const bool value = _S1 < _S2;
};

template <class _R1, class _R2> struct __ratio_less<_R1, _R2, 1LL, 1LL> {
  static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2> struct __ratio_less<_R1, _R2, -1LL, -1LL> {
  static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>,
                                          ratio<-_R1::num, _R1::den>>::value;
};

template <class _R1, class _R2>
struct __attribute__((__visibility__("default"))) ratio_less
    : public integral_constant<bool, ((__ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __attribute__((__visibility__("default"))) ratio_less_equal
    : public integral_constant<bool, ((!ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__((__visibility__("default"))) ratio_greater
    : public integral_constant<bool, ((ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__((__visibility__("default"))) ratio_greater_equal
    : public integral_constant<bool, ((!ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2> struct __ratio_gcd {
  typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                __static_lcm<_R1::den, _R2::den>::value>
      type;
};
} }




namespace std { inline namespace __1 {

namespace chrono {

template <class _Rep, class _Period = ratio<1>>
class __attribute__((__visibility__("default"))) duration;

template <class _Tp> struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period>> : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period>> : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period>> : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period>> : true_type {};

}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__((__visibility__("default"))) common_type<chrono::duration<_Rep1, _Period1>,
                                         chrono::duration<_Rep2, _Period2>> {
  typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                           typename __ratio_gcd<_Period1, _Period2>::type>
      type;
};

namespace chrono {



template <class _FromDuration, class _ToDuration,
          class _Period =
              typename ratio_divide<typename _FromDuration::period,
                                    typename _ToDuration::period>::type,
          bool = _Period::num == 1, bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true> {
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr _ToDuration
  operator()(const _FromDuration &__fd) const {
    return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
  }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false> {
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr _ToDuration
  operator()(const _FromDuration &__fd) const {
    typedef
        typename common_type<typename _ToDuration::rep,
                             typename _FromDuration::rep, intmax_t>::type _Ct;
    return _ToDuration(static_cast<typename _ToDuration::rep>(
        static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
  }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true> {
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr _ToDuration
  operator()(const _FromDuration &__fd) const {
    typedef
        typename common_type<typename _ToDuration::rep,
                             typename _FromDuration::rep, intmax_t>::type _Ct;
    return _ToDuration(static_cast<typename _ToDuration::rep>(
        static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
  }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false> {
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr _ToDuration
  operator()(const _FromDuration &__fd) const {
    typedef
        typename common_type<typename _ToDuration::rep,
                             typename _FromDuration::rep, intmax_t>::type _Ct;
    return _ToDuration(static_cast<typename _ToDuration::rep>(
        static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num) /
        static_cast<_Ct>(_Period::den)));
  }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    typename enable_if<__is_duration<_ToDuration>::value, _ToDuration>::type
    duration_cast(const duration<_Rep, _Period> &__fd) {
  return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct __attribute__((__visibility__("default"))) treat_as_floating_point : is_floating_point<_Rep> {
};







template <class _Rep> struct __attribute__((__visibility__("default"))) duration_values {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr _Rep zero() {
    return _Rep(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr _Rep max() {
    return numeric_limits<_Rep>::max();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr _Rep min() {
    return numeric_limits<_Rep>::lowest();
  }
};
template <class _Rep, class _Period> class __attribute__((__visibility__("default"))) duration {
  static_assert(!__is_duration<_Rep>::value,
                "A duration representation can not be a duration");
  static_assert(__is_ratio<_Period>::value,
                "Second template parameter of duration must be a std::ratio");
  static_assert(_Period::num > 0, "duration period must be positive");

  template <class _R1, class _R2> struct __no_overflow {
  private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
    static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
    static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
    static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
    static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
    static const intmax_t max =
        -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

    template <intmax_t _Xp, intmax_t _Yp, bool __overflow>
    struct __mul
    {
      static const intmax_t value = _Xp * _Yp;
    };

    template <intmax_t _Xp, intmax_t _Yp> struct __mul<_Xp, _Yp, true> {
      static const intmax_t value = 1;
    };

  public:
    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
    typedef ratio<__mul<__n1, __d2, !value>::value,
                  __mul<__n2, __d1, !value>::value>
        type;
  };

public:
  typedef _Rep rep;
  typedef _Period period;

private:
  rep __rep_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr

  duration() = default;





  template <class _Rep2>
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr explicit duration(
      const _Rep2 &__r,
      typename enable_if<is_convertible<_Rep2, rep>::value &&
                         (treat_as_floating_point<rep>::value ||
                          !treat_as_floating_point<_Rep2>::value)>::type * = 0)
      : __rep_(__r) {}


  template <class _Rep2, class _Period2>
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr duration(
      const duration<_Rep2, _Period2> &__d,
      typename enable_if<__no_overflow<_Period2, period>::value &&
                         (treat_as_floating_point<rep>::value ||
                          (__no_overflow<_Period2, period>::type::den == 1 &&
                           !treat_as_floating_point<_Rep2>::value))>::type * =
          0)
      : __rep_(std::__1::chrono::duration_cast<duration>(__d).count()) {}



  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr rep count() const {
    return __rep_;
  }



  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr duration operator+() const {
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr duration operator-() const {
    return duration(-__rep_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) duration &operator++() {
    ++__rep_;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) duration operator++(int) {
    return duration(__rep_++);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) duration &operator--() {
    --__rep_;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) duration operator--(int) {
    return duration(__rep_--);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) duration &operator+=(const duration &__d) {
    __rep_ += __d.count();
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) duration &operator-=(const duration &__d) {
    __rep_ -= __d.count();
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) duration &operator*=(const rep &rhs) {
    __rep_ *= rhs;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) duration &operator/=(const rep &rhs) {
    __rep_ /= rhs;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) duration &operator%=(const rep &rhs) {
    __rep_ %= rhs;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) duration &operator%=(const duration &rhs) {
    __rep_ %= rhs.count();
    return *this;
  }



  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr duration zero() {
    return duration(duration_values<rep>::zero());
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr duration min() {
    return duration(duration_values<rep>::min());
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr duration max() {
    return duration(duration_values<rep>::max());
  }
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long> seconds;
typedef duration<long, ratio<60>> minutes;
typedef duration<long, ratio<3600>> hours;



template <class _LhsDuration, class _RhsDuration> struct __duration_eq {
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
  operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const {
    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
    return _Ct(__lhs).count() == _Ct(__rhs).count();
  }
};

template <class _LhsDuration> struct __duration_eq<_LhsDuration, _LhsDuration> {
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
  operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const {
    return __lhs.count() == __rhs.count();
  }
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
operator==(const duration<_Rep1, _Period1> &__lhs,
           const duration<_Rep2, _Period2> &__rhs) {
  return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>()(
      __lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
operator!=(const duration<_Rep1, _Period1> &__lhs,
           const duration<_Rep2, _Period2> &__rhs) {
  return !(__lhs == __rhs);
}



template <class _LhsDuration, class _RhsDuration> struct __duration_lt {
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
  operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const {
    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
    return _Ct(__lhs).count() < _Ct(__rhs).count();
  }
};

template <class _LhsDuration> struct __duration_lt<_LhsDuration, _LhsDuration> {
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
  operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const {
    return __lhs.count() < __rhs.count();
  }
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
operator<(const duration<_Rep1, _Period1> &__lhs,
          const duration<_Rep2, _Period2> &__rhs) {
  return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>()(
      __lhs, __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
operator>(const duration<_Rep1, _Period1> &__lhs,
          const duration<_Rep2, _Period2> &__rhs) {
  return __rhs < __lhs;
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
operator<=(const duration<_Rep1, _Period1> &__lhs,
           const duration<_Rep2, _Period2> &__rhs) {
  return !(__rhs < __lhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr bool
operator>=(const duration<_Rep1, _Period1> &__lhs,
           const duration<_Rep2, _Period2> &__rhs) {
  return !(__lhs < __rhs);
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    typename common_type<duration<_Rep1, _Period1>,
                         duration<_Rep2, _Period2>>::type
    operator+(const duration<_Rep1, _Period1> &__lhs,
              const duration<_Rep2, _Period2> &__rhs) {
  typedef typename common_type<duration<_Rep1, _Period1>,
                               duration<_Rep2, _Period2>>::type _Cd;
  return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}



template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    typename common_type<duration<_Rep1, _Period1>,
                         duration<_Rep2, _Period2>>::type
    operator-(const duration<_Rep1, _Period1> &__lhs,
              const duration<_Rep2, _Period2> &__rhs) {
  typedef typename common_type<duration<_Rep1, _Period1>,
                               duration<_Rep2, _Period2>>::type _Cd;
  return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr typename enable_if<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
operator*(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef duration<_Cr, _Period> _Cd;
  return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr typename enable_if<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
operator*(const _Rep1 &__s, const duration<_Rep2, _Period> &__d) {
  return __d * __s;
}



template <class _Duration, class _Rep, bool = __is_duration<_Rep>::value>
struct __duration_divide_result {};

template <
    class _Duration, class _Rep2,
    bool = is_convertible<_Rep2, typename common_type<typename _Duration::rep,
                                                      _Rep2>::type>::value>
struct __duration_divide_imp {};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_imp<duration<_Rep1, _Period>, _Rep2, true> {
  typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period> type;
};

template <class _Rep1, class _Period, class _Rep2>
struct __duration_divide_result<duration<_Rep1, _Period>, _Rep2, false>
    : __duration_divide_imp<duration<_Rep1, _Period>, _Rep2> {};

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
    operator/(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef duration<_Cr, _Period> _Cd;
  return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    typename common_type<_Rep1, _Rep2>::type
    operator/(const duration<_Rep1, _Period1> &__lhs,
              const duration<_Rep2, _Period2> &__rhs) {
  typedef typename common_type<duration<_Rep1, _Period1>,
                               duration<_Rep2, _Period2>>::type _Ct;
  return _Ct(__lhs).count() / _Ct(__rhs).count();
}



template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    typename __duration_divide_result<duration<_Rep1, _Period>, _Rep2>::type
    operator%(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef duration<_Cr, _Period> _Cd;
  return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) constexpr
    typename common_type<duration<_Rep1, _Period1>,
                         duration<_Rep2, _Period2>>::type
    operator%(const duration<_Rep1, _Period1> &__lhs,
              const duration<_Rep2, _Period2> &__rhs) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef typename common_type<duration<_Rep1, _Period1>,
                               duration<_Rep2, _Period2>>::type _Cd;
  return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) %
             static_cast<_Cr>(_Cd(__rhs).count()));
}





template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__((__visibility__("default"))) time_point {
  static_assert(__is_duration<_Duration>::value, "Second template parameter of "
                                                 "time_point must be a "
                                                 "std::chrono::duration");

public:
  typedef _Clock clock;
  typedef _Duration duration;
  typedef typename duration::rep rep;
  typedef typename duration::period period;

private:
  duration __d_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) time_point()
      : __d_(duration::zero()) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
                                    explicit time_point(const duration &__d)
      : __d_(__d) {}


  template <class _Duration2>
  __attribute__((__visibility__("hidden"), __always_inline__)) time_point(
      const time_point<clock, _Duration2> &t,
      typename enable_if<is_convertible<_Duration2, duration>::value>::type * =
          0)
      : __d_(t.time_since_epoch()) {}



  __attribute__((__visibility__("hidden"), __always_inline__)) duration
  time_since_epoch() const {
    return __d_;
  }



  __attribute__((__visibility__("hidden"), __always_inline__)) time_point &operator+=(const duration &__d) {
    __d_ += __d;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) time_point &operator-=(const duration &__d) {
    __d_ -= __d;
    return *this;
  }



  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr time_point min() {
    return time_point(duration::min());
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) static constexpr time_point max() {
    return time_point(duration::max());
  }
};

}

template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__((__visibility__("default")))
    common_type<chrono::time_point<_Clock, _Duration1>,
                chrono::time_point<_Clock, _Duration2>> {
  typedef chrono::time_point<_Clock,
                             typename common_type<_Duration1, _Duration2>::type>
      type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__((__visibility__("hidden"), __always_inline__))
                                  time_point<_Clock, _ToDuration>
    time_point_cast(const time_point<_Clock, _Duration> &__t) {
  return time_point<_Clock, _ToDuration>(
      std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const time_point<_Clock, _Duration1> &__lhs,
           const time_point<_Clock, _Duration2> &__rhs) {
  return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const time_point<_Clock, _Duration1> &__lhs,
           const time_point<_Clock, _Duration2> &__rhs) {
  return !(__lhs == __rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const time_point<_Clock, _Duration1> &__lhs,
          const time_point<_Clock, _Duration2> &__rhs) {
  return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const time_point<_Clock, _Duration1> &__lhs,
          const time_point<_Clock, _Duration2> &__rhs) {
  return __rhs < __lhs;
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const time_point<_Clock, _Duration1> &__lhs,
           const time_point<_Clock, _Duration2> &__rhs) {
  return !(__rhs < __lhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const time_point<_Clock, _Duration1> &__lhs,
           const time_point<_Clock, _Duration2> &__rhs) {
  return !(__lhs < __rhs);
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) time_point<
    _Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>
operator+(const time_point<_Clock, _Duration1> &__lhs,
          const duration<_Rep2, _Period2> &__rhs) {
  typedef time_point<
      _Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>
      _Tr;
  return _Tr(__lhs.time_since_epoch() + __rhs);
}



template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) time_point<
    _Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1> &__lhs,
          const time_point<_Clock, _Duration2> &__rhs) {
  return __rhs + __lhs;
}



template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden"), __always_inline__)) time_point<
    _Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>
operator-(const time_point<_Clock, _Duration1> &__lhs,
          const duration<_Rep2, _Period2> &__rhs) {
  return __lhs + (-__rhs);
}



template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename common_type<_Duration1, _Duration2>::type
    operator-(const time_point<_Clock, _Duration1> &__lhs,
              const time_point<_Clock, _Duration2> &__rhs) {
  return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}





class __attribute__((__visibility__("default"))) system_clock {
public:
  typedef microseconds duration;
  typedef duration::rep rep;
  typedef duration::period period;
  typedef chrono::time_point<system_clock> time_point;
  static const bool is_steady = false;

  static time_point now() noexcept;
  static time_t to_time_t(const time_point &__t) noexcept;
  static time_point from_time_t(time_t __t) noexcept;
};


class __attribute__((__visibility__("default"))) steady_clock {
public:
  typedef nanoseconds duration;
  typedef duration::rep rep;
  typedef duration::period period;
  typedef chrono::time_point<steady_clock, duration> time_point;
  static const bool is_steady = true;

  static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;




}
} }




#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
    int __errno2(void);
    int *__err2ad(void);
           extern int errno;
           extern int *__errno(void);
  }


#pragma checkout(resume)
static const int __elast1 = 104;
static const int __elast2 = 105;


namespace std { inline namespace __1 {



template <class _Tp>
struct __attribute__((__visibility__("default"))) is_error_code_enum : public false_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_error_condition_enum : public false_type {};
enum class errc{address_family_not_supported = 1114,
                                  address_in_use = 1115,
                                  address_not_available = 1116,
                                  already_connected = 1123,
                                  argument_list_too_long = 145,
                                  argument_out_of_domain = 1,
                                  bad_address = 118,
                                  bad_file_descriptor = 113,
                                  bad_message = 1140,
                                  broken_pipe = 140,
                                  connection_aborted = 1120,
                                  connection_already_in_progress = 1104,
                                  connection_refused = 1128,
                                  connection_reset = 1121,
                                  cross_device_link = 144,
                                  destination_address_required = 1106,
                                  device_or_resource_busy = 114,
                                  directory_not_empty = 136,
                                  executable_format_error = 130,
                                  file_exists = 117,
                                  file_too_large = 119,
                                  filename_too_long = 126,
                                  function_not_supported = 134,
                                  host_unreachable = 1130,
                                  identifier_removed = 1141,
                                  illegal_byte_sequence = 147,
                                  inappropriate_io_control_operation = 137,
                                  interrupted = 120,
                                  invalid_argument = 121,
                                  invalid_seek = 142,
                                  io_error = 122,
                                  is_a_directory = 123,
                                  message_size = 1107,
                                  network_down = 1117,
                                  network_reset = 1119,
                                  network_unreachable = 1118,
                                  no_buffer_space = 1122,
                                  no_child_process = 115,
                                  no_link = 1144,
                                  no_lock_available = 131,

                                  no_message_available = 148,



                                  no_message = 1139,
                                  no_protocol_option = 1109,
                                  no_space_on_device = 133,

                                  no_stream_resources = 1138,



                                  no_such_device_or_address = 138,
                                  no_such_device = 128,
                                  no_such_file_or_directory = 129,
                                  no_such_process = 143,
                                  not_a_directory = 135,
                                  not_a_socket = 1105,

                                  not_a_stream = 1136,



                                  not_connected = 1124,
                                  not_enough_memory = 132,
                                  not_supported = 247,
                                  operation_canceled = 1152,
                                  operation_in_progress = 1103,
                                  operation_not_permitted = 139,
                                  operation_not_supported = 1112,
                                  operation_would_block = 1102,
                                  owner_dead = __elast1,
                                  permission_denied = 111,
                                  protocol_error = 1148,
                                  protocol_not_supported = 1110,
                                  read_only_file_system = 141,
                                  resource_deadlock_would_occur = 116,
                                  resource_unavailable_try_again = 112,
                                  result_out_of_range = 2,
                                  state_not_recoverable = __elast2,

                                  stream_timeout = 1137,



                                  text_file_busy = 1101,
                                  timed_out = 1127,
                                  too_many_files_open_in_system = 127,
                                  too_many_files_open = 124,
                                  too_many_links = 125,
                                  too_many_symbolic_link_levels = 146,
                                  value_too_large = 149,
                                  wrong_protocol_type = 1108};


template <>
struct __attribute__((__visibility__("default"))) is_error_condition_enum<errc> : true_type {};






class __attribute__((__visibility__("default"))) error_condition;
class __attribute__((__visibility__("default"))) error_code;



class __attribute__((__visibility__("hidden"))) __do_message;

class __attribute__((__visibility__("default"))) error_category {
public:
  virtual ~error_category() noexcept;




  __attribute__((__visibility__("hidden"), __always_inline__))
                                error_category() noexcept = default;

private:
  error_category(const error_category &);
  error_category &operator=(const error_category &);

public:
  virtual const char *name() const noexcept = 0;
  virtual error_condition default_error_condition(int __ev) const noexcept;
  virtual bool equivalent(int __code,
                          const error_condition &__condition) const noexcept;
  virtual bool equivalent(const error_code &__code,
                          int __condition) const noexcept;
  virtual string message(int __ev) const = 0;

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator==(const error_category &__rhs) const noexcept {
    return this == &__rhs;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator!=(const error_category &__rhs) const noexcept {
    return !(*this == __rhs);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator<(const error_category &__rhs) const noexcept {
    return this < &__rhs;
  }

  friend class __attribute__((__visibility__("hidden"))) __do_message;
};

class __attribute__((__visibility__("hidden"))) __do_message : public error_category {
public:
  virtual string message(int ev) const;
};

__attribute__((__visibility__("default"))) const error_category &generic_category() noexcept;
__attribute__((__visibility__("default"))) const error_category &system_category() noexcept;

class __attribute__((__visibility__("default"))) error_condition {
  int __val_;
  const error_category *__cat_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  error_condition() noexcept : __val_(0), __cat_(&generic_category()) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  error_condition(int __val, const error_category &__cat) noexcept
      : __val_(__val),
        __cat_(&__cat) {}

  template <class _Ep>
  __attribute__((__visibility__("hidden"), __always_inline__)) error_condition(
      _Ep __e, typename enable_if<is_error_condition_enum<_Ep>::value>::type * =
                   0) noexcept {
    *this = make_error_condition(__e);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void assign(int __val, const error_category &__cat) noexcept {
    __val_ = __val;
    __cat_ = &__cat;
  }

  template <class _Ep>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<is_error_condition_enum<_Ep>::value,
                                           error_condition &>::type
  operator=(_Ep __e) noexcept {
    *this = make_error_condition(__e);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept {
    __val_ = 0;
    __cat_ = &generic_category();
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int value() const noexcept { return __val_; }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const error_category &category() const noexcept { return *__cat_; }
  string message() const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit
  operator bool() const noexcept { return __val_ != 0; }
};

inline __attribute__((__visibility__("hidden"), __always_inline__)) error_condition
make_error_condition(errc __e) noexcept {
  return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const error_condition &__x, const error_condition &__y) noexcept {
  return __x.category() < __y.category() ||
         (__x.category() == __y.category() && __x.value() < __y.value());
}



class __attribute__((__visibility__("default"))) error_code {
  int __val_;
  const error_category *__cat_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  error_code() noexcept : __val_(0), __cat_(&system_category()) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  error_code(int __val, const error_category &__cat) noexcept
      : __val_(__val),
        __cat_(&__cat) {}

  template <class _Ep>
  __attribute__((__visibility__("hidden"), __always_inline__))
  error_code(_Ep __e,
             typename enable_if<is_error_code_enum<_Ep>::value>::type * =
                 0) noexcept {
    *this = make_error_code(__e);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void assign(int __val, const error_category &__cat) noexcept {
    __val_ = __val;
    __cat_ = &__cat;
  }

  template <class _Ep>
  __attribute__((__visibility__("hidden"), __always_inline__))
      typename enable_if<is_error_code_enum<_Ep>::value, error_code &>::type
      operator=(_Ep __e) noexcept {
    *this = make_error_code(__e);
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept {
    __val_ = 0;
    __cat_ = &system_category();
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int value() const noexcept { return __val_; }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const error_category &category() const noexcept { return *__cat_; }

  __attribute__((__visibility__("hidden"), __always_inline__))
  error_condition default_error_condition() const noexcept {
    return __cat_->default_error_condition(__val_);
  }

  string message() const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit
  operator bool() const noexcept { return __val_ != 0; }
};

inline __attribute__((__visibility__("hidden"), __always_inline__)) error_code
make_error_code(errc __e) noexcept {
  return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const error_code &__x, const error_code &__y) noexcept {
  return __x.category() < __y.category() ||
         (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const error_code &__x, const error_code &__y) noexcept {
  return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const error_code &__x, const error_condition &__y) noexcept {
  return __x.category().equivalent(__x.value(), __y) ||
         __y.category().equivalent(__x, __y.value());
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const error_condition &__x, const error_code &__y) noexcept {
  return __y == __x;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const error_condition &__x, const error_condition &__y) noexcept {
  return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const error_code &__x, const error_code &__y) noexcept {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const error_code &__x, const error_condition &__y) noexcept {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const error_condition &__x, const error_code &__y) noexcept {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const error_condition &__x, const error_condition &__y) noexcept {
  return !(__x == __y);
}

template <>
struct __attribute__((__visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(const error_code &__ec) const noexcept {
    return static_cast<size_t>(__ec.value());
  }
};



class __attribute__((__visibility__("default"))) system_error : public runtime_error {
  error_code __ec_;

public:
  system_error(error_code __ec, const string &__what_arg);
  system_error(error_code __ec, const char *__what_arg);
  system_error(error_code __ec);
  system_error(int __ev, const error_category &__ecat,
               const string &__what_arg);
  system_error(int __ev, const error_category &__ecat, const char *__what_arg);
  system_error(int __ev, const error_category &__ecat);
  ~system_error() noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  const error_code &code() const noexcept { return __ec_; }

private:
  static string __init(const error_code &, string);
};

[[noreturn]] __attribute__((__visibility__("default"))) void
__throw_system_error(int ev, const char *what_arg);

} }


namespace std { inline namespace __1 {
class __attribute__((__visibility__("default")))
                                                          mutex {

  __libcpp_mutex_t __m_ = {0x00000000FBD7C9D6};




public:
  __attribute__((__visibility__("hidden"), __always_inline__))

  constexpr mutex() noexcept = default;



      ~mutex();

private:
  mutex(const mutex &);
  mutex &operator=(const mutex &);

public:
  void lock() ;
  bool try_lock() noexcept
                                                                    ;
  void unlock() noexcept
                                                            ;

  typedef __libcpp_mutex_t *native_handle_type;
  __attribute__((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() { return &__m_; }
};

struct __attribute__((__visibility__("default"))) defer_lock_t {};
struct __attribute__((__visibility__("default"))) try_to_lock_t {};
struct __attribute__((__visibility__("default"))) adopt_lock_t {};
constexpr defer_lock_t defer_lock = defer_lock_t();
constexpr try_to_lock_t try_to_lock = try_to_lock_t();
constexpr adopt_lock_t adopt_lock = adopt_lock_t();
template <class _Mutex>
class __attribute__((__visibility__("default")))

    lock_guard



{
public:
  typedef _Mutex mutex_type;

private:
  mutex_type &__m_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit lock_guard(mutex_type &__m)

      : __m_(__m) {
    __m_.lock();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  lock_guard(mutex_type &__m, adopt_lock_t)

      : __m_(__m) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~lock_guard() {
    __m_.unlock();
  }

private:
  lock_guard(lock_guard const &) = delete;
  lock_guard &operator=(lock_guard const &) = delete;
};

template <class _Mutex> class __attribute__((__visibility__("default"))) unique_lock {
public:
  typedef _Mutex mutex_type;

private:
  mutex_type *__m_;
  bool __owns_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_lock() noexcept : __m_(nullptr), __owns_(false) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit unique_lock(mutex_type &__m)
      : __m_(std::__1::addressof(__m)), __owns_(true) {
    __m_->lock();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_lock(mutex_type &__m, defer_lock_t) noexcept
      : __m_(std::__1::addressof(__m)),
        __owns_(false) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_lock(mutex_type &__m, try_to_lock_t)
      : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock()) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_lock(mutex_type &__m, adopt_lock_t)
      : __m_(std::__1::addressof(__m)), __owns_(true) {}
  template <class _Clock, class _Duration>
  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_lock(mutex_type &__m, const chrono::time_point<_Clock, _Duration> &__t)
      : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_until(__t)) {}
  template <class _Rep, class _Period>
  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_lock(mutex_type &__m, const chrono::duration<_Rep, _Period> &__d)
      : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_for(__d)) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~unique_lock() {
    if (__owns_)
      __m_->unlock();
  }

private:
  unique_lock(unique_lock const &);
  unique_lock &operator=(unique_lock const &);

public:

  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_lock(unique_lock &&__u) noexcept : __m_(__u.__m_),
                                             __owns_(__u.__owns_) {
    __u.__m_ = nullptr;
    __u.__owns_ = false;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  unique_lock &operator=(unique_lock &&__u) noexcept {
    if (__owns_)
      __m_->unlock();
    __m_ = __u.__m_;
    __owns_ = __u.__owns_;
    __u.__m_ = nullptr;
    __u.__owns_ = false;
    return *this;
  }



  void lock();
  bool try_lock();

  template <class _Rep, class _Period>
  bool try_lock_for(const chrono::duration<_Rep, _Period> &__d);
  template <class _Clock, class _Duration>
  bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);

  void unlock();

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(unique_lock &__u) noexcept {
    std::__1::swap(__m_, __u.__m_);
    std::__1::swap(__owns_, __u.__owns_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  mutex_type *release() noexcept {
    mutex_type *__m = __m_;
    __m_ = nullptr;
    __owns_ = false;
    return __m;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool owns_lock() const noexcept { return __owns_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit
  operator bool() const noexcept { return __owns_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  mutex_type *mutex() const noexcept { return __m_; }
};

template <class _Mutex> void unique_lock<_Mutex>::lock() {
  if (__m_ == nullptr)
    __throw_system_error(139, "unique_lock::lock: references null mutex");
  if (__owns_)
    __throw_system_error(116, "unique_lock::lock: already locked");
  __m_->lock();
  __owns_ = true;
}

template <class _Mutex> bool unique_lock<_Mutex>::try_lock() {
  if (__m_ == nullptr)
    __throw_system_error(139, "unique_lock::try_lock: references null mutex");
  if (__owns_)
    __throw_system_error(116, "unique_lock::try_lock: already locked");
  __owns_ = __m_->try_lock();
  return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool unique_lock<_Mutex>::try_lock_for(
    const chrono::duration<_Rep, _Period> &__d) {
  if (__m_ == nullptr)
    __throw_system_error(139,
                         "unique_lock::try_lock_for: references null mutex");
  if (__owns_)
    __throw_system_error(116, "unique_lock::try_lock_for: already locked");
  __owns_ = __m_->try_lock_for(__d);
  return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool unique_lock<_Mutex>::try_lock_until(
    const chrono::time_point<_Clock, _Duration> &__t) {
  if (__m_ == nullptr)
    __throw_system_error(139,
                         "unique_lock::try_lock_until: references null mutex");
  if (__owns_)
    __throw_system_error(116,
                         "unique_lock::try_lock_until: already locked");
  __owns_ = __m_->try_lock_until(__t);
  return __owns_;
}

template <class _Mutex> void unique_lock<_Mutex>::unlock() {
  if (!__owns_)
    __throw_system_error(139, "unique_lock::unlock: not locked");
  __m_->unlock();
  __owns_ = false;
}

template <class _Mutex>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(unique_lock<_Mutex> &__x,
                                           unique_lock<_Mutex> &__y) noexcept {
  __x.swap(__y);
}


enum class cv_status{no_timeout, timeout};


class __attribute__((__visibility__("default"))) condition_variable {

  __libcpp_condvar_t __cv_ = {0x00000000FBC3C9D6};




public:
  __attribute__((__visibility__("hidden"), __always_inline__))

  constexpr condition_variable() noexcept = default;





      ~condition_variable();

private:
  condition_variable(const condition_variable &);
  condition_variable &operator=(const condition_variable &);

public:
  void notify_one() noexcept;
  void notify_all() noexcept;

  void wait(unique_lock<mutex> &__lk) noexcept;
  template <class _Predicate>
  void wait(unique_lock<mutex> &__lk, _Predicate __pred);

  template <class _Clock, class _Duration>
  cv_status wait_until(unique_lock<mutex> &__lk,
                       const chrono::time_point<_Clock, _Duration> &__t);

  template <class _Clock, class _Duration, class _Predicate>
  bool wait_until(unique_lock<mutex> &__lk,
                  const chrono::time_point<_Clock, _Duration> &__t,
                  _Predicate __pred);

  template <class _Rep, class _Period>
  cv_status wait_for(unique_lock<mutex> &__lk,
                     const chrono::duration<_Rep, _Period> &__d);

  template <class _Rep, class _Period, class _Predicate>
  bool __attribute__((__visibility__("hidden"), __always_inline__))
  wait_for(unique_lock<mutex> &__lk, const chrono::duration<_Rep, _Period> &__d,
           _Predicate __pred);

  typedef __libcpp_condvar_t *native_handle_type;
  __attribute__((__visibility__("hidden"), __always_inline__)) native_handle_type native_handle() {
    return &__cv_;
  }

private:
  void __do_timed_wait(
      unique_lock<mutex> &__lk,
      chrono::time_point<chrono::system_clock, chrono::nanoseconds>) noexcept;
};


template <class _To, class _Rep, class _Period>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<chrono::__is_duration<_To>::value, _To>::type
    __ceil(chrono::duration<_Rep, _Period> __d) {
  using namespace chrono;
  _To __r = duration_cast<_To>(__d);
  if (__r < __d)
    ++__r;
  return __r;
}


template <class _Predicate>
void condition_variable::wait(unique_lock<mutex> &__lk, _Predicate __pred) {
  while (!__pred())
    wait(__lk);
}

template <class _Clock, class _Duration>
cv_status condition_variable::wait_until(
    unique_lock<mutex> &__lk,
    const chrono::time_point<_Clock, _Duration> &__t) {
  using namespace chrono;
  wait_for(__lk, __t - _Clock::now());
  return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Clock, class _Duration, class _Predicate>
bool condition_variable::wait_until(
    unique_lock<mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t,
    _Predicate __pred) {
  while (!__pred()) {
    if (wait_until(__lk, __t) == cv_status::timeout)
      return __pred();
  }
  return true;
}

template <class _Rep, class _Period>
cv_status
condition_variable::wait_for(unique_lock<mutex> &__lk,
                             const chrono::duration<_Rep, _Period> &__d) {
  using namespace chrono;
  if (__d <= __d.zero())
    return cv_status::timeout;
  typedef time_point<system_clock, duration<long double, nano>> __sys_tpf;
  typedef time_point<system_clock, nanoseconds> __sys_tpi;
  __sys_tpf _Max = __sys_tpi::max();
  system_clock::time_point __s_now = system_clock::now();
  steady_clock::time_point __c_now = steady_clock::now();
  if (_Max - __d > __s_now)
    __do_timed_wait(__lk, __s_now + __ceil<nanoseconds>(__d));
  else
    __do_timed_wait(__lk, __sys_tpi::max());
  return steady_clock::now() - __c_now < __d ? cv_status::no_timeout
                                             : cv_status::timeout;
}

template <class _Rep, class _Period, class _Predicate>
inline bool
condition_variable::wait_for(unique_lock<mutex> &__lk,
                             const chrono::duration<_Rep, _Period> &__d,
                             _Predicate __pred) {
  return wait_until(__lk, chrono::steady_clock::now() + __d,
                    std::__1::move(__pred));
}



} }


namespace std { inline namespace __1 {




template <class _Tp>

struct __attribute__((__visibility__("default"))) plus : binary_function<_Tp, _Tp, _Tp> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x + __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) minus : binary_function<_Tp, _Tp, _Tp> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x - __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) multiplies : binary_function<_Tp, _Tp, _Tp> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x * __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) divides : binary_function<_Tp, _Tp, _Tp> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x / __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) modulus : binary_function<_Tp, _Tp, _Tp> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x % __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) negate : unary_function<_Tp, _Tp> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
  operator()(const _Tp &__x) const {
    return -__x;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) equal_to : binary_function<_Tp, _Tp, bool> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x == __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) not_equal_to : binary_function<_Tp, _Tp, bool> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x != __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) greater : binary_function<_Tp, _Tp, bool> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x > __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) greater_equal : binary_function<_Tp, _Tp, bool> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x >= __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) less_equal : binary_function<_Tp, _Tp, bool> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x <= __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) logical_and : binary_function<_Tp, _Tp, bool> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x && __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) logical_or : binary_function<_Tp, _Tp, bool> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x || __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) logical_not : unary_function<_Tp, bool> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const _Tp &__x) const {
    return !__x;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) bit_and : binary_function<_Tp, _Tp, _Tp> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x & __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) bit_or : binary_function<_Tp, _Tp, _Tp> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x | __y;
  }
};
template <class _Tp>

struct __attribute__((__visibility__("default"))) bit_xor : binary_function<_Tp, _Tp, _Tp> {
                                __attribute__((__visibility__("hidden"), __always_inline__)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x ^ __y;
  }
};
template <class _Predicate>
class __attribute__((__visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool> {
  _Predicate __pred_;

public:

      __attribute__((__visibility__("hidden"), __always_inline__)) explicit unary_negate(const _Predicate &__pred)
      : __pred_(__pred) {}
                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const typename _Predicate::argument_type &__x) const {
    return !__pred_(__x);
  }
};

template <class _Predicate>
inline
    __attribute__((__visibility__("hidden"), __always_inline__)) unary_negate<_Predicate>
    not1(const _Predicate &__pred) {
  return unary_negate<_Predicate>(__pred);
}

template <class _Predicate>
class __attribute__((__visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type, bool> {
  _Predicate __pred_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit
  binary_negate(const _Predicate &__pred)
      : __pred_(__pred) {}

                                __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator()(const typename _Predicate::first_argument_type &__x,
             const typename _Predicate::second_argument_type &__y) const {
    return !__pred_(__x, __y);
  }
};

template <class _Predicate>
inline
    __attribute__((__visibility__("hidden"), __always_inline__)) binary_negate<_Predicate>
    not2(const _Predicate &__pred) {
  return binary_negate<_Predicate>(__pred);
}

template <class __Operation>
class __attribute__((__visibility__("default"))) binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type> {
protected:
  __Operation op;
  typename __Operation::first_argument_type value;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  binder1st(const __Operation &__x,
            const typename __Operation::first_argument_type __y)
      : op(__x), value(__y) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type
  operator()(typename __Operation::second_argument_type &__x) const {
    return op(value, __x);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type
  operator()(const typename __Operation::second_argument_type &__x) const {
    return op(value, __x);
  }
};

template <class __Operation, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) binder1st<__Operation>
bind1st(const __Operation &__op, const _Tp &__x) {
  return binder1st<__Operation>(__op, __x);
}

template <class __Operation>
class __attribute__((__visibility__("default"))) binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type> {
protected:
  __Operation op;
  typename __Operation::second_argument_type value;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  binder2nd(const __Operation &__x,
            const typename __Operation::second_argument_type __y)
      : op(__x), value(__y) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type
  operator()(typename __Operation::first_argument_type &__x) const {
    return op(__x, value);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) typename __Operation::result_type
  operator()(const typename __Operation::first_argument_type &__x) const {
    return op(__x, value);
  }
};

template <class __Operation, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) binder2nd<__Operation>
bind2nd(const __Operation &__op, const _Tp &__x) {
  return binder2nd<__Operation>(__op, __x);
}

template <class _Arg, class _Result>
class __attribute__((__visibility__("default"))) pointer_to_unary_function
    : public unary_function<_Arg, _Result> {
  _Result (*__f_)(_Arg);

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit pointer_to_unary_function(
      _Result (*__f)(_Arg))
      : __f_(__f) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg __x) const {
    return __f_(__x);
  }
};

template <class _Arg, class _Result>
inline __attribute__((__visibility__("hidden"), __always_inline__)) pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__f)(_Arg)) {
  return pointer_to_unary_function<_Arg, _Result>(__f);
}

template <class _Arg1, class _Arg2, class _Result>
class __attribute__((__visibility__("default"))) pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result> {
  _Result (*__f_)(_Arg1, _Arg2);

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit pointer_to_binary_function(
      _Result (*__f)(_Arg1, _Arg2))
      : __f_(__f) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Result operator()(_Arg1 __x, _Arg2 __y) const {
    return __f_(__x, __y);
  }
};

template <class _Arg1, class _Arg2, class _Result>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    pointer_to_binary_function<_Arg1, _Arg2, _Result>
        ptr_fun(_Result (*__f)(_Arg1, _Arg2)) {
  return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__f);
}

template <class _Sp, class _Tp>
class __attribute__((__visibility__("default"))) mem_fun_t : public unary_function<_Tp *, _Sp> {
  _Sp (_Tp::*__p_)();

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit mem_fun_t(_Sp (_Tp::*__p)()) : __p_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp *__p) const {
    return (__p->*__p_)();
  }
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__((__visibility__("default"))) mem_fun1_t
    : public binary_function<_Tp *, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap);

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
      : __p_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp *__p, _Ap __x) const {
    return (__p->*__p_)(__x);
  }
};

template <class _Sp, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) mem_fun_t<_Sp, _Tp>
mem_fun(_Sp (_Tp::*__f)()) {
  return mem_fun_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__((__visibility__("hidden"), __always_inline__)) mem_fun1_t<_Sp, _Tp, _Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap)) {
  return mem_fun1_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Sp, class _Tp>
class __attribute__((__visibility__("default"))) mem_fun_ref_t : public unary_function<_Tp, _Sp> {
  _Sp (_Tp::*__p_)();

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
      : __p_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp &__p) const {
    return (__p.*__p_)();
  }
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__((__visibility__("default"))) mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap);

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
      : __p_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Sp operator()(_Tp &__p, _Ap __x) const {
    return (__p.*__p_)(__x);
  }
};

template <class _Sp, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) mem_fun_ref_t<_Sp, _Tp>
mem_fun_ref(_Sp (_Tp::*__f)()) {
  return mem_fun_ref_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__((__visibility__("hidden"), __always_inline__)) mem_fun1_ref_t<_Sp, _Tp, _Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap)) {
  return mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Sp, class _Tp>
class __attribute__((__visibility__("default"))) const_mem_fun_t
    : public unary_function<const _Tp *, _Sp> {
  _Sp (_Tp::*__p_)() const;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)
      : __p_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp *__p) const {
    return (__p->*__p_)();
  }
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__((__visibility__("default"))) const_mem_fun1_t
    : public binary_function<const _Tp *, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap) const;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap)
                                                          const)
      : __p_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp *__p, _Ap __x) const {
    return (__p->*__p_)(__x);
  }
};

template <class _Sp, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const_mem_fun_t<_Sp, _Tp>
mem_fun(_Sp (_Tp::*__f)() const) {
  return const_mem_fun_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const_mem_fun1_t<_Sp, _Tp, _Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const) {
  return const_mem_fun1_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Sp, class _Tp>
class __attribute__((__visibility__("default"))) const_mem_fun_ref_t
    : public unary_function<_Tp, _Sp> {
  _Sp (_Tp::*__p_)() const;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)()
                                                             const)
      : __p_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp &__p) const {
    return (__p.*__p_)();
  }
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__((__visibility__("default"))) const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap) const;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap)
                                                              const)
      : __p_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) _Sp operator()(const _Tp &__p, _Ap __x) const {
    return (__p.*__p_)(__x);
  }
};

template <class _Sp, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const_mem_fun_ref_t<_Sp, _Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const) {
  return const_mem_fun_ref_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const_mem_fun1_ref_t<_Sp, _Tp, _Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const) {
  return const_mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
}





template <class _Tp> class __mem_fn : public __weak_result_type<_Tp> {
public:

  typedef _Tp type;

private:
  type __f_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) __mem_fn(type __f) noexcept : __f_(__f) {}



  template <class... _ArgTypes>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename __invoke_return<type, _ArgTypes...>::type
  operator()(_ArgTypes &&... __args) const {
    return __invoke(__f_, std::__1::forward<_ArgTypes>(__args)...);
  }
};

template <class _Rp, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::*__pm) noexcept {
  return __mem_fn<_Rp _Tp::*>(__pm);
}







class __attribute__((__visibility__("default"))) bad_function_call : public exception {};

[[noreturn]] inline __attribute__((__visibility__("hidden"), __always_inline__)) void __throw_bad_function_call() {

  throw bad_function_call();



}

template <class _Fp> class __attribute__((__visibility__("default"))) function;

namespace __function {

template <class _Rp> struct __maybe_derive_from_unary_function {};

template <class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp> {};

template <class _Rp> struct __maybe_derive_from_binary_function {};

template <class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp> {};

template <class _Fp> __attribute__((__visibility__("hidden"), __always_inline__)) bool __not_null(_Fp const &) {
  return true;
}

template <class _Fp> __attribute__((__visibility__("hidden"), __always_inline__)) bool __not_null(_Fp *__ptr) {
  return __ptr;
}

template <class _Ret, class _Class>
__attribute__((__visibility__("hidden"), __always_inline__)) bool __not_null(_Ret _Class::*__ptr) {
  return __ptr;
}

template <class _Fp>
__attribute__((__visibility__("hidden"), __always_inline__)) bool __not_null(function<_Fp> const &__f) {
  return !!__f;
}

}



namespace __function {

template <class _Fp> class __base;

template <class _Rp, class... _ArgTypes> class __base<_Rp(_ArgTypes...)> {
  __base(const __base &);
  __base &operator=(const __base &);

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) __base() {}
  __attribute__((__visibility__("hidden"), __always_inline__)) virtual ~__base() {}
  virtual __base *__clone() const = 0;
  virtual void __clone(__base *) const = 0;
  virtual void destroy() noexcept = 0;
  virtual void destroy_deallocate() noexcept = 0;
  virtual _Rp operator()(_ArgTypes &&...) = 0;




};

template <class _FD, class _Alloc, class _FB> class __func;

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)> {
  __compressed_pair<_Fp, _Alloc> __f_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __func(_Fp &&__f)
      : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
             std::__1::forward_as_tuple()) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __func(const _Fp &__f, const _Alloc &__a)
      : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
             std::__1::forward_as_tuple(__a)) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __func(const _Fp &__f, _Alloc &&__a)
      : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
             std::__1::forward_as_tuple(std::__1::move(__a))) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __func(_Fp &&__f, _Alloc &&__a)
      : __f_(piecewise_construct, std::__1::forward_as_tuple(std::__1::move(__f)),
             std::__1::forward_as_tuple(std::__1::move(__a))) {}
  virtual __base<_Rp(_ArgTypes...)> *__clone() const;
  virtual void __clone(__base<_Rp(_ArgTypes...)> *) const;
  virtual void destroy() noexcept;
  virtual void destroy_deallocate() noexcept;
  virtual _Rp operator()(_ArgTypes &&... __arg);




};

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
__base<_Rp(_ArgTypes...)> *
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const {
  typedef allocator_traits<_Alloc> __alloc_traits;
  typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
  _Ap __a(__f_.second());
  typedef __allocator_destructor<_Ap> _Dp;
  unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
  ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));
  return __hold.release();
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
void __func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(
    __base<_Rp(_ArgTypes...)> *__p) const {
  ::new (__p) __func(__f_.first(), __f_.second());
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
void __func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() noexcept {
  __f_.~__compressed_pair<_Fp, _Alloc>();
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
void __func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() noexcept {
  typedef allocator_traits<_Alloc> __alloc_traits;
  typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
  _Ap __a(__f_.second());
  __f_.~__compressed_pair<_Fp, _Alloc>();
  __a.deallocate(this, 1);
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
_Rp __func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes &&... __arg) {
  typedef __invoke_void_return_wrapper<_Rp> _Invoker;
  return _Invoker::__call(__f_.first(), std::__1::forward<_ArgTypes>(__arg)...);
}
}

template <class _Rp, class... _ArgTypes>
class __attribute__((__visibility__("default"))) function<_Rp(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(
          _ArgTypes...)> {
  typedef __function::__base<_Rp(_ArgTypes...)> __base;
  typename aligned_storage<3 * sizeof(void *)>::type __buf_;
  __base *__f_;

                 static __base *__as_base(void *p) {
    return reinterpret_cast<__base *>(p);
  }

  template <class _Fp, bool = !is_same<_Fp, function>::value &&
                              __invokable<_Fp &, _ArgTypes...>::value>
  struct __callable;
  template <class _Fp> struct __callable<_Fp, true> {
    static const bool value =
        is_same<void, _Rp>::value ||
        is_convertible<typename __invoke_of<_Fp &, _ArgTypes...>::type,
                       _Rp>::value;
  };
  template <class _Fp> struct __callable<_Fp, false> {
    static const bool value = false;
  };

public:
  typedef _Rp result_type;


  __attribute__((__visibility__("hidden"), __always_inline__))
  function() noexcept : __f_(0) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  function(nullptr_t) noexcept : __f_(0) {}
  function(const function &);
  function(function &&) noexcept;
  template <class _Fp,
            class = typename enable_if<__callable<_Fp>::value &&
                                       !is_same<_Fp, function>::value>::type>
  function(_Fp);


  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) function(allocator_arg_t, const _Alloc &) noexcept
      : __f_(0) {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) function(allocator_arg_t, const _Alloc &,
                                     nullptr_t) noexcept : __f_(0) {}
  template <class _Alloc>
  function(allocator_arg_t, const _Alloc &, const function &);
  template <class _Alloc>
  function(allocator_arg_t, const _Alloc &, function &&);
  template <class _Fp, class _Alloc,
            class = typename enable_if<__callable<_Fp>::value>::type>
  function(allocator_arg_t, const _Alloc &__a, _Fp __f);


  function &operator=(const function &);
  function &operator=(function &&) noexcept;
  function &operator=(nullptr_t) noexcept;
  template <class _Fp>
  typename enable_if<
      __callable<typename decay<_Fp>::type>::value &&
          !is_same<typename remove_reference<_Fp>::type, function>::value,
      function &>::type
  operator=(_Fp &&);

  ~function();


  void swap(function &) noexcept;


  template <class _Fp, class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) void assign(_Fp &&__f, const _Alloc &__a) {
    function(allocator_arg, __a, std::__1::forward<_Fp>(__f)).swap(*this);
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit operator bool() const noexcept { return __f_; }


  template <class _R2, class... _ArgTypes2>
  bool operator==(const function<_R2(_ArgTypes2...)> &) const = delete;
  template <class _R2, class... _ArgTypes2>
  bool operator!=(const function<_R2(_ArgTypes2...)> &) const = delete;

public:

  _Rp operator()(_ArgTypes...) const;







};

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function &__f) {
  if (__f.__f_ == 0)
    __f_ = 0;
  else if ((void *)__f.__f_ == &__f.__buf_) {
    __f_ = __as_base(&__buf_);
    __f.__f_->__clone(__f_);
  } else
    __f_ = __f.__f_->__clone();
}


template <class _Rp, class... _ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc &,
                                      const function &__f) {
  if (__f.__f_ == 0)
    __f_ = 0;
  else if ((void *)__f.__f_ == &__f.__buf_) {
    __f_ = __as_base(&__buf_);
    __f.__f_->__clone(__f_);
  } else
    __f_ = __f.__f_->__clone();
}


template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::function(function &&__f) noexcept {
  if (__f.__f_ == 0)
    __f_ = 0;
  else if ((void *)__f.__f_ == &__f.__buf_) {
    __f_ = __as_base(&__buf_);
    __f.__f_->__clone(__f_);
  } else {
    __f_ = __f.__f_;
    __f.__f_ = 0;
  }
}


template <class _Rp, class... _ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc &,
                                      function &&__f) {
  if (__f.__f_ == 0)
    __f_ = 0;
  else if ((void *)__f.__f_ == &__f.__buf_) {
    __f_ = __as_base(&__buf_);
    __f.__f_->__clone(__f_);
  } else {
    __f_ = __f.__f_;
    __f.__f_ = 0;
  }
}


template <class _Rp, class... _ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>::function(_Fp __f) : __f_(0) {
  if (__function::__not_null(__f)) {
    typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;
    if (sizeof(_FF) <= sizeof(__buf_) &&
        is_nothrow_copy_constructible<_Fp>::value) {
      __f_ = ::new ((void *)&__buf_) _FF(std::__1::move(__f));
    } else {
      typedef allocator<_FF> _Ap;
      _Ap __a;
      typedef __allocator_destructor<_Ap> _Dp;
      unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
      ::new (__hold.get()) _FF(std::__1::move(__f), allocator<_Fp>(__a));
      __f_ = __hold.release();
    }
  }
}


template <class _Rp, class... _ArgTypes>
template <class _Fp, class _Alloc, class>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc &__a0,
                                      _Fp __f)
    : __f_(0) {
  typedef allocator_traits<_Alloc> __alloc_traits;
  if (__function::__not_null(__f)) {
    typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;
    typedef typename __rebind_alloc_helper<__alloc_traits, _FF>::type _Ap;
    _Ap __a(__a0);
    if (sizeof(_FF) <= sizeof(__buf_) &&
        is_nothrow_copy_constructible<_Fp>::value &&
        is_nothrow_copy_constructible<_Ap>::value) {
      __f_ = ::new ((void *)&__buf_) _FF(std::__1::move(__f), _Alloc(__a));
    } else {
      typedef __allocator_destructor<_Ap> _Dp;
      unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
      ::new (__hold.get()) _FF(std::__1::move(__f), _Alloc(__a));
      __f_ = __hold.release();
    }
  }
}


template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)> &function<_Rp(_ArgTypes...)>::
operator=(const function &__f) {
  function(__f).swap(*this);
  return *this;
}

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)> &function<_Rp(_ArgTypes...)>::
operator=(function &&__f) noexcept {
  if ((void *)__f_ == &__buf_)
    __f_->destroy();
  else if (__f_)
    __f_->destroy_deallocate();
  __f_ = 0;
  if (__f.__f_ == 0)
    __f_ = 0;
  else if ((void *)__f.__f_ == &__f.__buf_) {
    __f_ = __as_base(&__buf_);
    __f.__f_->__clone(__f_);
  } else {
    __f_ = __f.__f_;
    __f.__f_ = 0;
  }
  return *this;
}

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)> &function<_Rp(_ArgTypes...)>::
operator=(nullptr_t) noexcept {
  if ((void *)__f_ == &__buf_)
    __f_->destroy();
  else if (__f_)
    __f_->destroy_deallocate();
  __f_ = 0;
  return *this;
}

template <class _Rp, class... _ArgTypes>
template <class _Fp>
typename enable_if<function<_Rp(_ArgTypes...)>::template __callable<
                       typename decay<_Fp>::type>::value &&
                       !is_same<typename remove_reference<_Fp>::type,
                                function<_Rp(_ArgTypes...)>>::value,
                   function<_Rp(_ArgTypes...)> &>::type
function<_Rp(_ArgTypes...)>::operator=(_Fp &&__f) {
  function(std::__1::forward<_Fp>(__f)).swap(*this);
  return *this;
}

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::~function() {
  if ((void *)__f_ == &__buf_)
    __f_->destroy();
  else if (__f_)
    __f_->destroy_deallocate();
}

template <class _Rp, class... _ArgTypes>
void function<_Rp(_ArgTypes...)>::swap(function &__f) noexcept {
  if ((void *)__f_ == &__buf_ && (void *)__f.__f_ == &__f.__buf_) {
    typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
    __base *__t = __as_base(&__tempbuf);
    __f_->__clone(__t);
    __f_->destroy();
    __f_ = 0;
    __f.__f_->__clone(__as_base(&__buf_));
    __f.__f_->destroy();
    __f.__f_ = 0;
    __f_ = __as_base(&__buf_);
    __t->__clone(__as_base(&__f.__buf_));
    __t->destroy();
    __f.__f_ = __as_base(&__f.__buf_);
  } else if ((void *)__f_ == &__buf_) {
    __f_->__clone(__as_base(&__f.__buf_));
    __f_->destroy();
    __f_ = __f.__f_;
    __f.__f_ = __as_base(&__f.__buf_);
  } else if ((void *)__f.__f_ == &__f.__buf_) {
    __f.__f_->__clone(__as_base(&__buf_));
    __f.__f_->destroy();
    __f.__f_ = __f_;
    __f_ = __as_base(&__buf_);
  } else
    std::__1::swap(__f_, __f.__f_);
}

template <class _Rp, class... _ArgTypes>
_Rp function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const {
  if (__f_ == 0)
    __throw_bad_function_call();
  return (*__f_)(std::__1::forward<_ArgTypes>(__arg)...);
}
template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const function<_Rp(_ArgTypes...)> &__f, nullptr_t) noexcept {
  return !__f;
}

template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)> &__f) noexcept {
  return !__f;
}

template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const function<_Rp(_ArgTypes...)> &__f, nullptr_t) noexcept {
  return (bool)__f;
}

template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)> &__f) noexcept {
  return (bool)__f;
}

template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(function<_Rp(_ArgTypes...)> &__x,
     function<_Rp(_ArgTypes...)> &__y) noexcept {
  return __x.swap(__y);
}
template <class _Tp> struct __is_bind_expression : public false_type {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};






template <class _Tp>
struct __is_placeholder : public integral_constant<int, 0> {};
template <class _Tp>
struct __attribute__((__visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};






namespace placeholders {

template <int _Np> struct __ph {};
constexpr __ph<1> _1{};
constexpr __ph<2> _2{};
constexpr __ph<3> _3{};
constexpr __ph<4> _4{};
constexpr __ph<5> _5{};
constexpr __ph<6> _6{};
constexpr __ph<7> _7{};
constexpr __ph<8> _8{};
constexpr __ph<9> _9{};
constexpr __ph<10> _10{};


}

template <int _Np>
struct __is_placeholder<placeholders::__ph<_Np>>
    : public integral_constant<int, _Np> {};



template <class _Tp, class _Uj>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _Tp &__mu(reference_wrapper<_Tp> __t, _Uj &) {
  return __t.get();
}

template <class _Ti, class... _Uj, size_t... _Indx>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename __invoke_of<_Ti &, _Uj...>::type
__mu_expand(_Ti &__ti, tuple<_Uj...> &__uj, __tuple_indices<_Indx...>) {
  return __ti(std::__1::forward<_Uj>(std::__1::get<_Indx>(__uj))...);
}

template <class _Ti, class... _Uj>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename __lazy_enable_if<is_bind_expression<_Ti>::value,
                              __invoke_of<_Ti &, _Uj...>>::type
    __mu(_Ti &__ti, tuple<_Uj...> &__uj) {
  typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
  return __mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj> struct __mu_return2 {};

template <class _Ti, class _Uj> struct __mu_return2<true, _Ti, _Uj> {
  typedef
      typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type>::type
__mu(_Ti &, _Uj &__uj) {
  const size_t _Indx = is_placeholder<_Ti>::value - 1;
  return std::__1::forward<typename tuple_element<_Indx, _Uj>::type>(
      std::__1::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<!is_bind_expression<_Ti>::value &&
                           is_placeholder<_Ti>::value == 0 &&
                           !__is_reference_wrapper<_Ti>::value,
                       _Ti &>::type
    __mu(_Ti &__ti, _Uj &) {
  return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct ____mu_return;

template <bool _Invokable, class _Ti, class... _Uj>
struct ____mu_return_invokable
{
  typedef __nat type;
};

template <class _Ti, class... _Uj>
struct ____mu_return_invokable<true, _Ti, _Uj...> {
  typedef typename __invoke_of<_Ti &, _Uj...>::type type;
};

template <class _Ti, class... _Uj>
struct ____mu_return<_Ti, false, true, false, tuple<_Uj...>>
    : public ____mu_return_invokable<__invokable<_Ti &, _Uj...>::value, _Ti,
                                     _Uj...> {};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, true, _TupleUj> {
  typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _TupleUj>::type
      &&type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, true, false, false, _TupleUj> {
  typedef typename _Ti::type &type;
};

template <class _Ti, class _TupleUj>
struct ____mu_return<_Ti, false, false, false, _TupleUj> {
  typedef _Ti &type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public ____mu_return<_Ti, __is_reference_wrapper<_Ti>::value,
                           is_bind_expression<_Ti>::value,
                           0 < is_placeholder<_Ti>::value &&
                               is_placeholder<_Ti>::value <=
                                   tuple_size<_TupleUj>::value,
                           _TupleUj> {};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct __is_valid_bind_return {
  static const bool value = false;
};

template <class _Fp, class... _BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj> {
  static const bool value =
      __invokable<_Fp,
                  typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class... _BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj> {
  static const bool value = __invokable<
      _Fp, typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class... _BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true> {
  typedef typename __invoke_of<
      _Fp &, typename __mu_return<_BoundArgs, _TupleUj>::type...>::type type;
};

template <class _Fp, class... _BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true> {
  typedef typename __invoke_of<
      _Fp &, typename __mu_return<const _BoundArgs, _TupleUj>::type...>::type
      type;
};

template <class _Fp, class _BoundArgs, size_t... _Indx, class _Args>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename __bind_return<_Fp, _BoundArgs, _Args>::type
    __apply_functor(_Fp &__f, _BoundArgs &__bound_args,
                    __tuple_indices<_Indx...>, _Args &&__args) {
  return __invoke(__f, __mu(std::__1::get<_Indx>(__bound_args), __args)...);
}

template <class _Fp, class... _BoundArgs>
class __bind : public __weak_result_type<typename decay<_Fp>::type> {
protected:
  typedef typename decay<_Fp>::type _Fd;
  typedef tuple<typename decay<_BoundArgs>::type...> _Td;

private:
  _Fd __f_;
  _Td __bound_args_;

  typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;

public:
  template <
      class _Gp, class... _BA,
      class = typename enable_if<
          is_constructible<_Fd, _Gp>::value &&
          !is_same<typename remove_reference<_Gp>::type, __bind>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __bind(_Gp &&__f, _BA &&... __bound_args)
      : __f_(std::__1::forward<_Gp>(__f)),
        __bound_args_(std::__1::forward<_BA>(__bound_args)...) {}

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__))
      typename __bind_return<_Fd, _Td, tuple<_Args &&...>>::type
      operator()(_Args &&... __args) {
    return __apply_functor(
        __f_, __bound_args_, __indices(),
        tuple<_Args &&...>(std::__1::forward<_Args>(__args)...));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__))
      typename __bind_return<const _Fd, const _Td, tuple<_Args &&...>>::type
      operator()(_Args &&... __args) const {
    return __apply_functor(
        __f_, __bound_args_, __indices(),
        tuple<_Args &&...>(std::__1::forward<_Args>(__args)...));
  }
};

template <class _Fp, class... _BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...>> : public true_type {};

template <class _Rp, class _Fp, class... _BoundArgs>
class __bind_r : public __bind<_Fp, _BoundArgs...> {
  typedef __bind<_Fp, _BoundArgs...> base;
  typedef typename base::_Fd _Fd;
  typedef typename base::_Td _Td;

public:
  typedef _Rp result_type;
  template <
      class _Gp, class... _BA,
      class = typename enable_if<is_constructible<_Fd, _Gp>::value &&
                                 !is_same<typename remove_reference<_Gp>::type,
                                          __bind_r>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit __bind_r(_Gp &&__f, _BA &&... __bound_args)
      : base(std::__1::forward<_Gp>(__f), std::__1::forward<_BA>(__bound_args)...) {}

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<
      is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args &&...>>::type,
                     result_type>::value ||
          is_void<_Rp>::value,
      result_type>::type
  operator()(_Args &&... __args) {
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(static_cast<base &>(*this),
                            std::__1::forward<_Args>(__args)...);
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<
      is_convertible<typename __bind_return<const _Fd, const _Td,
                                            tuple<_Args &&...>>::type,
                     result_type>::value ||
          is_void<_Rp>::value,
      result_type>::type
  operator()(_Args &&... __args) const {
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(static_cast<base const &>(*this),
                            std::__1::forward<_Args>(__args)...);
  }
};

template <class _Rp, class _Fp, class... _BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...>>
    : public true_type {};

template <class _Fp, class... _BoundArgs>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __bind<_Fp, _BoundArgs...>
bind(_Fp &&__f, _BoundArgs &&... __bound_args) {
  typedef __bind<_Fp, _BoundArgs...> type;
  return type(std::__1::forward<_Fp>(__f),
              std::__1::forward<_BoundArgs>(__bound_args)...);
}

template <class _Rp, class _Fp, class... _BoundArgs>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp &&__f, _BoundArgs &&... __bound_args) {
  typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
  return type(std::__1::forward<_Fp>(__f),
              std::__1::forward<_BoundArgs>(__bound_args)...);
}



template <>
struct __attribute__((__visibility__("default"))) hash<bool> : public unary_function<bool, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(bool __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<char> : public unary_function<char, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(char __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<signed char>
    : public unary_function<signed char, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(signed char __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<unsigned char>
    : public unary_function<unsigned char, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(unsigned char __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};



template <>
struct __attribute__((__visibility__("default"))) hash<char16_t>
    : public unary_function<char16_t, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(char16_t __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<char32_t>
    : public unary_function<char32_t, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(char32_t __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};



template <>
struct __attribute__((__visibility__("default"))) hash<wchar_t>
    : public unary_function<wchar_t, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(wchar_t __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<short>
    : public unary_function<short, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(short __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<unsigned short>
    : public unary_function<unsigned short, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(unsigned short __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<int> : public unary_function<int, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(int __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<unsigned int>
    : public unary_function<unsigned int, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(unsigned int __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<long> : public unary_function<long, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(long __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<unsigned long>
    : public unary_function<unsigned long, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(unsigned long __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<long long> : public __scalar_hash<long long> {
};

template <>
struct __attribute__((__visibility__("default"))) hash<unsigned long long>
    : public __scalar_hash<unsigned long long> {};
template <>
struct __attribute__((__visibility__("default"))) hash<float> : public __scalar_hash<float> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(float __v) const noexcept {

    if (__v == 0)
      return 0;
    return __scalar_hash<float>::operator()(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<double> : public __scalar_hash<double> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(double __v) const noexcept {

    if (__v == 0)
      return 0;
    return __scalar_hash<double>::operator()(__v);
  }
};

template <>
struct __attribute__((__visibility__("default"))) hash<long double>
    : public __scalar_hash<long double> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(long double __v) const noexcept {

    if (__v == 0)
      return 0;
    return __scalar_hash<long double>::operator()(__v);

  }
};
} }








namespace std { inline namespace __1 {



class __attribute__((__visibility__("default"))) recursive_mutex {
  __libcpp_mutex_t __m_;

public:
  recursive_mutex();
  ~recursive_mutex();

private:
  recursive_mutex(const recursive_mutex &);
  recursive_mutex &operator=(const recursive_mutex &);

public:
  void lock();
  bool try_lock() noexcept;
  void unlock() noexcept;

  typedef __libcpp_mutex_t *native_handle_type;
  __attribute__((__visibility__("hidden"), __always_inline__))
  native_handle_type native_handle() { return &__m_; }
};

class __attribute__((__visibility__("default"))) timed_mutex {
  mutex __m_;
  condition_variable __cv_;
  bool __locked_;

public:
  timed_mutex();
  ~timed_mutex();

private:
  timed_mutex(const timed_mutex &);
  timed_mutex &operator=(const timed_mutex &);

public:
  void lock();
  bool try_lock() noexcept;
  template <class _Rep, class _Period>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  try_lock_for(const chrono::duration<_Rep, _Period> &__d) {
    return try_lock_until(chrono::steady_clock::now() + __d);
  }
  template <class _Clock, class _Duration>
  bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
  void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool timed_mutex::try_lock_until(
    const chrono::time_point<_Clock, _Duration> &__t) {
  using namespace chrono;
  unique_lock<mutex> __lk(__m_);
  bool no_timeout = _Clock::now() < __t;
  while (no_timeout && __locked_)
    no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
  if (!__locked_) {
    __locked_ = true;
    return true;
  }
  return false;
}

class __attribute__((__visibility__("default"))) recursive_timed_mutex {
  mutex __m_;
  condition_variable __cv_;
  size_t __count_;
  __libcpp_thread_id __id_;

public:
  recursive_timed_mutex();
  ~recursive_timed_mutex();

private:
  recursive_timed_mutex(const recursive_timed_mutex &);
  recursive_timed_mutex &operator=(const recursive_timed_mutex &);

public:
  void lock();
  bool try_lock() noexcept;
  template <class _Rep, class _Period>
  __attribute__((__visibility__("hidden"), __always_inline__)) bool
  try_lock_for(const chrono::duration<_Rep, _Period> &__d) {
    return try_lock_until(chrono::steady_clock::now() + __d);
  }
  template <class _Clock, class _Duration>
  bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
  void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool recursive_timed_mutex::try_lock_until(
    const chrono::time_point<_Clock, _Duration> &__t) {
  using namespace chrono;
  __libcpp_thread_id __id = __libcpp_thread_get_current_id();
  unique_lock<mutex> lk(__m_);
  if (__libcpp_thread_id_equal(__id, __id_)) {
    if (__count_ == numeric_limits<size_t>::max())
      return false;
    ++__count_;
    return true;
  }
  bool no_timeout = _Clock::now() < __t;
  while (no_timeout && __count_ != 0)
    no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
  if (__count_ == 0) {
    __count_ = 1;
    __id_ = __id;
    return true;
  }
  return false;
}

template <class _L0, class _L1> int try_lock(_L0 &__l0, _L1 &__l1) {
  unique_lock<_L0> __u0(__l0, try_to_lock);
  if (__u0.owns_lock()) {
    if (__l1.try_lock()) {
      __u0.release();
      return -1;
    } else
      return 1;
  }
  return 0;
}



template <class _L0, class _L1, class _L2, class... _L3>
int try_lock(_L0 &__l0, _L1 &__l1, _L2 &__l2, _L3 &... __l3) {
  int __r = 0;
  unique_lock<_L0> __u0(__l0, try_to_lock);
  if (__u0.owns_lock()) {
    __r = try_lock(__l1, __l2, __l3...);
    if (__r == -1)
      __u0.release();
    else
      ++__r;
  }
  return __r;
}



template <class _L0, class _L1> void lock(_L0 &__l0, _L1 &__l1) {
  while (true) {
    {
      unique_lock<_L0> __u0(__l0);
      if (__l1.try_lock()) {
        __u0.release();
        break;
      }
    }
    __libcpp_thread_yield();
    {
      unique_lock<_L1> __u1(__l1);
      if (__l0.try_lock()) {
        __u1.release();
        break;
      }
    }
    __libcpp_thread_yield();
  }
}



template <class _L0, class _L1, class _L2, class... _L3>
void __lock_first(int __i, _L0 &__l0, _L1 &__l1, _L2 &__l2, _L3 &... __l3) {
  while (true) {
    switch (__i) {
    case 0: {
      unique_lock<_L0> __u0(__l0);
      __i = try_lock(__l1, __l2, __l3...);
      if (__i == -1) {
        __u0.release();
        return;
      }
    }
      ++__i;
      __libcpp_thread_yield();
      break;
    case 1: {
      unique_lock<_L1> __u1(__l1);
      __i = try_lock(__l2, __l3..., __l0);
      if (__i == -1) {
        __u1.release();
        return;
      }
    }
      if (__i == sizeof...(_L3) + 1)
        __i = 0;
      else
        __i += 2;
      __libcpp_thread_yield();
      break;
    default:
      __lock_first(__i - 2, __l2, __l3..., __l0, __l1);
      return;
    }
  }
}

template <class _L0, class _L1, class _L2, class... _L3>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void lock(_L0 &__l0, _L1 &__l1, _L2 &__l2,
                                           _L3 &... __l3) {
  __lock_first(0, __l0, __l1, __l2, __l3...);
}

template <class _L0> inline __attribute__((__visibility__("hidden"), __always_inline__)) void __unlock(_L0 &__l0) {
  __l0.unlock();
}

template <class _L0, class _L1>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void __unlock(_L0 &__l0, _L1 &__l1) {
  __l0.unlock();
  __l1.unlock();
}

template <class _L0, class _L1, class _L2, class... _L3>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void __unlock(_L0 &__l0, _L1 &__l1, _L2 &__l2,
                                               _L3 &... __l3) {
  __l0.unlock();
  __l1.unlock();
  std::__1::__unlock(__l2, __l3...);
}





struct __attribute__((__visibility__("default"))) once_flag;



template <class _Callable, class... _Args>
__attribute__((__visibility__("hidden"), __always_inline__)) void call_once(once_flag &, _Callable &&,
                                         _Args &&...);
struct __attribute__((__visibility__("default"))) once_flag {
  __attribute__((__visibility__("hidden"), __always_inline__))
  constexpr
  once_flag() noexcept : __state_(0) {}

private:
  once_flag(const once_flag &);
  once_flag &operator=(const once_flag &);

  unsigned long __state_;


  template <class _Callable, class... _Args>
  friend void call_once(once_flag &, _Callable &&, _Args &&...);






};



template <class _Fp> class __call_once_param {
  _Fp &__f_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __call_once_param(_Fp &__f) : __f_(__f) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator()() {
    typedef
        typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
    __execute(_Index());
  }

private:
  template <size_t... _Indices>
  __attribute__((__visibility__("hidden"), __always_inline__)) void __execute(__tuple_indices<_Indices...>) {
    __invoke(std::__1::get<0>(std::__1::move(__f_)),
             std::__1::get<_Indices>(std::__1::move(__f_))...);
  }
};
template <class _Fp> void __call_once_proxy(void *__vp) {
  __call_once_param<_Fp> *__p = static_cast<__call_once_param<_Fp> *>(__vp);
  (*__p)();
}

__attribute__((__visibility__("default"))) void __call_once(volatile unsigned long &, void *,
                                  void (*)(void *));



template <class _Callable, class... _Args>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
call_once(once_flag &__flag, _Callable &&__func, _Args &&... __args) {
  if (__libcpp_acquire_load(&__flag.__state_) != ~0ul) {
    typedef tuple<_Callable &&, _Args &&...> _Gp;
    _Gp __f(std::__1::forward<_Callable>(__func),
            std::__1::forward<_Args>(__args)...);
    __call_once_param<_Gp> __p(__f);
    __call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
  }
}
} }










#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {


#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)


  extern "C" {
        extern "builtin"







        int __clcl (void*, void*, unsigned int*,
                        unsigned int*, unsigned char);






        extern "builtin"







        int __stck (unsigned long long *);






        extern "builtin"







        int __stcke (void *);
#pragma pack (1)

 typedef struct __stcke_tod {
            unsigned char c;

            unsigned long long slice;




            unsigned int i;
          } __stcke_tod_t;

          typedef struct __stcke_tag {
            unsigned char zeros;
            __stcke_tod_t tod;
            unsigned short p_field;
          } __stcke_t;
#pragma pack (reset)
 extern "builtin" {







        void __tr (unsigned char*, const unsigned char*, unsigned char);




      }





        extern "builtin" {
        int __ed (unsigned char*, unsigned char*, unsigned char);
        int __edmk (unsigned char*, unsigned char*, unsigned char, unsigned char**);

        int __trt (unsigned char*, const unsigned char*, unsigned char, unsigned char*, unsigned char**);

        int __nc (unsigned char*, unsigned char*, unsigned char);
        int __oc (unsigned char*, unsigned char*, unsigned char);
        int __xc (unsigned char*, unsigned char*, unsigned char);
        void __pack (unsigned char*, unsigned char, unsigned char*, unsigned char);

        void __unpk (unsigned char*, unsigned char, unsigned char*, unsigned char);




      }





        long double __fmaddl (long double, long double, long double);
        extern "builtin" {
        double __fmadd (double, double, double);
        float __fmadds (float, float, float);
        double __fmsub (double, double, double);
        float __fmsubs (float, float, float);



      }
        extern "builtin" {
        int __csg (void*, void*, void*);
        int __cdsg (void*, void*, void*);



      }
      extern "builtin" {
        int __efpc (void);
        void __sfpc (int);
        void __srnm (int);
        float __fiebr (int, float);
        double __fidbr (int, double);
        long double __fixbr (int, long double);
        int __tceb (float, int);
        int __tcdb (double, int);
        int __tcxb (long double, int);
        int __lpebr (float*, float);
        int __lpdbr (double*, double);
        int __lpxbr (long double*, long double);
        int __lnebr (float*, float);
        int __lndbr (double*, double);
        int __lnxbr (long double*, long double);
        float __sqebr (float);
        double __sqdbr (double);
        long double __sqxbr (long double);
        int __cfebr (int*, int, float);
        int __cfdbr (int*, int, double);
        int __cfxbr (int*, int, long double);
        float __maebr (float, float, float);
        double __madbr (double, double, double);
        float __msebr (float, float, float);
        double __msdbr (double, double, double);
        int __diebr (float*, float*, float, float, int);
        int __didbr (double*, double*, double, double, int);



      }
      extern "builtin" {
        int __cgebr (long*, int, float);
        int __cgdbr (long*, int, double);
        int __cgxbr (long*, int, long double);



      }
      extern "builtin" {
        int __thder (double*, float);
        int __thdr (double*, double);
        int __tbedr (float*, int, double);
        int __tbdr (double*, int, double);
        unsigned short __lrvh (unsigned short*);
        unsigned int __lrv (unsigned int*);
        void __strvh (unsigned short, unsigned short*);
        void __strv (unsigned int, unsigned int*);


          unsigned long __lrvg (unsigned long*);
          void __strvg (unsigned long, unsigned long*);




      }
      extern "builtin" {
        int __cvb(char *op2);
        void __cvd(int op1, char *op2);
        int __zap(unsigned char *op1, unsigned char len1,
                   unsigned char *op2, unsigned char len2);
        int __clcle(char *op1, unsigned long op1_len, unsigned char op2,
                    char *op3, unsigned long op3_len);
        int __mvcle(char *op1, unsigned long op1_len, unsigned char op2,
                    char *op3, unsigned long op3_len);
        int __tre(char *op1, unsigned long op1_len,
                  char *op2, unsigned char test_char);


          long long __cvbg(char *op2);
          void __cvdg(long long op1, char *op2);

        int __clclu(unsigned short *op1, unsigned long op1_len,
                     unsigned short op2,
                     unsigned short *op3, unsigned long op3_len);
        int __mvclu(unsigned short *op1, unsigned long op1_len,
                     unsigned short op2,
                     unsigned short *op3, unsigned long op3_len);
        int __tp(char *op1, unsigned char op1_len);
        void __pka(char *op1, char *op2, unsigned char op2_len);
        void __pku(char *op1, unsigned short *op2, unsigned char op2_len);
        int __unpka(char *op1, unsigned char op1_len, char *op2);
        int __unpku(unsigned short *op1, unsigned char op1_len, char *op2);
        int __troo(char *op1, char *op2, unsigned long op2_len,
                   char *tr_table, unsigned char test_char,
                   unsigned char mask);
        int __trot(unsigned short *op1, char *op2, unsigned long op2_len,
                   char *tr_table, unsigned short test_char,
                   unsigned char mask);
        int __trto(char *op1, unsigned short *op2, unsigned long op2_len,
                   char *tr_table, char test_char , unsigned char mask);
        int __trtt(unsigned short *op1, unsigned short *op2,
                   unsigned long op2_len, char *tr_table,
                   unsigned short test_char, unsigned char mask);
        int __cu12(unsigned short *op1, unsigned long op1_len, char *op2,
                   unsigned long op2_len, char **invalid_utf8,
                   unsigned char mask);
        int __cu14(unsigned int *op1, unsigned long op1_len, char *op2,
                   unsigned long op2_len, unsigned char **invalid_utf8,
                   unsigned char mask);
        int __cu21(char *op1, unsigned long op1_len, unsigned short *op2,
                   unsigned long op2_len, unsigned char mask);
        int __cu24(unsigned int *op1, unsigned long op1_len,
                   unsigned short *op2, unsigned long op2_len,
                   unsigned char mask);
        int __cu41(char *op1, unsigned long op1_len, unsigned int *op2,
                    unsigned long op2_len, unsigned int **invalid_utf32);
        int __cu42(unsigned short *op1, unsigned long op1_len,
                   unsigned int *op2, unsigned long op2_len,
                   unsigned int **invalid_utf32);
        int __srstu(unsigned short *op1, unsigned short *op2,
                    unsigned short pattern, unsigned short **found_char);
        int __trtr(unsigned char *op1, const unsigned char *op2,
                   unsigned char length, unsigned char *R2,
                   unsigned char **R1);



      }
          extern "builtin" {
          int __stckf (unsigned long long *);
          void __dcbt(const void* addr);
          void __dcbtst(const void* addr);
          void __dcbst(const void* addr);
          void __dcbf(const void* addr);



        }
        typedef union {
            struct __dword {
                unsigned int __high_word;
                unsigned int __low_word;
            } __s_dword;
            unsigned long long __dword;
        } __plo_entry_t;

        typedef union {
            unsigned long long __val;
            unsigned long long * __ptr;
        } __plo_ull_ullptr_t;

        typedef union {
            unsigned int * __uint_ptr;
            unsigned long long * __ull_ptr;
        } __plo_uintptr_ullptr_t;

        typedef __plo_ull_ullptr_t __plo_plist[18];
          extern "builtin" {
          int __plo_CL (void *lock,
                            unsigned int *op1c, unsigned int *op2,
                            unsigned int *op3, unsigned int *op4);
          int __plo_CS (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2);
          int __plo_DCS (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2,
                            unsigned int *op3c, unsigned int op3r,
                            unsigned int *op4);
          int __plo_CSST (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2,
                            unsigned int op3, unsigned int *op4);
          int __plo_CSDST (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2, void *param_list);
          int __plo_CSTST (void *lock,
                            unsigned int *op1c, unsigned int op1r,
                            unsigned int *op2, void *param_list);

          int __plo_CLGR (void *lock,
                            unsigned long long *op1c, unsigned long long *op2,
                            unsigned long long *op3, unsigned long long *op4);
          int __plo_CLG (void *lock,
                            unsigned long long *op2, void *param_list);
          int __plo_CLX (void *lock,
                            void *op2, void *param_list);
          int __plo_CSGR (void *lock,
                            unsigned long long *op1c, unsigned long long op1r,
                            unsigned long long *op2);
          int __plo_CSG (void *lock,
                            unsigned long long *op2, void *param_list);
          int __plo_CSX (void *lock,
                            void *op2, void *param_list);
          int __plo_DCSGR (void *lock,
                            unsigned long long *op1c, unsigned long long op1r,
                            unsigned long long *op2,
                            unsigned long long *op3c, unsigned long long op3r,
                            unsigned long long *op4);
          int __plo_DCSG (void *lock,
                            unsigned long long *op2, void *param_list);
          int __plo_DCSX (void *lock,
                            void *op2, void *param_list);
          int __plo_CSSTGR (void *lock,
                            unsigned long long *op1c, unsigned long long op1r,
                            unsigned long long *op2,
                            unsigned long long op3, unsigned long long *op4);
          int __plo_CSSTG (void *lock,
                            unsigned long long *op2, void *param_list);
          int __plo_CSSTX (void *lock,
                            void *op2, void *param_list);
          int __plo_CSDSTGR(void *lock,
                            unsigned long long *op1c, unsigned long long op1r,
                            unsigned long long *op2, void *param_list);
          int __plo_CSDSTG (void *lock,
                            unsigned long long *op2, void *param_list);
          int __plo_CSDSTX (void *lock,
                            void *op2, void *param_list);
          int __plo_CSTSTGR(void *lock,
                            unsigned long long *op1c, unsigned long long op1r,
                            unsigned long long *op2, void *param_list);
          int __plo_CSTSTG (void *lock,
                            unsigned long long *op2, void *param_list);
          int __plo_CSTSTX (void *lock,
                            void *op2, void *param_list);




        }




        extern "builtin"







        unsigned long __popcnt(unsigned long op);
          extern "builtin" {
          int __lad (int* op1, int op3, int* op2);
          int __ladl (unsigned int* op1, unsigned int op3,
                            unsigned int* op2);
          int __lan (unsigned int* op1, unsigned int op3,
                            unsigned int* op2);
          int __lax (unsigned int* op1, unsigned int op3,
                            unsigned int* op2);
          int __lao (unsigned int* op1, unsigned int op3,
                            unsigned int* op2);
          int __lpd (unsigned int* op3, unsigned int* op4,
                            unsigned int* op1, unsigned int* op2);

          int __ladg (long* op1, long op3, long* op2);
          int __ladlg (unsigned long* op1, unsigned long op3,
                            unsigned long* op2);
          int __lang (unsigned long* op1, unsigned long op3,
                            unsigned long* op2);
          int __laxg (unsigned long* op1, unsigned long op3,
                            unsigned long* op2);
          int __laog (unsigned long* op1, unsigned long op3,
                            unsigned long* op2);
          int __lpdg (unsigned long* op3, unsigned long* op4,
                            unsigned long* op1, unsigned long* op2);




        }
  extern "builtin" {
  unsigned int __lcbb(const void*, unsigned short);
  int __cp(unsigned char*, unsigned char, unsigned char*, unsigned char);
  int __ap(unsigned char*, unsigned char, unsigned char*, unsigned char);
  int __sp(unsigned char*, unsigned char, unsigned char*, unsigned char);
  void __mp(unsigned char*, unsigned char, unsigned char*, unsigned char);
  void __dp(unsigned char*, unsigned char, unsigned char*, unsigned char);
  int __srp(unsigned char*, unsigned char, signed char, unsigned char);


  }







  extern "builtin" {
  long __builtin_expect(long,long);



  }







  extern "builtin" {
  long __TM_simple_begin();
  long __TM_begin(void*);
  long __TM_end();
  void __TM_abort();
  void __TM_named_abort(const unsigned char);
  long __TM_is_user_abort(void*const);
  long __TM_is_named_user_abort(void*const, unsigned char*);
  long __TM_is_illegal(void*const);
  long __TM_is_footprint_exceeded(void*const);
  long __TM_nesting_depth(void*const);
  long __TM_is_nested_too_deep(void*const);
  long __TM_is_conflict(void*const);
  long __TM_is_failure_persistent(const long);
  long __TM_failure_address(void*const);

  long long __TM_failure_code(void*const);
  void __TM_non_transactional_store(void*const,const long long);

  void __TM_abort_assist(unsigned int);


  }
}
#pragma checkout(resume)
    typedef struct __div_t



      {
      int quot;
      int rem;
      } div_t;


    typedef struct __ldiv_t



      {
      long int quot;
      long int rem;
      } ldiv_t;


   typedef struct {
               long long quot;
               long long rem;
   } lldiv_t;





       typedef struct {
                 long __uheap_size;
                 long __uheap_bytes_alloc;
                 long __uheap_bytes_free;
       } hreport_t;
      long long int strtoll (const char * , char * * , int);

      unsigned long long int strtoull (const char * , char * * , int);
#pragma map (strtoll, "\174\174STRLL")
#pragma map (strtoull, "\174\174STRULL")
 double atof (const char *);
    int atoi (const char *);
    long int atol (const char *);
    double strtod (const char * , char * * );
    long int strtol (const char * , char * * ,
                      int);
    unsigned long int strtoul (const char * ,
                                char * * , int);
    int rand (void);
    void srand (unsigned int);


        long long int strtoll (const char * ,
                                char * * , int);
        unsigned long long int strtoull (const char * ,
                                          char * * , int);
      long long atoll (const char *);


    float strtof (const char * , char ** );

    long double strtold (const char * , char ** );
      void * calloc (size_t, size_t);
      void free (void *);
      void * malloc (size_t);
      void * realloc (void *, size_t);




    void * __malloc24 (size_t);
    void * __malloc31 (size_t);


      struct __mopl_s {
        unsigned long
               __moplrequestsize;
        int __mopldumppriority;
        unsigned int
               __moplgetstorflags;
        long __moplreserved;
        int __mopl_iarv64_rc;
        int __mopl_iarv64_rsn;
      };

      typedef struct __mopl_s __mopl_t;
    int __moservices (int, size_t, __mopl_t *, void **);
#pragma map (__getenv, "\174\174GETENV")
 [[noreturn]] void abort (void) noexcept;
    int atexit (void (*)(void)) noexcept;
    [[noreturn]] void exit (int) noexcept;
    char * getenv (const char *);
    char * __getenv (const char *);
    int system (const char *);
    void * bsearch (const void *, const void *,
                      size_t, size_t,
                      int (*)(const void *,
                                    const void *));
    void qsort (void *, size_t, size_t,
                    int (*)(const void *,
                                  const void *));



    int unatexit (void (*)(void));
        int __heaprpt(hreport_t *);




    extern "C++" {
      inline int abs (int x) { return __abs(x); }
    }
    div_t div (int, int);
    long int labs (long int);
    ldiv_t ldiv (long int, long int);
    int mblen (const char *, size_t);
    int mbtowc (wchar_t * ,
                      const char * , size_t);
    int wctomb (char *, wchar_t);
    size_t mbstowcs (wchar_t * ,
                        const char * , size_t);
    size_t wcstombs (char * ,
                        const wchar_t * , size_t);
      long long llabs (long long );
      lldiv_t lldiv (long long , long long );
      void (* fetch (const char *))();
      void (* fetchep (void (*)()))();
      int release (void (*)());
#pragma map (rpmatch, "\174\174RPMTCH")
#pragma map (csid, "\174\174CSID")
#pragma map (wcsid, "\174\174WCSID")
 int __librel (void);

        int clearenv (void);


      int rpmatch(const char *);
      int csid(const char *);
      int wcsid(const wchar_t);
#pragma map(__EnvnA, "\174\174ENVNA")

 char *** __EnvnA(void);
    char *** __Envn(void);
        double drand48(void);
        double erand48(unsigned short int [3]);
        long int jrand48(unsigned short int [3]);
        void lcong48(unsigned short int [7]);
        long int lrand48(void);
        long int mrand48(void);
        long int nrand48(unsigned short int [3]);



          int putenv(const char *);

        unsigned short int *seed48(unsigned short int [3]);
        void srand48(long int);

          void setkey(const char *);
        long a64l(const char *);
        char *ecvt(double, int, int * ,
                                       int * );
        char *fcvt(double, int, int * ,
                                       int * );
        char *gcvt(double, int, char *);
        int getsubopt(char **, char *const *, char **);
        char *initstate(unsigned, char *, size_t);
        char *l64a(long);
        int mkstemp(char *);
        char *mktemp(char *);
        long random(void);
        char *realpath(const char * ,
                                    char * );
        char *setstate(const char *);
        void srandom(unsigned);

           int ttyslot(void);
           void *valloc(size_t);


          int grantpt(int);
          char *ptsname(int);
          int unlockpt(int);
       int rand_r (unsigned int *);
    int __discarddata (void *, size_t);
        [[noreturn]] void _Exit(int) noexcept;
          int setenv (const char *, const char *, int);
#pragma map(unsetenv,"\174\174UNSTNV")







 int unsetenv (const char *);
  }




  extern "C++" {
        inline long abs (long x) { return labs(x); }
        inline ldiv_t div (long x, long y)
        { return ldiv(x,y); }

          inline long long abs (long long x)
          { return llabs(x);}
          inline lldiv_t div (long long x, long long y)
          { return lldiv(x,y); }


  }



#pragma checkout(resume)



extern "C++" {
}








namespace std { inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;
using ::getenv;
using ::system;
using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;


using ::mblen;
using ::mbtowc;
using ::wctomb;

using ::mbstowcs;
using ::wcstombs;
} }


extern "C" {
typedef struct locale_struct {
  int category_mask;
  std::string locale_name;
  locale_struct(int cmask, const char *loc_name)
      : category_mask(cmask), locale_name(loc_name) {}
} * locale_t;




static inline locale_t newlocale(int category_mask, const char *locale,
                                 locale_t base) __asm__("newlocale_tmp");
static inline void freelocale(locale_t locobj) __asm__("freelocale_tmp");
static inline locale_t uselocale(locale_t newloc) __asm__("uselocale_tmp");

static inline locale_t newlocale(int category_mask, const char *locale,
                                 locale_t base) {
  const char *current_loc_name = setlocale((-1), 0);

  if (category_mask == ((1 << ((6 + 1))) - 1)) {
    if (setlocale((-1), locale) == 0) {
      (*__errno()) = 121;
      return (locale_t)0;
    }
  } else {
    for (int _Cat = 0; _Cat <= 6; ++_Cat) {
      if (((1 << (_Cat)) & category_mask) != 0 &&
          setlocale(_Cat, locale) == 0) {
        setlocale((-1), current_loc_name);
        (*__errno()) = 121;
        return (locale_t)0;
      }
    }
  }

  locale_t newloc = new locale_struct(category_mask, locale);
  delete base;
  setlocale((-1), current_loc_name);
  return (locale_t)newloc;
}

static inline void freelocale(locale_t locobj) { delete locobj; }

static inline locale_t uselocale(locale_t newloc) {
  const char *current_loc_name = setlocale((-1), 0);

  if (newloc && newloc->category_mask == ((1 << ((6 + 1))) - 1)) {
    if (setlocale((-1), newloc->locale_name.c_str()) == 0) {
      (*__errno()) = 121;
      return (locale_t)0;
    }
  } else if (newloc) {
    for (int _Cat = 0; _Cat <= 6; ++_Cat) {
      if (((1 << (_Cat)) & newloc->category_mask) != 0 &&
          setlocale(_Cat, newloc->locale_name.c_str()) == 0) {
        setlocale((-1), current_loc_name);
        (*__errno()) = 121;
        return (locale_t)0;
      }
    }
  }

  locale_t currentloc = new locale_struct(((1 << ((6 + 1))) - 1), current_loc_name);
  return currentloc;
}
static inline int isalnum_l(int c, locale_t locale) { return isalnum(c); }
static inline int isalpha_l(int c, locale_t locale) { return isalpha(c); }
static inline int isblank_l(int c, locale_t locale) { return isblank(c); }
static inline int iscntrl_l(int c, locale_t locale) { return iscntrl(c); }
static inline int isdigit_l(int c, locale_t locale) { return isdigit(c); }
static inline int isgraph_l(int c, locale_t locale) { return isgraph(c); }
static inline int islower_l(int c, locale_t locale) { return islower(c); }
static inline int isprint_l(int c, locale_t locale) { return isprint(c); }

static inline int ispunct_l(int c, locale_t locale) { return ispunct(c); }
static inline int isspace_l(int c, locale_t locale) { return isspace(c); }
static inline int isupper_l(int c, locale_t locale) { return isupper(c); }

static inline int isxdigit_l(int c, locale_t locale) { return isxdigit(c); }

static inline int iswalnum_l(wchar_t wc, locale_t locale) {
  return iswalnum(wc);
}

static inline int iswalpha_l(wchar_t wc, locale_t locale) {
  return iswalpha(wc);
}
static inline int iswblank_l(wchar_t wc, locale_t locale) {
  return iswblank(wc);
}

static inline int iswcntrl_l(wchar_t wc, locale_t locale) {
  return iswcntrl(wc);
}

static inline int iswdigit_l(wchar_t wc, locale_t locale) {
  return iswdigit(wc);
}

static inline int iswgraph_l(wchar_t wc, locale_t locale) {
  return iswgraph(wc);
}

static inline int iswlower_l(wchar_t wc, locale_t locale) {
  return iswlower(wc);
}

static inline int iswprint_l(wchar_t wc, locale_t locale) {
  return iswprint(wc);
}

static inline int iswpunct_l(wchar_t wc, locale_t locale) {
  return iswpunct(wc);
}

static inline int iswspace_l(wchar_t wc, locale_t locale) {
  return iswspace(wc);
}

static inline int iswupper_l(wchar_t wc, locale_t locale) {
  return iswupper(wc);
}

static inline int iswxdigit_l(wchar_t wc, locale_t locale) {
  return iswxdigit(wc);
}

static inline int iswctype_l(wint_t wc, wctype_t desc, locale_t locale) {
  return iswctype(wc, desc);
}

static inline int toupper_l(int c, locale_t locale) { return toupper(c); }
static inline int tolower_l(int c, locale_t locale) { return tolower(c); }
static inline wint_t towupper_l(wint_t wc, locale_t locale) {
  return towupper(wc);
}
static inline wint_t towlower_l(wint_t wc, locale_t locale) {
  return towlower(wc);
}

static inline int strcoll_l(const char *__s1, const char *__s2,
                            locale_t locale) {
  return strcoll(__s1, __s2);
}
static inline int wcscoll_l(const wchar_t *__s1, const wchar_t *__s2,
                            locale_t locale) {
  return wcscoll(__s1, __s2);
}
static inline size_t strxfrm_l(char *__s1, const char *__s2, size_t __n,
                               locale_t locale) {
  return strxfrm(__s1, __s2, __n);
}

static inline size_t wcsxfrm_l(wchar_t *__ws1, const wchar_t *__ws2, size_t __n,
                               locale_t locale) {
  return wcsxfrm(__ws1, __ws2, __n);
}

size_t mbsnrtowcs(wchar_t *__restrict dst, const char **__restrict src,
                  size_t nms, size_t len, mbstate_t *__restrict ps);
size_t wcsnrtombs(char *__restrict dst, const wchar_t **__restrict src,
                  size_t nwc, size_t len, mbstate_t *__restrict ps);







#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
  }


#pragma checkout(resume)
static inline size_t strftime_l(char *__s, size_t __size, const char *__fmt,
                                const struct tm *__tm, locale_t locale) {





  return strftime(__s, __size, __fmt, __tm);

}



static inline long long strtoll_l(const char *__nptr, char **__endptr,
                                  int __base, locale_t locale) {
  return strtoll(__nptr, __endptr, __base);
}
static inline long strtol_l(const char *__nptr, char **__endptr, int __base,
                            locale_t locale) {
  return strtol(__nptr, __endptr, __base);
}
static inline double strtod_l(const char *__nptr, char **__endptr,
                              locale_t locale) {
  return strtod(__nptr, __endptr);
}
static inline float strtof_l(const char *__nptr, char **__endptr,
                             locale_t locale) {
  return strtof(__nptr, __endptr);
}
static inline long double strtold_l(const char *__nptr, char **__endptr,
                                    locale_t locale) {
  return strtold(__nptr, __endptr);
}
static inline unsigned long long strtoull_l(const char *__nptr, char **__endptr,
                                            int __base, locale_t locale) {
  return strtoull(__nptr, __endptr, __base);
}
static inline unsigned long strtoul_l(const char *__nptr, char **__endptr,
                                      int __base, locale_t locale) {
  return strtoul(__nptr, __endptr, __base);
}

static inline int vasprintf(char **strp, const char *fmt, va_list ap) {
  int str_size = -1;
  va_list ap2;

  ((ap2) = (ap));
  int count = vsnprintf(0, 0, fmt, ap2);
  (ap2)=(char *)0;

  if (count < 0)
    return -1;

  const size_t buf_size = count + 1;
  char *const buf = (char *)malloc(buf_size);
  if (buf) {
    *strp = buf;
    str_size = vsnprintf(*strp, buf_size, fmt, ap);
    if (str_size < 0 || str_size >= buf_size) {
      free(buf);
      str_size = -1;
    }
  }
  return str_size;
}


}


namespace std { inline namespace __1 {

class __attribute__((__visibility__("default"))) locale;

template <class _Facet>
__attribute__((__visibility__("hidden"), __always_inline__)) bool has_facet(const locale &) noexcept;

template <class _Facet>
__attribute__((__visibility__("hidden"), __always_inline__)) const _Facet &use_facet(const locale &);

class __attribute__((__visibility__("default"))) locale {
public:

  class __attribute__((__visibility__("default"))) facet;
  class __attribute__((__visibility__("default"))) id;

  typedef int category;
  static const category
      none = 0,
      collate = (1 << (0)), ctype = (1 << (1)),
      monetary = (1 << (3)), numeric = (1 << (2)),
      time = (1 << (4)), messages = (1 << (6)),
      all = collate | ctype | monetary | numeric | time | messages;


  locale() noexcept;
  locale(const locale &) noexcept;


  template <typename T = int> explicit locale(const char *std_name) {
    static_assert(
        !sizeof(T),
        "z/OS locale does not work in multi-threading mode, please define "
        "macro MVS_PARTIAL_LOCALE_SUPPORT to enable locale implementation in "
        "single thread environment.");
  }
  template <typename T = int> explicit locale(const string &std_name) {
    static_assert(
        !sizeof(T),
        "z/OS locale does not work in multi-threading mode, please define "
        "macro MVS_PARTIAL_LOCALE_SUPPORT to enable locale implementation in "
        "single thread environment.");
  }
  template <typename T = int>
  locale(const locale &other, const char *std_name, category c) {
    static_assert(
        !sizeof(T),
        "z/OS locale does not work in multi-threading mode, please define "
        "macro MVS_PARTIAL_LOCALE_SUPPORT to enable locale implementation in "
        "single thread environment.");
  }
  template <typename T = int>
  locale(const locale &other, const string &std_name, category c) {
    static_assert(
        !sizeof(T),
        "z/OS locale does not work in multi-threading mode, please define "
        "macro MVS_PARTIAL_LOCALE_SUPPORT to enable locale implementation in "
        "single thread environment.");
  }







  template <class _Facet>
  __attribute__((__visibility__("hidden"), __always_inline__)) locale(const locale &, _Facet *);
  locale(const locale &, const locale &, category);

  ~locale();

  const locale &operator=(const locale &) noexcept;

  template <class _Facet> locale combine(const locale &) const;


  string name() const;
  bool operator==(const locale &) const;
  bool operator!=(const locale &__y) const { return !(*this == __y); }
  template <class _CharT, class _Traits, class _Allocator>
  bool operator()(const basic_string<_CharT, _Traits, _Allocator> &,
                  const basic_string<_CharT, _Traits, _Allocator> &) const;


  static locale global(const locale &);
  static const locale &classic();

private:
  class __imp;
  __imp *__locale_;

  void __install_ctor(const locale &, facet *, long);
  static locale &__global();
  bool has_facet(id &) const;
  const facet *use_facet(id &) const;

  template <class _Facet> friend bool has_facet(const locale &) noexcept;
  template <class _Facet> friend const _Facet &use_facet(const locale &);
};

class __attribute__((__visibility__("default"))) locale::facet : public __shared_count {
protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit facet(size_t __refs = 0)
      : __shared_count(static_cast<long>(__refs) - 1) {}

  virtual ~facet();



private:
  virtual void __on_zero_shared() noexcept;
};

class __attribute__((__visibility__("default"))) locale::id {
  once_flag __flag_;
  int32_t __id_;

  static int32_t __next_id;

public:
  __attribute__((__visibility__("hidden"), __always_inline__)) constexpr id() : __id_(0) {}

private:
  void __init();
  void operator=(const id &);
  id(const id &);
public:
  long __get();

  friend class locale;
  friend class locale::__imp;
};

template <class _Facet>
inline __attribute__((__visibility__("hidden"), __always_inline__)) locale::locale(const locale &__other,
                                                _Facet *__f) {
  __install_ctor(__other, __f, __f ? __f->id.__get() : 0);
}

template <class _Facet> locale locale::combine(const locale &__other) const {
  if (!std::__1::has_facet<_Facet>(__other))


    throw runtime_error("locale::combine: locale missing facet");

  return locale(*this,
                &const_cast<_Facet &>(std::__1::use_facet<_Facet>(__other)));
}

template <class _Facet>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool has_facet(const locale &__l) noexcept {
  return __l.has_facet(_Facet::id);
}

template <class _Facet>
inline __attribute__((__visibility__("hidden"), __always_inline__)) const _Facet &use_facet(const locale &__l) {
  return static_cast<const _Facet &>(*__l.use_facet(_Facet::id));
}



template <class _CharT>
class __attribute__((__visibility__("default"))) collate : public locale::facet {
public:
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit collate(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  int compare(const char_type *__lo1, const char_type *__hi1,
              const char_type *__lo2, const char_type *__hi2) const {
    return do_compare(__lo1, __hi1, __lo2, __hi2);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  string_type transform(const char_type *__lo, const char_type *__hi) const {
    return do_transform(__lo, __hi);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  long hash(const char_type *__lo, const char_type *__hi) const {
    return do_hash(__lo, __hi);
  }

  static locale::id id;

protected:
  ~collate();
  virtual int do_compare(const char_type *__lo1, const char_type *__hi1,
                         const char_type *__lo2, const char_type *__hi2) const;
  virtual string_type do_transform(const char_type *__lo,
                                   const char_type *__hi) const {
    return string_type(__lo, __hi);
  }
  virtual long do_hash(const char_type *__lo, const char_type *__hi) const;
};





template <class _CharT> collate<_CharT>::~collate() {}

template <class _CharT>
int collate<_CharT>::do_compare(const char_type *__lo1, const char_type *__hi1,
                                const char_type *__lo2,
                                const char_type *__hi2) const {
  for (; __lo2 != __hi2; ++__lo1, ++__lo2) {
    if (__lo1 == __hi1 || *__lo1 < *__lo2)
      return -1;
    if (*__lo2 < *__lo1)
      return 1;
  }
  return __lo1 != __hi1;
}

template <class _CharT>
long collate<_CharT>::do_hash(const char_type *__lo,
                              const char_type *__hi) const {
  size_t __h = 0;
  const size_t __sr = 8 * sizeof(size_t) - 8;
  const size_t __mask = size_t(0xF) << (__sr + 4);
  for (const char_type *__p = __lo; __p != __hi; ++__p) {
    __h = (__h << 4) + static_cast<size_t>(*__p);
    size_t __g = __h & __mask;
    __h ^= __g | (__g >> __sr);
  }
  return static_cast<long>(__h);
}

extern template class collate<char>;
extern template class collate<wchar_t>;




template <class _CharT> class __attribute__((__visibility__("default"))) collate_byname;

template <> class __attribute__((__visibility__("default"))) collate_byname<char> : public collate<char> {
  locale_t __l;

public:
  typedef char char_type;
  typedef basic_string<char_type> string_type;

  explicit collate_byname(const char *__n, size_t __refs = 0);
  explicit collate_byname(const string &__n, size_t __refs = 0);

protected:
  ~collate_byname();
  virtual int do_compare(const char_type *__lo1, const char_type *__hi1,
                         const char_type *__lo2, const char_type *__hi2) const;
  virtual string_type do_transform(const char_type *__lo,
                                   const char_type *__hi) const;
};

template <>
class __attribute__((__visibility__("default"))) collate_byname<wchar_t> : public collate<wchar_t> {
  locale_t __l;

public:
  typedef wchar_t char_type;
  typedef basic_string<char_type> string_type;

  explicit collate_byname(const char *__n, size_t __refs = 0);
  explicit collate_byname(const string &__n, size_t __refs = 0);

protected:
  ~collate_byname();

  virtual int do_compare(const char_type *__lo1, const char_type *__hi1,
                         const char_type *__lo2, const char_type *__hi2) const;
  virtual string_type do_transform(const char_type *__lo,
                                   const char_type *__hi) const;
};

template <class _CharT, class _Traits, class _Allocator>
bool locale::
operator()(const basic_string<_CharT, _Traits, _Allocator> &__x,
           const basic_string<_CharT, _Traits, _Allocator> &__y) const {
  return std::__1::use_facet<std::__1::collate<_CharT>>(*this).compare(
             __x.data(), __x.data() + __x.size(), __y.data(),
             __y.data() + __y.size()) < 0;
}



class __attribute__((__visibility__("default"))) ctype_base {
public:
  typedef unsigned short mask;
  static const mask space = 0x0008;
  static const mask print = 0x0400;
  static const mask cntrl = 0x0020;
  static const mask upper = 0x0080;
  static const mask lower = 0x0040;
  static const mask alpha = 0x0100;
  static const mask digit = 0x0002;
  static const mask punct = 0x0010;
  static const mask xdigit = 0x0001;
  static const mask blank = 0x1000u;
  static const mask alnum = alpha | digit;
  static const mask graph = alnum | punct;

  __attribute__((__visibility__("hidden"), __always_inline__)) ctype_base() {}
};

template <class _CharT>
class __attribute__((__visibility__("default"))) ctype : public locale::facet, public ctype_base {
public:
  typedef _CharT char_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit ctype(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool is(mask __m, char_type __c) const { return do_is(__m, __c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *is(const char_type *__low, const char_type *__high,
                      mask *__vec) const {
    return do_is(__low, __high, __vec);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *scan_is(mask __m, const char_type *__low,
                           const char_type *__high) const {
    return do_scan_is(__m, __low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *scan_not(mask __m, const char_type *__low,
                            const char_type *__high) const {
    return do_scan_not(__m, __low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type toupper(char_type __c) const { return do_toupper(__c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *toupper(char_type *__low, const char_type *__high) const {
    return do_toupper(__low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type tolower(char_type __c) const { return do_tolower(__c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *tolower(char_type *__low, const char_type *__high) const {
    return do_tolower(__low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type widen(char __c) const { return do_widen(__c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char *widen(const char *__low, const char *__high,
                    char_type *__to) const {
    return do_widen(__low, __high, __to);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char narrow(char_type __c, char __dfault) const {
    return do_narrow(__c, __dfault);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *narrow(const char_type *__low, const char_type *__high,
                          char __dfault, char *__to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static locale::id id;

protected:
  ~ctype() {}
  virtual bool do_is(mask __m, char_type __c) const = 0;
  virtual const char_type *
  do_is(const char_type *__low, const char_type *__high, mask *__vec) const = 0;
  virtual const char_type *do_scan_is(mask __m, const char_type *__low,
                                      const char_type *__high) const = 0;
  virtual const char_type *do_scan_not(mask __m, const char_type *__low,
                                       const char_type *__high) const = 0;
  virtual char_type do_toupper(char_type) const = 0;
  virtual const char_type *do_toupper(char_type *__low,
                                      const char_type *__high) const = 0;
  virtual char_type do_tolower(char_type) const = 0;
  virtual const char_type *do_tolower(char_type *__low,
                                      const char_type *__high) const = 0;
  virtual char_type do_widen(char) const = 0;
  virtual const char *do_widen(const char *__low, const char *__high,
                               char_type *__dest) const = 0;
  virtual char do_narrow(char_type, char __dfault) const = 0;
  virtual const char_type *do_narrow(const char_type *__low,
                                     const char_type *__high, char __dfault,
                                     char *__dest) const = 0;
};

template <class _CharT> locale::id ctype<_CharT>::id;

template <>
class __attribute__((__visibility__("default"))) ctype<wchar_t> : public locale::facet,
                                        public ctype_base {
public:
  typedef wchar_t char_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit ctype(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool is(mask __m, char_type __c) const { return do_is(__m, __c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *is(const char_type *__low, const char_type *__high,
                      mask *__vec) const {
    return do_is(__low, __high, __vec);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *scan_is(mask __m, const char_type *__low,
                           const char_type *__high) const {
    return do_scan_is(__m, __low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *scan_not(mask __m, const char_type *__low,
                            const char_type *__high) const {
    return do_scan_not(__m, __low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type toupper(char_type __c) const { return do_toupper(__c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *toupper(char_type *__low, const char_type *__high) const {
    return do_toupper(__low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type tolower(char_type __c) const { return do_tolower(__c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *tolower(char_type *__low, const char_type *__high) const {
    return do_tolower(__low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type widen(char __c) const { return do_widen(__c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char *widen(const char *__low, const char *__high,
                    char_type *__to) const {
    return do_widen(__low, __high, __to);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char narrow(char_type __c, char __dfault) const {
    return do_narrow(__c, __dfault);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *narrow(const char_type *__low, const char_type *__high,
                          char __dfault, char *__to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static locale::id id;

protected:
  ~ctype();
  virtual bool do_is(mask __m, char_type __c) const;
  virtual const char_type *do_is(const char_type *__low,
                                 const char_type *__high, mask *__vec) const;
  virtual const char_type *do_scan_is(mask __m, const char_type *__low,
                                      const char_type *__high) const;
  virtual const char_type *do_scan_not(mask __m, const char_type *__low,
                                       const char_type *__high) const;
  virtual char_type do_toupper(char_type) const;
  virtual const char_type *do_toupper(char_type *__low,
                                      const char_type *__high) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type *do_tolower(char_type *__low,
                                      const char_type *__high) const;
  virtual char_type do_widen(char) const;
  virtual const char *do_widen(const char *__low, const char *__high,
                               char_type *__dest) const;
  virtual char do_narrow(char_type, char __dfault) const;
  virtual const char_type *do_narrow(const char_type *__low,
                                     const char_type *__high, char __dfault,
                                     char *__dest) const;
};

template <>
class __attribute__((__visibility__("default"))) ctype<char> : public locale::facet, public ctype_base {
  const mask *__tab_;
  bool __del_;

public:
  typedef char char_type;

  explicit ctype(const mask *__tab = 0, bool __del = false, size_t __refs = 0);

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool is(mask __m, char_type __c) const {
    return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) != 0 : false;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *is(const char_type *__low, const char_type *__high,
                      mask *__vec) const {
    for (; __low != __high; ++__low, ++__vec)
      *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;
    return __low;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *scan_is(mask __m, const char_type *__low,
                           const char_type *__high) const {
    for (; __low != __high; ++__low)
      if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))
        break;
    return __low;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *scan_not(mask __m, const char_type *__low,
                            const char_type *__high) const {
    for (; __low != __high; ++__low)
      if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))
        break;
    return __low;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type toupper(char_type __c) const { return do_toupper(__c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *toupper(char_type *__low, const char_type *__high) const {
    return do_toupper(__low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type tolower(char_type __c) const { return do_tolower(__c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char_type *tolower(char_type *__low, const char_type *__high) const {
    return do_tolower(__low, __high);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type widen(char __c) const { return do_widen(__c); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char *widen(const char *__low, const char *__high,
                    char_type *__to) const {
    return do_widen(__low, __high, __to);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  char narrow(char_type __c, char __dfault) const {
    return do_narrow(__c, __dfault);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const char *narrow(const char_type *__low, const char_type *__high,
                     char __dfault, char *__to) const {
    return do_narrow(__low, __high, __dfault, __to);
  }

  static locale::id id;




  static const size_t table_size = 256;

  __attribute__((__visibility__("hidden"), __always_inline__)) const mask *table() const noexcept { return __tab_; }
  static const mask *classic_table() noexcept;





  static const short *__classic_upper_table() noexcept;
  static const short *__classic_lower_table() noexcept;


protected:
  ~ctype();
  virtual char_type do_toupper(char_type __c) const;
  virtual const char_type *do_toupper(char_type *__low,
                                      const char_type *__high) const;
  virtual char_type do_tolower(char_type __c) const;
  virtual const char_type *do_tolower(char_type *__low,
                                      const char_type *__high) const;
  virtual char_type do_widen(char __c) const;
  virtual const char *do_widen(const char *__low, const char *__high,
                               char_type *__to) const;
  virtual char do_narrow(char_type __c, char __dfault) const;
  virtual const char *do_narrow(const char_type *__low, const char_type *__high,
                                char __dfault, char *__to) const;
};



template <class _CharT> class __attribute__((__visibility__("default"))) ctype_byname;

template <> class __attribute__((__visibility__("default"))) ctype_byname<char> : public ctype<char> {
  locale_t __l;

public:
  explicit ctype_byname(const char *, size_t = 0);
  explicit ctype_byname(const string &, size_t = 0);

protected:
  ~ctype_byname();
  virtual char_type do_toupper(char_type) const;
  virtual const char_type *do_toupper(char_type *__low,
                                      const char_type *__high) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type *do_tolower(char_type *__low,
                                      const char_type *__high) const;
};

template <>
class __attribute__((__visibility__("default"))) ctype_byname<wchar_t> : public ctype<wchar_t> {
  locale_t __l;

public:
  explicit ctype_byname(const char *, size_t = 0);
  explicit ctype_byname(const string &, size_t = 0);

protected:
  ~ctype_byname();
  virtual bool do_is(mask __m, char_type __c) const;
  virtual const char_type *do_is(const char_type *__low,
                                 const char_type *__high, mask *__vec) const;
  virtual const char_type *do_scan_is(mask __m, const char_type *__low,
                                      const char_type *__high) const;
  virtual const char_type *do_scan_not(mask __m, const char_type *__low,
                                       const char_type *__high) const;
  virtual char_type do_toupper(char_type) const;
  virtual const char_type *do_toupper(char_type *__low,
                                      const char_type *__high) const;
  virtual char_type do_tolower(char_type) const;
  virtual const char_type *do_tolower(char_type *__low,
                                      const char_type *__high) const;
  virtual char_type do_widen(char) const;
  virtual const char *do_widen(const char *__low, const char *__high,
                               char_type *__dest) const;
  virtual char do_narrow(char_type, char __dfault) const;
  virtual const char_type *do_narrow(const char_type *__low,
                                     const char_type *__high, char __dfault,
                                     char *__dest) const;
};

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool isspace(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::space, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool isprint(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::print, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool iscntrl(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::cntrl, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool isupper(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::upper, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool islower(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::lower, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool isalpha(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alpha, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool isdigit(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::digit, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool ispunct(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::punct, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool isxdigit(_CharT __c,
                                               const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::xdigit, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool isalnum(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::alnum, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool isgraph(_CharT __c, const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).is(ctype_base::graph, __c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _CharT toupper(_CharT __c,
                                                const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).toupper(__c);
}

template <class _CharT>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _CharT tolower(_CharT __c,
                                                const locale &__loc) {
  return use_facet<ctype<_CharT>>(__loc).tolower(__c);
}



class __attribute__((__visibility__("default"))) codecvt_base {
public:
  __attribute__((__visibility__("hidden"), __always_inline__)) codecvt_base() {}
  enum result { ok, partial, error, noconv };
};



template <class _InternT, class _ExternT, class _StateT>
class __attribute__((__visibility__("default"))) codecvt;



template <>
class __attribute__((__visibility__("default"))) codecvt<char, char, mbstate_t> : public locale::facet,
                                                        public codecvt_base {
public:
  typedef char intern_type;
  typedef char extern_type;
  typedef mbstate_t state_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit codecvt(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  result out(state_type &__st, const intern_type *__frm,
             const intern_type *__frm_end, const intern_type *&__frm_nxt,
             extern_type *__to, extern_type *__to_end,
             extern_type *&__to_nxt) const {
    return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  result unshift(state_type &__st, extern_type *__to, extern_type *__to_end,
                 extern_type *&__to_nxt) const {
    return do_unshift(__st, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  result in(state_type &__st, const extern_type *__frm,
            const extern_type *__frm_end, const extern_type *&__frm_nxt,
            intern_type *__to, intern_type *__to_end,
            intern_type *&__to_nxt) const {
    return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int encoding() const noexcept { return do_encoding(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool always_noconv() const noexcept { return do_always_noconv(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int length(state_type &__st, const extern_type *__frm,
             const extern_type *__end, size_t __mx) const {
    return do_length(__st, __frm, __end, __mx);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int max_length() const noexcept { return do_max_length(); }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs) {}

  ~codecvt();

  virtual result do_out(state_type &__st, const intern_type *__frm,
                        const intern_type *__frm_end,
                        const intern_type *&__frm_nxt, extern_type *__to,
                        extern_type *__to_end, extern_type *&__to_nxt) const;
  virtual result do_in(state_type &__st, const extern_type *__frm,
                       const extern_type *__frm_end,
                       const extern_type *&__frm_nxt, intern_type *__to,
                       intern_type *__to_end, intern_type *&__to_nxt) const;
  virtual result do_unshift(state_type &__st, extern_type *__to,
                            extern_type *__to_end,
                            extern_type *&__to_nxt) const;
  virtual int do_encoding() const noexcept;
  virtual bool do_always_noconv() const noexcept;
  virtual int do_length(state_type &__st, const extern_type *__frm,
                        const extern_type *__end, size_t __mx) const;
  virtual int do_max_length() const noexcept;
};



template <>
class __attribute__((__visibility__("default"))) codecvt<wchar_t, char, mbstate_t> : public locale::facet,
                                                           public codecvt_base {
  locale_t __l;

public:
  typedef wchar_t intern_type;
  typedef char extern_type;
  typedef mbstate_t state_type;

  explicit codecvt(size_t __refs = 0);

  __attribute__((__visibility__("hidden"), __always_inline__))
  result out(state_type &__st, const intern_type *__frm,
             const intern_type *__frm_end, const intern_type *&__frm_nxt,
             extern_type *__to, extern_type *__to_end,
             extern_type *&__to_nxt) const {
    return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  result unshift(state_type &__st, extern_type *__to, extern_type *__to_end,
                 extern_type *&__to_nxt) const {
    return do_unshift(__st, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  result in(state_type &__st, const extern_type *__frm,
            const extern_type *__frm_end, const extern_type *&__frm_nxt,
            intern_type *__to, intern_type *__to_end,
            intern_type *&__to_nxt) const {
    return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int encoding() const noexcept { return do_encoding(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool always_noconv() const noexcept { return do_always_noconv(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int length(state_type &__st, const extern_type *__frm,
             const extern_type *__end, size_t __mx) const {
    return do_length(__st, __frm, __end, __mx);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int max_length() const noexcept { return do_max_length(); }

  static locale::id id;

protected:
  explicit codecvt(const char *, size_t __refs = 0);

  ~codecvt();

  virtual result do_out(state_type &__st, const intern_type *__frm,
                        const intern_type *__frm_end,
                        const intern_type *&__frm_nxt, extern_type *__to,
                        extern_type *__to_end, extern_type *&__to_nxt) const;
  virtual result do_in(state_type &__st, const extern_type *__frm,
                       const extern_type *__frm_end,
                       const extern_type *&__frm_nxt, intern_type *__to,
                       intern_type *__to_end, intern_type *&__to_nxt) const;
  virtual result do_unshift(state_type &__st, extern_type *__to,
                            extern_type *__to_end,
                            extern_type *&__to_nxt) const;
  virtual int do_encoding() const noexcept;
  virtual bool do_always_noconv() const noexcept;
  virtual int do_length(state_type &, const extern_type *__frm,
                        const extern_type *__end, size_t __mx) const;
  virtual int do_max_length() const noexcept;
};



template <>
class __attribute__((__visibility__("default"))) codecvt<char16_t, char, mbstate_t>
    : public locale::facet, public codecvt_base {
public:
  typedef char16_t intern_type;
  typedef char extern_type;
  typedef mbstate_t state_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit codecvt(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  result out(state_type &__st, const intern_type *__frm,
             const intern_type *__frm_end, const intern_type *&__frm_nxt,
             extern_type *__to, extern_type *__to_end,
             extern_type *&__to_nxt) const {
    return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  result unshift(state_type &__st, extern_type *__to, extern_type *__to_end,
                 extern_type *&__to_nxt) const {
    return do_unshift(__st, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  result in(state_type &__st, const extern_type *__frm,
            const extern_type *__frm_end, const extern_type *&__frm_nxt,
            intern_type *__to, intern_type *__to_end,
            intern_type *&__to_nxt) const {
    return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int encoding() const noexcept { return do_encoding(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool always_noconv() const noexcept { return do_always_noconv(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int length(state_type &__st, const extern_type *__frm,
             const extern_type *__end, size_t __mx) const {
    return do_length(__st, __frm, __end, __mx);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int max_length() const noexcept { return do_max_length(); }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs) {}

  ~codecvt();

  virtual result do_out(state_type &__st, const intern_type *__frm,
                        const intern_type *__frm_end,
                        const intern_type *&__frm_nxt, extern_type *__to,
                        extern_type *__to_end, extern_type *&__to_nxt) const;
  virtual result do_in(state_type &__st, const extern_type *__frm,
                       const extern_type *__frm_end,
                       const extern_type *&__frm_nxt, intern_type *__to,
                       intern_type *__to_end, intern_type *&__to_nxt) const;
  virtual result do_unshift(state_type &__st, extern_type *__to,
                            extern_type *__to_end,
                            extern_type *&__to_nxt) const;
  virtual int do_encoding() const noexcept;
  virtual bool do_always_noconv() const noexcept;
  virtual int do_length(state_type &, const extern_type *__frm,
                        const extern_type *__end, size_t __mx) const;
  virtual int do_max_length() const noexcept;
};



template <>
class __attribute__((__visibility__("default"))) codecvt<char32_t, char, mbstate_t>
    : public locale::facet, public codecvt_base {
public:
  typedef char32_t intern_type;
  typedef char extern_type;
  typedef mbstate_t state_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit codecvt(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  result out(state_type &__st, const intern_type *__frm,
             const intern_type *__frm_end, const intern_type *&__frm_nxt,
             extern_type *__to, extern_type *__to_end,
             extern_type *&__to_nxt) const {
    return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  result unshift(state_type &__st, extern_type *__to, extern_type *__to_end,
                 extern_type *&__to_nxt) const {
    return do_unshift(__st, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  result in(state_type &__st, const extern_type *__frm,
            const extern_type *__frm_end, const extern_type *&__frm_nxt,
            intern_type *__to, intern_type *__to_end,
            intern_type *&__to_nxt) const {
    return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int encoding() const noexcept { return do_encoding(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool always_noconv() const noexcept { return do_always_noconv(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int length(state_type &__st, const extern_type *__frm,
             const extern_type *__end, size_t __mx) const {
    return do_length(__st, __frm, __end, __mx);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  int max_length() const noexcept { return do_max_length(); }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit codecvt(const char *, size_t __refs = 0) : locale::facet(__refs) {}

  ~codecvt();

  virtual result do_out(state_type &__st, const intern_type *__frm,
                        const intern_type *__frm_end,
                        const intern_type *&__frm_nxt, extern_type *__to,
                        extern_type *__to_end, extern_type *&__to_nxt) const;
  virtual result do_in(state_type &__st, const extern_type *__frm,
                       const extern_type *__frm_end,
                       const extern_type *&__frm_nxt, intern_type *__to,
                       intern_type *__to_end, intern_type *&__to_nxt) const;
  virtual result do_unshift(state_type &__st, extern_type *__to,
                            extern_type *__to_end,
                            extern_type *&__to_nxt) const;
  virtual int do_encoding() const noexcept;
  virtual bool do_always_noconv() const noexcept;
  virtual int do_length(state_type &, const extern_type *__frm,
                        const extern_type *__end, size_t __mx) const;
  virtual int do_max_length() const noexcept;
};



template <class _InternT, class _ExternT, class _StateT>
class __attribute__((__visibility__("default"))) codecvt_byname
    : public codecvt<_InternT, _ExternT, _StateT> {
public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit codecvt_byname(const char *__nm, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit codecvt_byname(const string &__nm, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}

protected:
  ~codecvt_byname();
};

template <class _InternT, class _ExternT, class _StateT>
codecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname() {}

extern template class codecvt_byname<char, char, mbstate_t>;

extern template class codecvt_byname<wchar_t, char, mbstate_t>;

extern template class codecvt_byname<char16_t, char, mbstate_t>;

extern template class codecvt_byname<char32_t, char, mbstate_t>;



__attribute__((__visibility__("default"))) void __throw_runtime_error(const char *);

template <size_t _Np> struct __narrow_to_utf8 {
  template <class _OutputIterator, class _CharT>
  _OutputIterator operator()(_OutputIterator __s, const _CharT *__wb,
                             const _CharT *__we) const;
};

template <> struct __narrow_to_utf8<8> {
  template <class _OutputIterator, class _CharT>
  __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator operator()(_OutputIterator __s,
                                                   const _CharT *__wb,
                                                   const _CharT *__we) const {
    for (; __wb < __we; ++__wb, ++__s)
      *__s = *__wb;
    return __s;
  }
};

template <>
struct __narrow_to_utf8<16> : public codecvt<char16_t, char, mbstate_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

  ~__narrow_to_utf8();

  template <class _OutputIterator, class _CharT>
  __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator operator()(_OutputIterator __s,
                                                   const _CharT *__wb,
                                                   const _CharT *__we) const {
    result __r = ok;
    mbstate_t __mb;
    while (__wb < __we && __r != error) {
      const int __sz = 32;
      char __buf[__sz];
      char *__bn;
      const char16_t *__wn = (const char16_t *)__wb;
      __r = do_out(__mb, (const char16_t *)__wb, (const char16_t *)__we, __wn,
                   __buf, __buf + __sz, __bn);
      if (__r == codecvt_base::error || __wn == (const char16_t *)__wb)
        __throw_runtime_error("locale not supported");
      for (const char *__p = __buf; __p < __bn; ++__p, ++__s)
        *__s = *__p;
      __wb = (const _CharT *)__wn;
    }
    return __s;
  }
};

template <>
struct __narrow_to_utf8<32> : public codecvt<char32_t, char, mbstate_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

  ~__narrow_to_utf8();

  template <class _OutputIterator, class _CharT>
  __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator operator()(_OutputIterator __s,
                                                   const _CharT *__wb,
                                                   const _CharT *__we) const {
    result __r = ok;
    mbstate_t __mb;
    while (__wb < __we && __r != error) {
      const int __sz = 32;
      char __buf[__sz];
      char *__bn;
      const char32_t *__wn = (const char32_t *)__wb;
      __r = do_out(__mb, (const char32_t *)__wb, (const char32_t *)__we, __wn,
                   __buf, __buf + __sz, __bn);
      if (__r == codecvt_base::error || __wn == (const char32_t *)__wb)
        __throw_runtime_error("locale not supported");
      for (const char *__p = __buf; __p < __bn; ++__p, ++__s)
        *__s = *__p;
      __wb = (const _CharT *)__wn;
    }
    return __s;
  }
};

template <size_t _Np> struct __widen_from_utf8 {
  template <class _OutputIterator>
  _OutputIterator operator()(_OutputIterator __s, const char *__nb,
                             const char *__ne) const;
};

template <> struct __widen_from_utf8<8> {
  template <class _OutputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator operator()(_OutputIterator __s,
                                                   const char *__nb,
                                                   const char *__ne) const {
    for (; __nb < __ne; ++__nb, ++__s)
      *__s = *__nb;
    return __s;
  }
};

template <>
struct __widen_from_utf8<16> : public codecvt<char16_t, char, mbstate_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}

  ~__widen_from_utf8();

  template <class _OutputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator operator()(_OutputIterator __s,
                                                   const char *__nb,
                                                   const char *__ne) const {
    result __r = ok;
    mbstate_t __mb;
    while (__nb < __ne && __r != error) {
      const int __sz = 32;
      char16_t __buf[__sz];
      char16_t *__bn;
      const char *__nn = __nb;
      __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn,
                  __buf, __buf + __sz, __bn);
      if (__r == codecvt_base::error || __nn == __nb)
        __throw_runtime_error("locale not supported");
      for (const char16_t *__p = __buf; __p < __bn; ++__p, ++__s)
        *__s = (wchar_t)*__p;
      __nb = __nn;
    }
    return __s;
  }
};

template <>
struct __widen_from_utf8<32> : public codecvt<char32_t, char, mbstate_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}

  ~__widen_from_utf8();

  template <class _OutputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) _OutputIterator operator()(_OutputIterator __s,
                                                   const char *__nb,
                                                   const char *__ne) const {
    result __r = ok;
    mbstate_t __mb;
    while (__nb < __ne && __r != error) {
      const int __sz = 32;
      char32_t __buf[__sz];
      char32_t *__bn;
      const char *__nn = __nb;
      __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb + __sz : __ne, __nn,
                  __buf, __buf + __sz, __bn);
      if (__r == codecvt_base::error || __nn == __nb)
        __throw_runtime_error("locale not supported");
      for (const char32_t *__p = __buf; __p < __bn; ++__p, ++__s)
        *__s = (wchar_t)*__p;
      __nb = __nn;
    }
    return __s;
  }
};



template <class _CharT> class __attribute__((__visibility__("default"))) numpunct;

template <> class __attribute__((__visibility__("default"))) numpunct<char> : public locale::facet {
public:
  typedef char char_type;
  typedef basic_string<char_type> string_type;

  explicit numpunct(size_t __refs = 0);

  __attribute__((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {
    return do_decimal_point();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {
    return do_thousands_sep();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) string grouping() const { return do_grouping(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) string_type truename() const { return do_truename(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) string_type falsename() const { return do_falsename(); }

  static locale::id id;

protected:
  ~numpunct();
  virtual char_type do_decimal_point() const;
  virtual char_type do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string_type do_truename() const;
  virtual string_type do_falsename() const;

  char_type __decimal_point_;
  char_type __thousands_sep_;
  string __grouping_;
};

template <> class __attribute__((__visibility__("default"))) numpunct<wchar_t> : public locale::facet {
public:
  typedef wchar_t char_type;
  typedef basic_string<char_type> string_type;

  explicit numpunct(size_t __refs = 0);

  __attribute__((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {
    return do_decimal_point();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {
    return do_thousands_sep();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) string grouping() const { return do_grouping(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) string_type truename() const { return do_truename(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) string_type falsename() const { return do_falsename(); }

  static locale::id id;

protected:
  ~numpunct();
  virtual char_type do_decimal_point() const;
  virtual char_type do_thousands_sep() const;
  virtual string do_grouping() const;
  virtual string_type do_truename() const;
  virtual string_type do_falsename() const;

  char_type __decimal_point_;
  char_type __thousands_sep_;
  string __grouping_;
};



template <class _CharT> class __attribute__((__visibility__("default"))) numpunct_byname;

template <>
class __attribute__((__visibility__("default"))) numpunct_byname<char> : public numpunct<char> {
public:
  typedef char char_type;
  typedef basic_string<char_type> string_type;

  explicit numpunct_byname(const char *__nm, size_t __refs = 0);
  explicit numpunct_byname(const string &__nm, size_t __refs = 0);

protected:
  ~numpunct_byname();

private:
  void __init(const char *);
};

template <>
class __attribute__((__visibility__("default"))) numpunct_byname<wchar_t> : public numpunct<wchar_t> {
public:
  typedef wchar_t char_type;
  typedef basic_string<char_type> string_type;

  explicit numpunct_byname(const char *__nm, size_t __refs = 0);
  explicit numpunct_byname(const string &__nm, size_t __refs = 0);

protected:
  ~numpunct_byname();

private:
  void __init(const char *);
};

} }


namespace std { inline namespace __1 {

typedef ptrdiff_t streamsize;

class __attribute__((__visibility__("default"))) ios_base {
public:
  class __attribute__((__visibility__("default"))) failure;

  typedef unsigned int fmtflags;
  static const fmtflags boolalpha = 0x0001;
  static const fmtflags dec = 0x0002;
  static const fmtflags fixed = 0x0004;
  static const fmtflags hex = 0x0008;
  static const fmtflags internal = 0x0010;
  static const fmtflags left = 0x0020;
  static const fmtflags oct = 0x0040;
  static const fmtflags right = 0x0080;
  static const fmtflags scientific = 0x0100;
  static const fmtflags showbase = 0x0200;
  static const fmtflags showpoint = 0x0400;
  static const fmtflags showpos = 0x0800;
  static const fmtflags skipws = 0x1000;
  static const fmtflags unitbuf = 0x2000;
  static const fmtflags uppercase = 0x4000;
  static const fmtflags adjustfield = left | right | internal;
  static const fmtflags basefield = dec | oct | hex;
  static const fmtflags floatfield = scientific | fixed;

  typedef unsigned int iostate;
  static const iostate badbit = 0x1;
  static const iostate eofbit = 0x2;
  static const iostate failbit = 0x4;
  static const iostate goodbit = 0x0;

  typedef unsigned int openmode;
  static const openmode app = 0x01;
  static const openmode ate = 0x02;
  static const openmode binary = 0x04;
  static const openmode in = 0x08;
  static const openmode out = 0x10;
  static const openmode trunc = 0x20;

  enum seekdir { beg, cur, end };


  typedef iostate io_state;
  typedef openmode open_mode;
  typedef seekdir seek_dir;

  typedef std::__1::streamoff streamoff;
  typedef std::__1::streampos streampos;


  class __attribute__((__visibility__("default"))) Init;


  __attribute__((__visibility__("hidden"), __always_inline__)) fmtflags flags() const;
  __attribute__((__visibility__("hidden"), __always_inline__)) fmtflags flags(fmtflags __fmtfl);
  __attribute__((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl);
  __attribute__((__visibility__("hidden"), __always_inline__)) fmtflags setf(fmtflags __fmtfl, fmtflags __mask);
  __attribute__((__visibility__("hidden"), __always_inline__)) void unsetf(fmtflags __mask);

  __attribute__((__visibility__("hidden"), __always_inline__)) streamsize precision() const;
  __attribute__((__visibility__("hidden"), __always_inline__)) streamsize precision(streamsize __prec);
  __attribute__((__visibility__("hidden"), __always_inline__)) streamsize width() const;
  __attribute__((__visibility__("hidden"), __always_inline__)) streamsize width(streamsize __wide);


  locale imbue(const locale &__loc);
  locale getloc() const;


  static int xalloc();
  long &iword(int __index);
  void *&pword(int __index);


  virtual ~ios_base();


  enum event { erase_event, imbue_event, copyfmt_event };
  typedef void (*event_callback)(event, ios_base &, int __index);
  void register_callback(event_callback __fn, int __index);

private:
  ios_base(const ios_base &);
  ios_base &operator=(const ios_base &);

public:
  static bool sync_with_stdio(bool __sync = true);

  __attribute__((__visibility__("hidden"), __always_inline__)) iostate rdstate() const;
  void clear(iostate __state = goodbit);
  __attribute__((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state);

  __attribute__((__visibility__("hidden"), __always_inline__)) bool good() const;
  __attribute__((__visibility__("hidden"), __always_inline__)) bool eof() const;
  __attribute__((__visibility__("hidden"), __always_inline__)) bool fail() const;
  __attribute__((__visibility__("hidden"), __always_inline__)) bool bad() const;

  __attribute__((__visibility__("hidden"), __always_inline__)) iostate exceptions() const;
  __attribute__((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate);

  void __set_badbit_and_consider_rethrow();
  void __set_failbit_and_consider_rethrow();

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ios_base() {
  }

  void init(void *__sb);
  __attribute__((__visibility__("hidden"), __always_inline__)) void *rdbuf() const { return __rdbuf_; }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void rdbuf(void *__sb) {
    __rdbuf_ = __sb;
    clear();
  }

  void __call_callbacks(event);
  void copyfmt(const ios_base &);
  void move(ios_base &);
  void swap(ios_base &) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  void set_rdbuf(void *__sb) { __rdbuf_ = __sb; }

private:

  fmtflags __fmtflags_;
  streamsize __precision_;
  streamsize __width_;
  iostate __rdstate_;
  iostate __exceptions_;
  void *__rdbuf_;
  void *__loc_;
  event_callback *__fn_;
  int *__index_;
  size_t __event_size_;
  size_t __event_cap_;





  static int __xindex_;

  long *__iarray_;
  size_t __iarray_size_;
  size_t __iarray_cap_;
  void **__parray_;
  size_t __parray_size_;
  size_t __parray_cap_;
};


enum class io_errc{stream = 1};


template <>
struct __attribute__((__visibility__("default"))) is_error_code_enum<io_errc> : public true_type {};







__attribute__((__visibility__("default")))
const error_category &iostream_category() noexcept;

inline __attribute__((__visibility__("hidden"), __always_inline__)) error_code
make_error_code(io_errc __e) noexcept {
  return error_code(static_cast<int>(__e), iostream_category());
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) error_condition
make_error_condition(io_errc __e) noexcept {
  return error_condition(static_cast<int>(__e), iostream_category());
}

class __attribute__((__visibility__("default"))) ios_base::failure : public system_error {
public:
  explicit failure(const string &__msg,
                   const error_code &__ec = io_errc::stream);
  explicit failure(const char *__msg, const error_code &__ec = io_errc::stream);
  virtual ~failure() throw();
};

class __attribute__((__visibility__("default"))) ios_base::Init {
public:
  Init();
  ~Init();
};



inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base::fmtflags ios_base::flags() const {
  return __fmtflags_;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base::fmtflags
ios_base::flags(fmtflags __fmtfl) {
  fmtflags __r = __fmtflags_;
  __fmtflags_ = __fmtfl;
  return __r;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl) {
  fmtflags __r = __fmtflags_;
  __fmtflags_ |= __fmtfl;
  return __r;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void ios_base::unsetf(fmtflags __mask) {
  __fmtflags_ &= ~__mask;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base::fmtflags
ios_base::setf(fmtflags __fmtfl, fmtflags __mask) {
  fmtflags __r = __fmtflags_;
  unsetf(__mask);
  __fmtflags_ |= __fmtfl & __mask;
  return __r;
}



inline __attribute__((__visibility__("hidden"), __always_inline__)) streamsize ios_base::precision() const {
  return __precision_;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) streamsize
ios_base::precision(streamsize __prec) {
  streamsize __r = __precision_;
  __precision_ = __prec;
  return __r;
}



inline __attribute__((__visibility__("hidden"), __always_inline__)) streamsize ios_base::width() const {
  return __width_;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) streamsize ios_base::width(streamsize __wide) {
  streamsize __r = __width_;
  __width_ = __wide;
  return __r;
}



inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base::iostate ios_base::rdstate() const {
  return __rdstate_;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void ios_base::setstate(iostate __state) {
  clear(__rdstate_ | __state);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool ios_base::good() const {
  return __rdstate_ == 0;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool ios_base::eof() const {
  return (__rdstate_ & eofbit) != 0;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool ios_base::fail() const {
  return (__rdstate_ & (failbit | badbit)) != 0;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) bool ios_base::bad() const {
  return (__rdstate_ & badbit) != 0;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base::iostate
ios_base::exceptions() const {
  return __exceptions_;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) void ios_base::exceptions(iostate __iostate) {
  __exceptions_ = __iostate;
  clear(__rdstate_);
}

template <class _CharT, class _Traits>
class __attribute__((__visibility__("default"))) basic_ios : public ios_base {
public:

  typedef _CharT char_type;
  typedef _Traits traits_type;

  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit
  operator bool() const { return !fail(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool operator!() const { return fail(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) iostate rdstate() const { return ios_base::rdstate(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) void clear(iostate __state = goodbit) {
    ios_base::clear(__state);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void setstate(iostate __state) {
    ios_base::setstate(__state);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool good() const { return ios_base::good(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool eof() const { return ios_base::eof(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool fail() const { return ios_base::fail(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool bad() const { return ios_base::bad(); }

  __attribute__((__visibility__("hidden"), __always_inline__)) iostate exceptions() const {
    return ios_base::exceptions();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void exceptions(iostate __iostate) {
    ios_base::exceptions(__iostate);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit basic_ios(basic_streambuf<char_type, traits_type> *__sb);
  virtual ~basic_ios();


  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_ostream<char_type, traits_type> *tie() const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_ostream<char_type, traits_type> *
  tie(basic_ostream<char_type, traits_type> *__tiestr);

  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_streambuf<char_type, traits_type> *rdbuf() const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_streambuf<char_type, traits_type> *
  rdbuf(basic_streambuf<char_type, traits_type> *__sb);

  basic_ios &copyfmt(const basic_ios &__rhs);

  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type fill() const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type fill(char_type __ch);

  __attribute__((__visibility__("hidden"), __always_inline__))
  locale imbue(const locale &__loc);

  __attribute__((__visibility__("hidden"), __always_inline__))
  char narrow(char_type __c, char __dfault) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  char_type widen(char __c) const;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_ios() {
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void init(basic_streambuf<char_type, traits_type> *__sb);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void move(basic_ios &__rhs);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void move(basic_ios &&__rhs) { move(__rhs); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(basic_ios &__rhs) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  void set_rdbuf(basic_streambuf<char_type, traits_type> *__sb);

private:
  basic_ostream<char_type, traits_type> *__tie_;
  mutable int_type __fill_;

  bool __fill_set;

};

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ios<_CharT, _Traits>::basic_ios(
    basic_streambuf<char_type, traits_type> *__sb) {
  init(__sb);
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits>::~basic_ios() {}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void basic_ios<_CharT, _Traits>::init(
    basic_streambuf<char_type, traits_type> *__sb) {
  ios_base::init(__sb);
  __tie_ = 0;
  __fill_ = traits_type::eof();

  __fill_set = false;

}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream<_CharT, _Traits> *
basic_ios<_CharT, _Traits>::tie() const {
  return __tie_;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream<_CharT, _Traits> *
basic_ios<_CharT, _Traits>::tie(
    basic_ostream<char_type, traits_type> *__tiestr) {
  basic_ostream<char_type, traits_type> *__r = __tie_;
  __tie_ = __tiestr;
  return __r;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_streambuf<_CharT, _Traits> *
basic_ios<_CharT, _Traits>::rdbuf() const {
  return static_cast<basic_streambuf<char_type, traits_type> *>(
      ios_base::rdbuf());
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_streambuf<_CharT, _Traits> *
basic_ios<_CharT, _Traits>::rdbuf(
    basic_streambuf<char_type, traits_type> *__sb) {
  basic_streambuf<char_type, traits_type> *__r = rdbuf();
  ios_base::rdbuf(__sb);
  return __r;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) locale
basic_ios<_CharT, _Traits>::imbue(const locale &__loc) {
  locale __r = getloc();
  ios_base::imbue(__loc);
  if (rdbuf())
    rdbuf()->pubimbue(__loc);
  return __r;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) char
basic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const {
  return use_facet<ctype<char_type>>(getloc()).narrow(__c, __dfault);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _CharT
basic_ios<_CharT, _Traits>::widen(char __c) const {
  return use_facet<ctype<char_type>>(getloc()).widen(__c);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _CharT
basic_ios<_CharT, _Traits>::fill() const {

  if (!__fill_set)

    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
      __fill_ = widen(' ');
  return __fill_;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _CharT
basic_ios<_CharT, _Traits>::fill(char_type __ch) {

  if (!__fill_set)

    if (traits_type::eq_int_type(traits_type::eof(), __fill_))
      __fill_ = widen(' ');
  char_type __r = __fill_;
  __fill_ = __ch;

  __fill_set = true;

  return __r;
}

template <class _CharT, class _Traits>
basic_ios<_CharT, _Traits> &
basic_ios<_CharT, _Traits>::copyfmt(const basic_ios &__rhs) {
  if (this != &__rhs) {
    __call_callbacks(erase_event);
    ios_base::copyfmt(__rhs);
    __tie_ = __rhs.__tie_;
    __fill_ = __rhs.__fill_;

    __fill_set = __rhs.__fill_set;

    __call_callbacks(copyfmt_event);
    exceptions(__rhs.exceptions());
  }
  return *this;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_ios<_CharT, _Traits>::move(basic_ios &__rhs) {
  ios_base::move(__rhs);
  __tie_ = __rhs.__tie_;
  __rhs.__tie_ = 0;
  __fill_ = __rhs.__fill_;

  __fill_set = __rhs.__fill_set;

}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
basic_ios<_CharT, _Traits>::swap(basic_ios &__rhs) noexcept {
  ios_base::swap(__rhs);
  std::__1::swap(__tie_, __rhs.__tie_);
  std::__1::swap(__fill_, __rhs.__fill_);

  std::__1::swap(__fill_set, __rhs.__fill_set);

}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void basic_ios<_CharT, _Traits>::set_rdbuf(
    basic_streambuf<char_type, traits_type> *__sb) {
  ios_base::set_rdbuf(__sb);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &boolalpha(ios_base &__str) {
  __str.setf(ios_base::boolalpha);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &noboolalpha(ios_base &__str) {
  __str.unsetf(ios_base::boolalpha);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &showbase(ios_base &__str) {
  __str.setf(ios_base::showbase);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &noshowbase(ios_base &__str) {
  __str.unsetf(ios_base::showbase);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &showpoint(ios_base &__str) {
  __str.setf(ios_base::showpoint);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &noshowpoint(ios_base &__str) {
  __str.unsetf(ios_base::showpoint);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &showpos(ios_base &__str) {
  __str.setf(ios_base::showpos);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &noshowpos(ios_base &__str) {
  __str.unsetf(ios_base::showpos);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &skipws(ios_base &__str) {
  __str.setf(ios_base::skipws);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &noskipws(ios_base &__str) {
  __str.unsetf(ios_base::skipws);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &uppercase(ios_base &__str) {
  __str.setf(ios_base::uppercase);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &nouppercase(ios_base &__str) {
  __str.unsetf(ios_base::uppercase);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &unitbuf(ios_base &__str) {
  __str.setf(ios_base::unitbuf);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &nounitbuf(ios_base &__str) {
  __str.unsetf(ios_base::unitbuf);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &internal(ios_base &__str) {
  __str.setf(ios_base::internal, ios_base::adjustfield);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &left(ios_base &__str) {
  __str.setf(ios_base::left, ios_base::adjustfield);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &right(ios_base &__str) {
  __str.setf(ios_base::right, ios_base::adjustfield);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &dec(ios_base &__str) {
  __str.setf(ios_base::dec, ios_base::basefield);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &hex(ios_base &__str) {
  __str.setf(ios_base::hex, ios_base::basefield);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &oct(ios_base &__str) {
  __str.setf(ios_base::oct, ios_base::basefield);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &fixed(ios_base &__str) {
  __str.setf(ios_base::fixed, ios_base::floatfield);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &scientific(ios_base &__str) {
  __str.setf(ios_base::scientific, ios_base::floatfield);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &hexfloat(ios_base &__str) {
  __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
  return __str;
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) ios_base &defaultfloat(ios_base &__str) {
  __str.unsetf(ios_base::floatfield);
  return __str;
}

template <class _CharT, class _Traits> class __save_flags {
  typedef basic_ios<_CharT, _Traits> __stream_type;
  typedef typename __stream_type::fmtflags fmtflags;

  __stream_type &__stream_;
  fmtflags __fmtflags_;
  _CharT __fill_;

  __save_flags(const __save_flags &);
  __save_flags &operator=(const __save_flags &);

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __save_flags(__stream_type &__stream)
      : __stream_(__stream), __fmtflags_(__stream.flags()),
        __fill_(__stream.fill()) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~__save_flags() {
    __stream_.flags(__fmtflags_);
    __stream_.fill(__fill_);
  }
};

} }



namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__((__visibility__("default"))) basic_streambuf {
public:

  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;

  virtual ~basic_streambuf();


  inline __attribute__((__visibility__("hidden"), __always_inline__)) locale
  pubimbue(const locale &__loc) {
    imbue(__loc);
    locale __r = __loc_;
    __loc_ = __loc;
    return __r;
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) locale getloc() const {
    return __loc_;
  }


  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_streambuf *
  pubsetbuf(char_type *__s, streamsize __n) {
    return setbuf(__s, __n);
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) pos_type
  pubseekoff(off_type __off, ios_base::seekdir __way,
             ios_base::openmode __which = ios_base::in | ios_base::out) {
    return seekoff(__off, __way, __which);
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) pos_type
  pubseekpos(pos_type __sp,
             ios_base::openmode __which = ios_base::in | ios_base::out) {
    return seekpos(__sp, __which);
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) int pubsync() {
    return sync();
  }



  inline __attribute__((__visibility__("hidden"), __always_inline__)) streamsize in_avail() {
    if (__ninp_ < __einp_)
      return static_cast<streamsize>(__einp_ - __ninp_);
    return showmanyc();
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) int_type snextc() {
    if (sbumpc() == traits_type::eof())
      return traits_type::eof();
    return sgetc();
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) int_type sbumpc() {
    if (__ninp_ == __einp_)
      return uflow();
    return traits_type::to_int_type(*__ninp_++);
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) int_type sgetc() {
    if (__ninp_ == __einp_)
      return underflow();
    return traits_type::to_int_type(*__ninp_);
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) streamsize
  sgetn(char_type *__s, streamsize __n) {
    return xsgetn(__s, __n);
  }


  inline __attribute__((__visibility__("hidden"), __always_inline__)) int_type
  sputbackc(char_type __c) {
    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))
      return pbackfail(traits_type::to_int_type(__c));
    return traits_type::to_int_type(*--__ninp_);
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) int_type sungetc() {
    if (__binp_ == __ninp_)
      return pbackfail();
    return traits_type::to_int_type(*--__ninp_);
  }


  inline __attribute__((__visibility__("hidden"), __always_inline__)) int_type
  sputc(char_type __c) {
    if (__nout_ == __eout_)
      return overflow(traits_type::to_int_type(__c));
    *__nout_++ = __c;
    return traits_type::to_int_type(__c);
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) streamsize
  sputn(const char_type *__s, streamsize __n) {
    return xsputn(__s, __n);
  }

protected:
  basic_streambuf();
  basic_streambuf(const basic_streambuf &__rhs);
  basic_streambuf &operator=(const basic_streambuf &__rhs);
  void swap(basic_streambuf &__rhs);


  __attribute__((__visibility__("hidden"), __always_inline__)) char_type *eback() const { return __binp_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) char_type *gptr() const { return __ninp_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) char_type *egptr() const { return __einp_; }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void gbump(int __n) {
    __ninp_ += __n;
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void
  setg(char_type *__gbeg, char_type *__gnext, char_type *__gend) {
    __binp_ = __gbeg;
    __ninp_ = __gnext;
    __einp_ = __gend;
  }


  __attribute__((__visibility__("hidden"), __always_inline__)) char_type *pbase() const { return __bout_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) char_type *pptr() const { return __nout_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) char_type *epptr() const { return __eout_; }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void pbump(int __n) {
    __nout_ += __n;
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void
  setp(char_type *__pbeg, char_type *__pend) {
    __bout_ = __nout_ = __pbeg;
    __eout_ = __pend;
  }



  virtual void imbue(const locale &__loc);


  virtual basic_streambuf *setbuf(char_type *__s, streamsize __n);
  virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                           ios_base::openmode __which = ios_base::in |
                                                        ios_base::out);
  virtual pos_type seekpos(pos_type __sp,
                           ios_base::openmode __which = ios_base::in |
                                                        ios_base::out);
  virtual int sync();


  virtual streamsize showmanyc();
  virtual streamsize xsgetn(char_type *__s, streamsize __n);
  virtual int_type underflow();
  virtual int_type uflow();


  virtual int_type pbackfail(int_type __c = traits_type::eof());


  virtual streamsize xsputn(const char_type *__s, streamsize __n);
  virtual int_type overflow(int_type __c = traits_type::eof());

private:
  locale __loc_;
  char_type *__binp_;
  char_type *__ninp_;
  char_type *__einp_;
  char_type *__bout_;
  char_type *__nout_;
  char_type *__eout_;
};

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::~basic_streambuf() {}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf()
    : __binp_(0), __ninp_(0), __einp_(0), __bout_(0), __nout_(0), __eout_(0) {}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf &__sb)
    : __loc_(__sb.__loc_), __binp_(__sb.__binp_), __ninp_(__sb.__ninp_),
      __einp_(__sb.__einp_), __bout_(__sb.__bout_), __nout_(__sb.__nout_),
      __eout_(__sb.__eout_) {}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits> &basic_streambuf<_CharT, _Traits>::
operator=(const basic_streambuf &__sb) {
  __loc_ = __sb.__loc_;
  __binp_ = __sb.__binp_;
  __ninp_ = __sb.__ninp_;
  __einp_ = __sb.__einp_;
  __bout_ = __sb.__bout_;
  __nout_ = __sb.__nout_;
  __eout_ = __sb.__eout_;
  return *this;
}

template <class _CharT, class _Traits>
void basic_streambuf<_CharT, _Traits>::swap(basic_streambuf &__sb) {
  std::__1::swap(__loc_, __sb.__loc_);
  std::__1::swap(__binp_, __sb.__binp_);
  std::__1::swap(__ninp_, __sb.__ninp_);
  std::__1::swap(__einp_, __sb.__einp_);
  std::__1::swap(__bout_, __sb.__bout_);
  std::__1::swap(__nout_, __sb.__nout_);
  std::__1::swap(__eout_, __sb.__eout_);
}

template <class _CharT, class _Traits>
void basic_streambuf<_CharT, _Traits>::imbue(const locale &) {}

template <class _CharT, class _Traits>
basic_streambuf<_CharT, _Traits> *
basic_streambuf<_CharT, _Traits>::setbuf(char_type *, streamsize) {
  return this;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
    basic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,
                                              ios_base::openmode) {
  return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::pos_type
    basic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode) {
  return pos_type(off_type(-1));
}

template <class _CharT, class _Traits>
int basic_streambuf<_CharT, _Traits>::sync() {
  return 0;
}

template <class _CharT, class _Traits>
streamsize basic_streambuf<_CharT, _Traits>::showmanyc() {
  return 0;
}

template <class _CharT, class _Traits>
streamsize basic_streambuf<_CharT, _Traits>::xsgetn(char_type *__s,
                                                    streamsize __n) {
  const int_type __eof = traits_type::eof();
  int_type __c;
  streamsize __i = 0;
  while (__i < __n) {
    if (__ninp_ < __einp_) {
      const streamsize __len = std::__1::min(__einp_ - __ninp_, __n - __i);
      traits_type::copy(__s, __ninp_, __len);
      __s += __len;
      __i += __len;
      this->gbump(__len);
    } else if ((__c = uflow()) != __eof) {
      *__s = traits_type::to_char_type(__c);
      ++__s;
      ++__i;
    } else
      break;
  }
  return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::underflow() {
  return traits_type::eof();
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow() {
  if (underflow() == traits_type::eof())
    return traits_type::eof();
  return traits_type::to_int_type(*__ninp_++);
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::pbackfail(int_type) {
  return traits_type::eof();
}

template <class _CharT, class _Traits>
streamsize basic_streambuf<_CharT, _Traits>::xsputn(const char_type *__s,
                                                    streamsize __n) {
  streamsize __i = 0;
  int_type __eof = traits_type::eof();
  while (__i < __n) {
    if (__nout_ >= __eout_) {
      if (overflow(traits_type::to_int_type(*__s)) == __eof)
        break;
      ++__s;
      ++__i;
    } else {
      streamsize __chunk_size = std::__1::min(__eout_ - __nout_, __n - __i);
      traits_type::copy(__nout_, __s, __chunk_size);
      __nout_ += __chunk_size;
      __s += __chunk_size;
      __i += __chunk_size;
    }
  }
  return __i;
}

template <class _CharT, class _Traits>
typename basic_streambuf<_CharT, _Traits>::int_type
    basic_streambuf<_CharT, _Traits>::overflow(int_type) {
  return traits_type::eof();
}

extern template class basic_streambuf<char>;

extern template class basic_streambuf<wchar_t>;


extern template class basic_ios<char>;
extern template class basic_ios<wchar_t>;


} }



namespace std { inline namespace __1 {

using ::va_list;

} }






namespace std { inline namespace __1 {

typedef std::__1::remove_pointer<locale_t>::type __use_locale_struct;
typedef std::__1::unique_ptr<__use_locale_struct, decltype(&uselocale)>
    __locale_raii;

inline __attribute__((__visibility__("hidden"), __always_inline__)) decltype(((size_t const) (*(_Gtab(23)))))
__libcpp_mb_cur_max_l(locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return ((size_t const) (*(_Gtab(23))));
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) wint_t __libcpp_btowc_l(int __c, locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return btowc(__c);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) int __libcpp_wctob_l(wint_t __c, locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return wctob(__c);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) size_t
__libcpp_wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,
                      size_t __len, mbstate_t *__ps, locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return wcsnrtombs(__dest, __src, __nwc, __len, __ps);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) size_t __libcpp_wcrtomb_l(char *__s, wchar_t __wc,
                                                       mbstate_t *__ps,
                                                       locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return wcrtomb(__s, __wc, __ps);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) size_t
__libcpp_mbsnrtowcs_l(wchar_t *__dest, const char **__src, size_t __nms,
                      size_t __len, mbstate_t *__ps, locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return mbsnrtowcs(__dest, __src, __nms, __len, __ps);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) size_t __libcpp_mbrtowc_l(wchar_t *__pwc,
                                                       const char *__s,
                                                       size_t __n,
                                                       mbstate_t *__ps,
                                                       locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return mbrtowc(__pwc, __s, __n, __ps);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) int __libcpp_mbtowc_l(wchar_t *__pwc,
                                                   const char *__pmb,
                                                   size_t __max, locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return mbtowc(__pwc, __pmb, __max);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) size_t __libcpp_mbrlen_l(const char *__s,
                                                      size_t __n,
                                                      mbstate_t *__ps,
                                                      locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return mbrlen(__s, __n, __ps);
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) lconv *__libcpp_localeconv_l(locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return localeconv();
}

inline __attribute__((__visibility__("hidden"), __always_inline__)) size_t __libcpp_mbsrtowcs_l(wchar_t *__dest,
                                                         const char **__src,
                                                         size_t __len,
                                                         mbstate_t *__ps,
                                                         locale_t __l) {
  __locale_raii __current(uselocale(__l), uselocale);
  return mbsrtowcs(__dest, __src, __len, __ps);
}

inline int __libcpp_snprintf_l(char *__s, size_t __n, locale_t __l,
                               const char *__format, ...) {
  va_list __va;
  __va = (char *)((((((unsigned long)&(__format) + (sizeof(__format)))+(sizeof(void *)-1)) /sizeof(void *))*sizeof(void *)));
  __locale_raii __current(uselocale(__l), uselocale);
  int __res = vsnprintf(__s, __n, __format, __va);
  (__va)=(char *)0;
  return __res;
}

inline int __libcpp_asprintf_l(char **__s, locale_t __l, const char *__format,
                               ...) {
  va_list __va;
  __va = (char *)((((((unsigned long)&(__format) + (sizeof(__format)))+(sizeof(void *)-1)) /sizeof(void *))*sizeof(void *)));
  __locale_raii __current(uselocale(__l), uselocale);
  int __res = vasprintf(__s, __format, __va);
  (__va)=(char *)0;
  return __res;
}

inline int __libcpp_sscanf_l(const char *__s, locale_t __l,
                             const char *__format, ...) {
  va_list __va;
  __va = (char *)((((((unsigned long)&(__format) + (sizeof(__format)))+(sizeof(void *)-1)) /sizeof(void *))*sizeof(void *)));
  __locale_raii __current(uselocale(__l), uselocale);
  int __res = vsscanf(__s, __format, __va);
  (__va)=(char *)0;
  return __res;
}

} }


namespace std { inline namespace __1 {
__attribute__((__visibility__("default"))) locale_t __cloc();



typedef void( *freelocale_t)(locale_t);
typedef void( *free_t)(void *);

typedef std::__1::remove_pointer<locale_t>::type __locale_struct;
typedef std::__1::unique_ptr<__locale_struct, freelocale_t> __locale_unique_ptr;
template <class _InputIterator, class _ForwardIterator, class _Ctype>
__attribute__((__visibility__("hidden"))) _ForwardIterator
__scan_keyword(_InputIterator &__b, _InputIterator __e, _ForwardIterator __kb,
               _ForwardIterator __ke, const _Ctype &__ct,
               ios_base::iostate &__err, bool __case_sensitive = true) {
  typedef typename iterator_traits<_InputIterator>::value_type _CharT;
  size_t __nkw = static_cast<size_t>(std::__1::distance(__kb, __ke));
  const unsigned char __doesnt_match = '\0';
  const unsigned char __might_match = '\1';
  const unsigned char __does_match = '\2';
  unsigned char __statbuf[100];
  unsigned char *__status = __statbuf;
  unique_ptr<unsigned char, free_t> __stat_hold(0, free);
  if (__nkw > sizeof(__statbuf)) {
    __status = (unsigned char *)malloc(__nkw);
    if (__status == 0)
      __throw_bad_alloc();
    __stat_hold.reset(__status);
  }
  size_t __n_might_match = __nkw;
  size_t __n_does_match = 0;


  unsigned char *__st = __status;
  for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st) {
    if (!__ky->empty())
      *__st = __might_match;
    else {
      *__st = __does_match;
      --__n_might_match;
      ++__n_does_match;
    }
  }

  for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx) {

    _CharT __c = *__b;
    if (!__case_sensitive)
      __c = __ct.toupper(__c);
    bool __consume = false;






    __st = __status;
    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st) {
      if (*__st == __might_match) {
        _CharT __kc = (*__ky)[__indx];
        if (!__case_sensitive)
          __kc = __ct.toupper(__kc);
        if (__c == __kc) {
          __consume = true;
          if (__ky->size() == __indx + 1) {
            *__st = __does_match;
            --__n_might_match;
            ++__n_does_match;
          }
        } else {
          *__st = __doesnt_match;
          --__n_might_match;
        }
      }
    }

    if (__consume) {
      ++__b;



      if (__n_might_match + __n_does_match > 1) {
        __st = __status;
        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, (void)++__st) {
          if (*__st == __does_match && __ky->size() != __indx + 1) {
            *__st = __doesnt_match;
            --__n_does_match;
          }
        }
      }
    }
  }


  if (__b == __e)
    __err |= ios_base::eofbit;

  for (__st = __status; __kb != __ke; ++__kb, (void)++__st)
    if (*__st == __does_match)
      break;
  if (__kb == __ke)
    __err |= ios_base::failbit;
  return __kb;
}

struct __attribute__((__visibility__("default"))) __num_get_base {
  static const int __num_get_buf_sz = 40;

  static int __get_base(ios_base &);
  static const char __src[33];
};

__attribute__((__visibility__("default")))
void __check_grouping(const string &__grouping, unsigned *__g,
                      unsigned *__g_end, ios_base::iostate &__err);

template <class _CharT> struct __num_get : protected __num_get_base {
  static string __stage2_int_prep(ios_base &__iob, _CharT *__atoms,
                                  _CharT &__thousands_sep);
  static string __stage2_float_prep(ios_base &__iob, _CharT *__atoms,
                                    _CharT &__decimal_point,
                                    _CharT &__thousands_sep);
  static int __stage2_int_loop(_CharT __ct, int __base, char *__a,
                               char *&__a_end, unsigned &__dc,
                               _CharT __thousands_sep, const string &__grouping,
                               unsigned *__g, unsigned *&__g_end,
                               _CharT *__atoms);
  static int __stage2_float_loop(_CharT __ct, bool &__in_units, char &__exp,
                                 char *__a, char *&__a_end,
                                 _CharT __decimal_point, _CharT __thousands_sep,
                                 const string &__grouping, unsigned *__g,
                                 unsigned *&__g_end, unsigned &__dc,
                                 _CharT *__atoms);
};

template <class _CharT>
string __num_get<_CharT>::__stage2_int_prep(ios_base &__iob, _CharT *__atoms,
                                            _CharT &__thousands_sep) {
  locale __loc = __iob.getloc();
  use_facet<ctype<_CharT>>(__loc).widen(__src, __src + 26, __atoms);
  const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__loc);
  __thousands_sep = __np.thousands_sep();
  return __np.grouping();
}

template <class _CharT>
string __num_get<_CharT>::__stage2_float_prep(ios_base &__iob, _CharT *__atoms,
                                              _CharT &__decimal_point,
                                              _CharT &__thousands_sep) {
  locale __loc = __iob.getloc();
  use_facet<ctype<_CharT>>(__loc).widen(__src, __src + 32, __atoms);
  const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__loc);
  __decimal_point = __np.decimal_point();
  __thousands_sep = __np.thousands_sep();
  return __np.grouping();
}

template <class _CharT>
int __num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char *__a,
                                         char *&__a_end, unsigned &__dc,
                                         _CharT __thousands_sep,
                                         const string &__grouping,
                                         unsigned *__g, unsigned *&__g_end,
                                         _CharT *__atoms) {
  if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25])) {
    *__a_end++ = __ct == __atoms[24] ? '+' : '-';
    __dc = 0;
    return 0;
  }
  if (__grouping.size() != 0 && __ct == __thousands_sep) {
    if (__g_end - __g < __num_get_buf_sz) {
      *__g_end++ = __dc;
      __dc = 0;
    }
    return 0;
  }
  ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;
  if (__f >= 24)
    return -1;
  switch (__base) {
  case 8:
  case 10:
    if (__f >= __base)
      return -1;
    break;
  case 16:
    if (__f < 22)
      break;
    if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0') {
      __dc = 0;
      *__a_end++ = __src[__f];
      return 0;
    }
    return -1;
  }
  *__a_end++ = __src[__f];
  ++__dc;
  return 0;
}

template <class _CharT>
int __num_get<_CharT>::__stage2_float_loop(
    _CharT __ct, bool &__in_units, char &__exp, char *__a, char *&__a_end,
    _CharT __decimal_point, _CharT __thousands_sep, const string &__grouping,
    unsigned *__g, unsigned *&__g_end, unsigned &__dc, _CharT *__atoms) {
  if (__ct == __decimal_point) {
    if (!__in_units)
      return -1;
    __in_units = false;
    *__a_end++ = '.';
    if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
      *__g_end++ = __dc;
    return 0;
  }
  if (__ct == __thousands_sep && __grouping.size() != 0) {
    if (!__in_units)
      return -1;
    if (__g_end - __g < __num_get_buf_sz) {
      *__g_end++ = __dc;
      __dc = 0;
    }
    return 0;
  }
  ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;
  if (__f >= 32)
    return -1;
  char __x = __src[__f];
  if (__x == '-' || __x == '+') {
    if (__a_end == __a || (toupper(__a_end[-1]) == __exp)) {
      *__a_end++ = __x;
      return 0;
    }
    return -1;
  }
  if (__x == 'x' || __x == 'X')
    __exp = 'P';
  else if (toupper(__x) == __exp) {
    if (__in_units) {
      __in_units = false;
      if (__grouping.size() != 0 && __g_end - __g < __num_get_buf_sz)
        *__g_end++ = __dc;
    }
  }
  *__a_end++ = __x;
  if (__f >= 22)
    return 0;
  ++__dc;
  return 0;
}

extern template struct __num_get<char>;

extern template struct __num_get<wchar_t>;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>>
class __attribute__((__visibility__("default"))) num_get : public locale::facet,
                                      private __num_get<_CharT> {
public:
  typedef _CharT char_type;
  typedef _InputIterator iter_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit num_get(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, bool &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, long &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, long long &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, unsigned short &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, unsigned int &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, unsigned long &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, unsigned long long &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, float &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, double &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, long double &__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, void *&__v) const {
    return do_get(__b, __e, __iob, __err, __v);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~num_get() {}

  template <class _Fp>
  iter_type __do_get_floating_point(iter_type __b, iter_type __e,
                                    ios_base &__iob, ios_base::iostate &__err,
                                    _Fp &__v) const;

  template <class _Signed>
  iter_type __do_get_signed(iter_type __b, iter_type __e, ios_base &__iob,
                            ios_base::iostate &__err, _Signed &__v) const;

  template <class _Unsigned>
  iter_type __do_get_unsigned(iter_type __b, iter_type __e, ios_base &__iob,
                              ios_base::iostate &__err, _Unsigned &__v) const;

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, bool &__v) const;

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, long &__v) const {
    return this->__do_get_signed(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, long long &__v) const {
    return this->__do_get_signed(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err,
                           unsigned short &__v) const {
    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, unsigned int &__v) const {
    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, unsigned long &__v) const {
    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err,
                           unsigned long long &__v) const {
    return this->__do_get_unsigned(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, float &__v) const {
    return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, double &__v) const {
    return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, long double &__v) const {
    return this->__do_get_floating_point(__b, __e, __iob, __err, __v);
  }

  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, void *&__v) const;
};

template <class _CharT, class _InputIterator>
locale::id num_get<_CharT, _InputIterator>::id;

template <class _Tp>
_Tp __num_get_signed_integral(const char *__a, const char *__a_end,
                              ios_base::iostate &__err, int __base) {
  if (__a != __a_end) {
    typename remove_reference<decltype((*__errno()))>::type __save_errno = (*__errno());
    (*__errno()) = 0;
    char *__p2;
    long long __ll = strtoll_l(__a, &__p2, __base, __cloc());
    typename remove_reference<decltype((*__errno()))>::type __current_errno = (*__errno());
    if (__current_errno == 0)
      (*__errno()) = __save_errno;
    if (__p2 != __a_end) {
      __err = ios_base::failbit;
      return 0;
    } else if (__current_errno == 2 || __ll < numeric_limits<_Tp>::min() ||
               numeric_limits<_Tp>::max() < __ll) {
      __err = ios_base::failbit;
      if (__ll > 0)
        return numeric_limits<_Tp>::max();
      else
        return numeric_limits<_Tp>::min();
    }
    return static_cast<_Tp>(__ll);
  }
  __err = ios_base::failbit;
  return 0;
}

template <class _Tp>
_Tp __num_get_unsigned_integral(const char *__a, const char *__a_end,
                                ios_base::iostate &__err, int __base) {
  if (__a != __a_end) {
    if (*__a == '-') {
      __err = ios_base::failbit;
      return 0;
    }
    typename remove_reference<decltype((*__errno()))>::type __save_errno = (*__errno());
    (*__errno()) = 0;
    char *__p2;
    unsigned long long __ll =
        strtoull_l(__a, &__p2, __base, __cloc());
    typename remove_reference<decltype((*__errno()))>::type __current_errno = (*__errno());
    if (__current_errno == 0)
      (*__errno()) = __save_errno;
    if (__p2 != __a_end) {
      __err = ios_base::failbit;
      return 0;
    } else if (__current_errno == 2 || numeric_limits<_Tp>::max() < __ll) {
      __err = ios_base::failbit;
      return numeric_limits<_Tp>::max();
    }
    return static_cast<_Tp>(__ll);
  }
  __err = ios_base::failbit;
  return 0;
}

template <class _Tp>
__attribute__((__visibility__("hidden"), __always_inline__)) _Tp __do_strtod(const char *__a, char **__p2);

template <>
inline __attribute__((__visibility__("hidden"), __always_inline__)) float __do_strtod<float>(const char *__a,
                                                          char **__p2) {
  return strtof_l(__a, __p2, __cloc());
}

template <>
inline __attribute__((__visibility__("hidden"), __always_inline__)) double __do_strtod<double>(const char *__a,
                                                            char **__p2) {
  return strtod_l(__a, __p2, __cloc());
}

template <>
inline __attribute__((__visibility__("hidden"), __always_inline__)) long double
__do_strtod<long double>(const char *__a, char **__p2) {
  return strtold_l(__a, __p2, __cloc());
}

template <class _Tp>
_Tp __num_get_float(const char *__a, const char *__a_end,
                    ios_base::iostate &__err) {
  if (__a != __a_end) {
    typename remove_reference<decltype((*__errno()))>::type __save_errno = (*__errno());
    (*__errno()) = 0;
    char *__p2;
    _Tp __ld = __do_strtod<_Tp>(__a, &__p2);
    typename remove_reference<decltype((*__errno()))>::type __current_errno = (*__errno());
    if (__current_errno == 0)
      (*__errno()) = __save_errno;
    if (__p2 != __a_end) {
      __err = ios_base::failbit;
      return 0;
    } else if (__current_errno == 2)
      __err = ios_base::failbit;
    return __ld;
  }
  __err = ios_base::failbit;
  return 0;
}

template <class _CharT, class _InputIterator>
_InputIterator num_get<_CharT, _InputIterator>::do_get(iter_type __b,
                                                       iter_type __e,
                                                       ios_base &__iob,
                                                       ios_base::iostate &__err,
                                                       bool &__v) const {
  if ((__iob.flags() & ios_base::boolalpha) == 0) {
    long __lv = -1;
    __b = do_get(__b, __e, __iob, __err, __lv);
    switch (__lv) {
    case 0:
      __v = false;
      break;
    case 1:
      __v = true;
      break;
    default:
      __v = true;
      __err = ios_base::failbit;
      break;
    }
    return __b;
  }
  const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__iob.getloc());
  const numpunct<_CharT> &__np = use_facet<numpunct<_CharT>>(__iob.getloc());
  typedef typename numpunct<_CharT>::string_type string_type;
  const string_type __names[2] = {__np.truename(), __np.falsename()};
  const string_type *__i =
      __scan_keyword(__b, __e, __names, __names + 2, __ct, __err);
  __v = __i == __names;
  return __b;
}



template <class _CharT, class _InputIterator>
template <class _Signed>
_InputIterator num_get<_CharT, _InputIterator>::__do_get_signed(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    _Signed &__v) const {

  int __base = this->__get_base(__iob);

  char_type __atoms[26];
  char_type __thousands_sep;
  string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
  string __buf;
  __buf.resize(__buf.capacity());
  char *__a = &__buf[0];
  char *__a_end = __a;
  unsigned __g[__num_get_base::__num_get_buf_sz];
  unsigned *__g_end = __g;
  unsigned __dc = 0;
  for (; __b != __e; ++__b) {
    if (__a_end == __a + __buf.size()) {
      size_t __tmp = __buf.size();
      __buf.resize(2 * __buf.size());
      __buf.resize(__buf.capacity());
      __a = &__buf[0];
      __a_end = __a + __tmp;
    }
    if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                __thousands_sep, __grouping, __g, __g_end,
                                __atoms))
      break;
  }
  if (__grouping.size() != 0 &&
      __g_end - __g < __num_get_base::__num_get_buf_sz)
    *__g_end++ = __dc;

  __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);

  __check_grouping(__grouping, __g, __g_end, __err);

  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}



template <class _CharT, class _InputIterator>
template <class _Unsigned>
_InputIterator num_get<_CharT, _InputIterator>::__do_get_unsigned(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    _Unsigned &__v) const {

  int __base = this->__get_base(__iob);

  char_type __atoms[26];
  char_type __thousands_sep;
  string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);
  string __buf;
  __buf.resize(__buf.capacity());
  char *__a = &__buf[0];
  char *__a_end = __a;
  unsigned __g[__num_get_base::__num_get_buf_sz];
  unsigned *__g_end = __g;
  unsigned __dc = 0;
  for (; __b != __e; ++__b) {
    if (__a_end == __a + __buf.size()) {
      size_t __tmp = __buf.size();
      __buf.resize(2 * __buf.size());
      __buf.resize(__buf.capacity());
      __a = &__buf[0];
      __a_end = __a + __tmp;
    }
    if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                __thousands_sep, __grouping, __g, __g_end,
                                __atoms))
      break;
  }
  if (__grouping.size() != 0 &&
      __g_end - __g < __num_get_base::__num_get_buf_sz)
    *__g_end++ = __dc;

  __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);

  __check_grouping(__grouping, __g, __g_end, __err);

  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}



template <class _CharT, class _InputIterator>
template <class _Fp>
_InputIterator num_get<_CharT, _InputIterator>::__do_get_floating_point(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    _Fp &__v) const {


  char_type __atoms[32];
  char_type __decimal_point;
  char_type __thousands_sep;
  string __grouping = this->__stage2_float_prep(__iob, __atoms, __decimal_point,
                                                __thousands_sep);
  string __buf;
  __buf.resize(__buf.capacity());
  char *__a = &__buf[0];
  char *__a_end = __a;
  unsigned __g[__num_get_base::__num_get_buf_sz];
  unsigned *__g_end = __g;
  unsigned __dc = 0;
  bool __in_units = true;
  char __exp = 'E';
  for (; __b != __e; ++__b) {
    if (__a_end == __a + __buf.size()) {
      size_t __tmp = __buf.size();
      __buf.resize(2 * __buf.size());
      __buf.resize(__buf.capacity());
      __a = &__buf[0];
      __a_end = __a + __tmp;
    }
    if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,
                                  __decimal_point, __thousands_sep, __grouping,
                                  __g, __g_end, __dc, __atoms))
      break;
  }
  if (__grouping.size() != 0 && __in_units &&
      __g_end - __g < __num_get_base::__num_get_buf_sz)
    *__g_end++ = __dc;

  __v = __num_get_float<_Fp>(__a, __a_end, __err);

  __check_grouping(__grouping, __g, __g_end, __err);

  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator num_get<_CharT, _InputIterator>::do_get(iter_type __b,
                                                       iter_type __e,
                                                       ios_base &__iob,
                                                       ios_base::iostate &__err,
                                                       void *&__v) const {

  int __base = 16;

  char_type __atoms[26];
  char_type __thousands_sep = 0;
  string __grouping;
  use_facet<ctype<_CharT>>(__iob.getloc())
      .widen(__num_get_base::__src, __num_get_base::__src + 26, __atoms);
  string __buf;
  __buf.resize(__buf.capacity());
  char *__a = &__buf[0];
  char *__a_end = __a;
  unsigned __g[__num_get_base::__num_get_buf_sz];
  unsigned *__g_end = __g;
  unsigned __dc = 0;
  for (; __b != __e; ++__b) {
    if (__a_end == __a + __buf.size()) {
      size_t __tmp = __buf.size();
      __buf.resize(2 * __buf.size());
      __buf.resize(__buf.capacity());
      __a = &__buf[0];
      __a_end = __a + __tmp;
    }
    if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,
                                __thousands_sep, __grouping, __g, __g_end,
                                __atoms))
      break;
  }

  __buf.resize(__a_end - __a);
  if (__libcpp_sscanf_l(__buf.c_str(), __cloc(), "%p", &__v) != 1)
    __err = ios_base::failbit;

  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

extern template class num_get<char>;
extern template class num_get<wchar_t>;


struct __attribute__((__visibility__("default"))) __num_put_base {
protected:
  static void __format_int(char *__fmt, const char *__len, bool __signd,
                           ios_base::fmtflags __flags);
  static bool __format_float(char *__fmt, const char *__len,
                             ios_base::fmtflags __flags);
  static char *__identify_padding(char *__nb, char *__ne,
                                  const ios_base &__iob);
};

template <class _CharT> struct __num_put : protected __num_put_base {
  static void __widen_and_group_int(char *__nb, char *__np, char *__ne,
                                    _CharT *__ob, _CharT *&__op, _CharT *&__oe,
                                    const locale &__loc);
  static void __widen_and_group_float(char *__nb, char *__np, char *__ne,
                                      _CharT *__ob, _CharT *&__op,
                                      _CharT *&__oe, const locale &__loc);
};

template <class _CharT>
void __num_put<_CharT>::__widen_and_group_int(char *__nb, char *__np,
                                              char *__ne, _CharT *__ob,
                                              _CharT *&__op, _CharT *&__oe,
                                              const locale &__loc) {
  const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__loc);
  const numpunct<_CharT> &__npt = use_facet<numpunct<_CharT>>(__loc);
  string __grouping = __npt.grouping();
  if (__grouping.empty()) {
    __ct.widen(__nb, __ne, __ob);
    __oe = __ob + (__ne - __nb);
  } else {
    __oe = __ob;
    char *__nf = __nb;
    if (*__nf == '-' || *__nf == '+')
      *__oe++ = __ct.widen(*__nf++);
    if (__ne - __nf >= 2 && __nf[0] == '0' &&
        (__nf[1] == 'x' || __nf[1] == 'X')) {
      *__oe++ = __ct.widen(*__nf++);
      *__oe++ = __ct.widen(*__nf++);
    }
    reverse(__nf, __ne);
    _CharT __thousands_sep = __npt.thousands_sep();
    unsigned __dc = 0;
    unsigned __dg = 0;
    for (char *__p = __nf; __p < __ne; ++__p) {
      if (static_cast<unsigned>(__grouping[__dg]) > 0 &&
          __dc == static_cast<unsigned>(__grouping[__dg])) {
        *__oe++ = __thousands_sep;
        __dc = 0;
        if (__dg < __grouping.size() - 1)
          ++__dg;
      }
      *__oe++ = __ct.widen(*__p);
      ++__dc;
    }
    reverse(__ob + (__nf - __nb), __oe);
  }
  if (__np == __ne)
    __op = __oe;
  else
    __op = __ob + (__np - __nb);
}

template <class _CharT>
void __num_put<_CharT>::__widen_and_group_float(char *__nb, char *__np,
                                                char *__ne, _CharT *__ob,
                                                _CharT *&__op, _CharT *&__oe,
                                                const locale &__loc) {
  const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__loc);
  const numpunct<_CharT> &__npt = use_facet<numpunct<_CharT>>(__loc);
  string __grouping = __npt.grouping();
  __oe = __ob;
  char *__nf = __nb;
  if (*__nf == '-' || *__nf == '+')
    *__oe++ = __ct.widen(*__nf++);
  char *__ns;
  if (__ne - __nf >= 2 && __nf[0] == '0' &&
      (__nf[1] == 'x' || __nf[1] == 'X')) {
    *__oe++ = __ct.widen(*__nf++);
    *__oe++ = __ct.widen(*__nf++);
    for (__ns = __nf; __ns < __ne; ++__ns)
      if (!isxdigit_l(*__ns, __cloc()))
        break;
  } else {
    for (__ns = __nf; __ns < __ne; ++__ns)
      if (!isdigit_l(*__ns, __cloc()))
        break;
  }
  if (__grouping.empty()) {
    __ct.widen(__nf, __ns, __oe);
    __oe += __ns - __nf;
  } else {
    reverse(__nf, __ns);
    _CharT __thousands_sep = __npt.thousands_sep();
    unsigned __dc = 0;
    unsigned __dg = 0;
    for (char *__p = __nf; __p < __ns; ++__p) {
      if (__grouping[__dg] > 0 &&
          __dc == static_cast<unsigned>(__grouping[__dg])) {
        *__oe++ = __thousands_sep;
        __dc = 0;
        if (__dg < __grouping.size() - 1)
          ++__dg;
      }
      *__oe++ = __ct.widen(*__p);
      ++__dc;
    }
    reverse(__ob + (__nf - __nb), __oe);
  }
  for (__nf = __ns; __nf < __ne; ++__nf) {
    if (*__nf == '.') {
      *__oe++ = __npt.decimal_point();
      ++__nf;
      break;
    } else
      *__oe++ = __ct.widen(*__nf);
  }
  __ct.widen(__nf, __ne, __oe);
  __oe += __ne - __nf;
  if (__np == __ne)
    __op = __oe;
  else
    __op = __ob + (__np - __nb);
}

extern template struct __num_put<char>;

extern template struct __num_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>>
class __attribute__((__visibility__("default"))) num_put : public locale::facet,
                                      private __num_put<_CharT> {
public:
  typedef _CharT char_type;
  typedef _OutputIterator iter_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit num_put(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                bool __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                long __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                long long __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                unsigned long __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                unsigned long long __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                double __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                long double __v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, ios_base &__iob, char_type __fl,
                const void *__v) const {
    return do_put(__s, __iob, __fl, __v);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~num_put() {}

  virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                           bool __v) const;
  virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                           long __v) const;
  virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                           long long __v) const;
  virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                           unsigned long) const;
  virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                           unsigned long long) const;
  virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                           double __v) const;
  virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                           long double __v) const;
  virtual iter_type do_put(iter_type __s, ios_base &__iob, char_type __fl,
                           const void *__v) const;
};

template <class _CharT, class _OutputIterator>
locale::id num_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
__attribute__((__visibility__("hidden"))) _OutputIterator __pad_and_output(_OutputIterator __s,
                                                const _CharT *__ob,
                                                const _CharT *__op,
                                                const _CharT *__oe,
                                                ios_base &__iob, _CharT __fl) {
  streamsize __sz = __oe - __ob;
  streamsize __ns = __iob.width();
  if (__ns > __sz)
    __ns -= __sz;
  else
    __ns = 0;
  for (; __ob < __op; ++__ob, ++__s)
    *__s = *__ob;
  for (; __ns; --__ns, ++__s)
    *__s = __fl;
  for (; __ob < __oe; ++__ob, ++__s)
    *__s = *__ob;
  __iob.width(0);
  return __s;
}






template <class _CharT, class _Traits>
__attribute__((__visibility__("hidden"))) ostreambuf_iterator<_CharT, _Traits>
__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s, const _CharT *__ob,
                 const _CharT *__op, const _CharT *__oe, ios_base &__iob,
                 _CharT __fl) {
  if (__s.__sbuf_ == nullptr)
    return __s;
  streamsize __sz = __oe - __ob;
  streamsize __ns = __iob.width();
  if (__ns > __sz)
    __ns -= __sz;
  else
    __ns = 0;
  streamsize __np = __op - __ob;
  if (__np > 0) {
    if (__s.__sbuf_->sputn(__ob, __np) != __np) {
      __s.__sbuf_ = nullptr;
      return __s;
    }
  }
  if (__ns > 0) {
    basic_string<_CharT, _Traits> __sp(__ns, __fl);
    if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns) {
      __s.__sbuf_ = nullptr;
      return __s;
    }
  }
  __np = __oe - __op;
  if (__np > 0) {
    if (__s.__sbuf_->sputn(__op, __np) != __np) {
      __s.__sbuf_ = nullptr;
      return __s;
    }
  }
  __iob.width(0);
  return __s;
}



template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, bool __v) const {
  if ((__iob.flags() & ios_base::boolalpha) == 0)
    return do_put(__s, __iob, __fl, (unsigned long)__v);
  const numpunct<char_type> &__np =
      use_facet<numpunct<char_type>>(__iob.getloc());
  typedef typename numpunct<char_type>::string_type string_type;




  string_type __nm = __v ? __np.truename() : __np.falsename();

  for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end();
       ++__i, ++__s)
    *__s = *__i;
  return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, long __v) const {

  char __fmt[6] = {'%', 0};
  const char *__len = "l";
  this->__format_int(__fmt + 1, __len, true, __iob.flags());
  const unsigned __nbuf = (numeric_limits<long>::digits / 3) +
                          ((numeric_limits<long>::digits % 3) != 0) + 2;
  char __nar[__nbuf];
  int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(),
                                 __fmt, __v);
  char *__ne = __nar + __nc;
  char *__np = this->__identify_padding(__nar, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type *__op;
  char_type *__oe;
  this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe,
                              __iob.getloc());


  return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, long long __v) const {

  char __fmt[8] = {'%', 0};
  const char *__len = "ll";
  this->__format_int(__fmt + 1, __len, true, __iob.flags());
  const unsigned __nbuf = (numeric_limits<long long>::digits / 3) +
                          ((numeric_limits<long long>::digits % 3) != 0) + 2;
  char __nar[__nbuf];
  int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(),
                                 __fmt, __v);
  char *__ne = __nar + __nc;
  char *__np = this->__identify_padding(__nar, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type *__op;
  char_type *__oe;
  this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe,
                              __iob.getloc());


  return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator num_put<_CharT, _OutputIterator>::do_put(
    iter_type __s, ios_base &__iob, char_type __fl, unsigned long __v) const {

  char __fmt[6] = {'%', 0};
  const char *__len = "l";
  this->__format_int(__fmt + 1, __len, false, __iob.flags());
  const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3) +
                          ((numeric_limits<unsigned long>::digits % 3) != 0) +
                          1;
  char __nar[__nbuf];
  int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(),
                                 __fmt, __v);
  char *__ne = __nar + __nc;
  char *__np = this->__identify_padding(__nar, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type *__op;
  char_type *__oe;
  this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe,
                              __iob.getloc());


  return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl,
                                         unsigned long long __v) const {

  char __fmt[8] = {'%', 0};
  const char *__len = "ll";
  this->__format_int(__fmt + 1, __len, false, __iob.flags());
  const unsigned __nbuf =
      (numeric_limits<unsigned long long>::digits / 3) +
      ((numeric_limits<unsigned long long>::digits % 3) != 0) + 1;
  char __nar[__nbuf];
  int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(),
                                 __fmt, __v);
  char *__ne = __nar + __nc;
  char *__np = this->__identify_padding(__nar, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type *__op;
  char_type *__oe;
  this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe,
                              __iob.getloc());


  return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &__iob,
                                         char_type __fl, double __v) const {

  char __fmt[8] = {'%', 0};
  const char *__len = "";
  bool __specify_precision =
      this->__format_float(__fmt + 1, __len, __iob.flags());
  const unsigned __nbuf = 30;
  char __nar[__nbuf];
  char *__nb = __nar;
  int __nc;
  if (__specify_precision)
    __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt,
                               (int)__iob.precision(), __v);
  else
    __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
  unique_ptr<char, free_t> __nbh(0, free);
  if (__nc > static_cast<int>(__nbuf - 1)) {
    if (__specify_precision)
      __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt,
                                 (int)__iob.precision(), __v);
    else
      __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, __v);
    if (__nb == 0)
      __throw_bad_alloc();
    __nbh.reset(__nb);
  }
  char *__ne = __nb + __nc;
  char *__np = this->__identify_padding(__nb, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type *__ob = __o;
  unique_ptr<char_type, free_t> __obh(0, free);
  if (__nb != __nar) {
    __ob =
        (char_type *)malloc(2 * static_cast<size_t>(__nc) * sizeof(char_type));
    if (__ob == 0)
      __throw_bad_alloc();
    __obh.reset(__ob);
  }
  char_type *__op;
  char_type *__oe;
  this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe,
                                __iob.getloc());


  __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
  return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator num_put<_CharT, _OutputIterator>::do_put(
    iter_type __s, ios_base &__iob, char_type __fl, long double __v) const {

  char __fmt[8] = {'%', 0};
  const char *__len = "L";
  bool __specify_precision =
      this->__format_float(__fmt + 1, __len, __iob.flags());
  const unsigned __nbuf = 30;
  char __nar[__nbuf];
  char *__nb = __nar;
  int __nc;
  if (__specify_precision)
    __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt,
                               (int)__iob.precision(), __v);
  else
    __nc = __libcpp_snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);
  unique_ptr<char, free_t> __nbh(0, free);
  if (__nc > static_cast<int>(__nbuf - 1)) {
    if (__specify_precision)
      __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt,
                                 (int)__iob.precision(), __v);
    else
      __nc = __libcpp_asprintf_l(&__nb, __cloc(), __fmt, __v);
    if (__nb == 0)
      __throw_bad_alloc();
    __nbh.reset(__nb);
  }
  char *__ne = __nb + __nc;
  char *__np = this->__identify_padding(__nb, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type *__ob = __o;
  unique_ptr<char_type, free_t> __obh(0, free);
  if (__nb != __nar) {
    __ob =
        (char_type *)malloc(2 * static_cast<size_t>(__nc) * sizeof(char_type));
    if (__ob == 0)
      __throw_bad_alloc();
    __obh.reset(__ob);
  }
  char_type *__op;
  char_type *__oe;
  this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe,
                                __iob.getloc());


  __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);
  return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator num_put<_CharT, _OutputIterator>::do_put(
    iter_type __s, ios_base &__iob, char_type __fl, const void *__v) const {

  char __fmt[6] = "%p";
  const unsigned __nbuf = 20;
  char __nar[__nbuf];
  int __nc = __libcpp_snprintf_l(__nar, sizeof(__nar), __cloc(),
                                 __fmt, __v);
  char *__ne = __nar + __nc;
  char *__np = this->__identify_padding(__nar, __ne, __iob);

  char_type __o[2 * (__nbuf - 1) - 1];
  char_type *__op;
  char_type *__oe;
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
  __ct.widen(__nar, __ne, __o);
  __oe = __o + (__ne - __nar);
  if (__np == __ne)
    __op = __oe;
  else
    __op = __o + (__np - __nar);


  return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);
}

extern template class num_put<char>;
extern template class num_put<wchar_t>;


template <class _CharT, class _InputIterator>
__attribute__((__visibility__("hidden"))) int __get_up_to_n_digits(_InputIterator &__b, _InputIterator __e,
                                        ios_base::iostate &__err,
                                        const ctype<_CharT> &__ct, int __n) {

  if (__b == __e) {
    __err |= ios_base::eofbit | ios_base::failbit;
    return 0;
  }

  _CharT __c = *__b;
  if (!__ct.is(ctype_base::digit, __c)) {
    __err |= ios_base::failbit;
    return 0;
  }
  int __r = __ct.narrow(__c, 0) - '0';
  for (++__b, (void)--__n; __b != __e && __n > 0; ++__b, (void)--__n) {

    __c = *__b;
    if (!__ct.is(ctype_base::digit, __c))
      return __r;
    __r = __r * 10 + __ct.narrow(__c, 0) - '0';
  }
  if (__b == __e)
    __err |= ios_base::eofbit;
  return __r;
}

class __attribute__((__visibility__("default"))) time_base {
public:
  enum dateorder { no_order, dmy, mdy, ymd, ydm };
};

template <class _CharT> class __attribute__((__visibility__("default"))) __time_get_c_storage {
protected:
  typedef basic_string<_CharT> string_type;

  virtual const string_type *__weeks() const;
  virtual const string_type *__months() const;
  virtual const string_type *__am_pm() const;
  virtual const string_type &__c() const;
  virtual const string_type &__r() const;
  virtual const string_type &__x() const;
  virtual const string_type &__X() const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  ~__time_get_c_storage() {}
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>>
class __attribute__((__visibility__("default"))) time_get : public locale::facet,
                                       public time_base,
                                       private __time_get_c_storage<_CharT> {
public:
  typedef _CharT char_type;
  typedef _InputIterator iter_type;
  typedef time_base::dateorder dateorder;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit time_get(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  dateorder date_order() const { return this->do_date_order(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get_time(iter_type __b, iter_type __e, ios_base &__iob,
                     ios_base::iostate &__err, tm *__tm) const {
    return do_get_time(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get_date(iter_type __b, iter_type __e, ios_base &__iob,
                     ios_base::iostate &__err, tm *__tm) const {
    return do_get_date(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get_weekday(iter_type __b, iter_type __e, ios_base &__iob,
                        ios_base::iostate &__err, tm *__tm) const {
    return do_get_weekday(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get_monthname(iter_type __b, iter_type __e, ios_base &__iob,
                          ios_base::iostate &__err, tm *__tm) const {
    return do_get_monthname(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get_year(iter_type __b, iter_type __e, ios_base &__iob,
                     ios_base::iostate &__err, tm *__tm) const {
    return do_get_year(__b, __e, __iob, __err, __tm);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, tm *__tm, char __fmt,
                char __mod = 0) const {
    return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);
  }

  iter_type get(iter_type __b, iter_type __e, ios_base &__iob,
                ios_base::iostate &__err, tm *__tm, const char_type *__fmtb,
                const char_type *__fmte) const;

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~time_get() {}

  virtual dateorder do_date_order() const;
  virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base &__iob,
                                ios_base::iostate &__err, tm *__tm) const;
  virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base &__iob,
                                ios_base::iostate &__err, tm *__tm) const;
  virtual iter_type do_get_weekday(iter_type __b, iter_type __e,
                                   ios_base &__iob, ios_base::iostate &__err,
                                   tm *__tm) const;
  virtual iter_type do_get_monthname(iter_type __b, iter_type __e,
                                     ios_base &__iob, ios_base::iostate &__err,
                                     tm *__tm) const;
  virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base &__iob,
                                ios_base::iostate &__err, tm *__tm) const;
  virtual iter_type do_get(iter_type __b, iter_type __e, ios_base &__iob,
                           ios_base::iostate &__err, tm *__tm, char __fmt,
                           char __mod) const;

private:
  void __get_white_space(iter_type &__b, iter_type __e,
                         ios_base::iostate &__err,
                         const ctype<char_type> &__ct) const;
  void __get_percent(iter_type &__b, iter_type __e, ios_base::iostate &__err,
                     const ctype<char_type> &__ct) const;

  void __get_weekdayname(int &__m, iter_type &__b, iter_type __e,
                         ios_base::iostate &__err,
                         const ctype<char_type> &__ct) const;
  void __get_monthname(int &__m, iter_type &__b, iter_type __e,
                       ios_base::iostate &__err,
                       const ctype<char_type> &__ct) const;
  void __get_day(int &__d, iter_type &__b, iter_type __e,
                 ios_base::iostate &__err, const ctype<char_type> &__ct) const;
  void __get_month(int &__m, iter_type &__b, iter_type __e,
                   ios_base::iostate &__err,
                   const ctype<char_type> &__ct) const;
  void __get_year(int &__y, iter_type &__b, iter_type __e,
                  ios_base::iostate &__err, const ctype<char_type> &__ct) const;
  void __get_year4(int &__y, iter_type &__b, iter_type __e,
                   ios_base::iostate &__err,
                   const ctype<char_type> &__ct) const;
  void __get_hour(int &__d, iter_type &__b, iter_type __e,
                  ios_base::iostate &__err, const ctype<char_type> &__ct) const;
  void __get_12_hour(int &__h, iter_type &__b, iter_type __e,
                     ios_base::iostate &__err,
                     const ctype<char_type> &__ct) const;
  void __get_am_pm(int &__h, iter_type &__b, iter_type __e,
                   ios_base::iostate &__err,
                   const ctype<char_type> &__ct) const;
  void __get_minute(int &__m, iter_type &__b, iter_type __e,
                    ios_base::iostate &__err,
                    const ctype<char_type> &__ct) const;
  void __get_second(int &__s, iter_type &__b, iter_type __e,
                    ios_base::iostate &__err,
                    const ctype<char_type> &__ct) const;
  void __get_weekday(int &__w, iter_type &__b, iter_type __e,
                     ios_base::iostate &__err,
                     const ctype<char_type> &__ct) const;
  void __get_day_year_num(int &__w, iter_type &__b, iter_type __e,
                          ios_base::iostate &__err,
                          const ctype<char_type> &__ct) const;
};

template <class _CharT, class _InputIterator>
locale::id time_get<_CharT, _InputIterator>::id;



template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_weekdayname(
    int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {

  const string_type *__wk = this->__weeks();
  ptrdiff_t __i =
      __scan_keyword(__b, __e, __wk, __wk + 14, __ct, __err, false) - __wk;
  if (__i < 14)
    __w = __i % 7;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_monthname(
    int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {

  const string_type *__month = this->__months();
  ptrdiff_t __i =
      __scan_keyword(__b, __e, __month, __month + 24, __ct, __err, false) -
      __month;
  if (__i < 24)
    __m = __i % 12;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_day(
    int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)
    __d = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_month(
    int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;
  if (!(__err & ios_base::failbit) && __t <= 11)
    __m = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_year(
    int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
  if (!(__err & ios_base::failbit)) {
    if (__t < 69)
      __t += 2000;
    else if (69 <= __t && __t <= 99)
      __t += 1900;
    __y = __t - 1900;
  }
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_year4(
    int &__y, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);
  if (!(__err & ios_base::failbit))
    __y = __t - 1900;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_hour(
    int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && __t <= 23)
    __h = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_12_hour(
    int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)
    __h = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_minute(
    int &__m, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && __t <= 59)
    __m = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_second(
    int &__s, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);
  if (!(__err & ios_base::failbit) && __t <= 60)
    __s = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_weekday(
    int &__w, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);
  if (!(__err & ios_base::failbit) && __t <= 6)
    __w = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_day_year_num(
    int &__d, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);
  if (!(__err & ios_base::failbit) && __t <= 365)
    __d = __t;
  else
    __err |= ios_base::failbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_white_space(
    iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
    ;
  if (__b == __e)
    __err |= ios_base::eofbit;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_am_pm(
    int &__h, iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  const string_type *__ap = this->__am_pm();
  if (__ap[0].size() + __ap[1].size() == 0) {
    __err |= ios_base::failbit;
    return;
  }
  ptrdiff_t __i =
      __scan_keyword(__b, __e, __ap, __ap + 2, __ct, __err, false) - __ap;
  if (__i == 0 && __h == 12)
    __h = 0;
  else if (__i == 1 && __h < 12)
    __h += 12;
}

template <class _CharT, class _InputIterator>
void time_get<_CharT, _InputIterator>::__get_percent(
    iter_type &__b, iter_type __e, ios_base::iostate &__err,
    const ctype<char_type> &__ct) const {
  if (__b == __e) {
    __err |= ios_base::eofbit | ios_base::failbit;
    return;
  }
  if (__ct.narrow(*__b, 0) != '%')
    __err |= ios_base::failbit;
  else if (++__b == __e)
    __err |= ios_base::eofbit;
}



template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::get(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    tm *__tm, const char_type *__fmtb, const char_type *__fmte) const {
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
  __err = ios_base::goodbit;
  while (__fmtb != __fmte && __err == ios_base::goodbit) {
    if (__b == __e) {
      __err = ios_base::failbit;
      break;
    }
    if (__ct.narrow(*__fmtb, 0) == '%') {
      if (++__fmtb == __fmte) {
        __err = ios_base::failbit;
        break;
      }
      char __cmd = __ct.narrow(*__fmtb, 0);
      char __opt = '\0';
      if (__cmd == 'E' || __cmd == '0') {
        if (++__fmtb == __fmte) {
          __err = ios_base::failbit;
          break;
        }
        __opt = __cmd;
        __cmd = __ct.narrow(*__fmtb, 0);
      }
      __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);
      ++__fmtb;
    } else if (__ct.is(ctype_base::space, *__fmtb)) {
      for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb);
           ++__fmtb)
        ;
      for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)
        ;
    } else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb)) {
      ++__b;
      ++__fmtb;
    } else
      __err = ios_base::failbit;
  }
  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

template <class _CharT, class _InputIterator>
typename time_get<_CharT, _InputIterator>::dateorder
time_get<_CharT, _InputIterator>::do_date_order() const {
  return mdy;
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_time(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    tm *__tm) const {
  const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
  return get(__b, __e, __iob, __err, __tm, __fmt,
             __fmt + sizeof(__fmt) / sizeof(__fmt[0]));
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_date(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    tm *__tm) const {
  const string_type &__fmt = this->__x();
  return get(__b, __e, __iob, __err, __tm, __fmt.data(),
             __fmt.data() + __fmt.size());
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_weekday(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    tm *__tm) const {
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
  __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_monthname(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    tm *__tm) const {
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
  __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get_year(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    tm *__tm) const {
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
  __get_year(__tm->tm_year, __b, __e, __err, __ct);
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator time_get<_CharT, _InputIterator>::do_get(
    iter_type __b, iter_type __e, ios_base &__iob, ios_base::iostate &__err,
    tm *__tm, char __fmt, char) const {
  __err = ios_base::goodbit;
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
  switch (__fmt) {
  case 'a':
  case 'A':
    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);
    break;
  case 'b':
  case 'B':
  case 'h':
    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);
    break;
  case 'c': {
    const string_type &__fm = this->__c();
    __b = get(__b, __e, __iob, __err, __tm, __fm.data(),
              __fm.data() + __fm.size());
  } break;
  case 'd':
  case 'e':
    __get_day(__tm->tm_mday, __b, __e, __err, __ct);
    break;
  case 'D': {
    const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};
    __b = get(__b, __e, __iob, __err, __tm, __fm,
              __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'F': {
    const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};
    __b = get(__b, __e, __iob, __err, __tm, __fm,
              __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'H':
    __get_hour(__tm->tm_hour, __b, __e, __err, __ct);
    break;
  case 'I':
    __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);
    break;
  case 'j':
    __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);
    break;
  case 'm':
    __get_month(__tm->tm_mon, __b, __e, __err, __ct);
    break;
  case 'M':
    __get_minute(__tm->tm_min, __b, __e, __err, __ct);
    break;
  case 'n':
  case 't':
    __get_white_space(__b, __e, __err, __ct);
    break;
  case 'p':
    __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);
    break;
  case 'r': {
    const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':',
                              '%', 'S', ' ', '%', 'p'};
    __b = get(__b, __e, __iob, __err, __tm, __fm,
              __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'R': {
    const char_type __fm[] = {'%', 'H', ':', '%', 'M'};
    __b = get(__b, __e, __iob, __err, __tm, __fm,
              __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'S':
    __get_second(__tm->tm_sec, __b, __e, __err, __ct);
    break;
  case 'T': {
    const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};
    __b = get(__b, __e, __iob, __err, __tm, __fm,
              __fm + sizeof(__fm) / sizeof(__fm[0]));
  } break;
  case 'w':
    __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);
    break;
  case 'x':
    return do_get_date(__b, __e, __iob, __err, __tm);
  case 'X': {
    const string_type &__fm = this->__X();
    __b = get(__b, __e, __iob, __err, __tm, __fm.data(),
              __fm.data() + __fm.size());
  } break;
  case 'y':
    __get_year(__tm->tm_year, __b, __e, __err, __ct);
    break;
  case 'Y':
    __get_year4(__tm->tm_year, __b, __e, __err, __ct);
    break;
  case '%':
    __get_percent(__b, __e, __err, __ct);
    break;
  default:
    __err |= ios_base::failbit;
  }
  return __b;
}

extern template class time_get<char>;
extern template class time_get<wchar_t>;


class __attribute__((__visibility__("default"))) __time_get {
protected:
  locale_t __loc_;

  __time_get(const char *__nm);
  __time_get(const string &__nm);
  ~__time_get();
};

template <class _CharT>
class __attribute__((__visibility__("default"))) __time_get_storage : public __time_get {
protected:
  typedef basic_string<_CharT> string_type;

  string_type __weeks_[14];
  string_type __months_[24];
  string_type __am_pm_[2];
  string_type __c_;
  string_type __r_;
  string_type __x_;
  string_type __X_;

  explicit __time_get_storage(const char *__nm);
  explicit __time_get_storage(const string &__nm);

  __attribute__((__visibility__("hidden"), __always_inline__)) ~__time_get_storage() {}

  time_base::dateorder __do_date_order() const;

private:
  void init(const ctype<_CharT> &);
  string_type __analyze(char __fmt, const ctype<_CharT> &);
};

template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>>
class __attribute__((__visibility__("default"))) time_get_byname
    : public time_get<_CharT, _InputIterator>,
      private __time_get_storage<_CharT> {
public:
  typedef time_base::dateorder dateorder;
  typedef _InputIterator iter_type;
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit time_get_byname(const char *__nm, size_t __refs = 0)
      : time_get<_CharT, _InputIterator>(__refs),
        __time_get_storage<_CharT>(__nm) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit time_get_byname(const string &__nm, size_t __refs = 0)
      : time_get<_CharT, _InputIterator>(__refs),
        __time_get_storage<_CharT>(__nm) {}

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~time_get_byname() {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  virtual dateorder do_date_order() const { return this->__do_date_order(); }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  virtual const string_type *__weeks() const { return this->__weeks_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  virtual const string_type *__months() const { return this->__months_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  virtual const string_type *__am_pm() const { return this->__am_pm_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  virtual const string_type &__c() const { return this->__c_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  virtual const string_type &__r() const { return this->__r_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  virtual const string_type &__x() const { return this->__x_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  virtual const string_type &__X() const { return this->__X_; }
};

extern template class time_get_byname<char>;

extern template class time_get_byname<wchar_t>;


class __attribute__((__visibility__("default"))) __time_put {
  locale_t __loc_;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__)) __time_put() : __loc_(__cloc()) {}
  __time_put(const char *__nm);
  __time_put(const string &__nm);
  ~__time_put();
  void __do_put(char *__nb, char *&__ne, const tm *__tm, char __fmt,
                char __mod) const;
  void __do_put(wchar_t *__wb, wchar_t *&__we, const tm *__tm, char __fmt,
                char __mod) const;
};

template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>>
class __attribute__((__visibility__("default"))) time_put : public locale::facet,
                                       private __time_put {
public:
  typedef _CharT char_type;
  typedef _OutputIterator iter_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit time_put(size_t __refs = 0) : locale::facet(__refs) {}

  iter_type put(iter_type __s, ios_base &__iob, char_type __fl, const tm *__tm,
                const char_type *__pb, const char_type *__pe) const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, ios_base &__iob, char_type __fl, const tm *__tm,
                char __fmt, char __mod = 0) const {
    return do_put(__s, __iob, __fl, __tm, __fmt, __mod);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~time_put() {}
  virtual iter_type do_put(iter_type __s, ios_base &, char_type, const tm *__tm,
                           char __fmt, char __mod) const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit time_put(const char *__nm, size_t __refs)
      : locale::facet(__refs), __time_put(__nm) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit time_put(const string &__nm, size_t __refs)
      : locale::facet(__refs), __time_put(__nm) {}
};

template <class _CharT, class _OutputIterator>
locale::id time_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator time_put<_CharT, _OutputIterator>::put(
    iter_type __s, ios_base &__iob, char_type __fl, const tm *__tm,
    const char_type *__pb, const char_type *__pe) const {
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__iob.getloc());
  for (; __pb != __pe; ++__pb) {
    if (__ct.narrow(*__pb, 0) == '%') {
      if (++__pb == __pe) {
        *__s++ = __pb[-1];
        break;
      }
      char __mod = 0;
      char __fmt = __ct.narrow(*__pb, 0);
      if (__fmt == 'E' || __fmt == 'O') {
        if (++__pb == __pe) {
          *__s++ = __pb[-2];
          *__s++ = __pb[-1];
          break;
        }
        __mod = __fmt;
        __fmt = __ct.narrow(*__pb, 0);
      }
      __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);
    } else
      *__s++ = *__pb;
  }
  return __s;
}

template <class _CharT, class _OutputIterator>
_OutputIterator
time_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base &, char_type,
                                          const tm *__tm, char __fmt,
                                          char __mod) const {
  char_type __nar[100];
  char_type *__nb = __nar;
  char_type *__ne = __nb + 100;
  __do_put(__nb, __ne, __tm, __fmt, __mod);
  return std::__1::copy(__nb, __ne, __s);
}

extern template class time_put<char>;
extern template class time_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>>
class __attribute__((__visibility__("default"))) time_put_byname
    : public time_put<_CharT, _OutputIterator> {
public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit time_put_byname(const char *__nm, size_t __refs = 0)
      : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit time_put_byname(const string &__nm, size_t __refs = 0)
      : time_put<_CharT, _OutputIterator>(__nm, __refs) {}

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~time_put_byname() {}
};

extern template class time_put_byname<char>;

extern template class time_put_byname<wchar_t>;




class __attribute__((__visibility__("default"))) money_base {
public:
  enum part { none, space, symbol, sign, value };
  struct pattern {
    char field[4];
  };

  __attribute__((__visibility__("hidden"), __always_inline__)) money_base() {}
};



template <class _CharT, bool _International = false>
class __attribute__((__visibility__("default"))) moneypunct : public locale::facet,
                                         public money_base {
public:
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit moneypunct(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__)) char_type decimal_point() const {
    return do_decimal_point();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) char_type thousands_sep() const {
    return do_thousands_sep();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) string grouping() const { return do_grouping(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) string_type curr_symbol() const {
    return do_curr_symbol();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) string_type positive_sign() const {
    return do_positive_sign();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) string_type negative_sign() const {
    return do_negative_sign();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) int frac_digits() const { return do_frac_digits(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) pattern pos_format() const { return do_pos_format(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) pattern neg_format() const { return do_neg_format(); }

  static locale::id id;
  static const bool intl = _International;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~moneypunct() {}

  virtual char_type do_decimal_point() const {
    return numeric_limits<char_type>::max();
  }
  virtual char_type do_thousands_sep() const {
    return numeric_limits<char_type>::max();
  }
  virtual string do_grouping() const { return string(); }
  virtual string_type do_curr_symbol() const { return string_type(); }
  virtual string_type do_positive_sign() const { return string_type(); }
  virtual string_type do_negative_sign() const { return string_type(1, '-'); }
  virtual int do_frac_digits() const { return 0; }
  virtual pattern do_pos_format() const {
    pattern __p = {{symbol, sign, none, value}};
    return __p;
  }
  virtual pattern do_neg_format() const {
    pattern __p = {{symbol, sign, none, value}};
    return __p;
  }
};

template <class _CharT, bool _International>
locale::id moneypunct<_CharT, _International>::id;

template <class _CharT, bool _International>
const bool moneypunct<_CharT, _International>::intl;

extern template class moneypunct<char, false>;

extern template class moneypunct<char, true>;

extern template class moneypunct<wchar_t, false>;

extern template class moneypunct<wchar_t, true>;




template <class _CharT, bool _International = false>
class __attribute__((__visibility__("default"))) moneypunct_byname
    : public moneypunct<_CharT, _International> {
public:
  typedef money_base::pattern pattern;
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit moneypunct_byname(const char *__nm, size_t __refs = 0)
      : moneypunct<_CharT, _International>(__refs) {
    init(__nm);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit moneypunct_byname(const string &__nm, size_t __refs = 0)
      : moneypunct<_CharT, _International>(__refs) {
    init(__nm.c_str());
  }

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~moneypunct_byname() {}

  virtual char_type do_decimal_point() const { return __decimal_point_; }
  virtual char_type do_thousands_sep() const { return __thousands_sep_; }
  virtual string do_grouping() const { return __grouping_; }
  virtual string_type do_curr_symbol() const { return __curr_symbol_; }
  virtual string_type do_positive_sign() const { return __positive_sign_; }
  virtual string_type do_negative_sign() const { return __negative_sign_; }
  virtual int do_frac_digits() const { return __frac_digits_; }
  virtual pattern do_pos_format() const { return __pos_format_; }
  virtual pattern do_neg_format() const { return __neg_format_; }

private:
  char_type __decimal_point_;
  char_type __thousands_sep_;
  string __grouping_;
  string_type __curr_symbol_;
  string_type __positive_sign_;
  string_type __negative_sign_;
  int __frac_digits_;
  pattern __pos_format_;
  pattern __neg_format_;

  void init(const char *);
};

template <> void moneypunct_byname<char, false>::init(const char *);
template <> void moneypunct_byname<char, true>::init(const char *);
template <> void moneypunct_byname<wchar_t, false>::init(const char *);
template <> void moneypunct_byname<wchar_t, true>::init(const char *);

extern template class moneypunct_byname<char, false>;

extern template class moneypunct_byname<char, true>;

extern template class moneypunct_byname<wchar_t, false>;

extern template class moneypunct_byname<wchar_t, true>;




template <class _CharT> class __money_get {
protected:
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__)) __money_get() {}

  static void __gather_info(bool __intl, const locale &__loc,
                            money_base::pattern &__pat, char_type &__dp,
                            char_type &__ts, string &__grp, string_type &__sym,
                            string_type &__psn, string_type &__nsn, int &__fd);
};

template <class _CharT>
void __money_get<_CharT>::__gather_info(bool __intl, const locale &__loc,
                                        money_base::pattern &__pat,
                                        char_type &__dp, char_type &__ts,
                                        string &__grp, string_type &__sym,
                                        string_type &__psn, string_type &__nsn,
                                        int &__fd) {
  if (__intl) {
    const moneypunct<char_type, true> &__mp =
        use_facet<moneypunct<char_type, true>>(__loc);
    __pat = __mp.neg_format();
    __nsn = __mp.negative_sign();
    __psn = __mp.positive_sign();
    __dp = __mp.decimal_point();
    __ts = __mp.thousands_sep();
    __grp = __mp.grouping();
    __sym = __mp.curr_symbol();
    __fd = __mp.frac_digits();
  } else {
    const moneypunct<char_type, false> &__mp =
        use_facet<moneypunct<char_type, false>>(__loc);
    __pat = __mp.neg_format();
    __nsn = __mp.negative_sign();
    __psn = __mp.positive_sign();
    __dp = __mp.decimal_point();
    __ts = __mp.thousands_sep();
    __grp = __mp.grouping();
    __sym = __mp.curr_symbol();
    __fd = __mp.frac_digits();
  }
}

extern template class __money_get<char>;

extern template class __money_get<wchar_t>;


template <class _CharT, class _InputIterator = istreambuf_iterator<_CharT>>
class __attribute__((__visibility__("default"))) money_get : public locale::facet,
                                        private __money_get<_CharT> {
public:
  typedef _CharT char_type;
  typedef _InputIterator iter_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit money_get(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base &__iob,
                ios_base::iostate &__err, long double &__v) const {
    return do_get(__b, __e, __intl, __iob, __err, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base &__iob,
                ios_base::iostate &__err, string_type &__v) const {
    return do_get(__b, __e, __intl, __iob, __err, __v);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~money_get() {}

  virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                           ios_base &__iob, ios_base::iostate &__err,
                           long double &__v) const;
  virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,
                           ios_base &__iob, ios_base::iostate &__err,
                           string_type &__v) const;

private:
  static bool __do_get(iter_type &__b, iter_type __e, bool __intl,
                       const locale &__loc, ios_base::fmtflags __flags,
                       ios_base::iostate &__err, bool &__neg,
                       const ctype<char_type> &__ct,
                       unique_ptr<char_type, free_t> &__wb, char_type *&__wn,
                       char_type *__we);
};

template <class _CharT, class _InputIterator>
locale::id money_get<_CharT, _InputIterator>::id;

__attribute__((__visibility__("default"))) void __do_nothing(void *);

template <class _Tp>
__attribute__((__visibility__("hidden"))) void __double_or_nothing(unique_ptr<_Tp, free_t> &__b, _Tp *&__n,
                                        _Tp *&__e) {
  bool __owns = __b.get_deleter() != __do_nothing;
  size_t __cur_cap = static_cast<size_t>(__e - __b.get()) * sizeof(_Tp);
  size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2
                         ? 2 * __cur_cap
                         : numeric_limits<size_t>::max();
  if (__new_cap == 0)
    __new_cap = sizeof(_Tp);
  size_t __n_off = static_cast<size_t>(__n - __b.get());
  _Tp *__t = (_Tp *)realloc(__owns ? __b.get() : 0, __new_cap);
  if (__t == 0)
    __throw_bad_alloc();
  if (__owns)
    __b.release();
  __b = unique_ptr<_Tp, free_t>(__t, free);
  __new_cap /= sizeof(_Tp);
  __n = __b.get() + __n_off;
  __e = __b.get() + __new_cap;
}


template <class _CharT, class _InputIterator>
bool money_get<_CharT, _InputIterator>::__do_get(
    iter_type &__b, iter_type __e, bool __intl, const locale &__loc,
    ios_base::fmtflags __flags, ios_base::iostate &__err, bool &__neg,
    const ctype<char_type> &__ct, unique_ptr<char_type, free_t> &__wb,
    char_type *&__wn, char_type *__we) {
  const unsigned __bz = 100;
  unsigned __gbuf[__bz];
  unique_ptr<unsigned, free_t> __gb(__gbuf, __do_nothing);
  unsigned *__gn = __gb.get();
  unsigned *__ge = __gn + __bz;
  money_base::pattern __pat;
  char_type __dp;
  char_type __ts;
  string __grp;
  string_type __sym;
  string_type __psn;
  string_type __nsn;


  string_type __spaces;
  int __fd;
  __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,
                                     __sym, __psn, __nsn, __fd);
  const string_type *__trailing_sign = 0;
  __wn = __wb.get();
  for (unsigned __p = 0; __p < 4 && __b != __e; ++__p) {
    switch (__pat.field[__p]) {
    case money_base::space:
      if (__p != 3) {
        if (__ct.is(ctype_base::space, *__b))
          __spaces.push_back(*__b++);
        else {
          __err |= ios_base::failbit;
          return false;
        }
      }

    case money_base::none:
      if (__p != 3) {
        while (__b != __e && __ct.is(ctype_base::space, *__b))
          __spaces.push_back(*__b++);
      }
      break;
    case money_base::sign:
      if (__psn.size() + __nsn.size() > 0) {
        if (__psn.size() == 0 || __nsn.size() == 0) {
          if (__psn.size() > 0) {
            if (*__b == __psn[0]) {
              ++__b;
              if (__psn.size() > 1)
                __trailing_sign = &__psn;
            } else
              __neg = true;
          } else if (*__b == __nsn[0])
          {
            ++__b;
            __neg = true;
            if (__nsn.size() > 1)
              __trailing_sign = &__nsn;
          }
        } else
        {
          if (*__b == __psn[0]) {
            ++__b;
            if (__psn.size() > 1)
              __trailing_sign = &__psn;
          } else if (*__b == __nsn[0]) {
            ++__b;
            __neg = true;
            if (__nsn.size() > 1)
              __trailing_sign = &__nsn;
          } else {
            __err |= ios_base::failbit;
            return false;
          }
        }
      }
      break;
    case money_base::symbol: {
      bool __more_needed =
          __trailing_sign || (__p < 2) ||
          (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));
      bool __sb = (__flags & ios_base::showbase) != 0;
      if (__sb || __more_needed) {
        typename string_type::const_iterator __sym_space_end = __sym.begin();
        if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||
                        __pat.field[__p - 1] == money_base::space)) {


          while (__sym_space_end != __sym.end() &&
                 __ct.is(ctype_base::space, *__sym_space_end))
            ++__sym_space_end;
          const size_t __num_spaces = __sym_space_end - __sym.begin();
          if (__num_spaces > __spaces.size() ||
              !equal(__spaces.end() - __num_spaces, __spaces.end(),
                     __sym.begin())) {



            __sym_space_end = __sym.begin();
          }
        }
        typename string_type::const_iterator __sym_curr_char = __sym_space_end;
        while (__sym_curr_char != __sym.end() && __b != __e &&
               *__b == *__sym_curr_char) {
          ++__b;
          ++__sym_curr_char;
        }
        if (__sb && __sym_curr_char != __sym.end()) {
          __err |= ios_base::failbit;
          return false;
        }
      }
    } break;
    case money_base::value: {
      unsigned __ng = 0;
      for (; __b != __e; ++__b) {
        char_type __c = *__b;
        if (__ct.is(ctype_base::digit, __c)) {
          if (__wn == __we)
            __double_or_nothing(__wb, __wn, __we);
          *__wn++ = __c;
          ++__ng;
        } else if (__grp.size() > 0 && __ng > 0 && __c == __ts) {
          if (__gn == __ge)
            __double_or_nothing(__gb, __gn, __ge);
          *__gn++ = __ng;
          __ng = 0;
        } else
          break;
      }
      if (__gb.get() != __gn && __ng > 0) {
        if (__gn == __ge)
          __double_or_nothing(__gb, __gn, __ge);
        *__gn++ = __ng;
      }
      if (__fd > 0) {
        if (__b == __e || *__b != __dp) {
          __err |= ios_base::failbit;
          return false;
        }
        for (++__b; __fd > 0; --__fd, ++__b) {
          if (__b == __e || !__ct.is(ctype_base::digit, *__b)) {
            __err |= ios_base::failbit;
            return false;
          }
          if (__wn == __we)
            __double_or_nothing(__wb, __wn, __we);
          *__wn++ = *__b;
        }
      }
      if (__wn == __wb.get()) {
        __err |= ios_base::failbit;
        return false;
      }
    } break;
    }
  }
  if (__trailing_sign) {
    for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b) {
      if (__b == __e || *__b != (*__trailing_sign)[__i]) {
        __err |= ios_base::failbit;
        return false;
      }
    }
  }
  if (__gb.get() != __gn) {
    ios_base::iostate __et = ios_base::goodbit;
    __check_grouping(__grp, __gb.get(), __gn, __et);
    if (__et) {
      __err |= ios_base::failbit;
      return false;
    }
  }
  return true;
}

template <class _CharT, class _InputIterator>
_InputIterator money_get<_CharT, _InputIterator>::do_get(
    iter_type __b, iter_type __e, bool __intl, ios_base &__iob,
    ios_base::iostate &__err, long double &__v) const {
  const int __bz = 100;
  char_type __wbuf[__bz];
  unique_ptr<char_type, free_t> __wb(__wbuf, __do_nothing);
  char_type *__wn;
  char_type *__we = __wbuf + __bz;
  locale __loc = __iob.getloc();
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__loc);
  bool __neg = false;
  if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb,
               __wn, __we)) {
    const char __src[] = "0123456789";
    char_type __atoms[sizeof(__src) - 1];
    __ct.widen(__src, __src + (sizeof(__src) - 1), __atoms);
    char __nbuf[__bz];
    char *__nc = __nbuf;
    unique_ptr<char, free_t> __h(0, free);
    if (__wn - __wb.get() > __bz - 2) {
      __h.reset((char *)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));
      if (__h.get() == 0)
        __throw_bad_alloc();
      __nc = __h.get();
    }
    if (__neg)
      *__nc++ = '-';
    for (const char_type *__w = __wb.get(); __w < __wn; ++__w, ++__nc)
      *__nc = __src[find(__atoms, std::__1::end(__atoms), *__w) - __atoms];
    *__nc = char();
    if (sscanf(__nbuf, "%Lf", &__v) != 1)
      __throw_runtime_error("money_get error");
  }
  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

template <class _CharT, class _InputIterator>
_InputIterator money_get<_CharT, _InputIterator>::do_get(
    iter_type __b, iter_type __e, bool __intl, ios_base &__iob,
    ios_base::iostate &__err, string_type &__v) const {
  const int __bz = 100;
  char_type __wbuf[__bz];
  unique_ptr<char_type, free_t> __wb(__wbuf, __do_nothing);
  char_type *__wn;
  char_type *__we = __wbuf + __bz;
  locale __loc = __iob.getloc();
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__loc);
  bool __neg = false;
  if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct, __wb,
               __wn, __we)) {
    __v.clear();
    if (__neg)
      __v.push_back(__ct.widen('-'));
    char_type __z = __ct.widen('0');
    char_type *__w;
    for (__w = __wb.get(); __w < __wn - 1; ++__w)
      if (*__w != __z)
        break;
    __v.append(__w, __wn);
  }
  if (__b == __e)
    __err |= ios_base::eofbit;
  return __b;
}

extern template class money_get<char>;
extern template class money_get<wchar_t>;




template <class _CharT> class __money_put {
protected:
  typedef _CharT char_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__)) __money_put() {}

  static void __gather_info(bool __intl, bool __neg, const locale &__loc,
                            money_base::pattern &__pat, char_type &__dp,
                            char_type &__ts, string &__grp, string_type &__sym,
                            string_type &__sn, int &__fd);
  static void __format(char_type *__mb, char_type *&__mi, char_type *&__me,
                       ios_base::fmtflags __flags, const char_type *__db,
                       const char_type *__de, const ctype<char_type> &__ct,
                       bool __neg, const money_base::pattern &__pat,
                       char_type __dp, char_type __ts, const string &__grp,
                       const string_type &__sym, const string_type &__sn,
                       int __fd);
};

template <class _CharT>
void __money_put<_CharT>::__gather_info(bool __intl, bool __neg,
                                        const locale &__loc,
                                        money_base::pattern &__pat,
                                        char_type &__dp, char_type &__ts,
                                        string &__grp, string_type &__sym,
                                        string_type &__sn, int &__fd) {
  if (__intl) {
    const moneypunct<char_type, true> &__mp =
        use_facet<moneypunct<char_type, true>>(__loc);
    if (__neg) {
      __pat = __mp.neg_format();
      __sn = __mp.negative_sign();
    } else {
      __pat = __mp.pos_format();
      __sn = __mp.positive_sign();
    }
    __dp = __mp.decimal_point();
    __ts = __mp.thousands_sep();
    __grp = __mp.grouping();
    __sym = __mp.curr_symbol();
    __fd = __mp.frac_digits();
  } else {
    const moneypunct<char_type, false> &__mp =
        use_facet<moneypunct<char_type, false>>(__loc);
    if (__neg) {
      __pat = __mp.neg_format();
      __sn = __mp.negative_sign();
    } else {
      __pat = __mp.pos_format();
      __sn = __mp.positive_sign();
    }
    __dp = __mp.decimal_point();
    __ts = __mp.thousands_sep();
    __grp = __mp.grouping();
    __sym = __mp.curr_symbol();
    __fd = __mp.frac_digits();
  }
}

template <class _CharT>
void __money_put<_CharT>::__format(
    char_type *__mb, char_type *&__mi, char_type *&__me,
    ios_base::fmtflags __flags, const char_type *__db, const char_type *__de,
    const ctype<char_type> &__ct, bool __neg, const money_base::pattern &__pat,
    char_type __dp, char_type __ts, const string &__grp,
    const string_type &__sym, const string_type &__sn, int __fd) {
  __me = __mb;
  for (unsigned __p = 0; __p < 4; ++__p) {
    switch (__pat.field[__p]) {
    case money_base::none:
      __mi = __me;
      break;
    case money_base::space:
      __mi = __me;
      *__me++ = __ct.widen(' ');
      break;
    case money_base::sign:
      if (!__sn.empty())
        *__me++ = __sn[0];
      break;
    case money_base::symbol:
      if (!__sym.empty() && (__flags & ios_base::showbase))
        __me = std::__1::copy(__sym.begin(), __sym.end(), __me);
      break;
    case money_base::value: {

      char_type *__t = __me;

      if (__neg)
        ++__db;

      const char_type *__d;
      for (__d = __db; __d < __de; ++__d)
        if (!__ct.is(ctype_base::digit, *__d))
          break;

      if (__fd > 0) {
        int __f;
        for (__f = __fd; __d > __db && __f > 0; --__f)
          *__me++ = *--__d;
        char_type __z = __f > 0 ? __ct.widen('0') : char_type();
        for (; __f > 0; --__f)
          *__me++ = __z;
        *__me++ = __dp;
      }

      if (__d == __db) {
        *__me++ = __ct.widen('0');
      } else {
        unsigned __ng = 0;
        unsigned __ig = 0;
        unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()
                                      : static_cast<unsigned>(__grp[__ig]);
        while (__d != __db) {
          if (__ng == __gl) {
            *__me++ = __ts;
            __ng = 0;
            if (++__ig < __grp.size())
              __gl = __grp[__ig] == numeric_limits<char>::max()
                         ? numeric_limits<unsigned>::max()
                         : static_cast<unsigned>(__grp[__ig]);
          }
          *__me++ = *--__d;
          ++__ng;
        }
      }

      reverse(__t, __me);
    } break;
    }
  }

  if (__sn.size() > 1)
    __me = std::__1::copy(__sn.begin() + 1, __sn.end(), __me);

  if ((__flags & ios_base::adjustfield) == ios_base::left)
    __mi = __me;
  else if ((__flags & ios_base::adjustfield) != ios_base::internal)
    __mi = __mb;
}

extern template class __money_put<char>;

extern template class __money_put<wchar_t>;


template <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT>>
class __attribute__((__visibility__("default"))) money_put : public locale::facet,
                                        private __money_put<_CharT> {
public:
  typedef _CharT char_type;
  typedef _OutputIterator iter_type;
  typedef basic_string<char_type> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit money_put(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, bool __intl, ios_base &__iob, char_type __fl,
                long double __units) const {
    return do_put(__s, __intl, __iob, __fl, __units);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iter_type put(iter_type __s, bool __intl, ios_base &__iob, char_type __fl,
                const string_type &__digits) const {
    return do_put(__s, __intl, __iob, __fl, __digits);
  }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~money_put() {}

  virtual iter_type do_put(iter_type __s, bool __intl, ios_base &__iob,
                           char_type __fl, long double __units) const;
  virtual iter_type do_put(iter_type __s, bool __intl, ios_base &__iob,
                           char_type __fl, const string_type &__digits) const;
};

template <class _CharT, class _OutputIterator>
locale::id money_put<_CharT, _OutputIterator>::id;

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base &__iob, char_type __fl,
                                           long double __units) const {

  const size_t __bs = 100;
  char __buf[__bs];
  char *__bb = __buf;
  char_type __digits[__bs];
  char_type *__db = __digits;
  size_t __n = static_cast<size_t>(snprintf(__bb, __bs, "%.0Lf", __units));
  unique_ptr<char, free_t> __hn(0, free);
  unique_ptr<char_type, free_t> __hd(0, free);

  if (__n > __bs - 1) {
    __n = static_cast<size_t>(
        __libcpp_asprintf_l(&__bb, __cloc(), "%.0Lf", __units));
    if (__bb == 0)
      __throw_bad_alloc();
    __hn.reset(__bb);
    __hd.reset((char_type *)malloc(__n * sizeof(char_type)));
    if (__hd == nullptr)
      __throw_bad_alloc();
    __db = __hd.get();
  }

  locale __loc = __iob.getloc();
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__loc);
  __ct.widen(__bb, __bb + __n, __db);
  bool __neg = __n > 0 && __bb[0] == '-';
  money_base::pattern __pat;
  char_type __dp;
  char_type __ts;
  string __grp;
  string_type __sym;
  string_type __sn;
  int __fd;
  this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym,
                      __sn, __fd);

  char_type __mbuf[__bs];
  char_type *__mb = __mbuf;
  unique_ptr<char_type, free_t> __hw(0, free);
  size_t __exn =
      static_cast<int>(__n) > __fd
          ? (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() + __sym.size() +
                static_cast<size_t>(__fd) + 1
          : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
  if (__exn > __bs) {
    __hw.reset((char_type *)malloc(__exn * sizeof(char_type)));
    __mb = __hw.get();
    if (__mb == 0)
      __throw_bad_alloc();
  }

  char_type *__mi;
  char_type *__me;
  this->__format(__mb, __mi, __me, __iob.flags(), __db, __db + __n, __ct, __neg,
                 __pat, __dp, __ts, __grp, __sym, __sn, __fd);
  return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

template <class _CharT, class _OutputIterator>
_OutputIterator
money_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,
                                           ios_base &__iob, char_type __fl,
                                           const string_type &__digits) const {

  locale __loc = __iob.getloc();
  const ctype<char_type> &__ct = use_facet<ctype<char_type>>(__loc);
  bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');
  money_base::pattern __pat;
  char_type __dp;
  char_type __ts;
  string __grp;
  string_type __sym;
  string_type __sn;
  int __fd;
  this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym,
                      __sn, __fd);

  char_type __mbuf[100];
  char_type *__mb = __mbuf;
  unique_ptr<char_type, free_t> __h(0, free);
  size_t __exn =
      static_cast<int>(__digits.size()) > __fd
          ? (__digits.size() - static_cast<size_t>(__fd)) * 2 + __sn.size() +
                __sym.size() + static_cast<size_t>(__fd) + 1
          : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;
  if (__exn > 100) {
    __h.reset((char_type *)malloc(__exn * sizeof(char_type)));
    __mb = __h.get();
    if (__mb == 0)
      __throw_bad_alloc();
  }

  char_type *__mi;
  char_type *__me;
  this->__format(__mb, __mi, __me, __iob.flags(), __digits.data(),
                 __digits.data() + __digits.size(), __ct, __neg, __pat, __dp,
                 __ts, __grp, __sym, __sn, __fd);
  return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);
}

extern template class money_put<char>;
extern template class money_put<wchar_t>;




class __attribute__((__visibility__("default"))) messages_base {
public:
  typedef ptrdiff_t catalog;

  __attribute__((__visibility__("hidden"), __always_inline__)) messages_base() {}
};

template <class _CharT>
class __attribute__((__visibility__("default"))) messages : public locale::facet,
                                       public messages_base {
public:
  typedef _CharT char_type;
  typedef basic_string<_CharT> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit messages(size_t __refs = 0) : locale::facet(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  catalog open(const basic_string<char> &__nm, const locale &__loc) const {
    return do_open(__nm, __loc);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  string_type get(catalog __c, int __set, int __msgid,
                  const string_type &__dflt) const {
    return do_get(__c, __set, __msgid, __dflt);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void close(catalog __c) const { do_close(__c); }

  static locale::id id;

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~messages() {}

  virtual catalog do_open(const basic_string<char> &, const locale &) const;
  virtual string_type do_get(catalog, int __set, int __msgid,
                             const string_type &__dflt) const;
  virtual void do_close(catalog) const;
};

template <class _CharT> locale::id messages<_CharT>::id;

template <class _CharT>
typename messages<_CharT>::catalog
messages<_CharT>::do_open(const basic_string<char> &__nm,
                          const locale &) const {






  return -1;

}

template <class _CharT>
typename messages<_CharT>::string_type
messages<_CharT>::do_get(catalog __c, int __set, int __msgid,
                         const string_type &__dflt) const {
  return __dflt;

}

template <class _CharT> void messages<_CharT>::do_close(catalog __c) const {






}

extern template class messages<char>;
extern template class messages<wchar_t>;


template <class _CharT>
class __attribute__((__visibility__("default"))) messages_byname : public messages<_CharT> {
public:
  typedef messages_base::catalog catalog;
  typedef basic_string<_CharT> string_type;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit messages_byname(const char *, size_t __refs = 0)
      : messages<_CharT>(__refs) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit messages_byname(const string &, size_t __refs = 0)
      : messages<_CharT>(__refs) {}

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  ~messages_byname() {}
};

extern template class messages_byname<char>;

extern template class messages_byname<wchar_t>;


template <class _Codecvt, class _Elem = wchar_t,
          class _Wide_alloc = allocator<_Elem>,
          class _Byte_alloc = allocator<char>>
class __attribute__((__visibility__("default"))) wstring_convert {
public:
  typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
  typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
  typedef typename _Codecvt::state_type state_type;
  typedef typename wide_string::traits_type::int_type int_type;

private:
  byte_string __byte_err_string_;
  wide_string __wide_err_string_;
  _Codecvt *__cvtptr_;
  state_type __cvtstate_;
  size_t __cvtcount_;

  wstring_convert(const wstring_convert &__wc);
  wstring_convert &operator=(const wstring_convert &__wc);

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
                               wstring_convert(_Codecvt *__pcvt = new _Codecvt);
  __attribute__((__visibility__("hidden"), __always_inline__))
  wstring_convert(_Codecvt *__pcvt, state_type __state);

  wstring_convert(const byte_string &__byte_err,
                  const wide_string &__wide_err = wide_string());

  __attribute__((__visibility__("hidden"), __always_inline__))
  wstring_convert(wstring_convert &&__wc);

  ~wstring_convert();

  __attribute__((__visibility__("hidden"), __always_inline__))
  wide_string from_bytes(char __byte) {
    return from_bytes(&__byte, &__byte + 1);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  wide_string from_bytes(const char *__ptr) {
    return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  wide_string from_bytes(const byte_string &__str) {
    return from_bytes(__str.data(), __str.data() + __str.size());
  }
  wide_string from_bytes(const char *__first, const char *__last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  byte_string to_bytes(_Elem __wide_char) {
    return to_bytes(&__wide_char, &__wide_char + 1);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  byte_string to_bytes(const _Elem *__wptr) {
    return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  byte_string to_bytes(const wide_string &__wstr) {
    return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());
  }
  byte_string to_bytes(const _Elem *__first, const _Elem *__last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t converted() const noexcept { return __cvtcount_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  state_type state() const { return __cvtstate_; }
};

template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline wstring_convert<_Codecvt, _Elem, _Wide_alloc,
                       _Byte_alloc>::wstring_convert(_Codecvt *__pcvt)
    : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0) {}

template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline wstring_convert<_Codecvt, _Elem, _Wide_alloc,
                       _Byte_alloc>::wstring_convert(_Codecvt *__pcvt,
                                                     state_type __state)
    : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0) {}

template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wstring_convert(
    const byte_string &__byte_err, const wide_string &__wide_err)
    : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),
      __cvtstate_(), __cvtcount_(0) {
  __cvtptr_ = new _Codecvt;
}



template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
inline wstring_convert<_Codecvt, _Elem, _Wide_alloc,
                       _Byte_alloc>::wstring_convert(wstring_convert &&__wc)
    : __byte_err_string_(std::__1::move(__wc.__byte_err_string_)),
      __wide_err_string_(std::__1::move(__wc.__wide_err_string_)),
      __cvtptr_(__wc.__cvtptr_), __cvtstate_(__wc.__cvtstate_),
      __cvtcount_(__wc.__cvtcount_) {
  __wc.__cvtptr_ = nullptr;
}



template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert() {
  delete __cvtptr_;
}

template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::from_bytes(
    const char *__frm, const char *__frm_end) {
  __cvtcount_ = 0;
  if (__cvtptr_ != nullptr) {
    wide_string __ws(2 * (__frm_end - __frm), _Elem());
    if (__frm != __frm_end)
      __ws.resize(__ws.capacity());
    codecvt_base::result __r = codecvt_base::ok;
    state_type __st = __cvtstate_;
    if (__frm != __frm_end) {
      _Elem *__to = &__ws[0];
      _Elem *__to_end = __to + __ws.size();
      const char *__frm_nxt;
      do {
        _Elem *__to_nxt;
        __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end,
                            __to_nxt);
        __cvtcount_ += __frm_nxt - __frm;
        if (__frm_nxt == __frm) {
          __r = codecvt_base::error;
        } else if (__r == codecvt_base::noconv) {
          __ws.resize(__to - &__ws[0]);

          __ws.append((const _Elem *)__frm, (const _Elem *)__frm_end);
          __frm = __frm_nxt;
          __r = codecvt_base::ok;
        } else if (__r == codecvt_base::ok) {
          __ws.resize(__to_nxt - &__ws[0]);
          __frm = __frm_nxt;
        } else if (__r == codecvt_base::partial) {
          ptrdiff_t __s = __to_nxt - &__ws[0];
          __ws.resize(2 * __s);
          __to = &__ws[0] + __s;
          __to_end = &__ws[0] + __ws.size();
          __frm = __frm_nxt;
        }
      } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
    }
    if (__r == codecvt_base::ok)
      return __ws;
  }

  if (__wide_err_string_.empty())
    __throw_range_error("wstring_convert: from_bytes error");

  return __wide_err_string_;
}

template <class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>
typename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string
wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::to_bytes(
    const _Elem *__frm, const _Elem *__frm_end) {
  __cvtcount_ = 0;
  if (__cvtptr_ != nullptr) {
    byte_string __bs(2 * (__frm_end - __frm), char());
    if (__frm != __frm_end)
      __bs.resize(__bs.capacity());
    codecvt_base::result __r = codecvt_base::ok;
    state_type __st = __cvtstate_;
    if (__frm != __frm_end) {
      char *__to = &__bs[0];
      char *__to_end = __to + __bs.size();
      const _Elem *__frm_nxt;
      do {
        char *__to_nxt;
        __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end,
                             __to_nxt);
        __cvtcount_ += __frm_nxt - __frm;
        if (__frm_nxt == __frm) {
          __r = codecvt_base::error;
        } else if (__r == codecvt_base::noconv) {
          __bs.resize(__to - &__bs[0]);

          __bs.append((const char *)__frm, (const char *)__frm_end);
          __frm = __frm_nxt;
          __r = codecvt_base::ok;
        } else if (__r == codecvt_base::ok) {
          __bs.resize(__to_nxt - &__bs[0]);
          __frm = __frm_nxt;
        } else if (__r == codecvt_base::partial) {
          ptrdiff_t __s = __to_nxt - &__bs[0];
          __bs.resize(2 * __s);
          __to = &__bs[0] + __s;
          __to_end = &__bs[0] + __bs.size();
          __frm = __frm_nxt;
        }
      } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);
    }
    if (__r == codecvt_base::ok) {
      size_t __s = __bs.size();
      __bs.resize(__bs.capacity());
      char *__to = &__bs[0] + __s;
      char *__to_end = __to + __bs.size();
      do {
        char *__to_nxt;
        __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);
        if (__r == codecvt_base::noconv) {
          __bs.resize(__to - &__bs[0]);
          __r = codecvt_base::ok;
        } else if (__r == codecvt_base::ok) {
          __bs.resize(__to_nxt - &__bs[0]);
        } else if (__r == codecvt_base::partial) {
          ptrdiff_t __sp = __to_nxt - &__bs[0];
          __bs.resize(2 * __sp);
          __to = &__bs[0] + __sp;
          __to_end = &__bs[0] + __bs.size();
        }
      } while (__r == codecvt_base::partial);
      if (__r == codecvt_base::ok)
        return __bs;
    }
  }

  if (__byte_err_string_.empty())
    __throw_range_error("wstring_convert: to_bytes error");

  return __byte_err_string_;
}

template <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem>>
class __attribute__((__visibility__("default"))) wbuffer_convert
    : public basic_streambuf<_Elem, _Tr> {
public:

  typedef _Elem char_type;
  typedef _Tr traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;
  typedef typename _Codecvt::state_type state_type;

private:
  char *__extbuf_;
  const char *__extbufnext_;
  const char *__extbufend_;
  char __extbuf_min_[8];
  size_t __ebs_;
  char_type *__intbuf_;
  size_t __ibs_;
  streambuf *__bufptr_;
  _Codecvt *__cv_;
  state_type __st_;
  ios_base::openmode __cm_;
  bool __owns_eb_;
  bool __owns_ib_;
  bool __always_noconv_;

  wbuffer_convert(const wbuffer_convert &);
  wbuffer_convert &operator=(const wbuffer_convert &);

public:

  wbuffer_convert(streambuf *__bytebuf = 0, _Codecvt *__pcvt = new _Codecvt,
                  state_type __state = state_type());
  ~wbuffer_convert();

  __attribute__((__visibility__("hidden"), __always_inline__))
  streambuf *rdbuf() const { return __bufptr_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  streambuf *rdbuf(streambuf *__bytebuf) {
    streambuf *__r = __bufptr_;
    __bufptr_ = __bytebuf;
    return __r;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  state_type state() const { return __st_; }

protected:
  virtual int_type underflow();
  virtual int_type pbackfail(int_type __c = traits_type::eof());
  virtual int_type overflow(int_type __c = traits_type::eof());
  virtual basic_streambuf<char_type, traits_type> *setbuf(char_type *__s,
                                                          streamsize __n);
  virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                           ios_base::openmode __wch = ios_base::in |
                                                      ios_base::out);
  virtual pos_type seekpos(pos_type __sp,
                           ios_base::openmode __wch = ios_base::in |
                                                      ios_base::out);
  virtual int sync();

private:
  bool __read_mode();
  void __write_mode();
  wbuffer_convert *__close();
};

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::wbuffer_convert(streambuf *__bytebuf,
                                                       _Codecvt *__pcvt,
                                                       state_type __state)
    : __extbuf_(0), __extbufnext_(0), __extbufend_(0), __ebs_(0), __intbuf_(0),
      __ibs_(0), __bufptr_(__bytebuf), __cv_(__pcvt), __st_(__state), __cm_(0),
      __owns_eb_(false), __owns_ib_(false),
      __always_noconv_(__cv_ ? __cv_->always_noconv() : false) {
  setbuf(0, 4096);
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert() {
  __close();
  delete __cv_;
  if (__owns_eb_)
    delete[] __extbuf_;
  if (__owns_ib_)
    delete[] __intbuf_;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::underflow() {
  if (__cv_ == 0 || __bufptr_ == 0)
    return traits_type::eof();
  bool __initial = __read_mode();
  char_type __1buf;
  if (this->gptr() == 0)
    this->setg(&__1buf, &__1buf + 1, &__1buf + 1);
  const size_t __unget_sz =
      __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);
  int_type __c = traits_type::eof();
  if (this->gptr() == this->egptr()) {
    memmove(this->eback(), this->egptr() - __unget_sz,
            __unget_sz * sizeof(char_type));
    if (__always_noconv_) {
      streamsize __nmemb =
          static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);
      __nmemb = __bufptr_->sgetn((char *)this->eback() + __unget_sz, __nmemb);
      if (__nmemb != 0) {
        this->setg(this->eback(), this->eback() + __unget_sz,
                   this->eback() + __unget_sz + __nmemb);
        __c = *this->gptr();
      }
    } else {
      ((void)0);


      if (__extbufend_ != __extbufnext_)
        memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);
      __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);
      __extbufend_ =
          __extbuf_ +
          (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);
      streamsize __nmemb = std::__1::min(
          static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),
          static_cast<streamsize>(__extbufend_ - __extbufnext_));
      codecvt_base::result __r;
      state_type __svs = __st_;
      streamsize __nr =
          __bufptr_->sgetn(const_cast<char *>(__extbufnext_), __nmemb);
      if (__nr != 0) {
        __extbufend_ = __extbufnext_ + __nr;
        char_type *__inext;
        __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,
                        this->eback() + __unget_sz, this->egptr(), __inext);
        if (__r == codecvt_base::noconv) {
          this->setg((char_type *)__extbuf_, (char_type *)__extbuf_,
                     (char_type *)__extbufend_);
          __c = *this->gptr();
        } else if (__inext != this->eback() + __unget_sz) {
          this->setg(this->eback(), this->eback() + __unget_sz, __inext);
          __c = *this->gptr();
        }
      }
    }
  } else
    __c = *this->gptr();
  if (this->eback() == &__1buf)
    this->setg(0, 0, 0);
  return __c;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c) {
  if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr()) {
    if (traits_type::eq_int_type(__c, traits_type::eof())) {
      this->gbump(-1);
      return traits_type::not_eof(__c);
    }
    if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])) {
      this->gbump(-1);
      *this->gptr() = traits_type::to_char_type(__c);
      return __c;
    }
  }
  return traits_type::eof();
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c) {
  if (__cv_ == 0 || __bufptr_ == 0)
    return traits_type::eof();
  __write_mode();
  char_type __1buf;
  char_type *__pb_save = this->pbase();
  char_type *__epb_save = this->epptr();
  if (!traits_type::eq_int_type(__c, traits_type::eof())) {
    if (this->pptr() == 0)
      this->setp(&__1buf, &__1buf + 1);
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
  if (this->pptr() != this->pbase()) {
    if (__always_noconv_) {
      streamsize __nmemb =
          static_cast<streamsize>(this->pptr() - this->pbase());
      if (__bufptr_->sputn((const char *)this->pbase(), __nmemb) != __nmemb)
        return traits_type::eof();
    } else {
      char *__extbe = __extbuf_;
      codecvt_base::result __r;
      do {
        const char_type *__e;
        __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e, __extbuf_,
                         __extbuf_ + __ebs_, __extbe);
        if (__e == this->pbase())
          return traits_type::eof();
        if (__r == codecvt_base::noconv) {
          streamsize __nmemb =
              static_cast<size_t>(this->pptr() - this->pbase());
          if (__bufptr_->sputn((const char *)this->pbase(), __nmemb) != __nmemb)
            return traits_type::eof();
        } else if (__r == codecvt_base::ok || __r == codecvt_base::partial) {
          streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);
          if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
            return traits_type::eof();
          if (__r == codecvt_base::partial) {
            this->setp((char_type *)__e, this->pptr());
            this->pbump(this->epptr() - this->pbase());
          }
        } else
          return traits_type::eof();
      } while (__r == codecvt_base::partial);
    }
    this->setp(__pb_save, __epb_save);
  }
  return traits_type::not_eof(__c);
}

template <class _Codecvt, class _Elem, class _Tr>
basic_streambuf<_Elem, _Tr> *
wbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type *__s, streamsize __n) {
  this->setg(0, 0, 0);
  this->setp(0, 0);
  if (__owns_eb_)
    delete[] __extbuf_;
  if (__owns_ib_)
    delete[] __intbuf_;
  __ebs_ = __n;
  if (__ebs_ > sizeof(__extbuf_min_)) {
    if (__always_noconv_ && __s) {
      __extbuf_ = (char *)__s;
      __owns_eb_ = false;
    } else {
      __extbuf_ = new char[__ebs_];
      __owns_eb_ = true;
    }
  } else {
    __extbuf_ = __extbuf_min_;
    __ebs_ = sizeof(__extbuf_min_);
    __owns_eb_ = false;
  }
  if (!__always_noconv_) {
    __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));
    if (__s && __ibs_ >= sizeof(__extbuf_min_)) {
      __intbuf_ = __s;
      __owns_ib_ = false;
    } else {
      __intbuf_ = new char_type[__ibs_];
      __owns_ib_ = true;
    }
  } else {
    __ibs_ = 0;
    __intbuf_ = 0;
    __owns_ib_ = false;
  }
  return this;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off,
                                               ios_base::seekdir __way,
                                               ios_base::openmode __om) {
  int __width = __cv_->encoding();
  if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())
    return pos_type(off_type(-1));

  if (__way != ios_base::beg && __way != ios_base::cur &&
      __way != ios_base::end)
    return pos_type(off_type(-1));
  pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);
  __r.state(__st_);
  return __r;
}

template <class _Codecvt, class _Elem, class _Tr>
typename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type
wbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp,
                                               ios_base::openmode __wch) {
  if (__cv_ == 0 || __bufptr_ == 0 || sync())
    return pos_type(off_type(-1));
  if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))
    return pos_type(off_type(-1));
  return __sp;
}

template <class _Codecvt, class _Elem, class _Tr>
int wbuffer_convert<_Codecvt, _Elem, _Tr>::sync() {
  if (__cv_ == 0 || __bufptr_ == 0)
    return 0;
  if (__cm_ & ios_base::out) {
    if (this->pptr() != this->pbase())
      if (overflow() == traits_type::eof())
        return -1;
    codecvt_base::result __r;
    do {
      char *__extbe;
      __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);
      streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);
      if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)
        return -1;
    } while (__r == codecvt_base::partial);
    if (__r == codecvt_base::error)
      return -1;
    if (__bufptr_->pubsync())
      return -1;
  } else if (__cm_ & ios_base::in) {
    off_type __c;
    if (__always_noconv_)
      __c = this->egptr() - this->gptr();
    else {
      int __width = __cv_->encoding();
      __c = __extbufend_ - __extbufnext_;
      if (__width > 0)
        __c += __width * (this->egptr() - this->gptr());
      else {
        if (this->gptr() != this->egptr()) {
          reverse(this->gptr(), this->egptr());
          codecvt_base::result __r;
          const char_type *__e = this->gptr();
          char *__extbe;
          do {
            __r = __cv_->out(__st_, __e, this->egptr(), __e, __extbuf_,
                             __extbuf_ + __ebs_, __extbe);
            switch (__r) {
            case codecvt_base::noconv:
              __c += this->egptr() - this->gptr();
              break;
            case codecvt_base::ok:
            case codecvt_base::partial:
              __c += __extbe - __extbuf_;
              break;
            default:
              return -1;
            }
          } while (__r == codecvt_base::partial);
        }
      }
    }
    if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) ==
        pos_type(off_type(-1)))
      return -1;
    this->setg(0, 0, 0);
    __cm_ = 0;
  }
  return 0;
}

template <class _Codecvt, class _Elem, class _Tr>
bool wbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode() {
  if (!(__cm_ & ios_base::in)) {
    this->setp(0, 0);
    if (__always_noconv_)
      this->setg((char_type *)__extbuf_, (char_type *)__extbuf_ + __ebs_,
                 (char_type *)__extbuf_ + __ebs_);
    else
      this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);
    __cm_ = ios_base::in;
    return true;
  }
  return false;
}

template <class _Codecvt, class _Elem, class _Tr>
void wbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode() {
  if (!(__cm_ & ios_base::out)) {
    this->setg(0, 0, 0);
    if (__ebs_ > sizeof(__extbuf_min_)) {
      if (__always_noconv_)
        this->setp((char_type *)__extbuf_,
                   (char_type *)__extbuf_ + (__ebs_ - 1));
      else
        this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));
    } else
      this->setp(0, 0);
    __cm_ = ios_base::out;
  }
}

template <class _Codecvt, class _Elem, class _Tr>
wbuffer_convert<_Codecvt, _Elem, _Tr> *
wbuffer_convert<_Codecvt, _Elem, _Tr>::__close() {
  wbuffer_convert *__rt = 0;
  if (__cv_ != 0 && __bufptr_ != 0) {
    __rt = this;
    if ((__cm_ & ios_base::out) && sync())
      __rt = 0;
  }
  return __rt;
}

} }


namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__((__visibility__("default"))) basic_ostream
    : virtual public basic_ios<_CharT, _Traits> {
public:

  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;


  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_ostream(
      basic_streambuf<char_type, traits_type> *__sb) {
    this->init(__sb);
  }
  virtual ~basic_ostream();

protected:

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream(basic_ostream &&__rhs);




  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream &
  operator=(basic_ostream &&__rhs);

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void
  swap(basic_ostream &__rhs) {
    basic_ios<char_type, traits_type>::swap(__rhs);
  }


  basic_ostream(const basic_ostream &__rhs) = delete;
  basic_ostream &operator=(const basic_ostream &__rhs) = delete;




public:

  class __attribute__((__visibility__("default"))) sentry;


  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream &
  operator<<(basic_ostream &(*__pf)(basic_ostream &)) {
    return __pf(*this);
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream &
  operator<<(basic_ios<char_type, traits_type> &(*__pf)(
      basic_ios<char_type, traits_type> &)) {
    __pf(*this);
    return *this;
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream &
  operator<<(ios_base &(*__pf)(ios_base &)) {
    __pf(*this);
    return *this;
  }

  basic_ostream &operator<<(bool __n);
  basic_ostream &operator<<(short __n);
  basic_ostream &operator<<(unsigned short __n);
  basic_ostream &operator<<(int __n);
  basic_ostream &operator<<(unsigned int __n);
  basic_ostream &operator<<(long __n);
  basic_ostream &operator<<(unsigned long __n);
  basic_ostream &operator<<(long long __n);
  basic_ostream &operator<<(unsigned long long __n);
  basic_ostream &operator<<(float __f);
  basic_ostream &operator<<(double __f);
  basic_ostream &operator<<(long double __f);
  basic_ostream &operator<<(const void *__p);
  basic_ostream &operator<<(basic_streambuf<char_type, traits_type> *__sb);


  basic_ostream &put(char_type __c);
  basic_ostream &write(const char_type *__s, streamsize __n);
  basic_ostream &flush();


  inline __attribute__((__visibility__("hidden"), __always_inline__)) pos_type tellp();
  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream &
  seekp(pos_type __pos);
  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream &
  seekp(off_type __off, ios_base::seekdir __dir);

protected:
  __attribute__((__visibility__("hidden"), __always_inline__))
  basic_ostream() {}
};

template <class _CharT, class _Traits>
class __attribute__((__visibility__("default"))) basic_ostream<_CharT, _Traits>::sentry {
  bool __ok_;
  basic_ostream<_CharT, _Traits> &__os_;

  sentry(const sentry &);
  sentry &operator=(const sentry &);

public:
  explicit sentry(basic_ostream<_CharT, _Traits> &__os);
  ~sentry();

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit
  operator bool() const { return __ok_; }
};

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::sentry(
    basic_ostream<_CharT, _Traits> &__os)
    : __ok_(false), __os_(__os) {
  if (__os.good()) {
    if (__os.tie())
      __os.tie()->flush();
    __ok_ = true;
  }
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::sentry::~sentry() {
  if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf) &&
      !uncaught_exception()) {

    try {

      if (__os_.rdbuf()->pubsync() == -1)
        __os_.setstate(ios_base::badbit);

    } catch (...) {
    }

  }
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream &&__rhs) {
  this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator=(basic_ostream &&__rhs) {
  swap(__rhs);
  return *this;
}



template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>::~basic_ostream() {}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(basic_streambuf<char_type, traits_type> *__sb) {

  try {

    sentry __s(*this);
    if (__s) {
      if (__sb) {

        try {

          typedef istreambuf_iterator<_CharT, _Traits> _Ip;
          typedef ostreambuf_iterator<_CharT, _Traits> _Op;
          _Ip __i(__sb);
          _Ip __eof;
          _Op __o(*this);
          size_t __c = 0;
          for (; __i != __eof; ++__i, ++__o, ++__c) {
            *__o = *__i;
            if (__o.failed())
              break;
          }
          if (__c == 0)
            this->setstate(ios_base::failbit);

        } catch (...) {
          this->__set_failbit_and_consider_rethrow();
        }

      } else
        this->setstate(ios_base::badbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(bool __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(short __n) {

  try {

    sentry __s(*this);
    if (__s) {
      ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(),
                  __flags == ios_base::oct || __flags == ios_base::hex
                      ? static_cast<long>(static_cast<unsigned short>(__n))
                      : static_cast<long>(__n))
              .failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(unsigned short __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n))
              .failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(int __n) {

  try {

    sentry __s(*this);
    if (__s) {
      ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(),
                  __flags == ios_base::oct || __flags == ios_base::hex
                      ? static_cast<long>(static_cast<unsigned int>(__n))
                      : static_cast<long>(__n))
              .failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(unsigned int __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n))
              .failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(long __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(unsigned long __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(long long __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(unsigned long long __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(float __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), static_cast<double>(__n))
              .failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(double __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(long double __n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::
operator<<(const void *__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type>>
          _Fp;
      const _Fp &__f = use_facet<_Fp>(this->getloc());
      if (__f.put(*this, *this, this->fill(), __n).failed())
        this->setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
__put_character_sequence(basic_ostream<_CharT, _Traits> &__os,
                         const _CharT *__str, size_t __len) {

  try {

    typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
    if (__s) {
      typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
      if (__pad_and_output(_Ip(__os), __str,
                           (__os.flags() & ios_base::adjustfield) ==
                                   ios_base::left
                               ? __str + __len
                               : __str,
                           __str + __len, __os, __os.fill())
              .failed())
        __os.setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    __os.__set_badbit_and_consider_rethrow();
  }

  return __os;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os,
                                           _CharT __c) {
  return std::__1::__put_character_sequence(__os, &__c, 1);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os,
                                           char __cn) {

  try {

    typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
    if (__s) {
      _CharT __c = __os.widen(__cn);
      typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
      if (__pad_and_output(_Ip(__os), &__c,
                           (__os.flags() & ios_base::adjustfield) ==
                                   ios_base::left
                               ? &__c + 1
                               : &__c,
                           &__c + 1, __os, __os.fill())
              .failed())
        __os.setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    __os.__set_badbit_and_consider_rethrow();
  }

  return __os;
}

template <class _Traits>
basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os,
                                         char __c) {
  return std::__1::__put_character_sequence(__os, &__c, 1);
}

template <class _Traits>
basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os,
                                         signed char __c) {
  return std::__1::__put_character_sequence(__os, (char *)&__c, 1);
}

template <class _Traits>
basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os,
                                         unsigned char __c) {
  return std::__1::__put_character_sequence(__os, (char *)&__c, 1);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os,
                                           const _CharT *__str) {
  return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os,
                                           const char *__strn) {

  try {

    typename basic_ostream<_CharT, _Traits>::sentry __s(__os);
    if (__s) {
      typedef ostreambuf_iterator<_CharT, _Traits> _Ip;
      size_t __len = char_traits<char>::length(__strn);
      const int __bs = 100;
      _CharT __wbb[__bs];
      _CharT *__wb = __wbb;
      unique_ptr<_CharT, void (*)(void *)> __h(0, free);
      if (__len > __bs) {
        __wb = (_CharT *)malloc(__len * sizeof(_CharT));
        if (__wb == 0)
          __throw_bad_alloc();
        __h.reset(__wb);
      }
      for (_CharT *__p = __wb; *__strn != '\0'; ++__strn, ++__p)
        *__p = __os.widen(*__strn);
      if (__pad_and_output(_Ip(__os), __wb,
                           (__os.flags() & ios_base::adjustfield) ==
                                   ios_base::left
                               ? __wb + __len
                               : __wb,
                           __wb + __len, __os, __os.fill())
              .failed())
        __os.setstate(ios_base::badbit | ios_base::failbit);
    }

  } catch (...) {
    __os.__set_badbit_and_consider_rethrow();
  }

  return __os;
}

template <class _Traits>
basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os,
                                         const char *__str) {
  return std::__1::__put_character_sequence(__os, __str, _Traits::length(__str));
}

template <class _Traits>
basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os,
                                         const signed char *__str) {
  const char *__s = (const char *)__str;
  return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _Traits>
basic_ostream<char, _Traits> &operator<<(basic_ostream<char, _Traits> &__os,
                                         const unsigned char *__str) {
  const char *__s = (const char *)__str;
  return std::__1::__put_character_sequence(__os, __s, _Traits::length(__s));
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::put(char_type __c) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef ostreambuf_iterator<_CharT, _Traits> _Op;
      _Op __o(*this);
      *__o = __c;
      if (__o.failed())
        this->setstate(ios_base::badbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::write(const char_type *__s, streamsize __n) {

  try {

    sentry __sen(*this);
    if (__sen && __n) {
      if (this->rdbuf()->sputn(__s, __n) != __n)
        this->setstate(ios_base::badbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &basic_ostream<_CharT, _Traits>::flush() {

  try {

    if (this->rdbuf()) {
      sentry __s(*this);
      if (__s) {
        if (this->rdbuf()->pubsync() == -1)
          this->setstate(ios_base::badbit);
      }
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp() {
  if (this->fail())
    return pos_type(-1);
  return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::seekp(pos_type __pos) {
  sentry __s(*this);
  if (!this->fail()) {
    if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))
      this->setstate(ios_base::failbit);
  }
  return *this;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
basic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir) {
  sentry __s(*this);
  if (!this->fail()) {
    if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))
      this->setstate(ios_base::failbit);
  }
  return *this;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream<_CharT, _Traits> &
endl(basic_ostream<_CharT, _Traits> &__os) {
  __os.put(__os.widen('\n'));
  __os.flush();
  return __os;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream<_CharT, _Traits> &
ends(basic_ostream<_CharT, _Traits> &__os) {
  __os.put(_CharT());
  return __os;
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream<_CharT, _Traits> &
flush(basic_ostream<_CharT, _Traits> &__os) {
  __os.flush();
  return __os;
}



template <class _Stream, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<!is_lvalue_reference<_Stream>::value &&
                           is_base_of<ios_base, _Stream>::value,
                       _Stream &&>::type
    operator<<(_Stream &&__os, const _Tp &__x) {
  __os << __x;
  return std::__1::move(__os);
}



template <class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           const basic_string<_CharT, _Traits, _Allocator> &__str) {
  return std::__1::__put_character_sequence(__os, __str.data(), __str.size());
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           const basic_string_view<_CharT, _Traits> __sv) {
  return std::__1::__put_character_sequence(__os, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, const error_code &__ec) {
  return __os << __ec.category().name() << ':' << __ec.value();
}

template <class _CharT, class _Traits, class _Yp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, shared_ptr<_Yp> const &__p) {
  return __os << __p.get();
}

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits> &operator<<(basic_ostream<_CharT, _Traits> &__os,
                                           const bitset<_Size> &__x) {
  return __os << __x.template to_string<_CharT, _Traits>(
             use_facet<ctype<_CharT>>(__os.getloc()).widen('0'),
             use_facet<ctype<_CharT>>(__os.getloc()).widen('1'));
}

extern template class basic_ostream<char>;

extern template class basic_ostream<wchar_t>;


} }








const int kPageSizeBits = 20;










namespace std { inline namespace __1 {

template <class _CharT, class _Traits>
class __attribute__((__visibility__("default"))) basic_istream
    : virtual public basic_ios<_CharT, _Traits> {
  streamsize __gc_;

public:

  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;


  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_istream(
      basic_streambuf<char_type, traits_type> *__sb)
      : __gc_(0) {
    this->init(__sb);
  }
  virtual ~basic_istream();

protected:

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream(basic_istream &&__rhs);



  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream &
  operator=(basic_istream &&__rhs);


  inline __attribute__((__visibility__("hidden"), __always_inline__)) void
  swap(basic_istream &__rhs) {
    std::__1::swap(__gc_, __rhs.__gc_);
    basic_ios<char_type, traits_type>::swap(__rhs);
  }
public:

  class __attribute__((__visibility__("default"))) sentry;


  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream &
  operator>>(basic_istream &(*__pf)(basic_istream &)) {
    return __pf(*this);
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream &
  operator>>(basic_ios<char_type, traits_type> &(*__pf)(
      basic_ios<char_type, traits_type> &)) {
    __pf(*this);
    return *this;
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream &
  operator>>(ios_base &(*__pf)(ios_base &)) {
    __pf(*this);
    return *this;
  }

  basic_istream &operator>>(basic_streambuf<char_type, traits_type> *__sb);
  basic_istream &operator>>(bool &__n);
  basic_istream &operator>>(short &__n);
  basic_istream &operator>>(unsigned short &__n);
  basic_istream &operator>>(int &__n);
  basic_istream &operator>>(unsigned int &__n);
  basic_istream &operator>>(long &__n);
  basic_istream &operator>>(unsigned long &__n);
  basic_istream &operator>>(long long &__n);
  basic_istream &operator>>(unsigned long long &__n);
  basic_istream &operator>>(float &__f);
  basic_istream &operator>>(double &__f);
  basic_istream &operator>>(long double &__f);
  basic_istream &operator>>(void *&__p);


  __attribute__((__visibility__("hidden"), __always_inline__))
  streamsize gcount() const { return __gc_; }
  int_type get();

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream &
  get(char_type &__c) {
    int_type __ch = get();
    if (__ch != traits_type::eof())
      __c = traits_type::to_char_type(__ch);
    return *this;
  }

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream &
  get(char_type *__s, streamsize __n) {
    return get(__s, __n, this->widen('\n'));
  }

  basic_istream &get(char_type *__s, streamsize __n, char_type __dlm);

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream &
  get(basic_streambuf<char_type, traits_type> &__sb) {
    return get(__sb, this->widen('\n'));
  }

  basic_istream &get(basic_streambuf<char_type, traits_type> &__sb,
                     char_type __dlm);

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream &
  getline(char_type *__s, streamsize __n) {
    return getline(__s, __n, this->widen('\n'));
  }

  basic_istream &getline(char_type *__s, streamsize __n, char_type __dlm);

  basic_istream &ignore(streamsize __n = 1,
                        int_type __dlm = traits_type::eof());
  int_type peek();
  basic_istream &read(char_type *__s, streamsize __n);
  streamsize readsome(char_type *__s, streamsize __n);

  basic_istream &putback(char_type __c);
  basic_istream &unget();
  int sync();

  pos_type tellg();
  basic_istream &seekg(pos_type __pos);
  basic_istream &seekg(off_type __off, ios_base::seekdir __dir);
};

template <class _CharT, class _Traits>
class __attribute__((__visibility__("default"))) basic_istream<_CharT, _Traits>::sentry {
  bool __ok_;

  sentry(const sentry &);
  sentry &operator=(const sentry &);

public:
  explicit sentry(basic_istream<_CharT, _Traits> &__is,
                  bool __noskipws = false);


  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit
  operator bool() const { return __ok_; }
};

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::sentry::sentry(
    basic_istream<_CharT, _Traits> &__is, bool __noskipws)
    : __ok_(false) {
  if (__is.good()) {
    if (__is.tie())
      __is.tie()->flush();
    if (!__noskipws && (__is.flags() & ios_base::skipws)) {
      typedef istreambuf_iterator<_CharT, _Traits> _Ip;
      const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
      _Ip __i(__is);
      _Ip __eof;
      for (; __i != __eof; ++__i)
        if (!__ct.is(__ct.space, *__i))
          break;
      if (__i == __eof)
        __is.setstate(ios_base::failbit | ios_base::eofbit);
    }
    __ok_ = __is.good();
  } else
    __is.setstate(ios_base::failbit);
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::basic_istream(basic_istream &&__rhs)
    : __gc_(__rhs.__gc_) {
  __rhs.__gc_ = 0;
  this->move(__rhs);
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator=(basic_istream &&__rhs) {
  swap(__rhs);
  return *this;
}



template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits>::~basic_istream() {}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(unsigned short &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(unsigned int &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(long &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(unsigned long &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(long long &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(unsigned long long &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(float &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(double &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(long double &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(bool &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(void *&__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      use_facet<_Fp>(this->getloc()).get(_Ip(*this), _Ip(), *this, __err, __n);
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(short &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      long ( *((long *)(_Gtab(1))) );
      use_facet<_Fp>(this->getloc())
          .get(_Ip(*this), _Ip(), *this, __err, ( *((long *)(_Gtab(1))) ));
      if (( *((long *)(_Gtab(1))) ) < numeric_limits<short>::min()) {
        __err |= ios_base::failbit;
        __n = numeric_limits<short>::min();
      } else if (( *((long *)(_Gtab(1))) ) > numeric_limits<short>::max()) {
        __err |= ios_base::failbit;
        __n = numeric_limits<short>::max();
      } else
        __n = static_cast<short>(( *((long *)(_Gtab(1))) ));
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(int &__n) {

  try {

    sentry __s(*this);
    if (__s) {
      typedef istreambuf_iterator<char_type, traits_type> _Ip;
      typedef num_get<char_type, _Ip> _Fp;
      ios_base::iostate __err = ios_base::goodbit;
      long ( *((long *)(_Gtab(1))) );
      use_facet<_Fp>(this->getloc())
          .get(_Ip(*this), _Ip(), *this, __err, ( *((long *)(_Gtab(1))) ));
      if (( *((long *)(_Gtab(1))) ) < numeric_limits<int>::min()) {
        __err |= ios_base::failbit;
        __n = numeric_limits<int>::min();
      } else if (( *((long *)(_Gtab(1))) ) > numeric_limits<int>::max()) {
        __err |= ios_base::failbit;
        __n = numeric_limits<int>::max();
      } else
        __n = static_cast<int>(( *((long *)(_Gtab(1))) ));
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is,
                                           _CharT *__s) {

  try {

    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen) {
      streamsize __n = __is.width();
      if (__n <= 0)
        __n = numeric_limits<streamsize>::max() / sizeof(_CharT) - 1;
      streamsize __c = 0;
      const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
      ios_base::iostate __err = ios_base::goodbit;
      while (__c < __n - 1) {
        typename _Traits::int_type __i = __is.rdbuf()->sgetc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __err |= ios_base::eofbit;
          break;
        }
        _CharT __ch = _Traits::to_char_type(__i);
        if (__ct.is(__ct.space, __ch))
          break;
        *__s++ = __ch;
        ++__c;
        __is.rdbuf()->sbumpc();
      }
      *__s = _CharT();
      __is.width(0);
      if (__c == 0)
        __err |= ios_base::failbit;
      __is.setstate(__err);
    }

  } catch (...) {
    __is.__set_badbit_and_consider_rethrow();
  }

  return __is;
}

template <class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<char, _Traits> &
operator>>(basic_istream<char, _Traits> &__is, unsigned char *__s) {
  return __is >> (char *)__s;
}

template <class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<char, _Traits> &
operator>>(basic_istream<char, _Traits> &__is, signed char *__s) {
  return __is >> (char *)__s;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is,
                                           _CharT &__c) {

  try {

    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen) {
      typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
      if (_Traits::eq_int_type(__i, _Traits::eof()))
        __is.setstate(ios_base::eofbit | ios_base::failbit);
      else
        __c = _Traits::to_char_type(__i);
    }

  } catch (...) {
    __is.__set_badbit_and_consider_rethrow();
  }

  return __is;
}

template <class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<char, _Traits> &
operator>>(basic_istream<char, _Traits> &__is, unsigned char &__c) {
  return __is >> (char &)__c;
}

template <class _Traits>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<char, _Traits> &
operator>>(basic_istream<char, _Traits> &__is, signed char &__c) {
  return __is >> (char &)__c;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::
operator>>(basic_streambuf<char_type, traits_type> *__sb) {
  __gc_ = 0;

  try {

    sentry __s(*this, true);
    if (__s) {
      if (__sb) {

        try {

          ios_base::iostate __err = ios_base::goodbit;
          while (true) {
            typename traits_type::int_type __i = this->rdbuf()->sgetc();
            if (traits_type::eq_int_type(__i, _Traits::eof())) {
              __err |= ios_base::eofbit;
              break;
            }
            if (traits_type::eq_int_type(
                    __sb->sputc(traits_type::to_char_type(__i)),
                    traits_type::eof()))
              break;
            ++__gc_;
            this->rdbuf()->sbumpc();
          }
          if (__gc_ == 0)
            __err |= ios_base::failbit;
          this->setstate(__err);

        } catch (...) {
          if (__gc_ == 0)
            this->__set_failbit_and_consider_rethrow();
        }

      } else
        this->setstate(ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::get() {
  __gc_ = 0;
  int_type __r = traits_type::eof();

  try {

    sentry __s(*this, true);
    if (__s) {
      __r = this->rdbuf()->sbumpc();
      if (traits_type::eq_int_type(__r, traits_type::eof()))
        this->setstate(ios_base::failbit | ios_base::eofbit);
      else
        __gc_ = 1;
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return __r;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::get(char_type *__s, streamsize __n,
                                    char_type __dlm) {
  __gc_ = 0;

  try {

    sentry __sen(*this, true);
    if (__sen) {
      if (__n > 0) {
        ios_base::iostate __err = ios_base::goodbit;
        while (__gc_ < __n - 1) {
          int_type __i = this->rdbuf()->sgetc();
          if (traits_type::eq_int_type(__i, traits_type::eof())) {
            __err |= ios_base::eofbit;
            break;
          }
          char_type __ch = traits_type::to_char_type(__i);
          if (traits_type::eq(__ch, __dlm))
            break;
          *__s++ = __ch;
          ++__gc_;
          this->rdbuf()->sbumpc();
        }
        *__s = char_type();
        if (__gc_ == 0)
          __err |= ios_base::failbit;
        this->setstate(__err);
      } else
        this->setstate(ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::get(
    basic_streambuf<char_type, traits_type> &__sb, char_type __dlm) {
  __gc_ = 0;

  try {

    sentry __sen(*this, true);
    if (__sen) {
      ios_base::iostate __err = ios_base::goodbit;

      try {

        while (true) {
          typename traits_type::int_type __i = this->rdbuf()->sgetc();
          if (traits_type::eq_int_type(__i, traits_type::eof())) {
            __err |= ios_base::eofbit;
            break;
          }
          char_type __ch = traits_type::to_char_type(__i);
          if (traits_type::eq(__ch, __dlm))
            break;
          if (traits_type::eq_int_type(__sb.sputc(__ch), traits_type::eof()))
            break;
          ++__gc_;
          this->rdbuf()->sbumpc();
        }

      } catch (...) {
      }

      if (__gc_ == 0)
        __err |= ios_base::failbit;
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::getline(char_type *__s, streamsize __n,
                                        char_type __dlm) {
  __gc_ = 0;

  try {

    sentry __sen(*this, true);
    if (__sen) {
      ios_base::iostate __err = ios_base::goodbit;
      while (true) {
        typename traits_type::int_type __i = this->rdbuf()->sgetc();
        if (traits_type::eq_int_type(__i, traits_type::eof())) {
          __err |= ios_base::eofbit;
          break;
        }
        char_type __ch = traits_type::to_char_type(__i);
        if (traits_type::eq(__ch, __dlm)) {
          this->rdbuf()->sbumpc();
          ++__gc_;
          break;
        }
        if (__gc_ >= __n - 1) {
          __err |= ios_base::failbit;
          break;
        }
        *__s++ = __ch;
        this->rdbuf()->sbumpc();
        ++__gc_;
      }
      if (__n > 0)
        *__s = char_type();
      if (__gc_ == 0)
        __err |= ios_base::failbit;
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::ignore(streamsize __n, int_type __dlm) {
  __gc_ = 0;

  try {

    sentry __sen(*this, true);
    if (__sen) {
      ios_base::iostate __err = ios_base::goodbit;
      if (__n == numeric_limits<streamsize>::max()) {
        while (true) {
          typename traits_type::int_type __i = this->rdbuf()->sbumpc();
          if (traits_type::eq_int_type(__i, traits_type::eof())) {
            __err |= ios_base::eofbit;
            break;
          }
          ++__gc_;
          if (traits_type::eq_int_type(__i, __dlm))
            break;
        }
      } else {
        while (__gc_ < __n) {
          typename traits_type::int_type __i = this->rdbuf()->sbumpc();
          if (traits_type::eq_int_type(__i, traits_type::eof())) {
            __err |= ios_base::eofbit;
            break;
          }
          ++__gc_;
          if (traits_type::eq_int_type(__i, __dlm))
            break;
        }
      }
      this->setstate(__err);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek() {
  __gc_ = 0;
  int_type __r = traits_type::eof();

  try {

    sentry __sen(*this, true);
    if (__sen) {
      __r = this->rdbuf()->sgetc();
      if (traits_type::eq_int_type(__r, traits_type::eof()))
        this->setstate(ios_base::eofbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return __r;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::read(char_type *__s, streamsize __n) {
  __gc_ = 0;

  try {

    sentry __sen(*this, true);
    if (__sen) {
      __gc_ = this->rdbuf()->sgetn(__s, __n);
      if (__gc_ != __n)
        this->setstate(ios_base::failbit | ios_base::eofbit);
    } else
      this->setstate(ios_base::failbit);

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
streamsize basic_istream<_CharT, _Traits>::readsome(char_type *__s,
                                                    streamsize __n) {
  __gc_ = 0;

  try {

    sentry __sen(*this, true);
    if (__sen) {
      streamsize __c = this->rdbuf()->in_avail();
      switch (__c) {
      case -1:
        this->setstate(ios_base::eofbit);
        break;
      case 0:
        break;
      default:
        read(__s, std::__1::min(__c, __n));
        break;
      }
    } else
      this->setstate(ios_base::failbit);

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return __gc_;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::putback(char_type __c) {
  __gc_ = 0;

  try {

    this->clear(this->rdstate() & ~ios_base::eofbit);
    sentry __sen(*this, true);
    if (__sen) {
      if (this->rdbuf() == 0 ||
          this->rdbuf()->sputbackc(__c) == traits_type::eof())
        this->setstate(ios_base::badbit);
    } else
      this->setstate(ios_base::failbit);

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &basic_istream<_CharT, _Traits>::unget() {
  __gc_ = 0;

  try {

    this->clear(this->rdstate() & ~ios_base::eofbit);
    sentry __sen(*this, true);
    if (__sen) {
      if (this->rdbuf() == 0 || this->rdbuf()->sungetc() == traits_type::eof())
        this->setstate(ios_base::badbit);
    } else
      this->setstate(ios_base::failbit);

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync() {
  int __r = 0;

  try {

    sentry __sen(*this, true);
    if (__sen) {
      if (this->rdbuf() == 0)
        return -1;
      if (this->rdbuf()->pubsync() == -1) {
        this->setstate(ios_base::badbit);
        return -1;
      }
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return __r;
}

template <class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg() {
  pos_type __r(-1);

  try {

    sentry __sen(*this, true);
    if (__sen)
      __r = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return __r;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::seekg(pos_type __pos) {

  try {

    this->clear(this->rdstate() & ~ios_base::eofbit);
    sentry __sen(*this, true);
    if (__sen) {
      if (this->rdbuf()->pubseekpos(__pos, ios_base::in) == pos_type(-1))
        this->setstate(ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &
basic_istream<_CharT, _Traits>::seekg(off_type __off, ios_base::seekdir __dir) {

  try {

    this->clear(this->rdstate() & ~ios_base::eofbit);
    sentry __sen(*this, true);
    if (__sen) {
      if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::in) == pos_type(-1))
        this->setstate(ios_base::failbit);
    }

  } catch (...) {
    this->__set_badbit_and_consider_rethrow();
  }

  return *this;
}

template <class _CharT, class _Traits>
basic_istream<_CharT, _Traits> &ws(basic_istream<_CharT, _Traits> &__is) {

  try {

    typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
    if (__sen) {
      const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
      while (true) {
        typename _Traits::int_type __i = __is.rdbuf()->sgetc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __is.setstate(ios_base::eofbit);
          break;
        }
        if (!__ct.is(__ct.space, _Traits::to_char_type(__i)))
          break;
        __is.rdbuf()->sbumpc();
      }
    }

  } catch (...) {
    __is.__set_badbit_and_consider_rethrow();
  }

  return __is;
}



template <class _CharT, class _Traits, class _Tp>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &&__is, _Tp &&__x) {
  __is >> std::__1::forward<_Tp>(__x);
  return __is;
}



template <class _CharT, class _Traits>
class __attribute__((__visibility__("default"))) basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits> {
public:

  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;


  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_iostream(
      basic_streambuf<char_type, traits_type> *__sb)
      : basic_istream<_CharT, _Traits>(__sb) {}

  virtual ~basic_iostream();

protected:

  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_iostream(basic_iostream &&__rhs);




  inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_iostream &
  operator=(basic_iostream &&__rhs);

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void
  swap(basic_iostream &__rhs) {
    basic_istream<char_type, traits_type>::swap(__rhs);
  }

public:
};



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::basic_iostream(basic_iostream &&__rhs)
    : basic_istream<_CharT, _Traits>(std::__1::move(__rhs)) {}

template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits> &basic_iostream<_CharT, _Traits>::
operator=(basic_iostream &&__rhs) {
  swap(__rhs);
  return *this;
}



template <class _CharT, class _Traits>
basic_iostream<_CharT, _Traits>::~basic_iostream() {}

template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is,
           basic_string<_CharT, _Traits, _Allocator> &__str) {

  try {

    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen) {
      __str.clear();
      streamsize __n = __is.width();
      if (__n <= 0)
        __n = __str.max_size();
      if (__n <= 0)
        __n = numeric_limits<streamsize>::max();
      streamsize __c = 0;
      const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
      ios_base::iostate __err = ios_base::goodbit;
      while (__c < __n) {
        typename _Traits::int_type __i = __is.rdbuf()->sgetc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __err |= ios_base::eofbit;
          break;
        }
        _CharT __ch = _Traits::to_char_type(__i);
        if (__ct.is(__ct.space, __ch))
          break;
        __str.push_back(__ch);
        ++__c;
        __is.rdbuf()->sbumpc();
      }
      __is.width(0);
      if (__c == 0)
        __err |= ios_base::failbit;
      __is.setstate(__err);
    } else
      __is.setstate(ios_base::failbit);

  } catch (...) {
    __is.__set_badbit_and_consider_rethrow();
  }

  return __is;
}

template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm) {

  try {

    typename basic_istream<_CharT, _Traits>::sentry __sen(__is, true);
    if (__sen) {
      __str.clear();
      ios_base::iostate __err = ios_base::goodbit;
      streamsize __extr = 0;
      while (true) {
        typename _Traits::int_type __i = __is.rdbuf()->sbumpc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __err |= ios_base::eofbit;
          break;
        }
        ++__extr;
        _CharT __ch = _Traits::to_char_type(__i);
        if (_Traits::eq(__ch, __dlm))
          break;
        __str.push_back(__ch);
        if (__str.size() == __str.max_size()) {
          __err |= ios_base::failbit;
          break;
        }
      }
      if (__extr == 0)
        __err |= ios_base::failbit;
      __is.setstate(__err);
    }

  } catch (...) {
    __is.__set_badbit_and_consider_rethrow();
  }

  return __is;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str) {
  return getline(__is, __str, __is.widen('\n'));
}



template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm) {
  return getline(__is, __str, __dlm);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str) {
  return getline(__is, __str, __is.widen('\n'));
}



template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits> &operator>>(basic_istream<_CharT, _Traits> &__is,
                                           bitset<_Size> &__x) {

  try {

    typename basic_istream<_CharT, _Traits>::sentry __sen(__is);
    if (__sen) {
      basic_string<_CharT, _Traits> __str;
      const ctype<_CharT> &__ct = use_facet<ctype<_CharT>>(__is.getloc());
      streamsize __c = 0;
      ios_base::iostate __err = ios_base::goodbit;
      _CharT __zero = __ct.widen('0');
      _CharT __one = __ct.widen('1');
      while (__c < _Size) {
        typename _Traits::int_type __i = __is.rdbuf()->sgetc();
        if (_Traits::eq_int_type(__i, _Traits::eof())) {
          __err |= ios_base::eofbit;
          break;
        }
        _CharT __ch = _Traits::to_char_type(__i);
        if (!_Traits::eq(__ch, __zero) && !_Traits::eq(__ch, __one))
          break;
        __str.push_back(__ch);
        ++__c;
        __is.rdbuf()->sbumpc();
      }
      __x = bitset<_Size>(__str);
      if (__c == 0)
        __err |= ios_base::failbit;
      __is.setstate(__err);
    } else
      __is.setstate(ios_base::failbit);

  } catch (...) {
    __is.__set_badbit_and_consider_rethrow();
  }

  return __is;
}

extern template class basic_istream<char>;

extern template class basic_istream<wchar_t>;

extern template class basic_iostream<char>;


} }





namespace std { inline namespace __1 {



template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__visibility__("default"))) basic_stringbuf
    : public basic_streambuf<_CharT, _Traits> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;
  typedef _Allocator allocator_type;

  typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
  string_type __str_;
  mutable char_type *__hm_;
  ios_base::openmode __mode_;

public:

  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_stringbuf(
      ios_base::openmode __wch = ios_base::in | ios_base::out);
  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_stringbuf(
      const string_type &__s,
      ios_base::openmode __wch = ios_base::in | ios_base::out);

  basic_stringbuf(basic_stringbuf &&__rhs);




  basic_stringbuf &operator=(basic_stringbuf &&__rhs);

  void swap(basic_stringbuf &__rhs);


  string_type str() const;
  void str(const string_type &__s);

protected:

  virtual int_type underflow();
  virtual int_type pbackfail(int_type __c = traits_type::eof());
  virtual int_type overflow(int_type __c = traits_type::eof());
  virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,
                           ios_base::openmode __wch = ios_base::in |
                                                      ios_base::out);
  inline __attribute__((__visibility__("hidden"), __always_inline__)) virtual pos_type
  seekpos(pos_type __sp,
          ios_base::openmode __wch = ios_base::in | ios_base::out);
};

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(
    ios_base::openmode __wch)
    : __hm_(0), __mode_(__wch) {
  str(string_type());
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(
    const string_type &__s, ios_base::openmode __wch)
    : __hm_(0), __mode_(__wch) {
  str(__s);
}



template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(
    basic_stringbuf &&__rhs)
    : __mode_(__rhs.__mode_) {
  char_type *__p = const_cast<char_type *>(__rhs.__str_.data());
  ptrdiff_t __binp = -1;
  ptrdiff_t __ninp = -1;
  ptrdiff_t __einp = -1;
  if (__rhs.eback() != nullptr) {
    __binp = __rhs.eback() - __p;
    __ninp = __rhs.gptr() - __p;
    __einp = __rhs.egptr() - __p;
  }
  ptrdiff_t __bout = -1;
  ptrdiff_t __nout = -1;
  ptrdiff_t __eout = -1;
  if (__rhs.pbase() != nullptr) {
    __bout = __rhs.pbase() - __p;
    __nout = __rhs.pptr() - __p;
    __eout = __rhs.epptr() - __p;
  }
  ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
  __str_ = std::__1::move(__rhs.__str_);
  __p = const_cast<char_type *>(__str_.data());
  if (__binp != -1)
    this->setg(__p + __binp, __p + __ninp, __p + __einp);
  if (__bout != -1) {
    this->setp(__p + __bout, __p + __eout);
    this->pbump(__nout);
  }
  __hm_ = __hm == -1 ? nullptr : __p + __hm;
  __p = const_cast<char_type *>(__rhs.__str_.data());
  __rhs.setg(__p, __p, __p);
  __rhs.setp(__p, __p);
  __rhs.__hm_ = __p;
  this->pubimbue(__rhs.getloc());
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator> &
basic_stringbuf<_CharT, _Traits, _Allocator>::
operator=(basic_stringbuf &&__rhs) {
  char_type *__p = const_cast<char_type *>(__rhs.__str_.data());
  ptrdiff_t __binp = -1;
  ptrdiff_t __ninp = -1;
  ptrdiff_t __einp = -1;
  if (__rhs.eback() != nullptr) {
    __binp = __rhs.eback() - __p;
    __ninp = __rhs.gptr() - __p;
    __einp = __rhs.egptr() - __p;
  }
  ptrdiff_t __bout = -1;
  ptrdiff_t __nout = -1;
  ptrdiff_t __eout = -1;
  if (__rhs.pbase() != nullptr) {
    __bout = __rhs.pbase() - __p;
    __nout = __rhs.pptr() - __p;
    __eout = __rhs.epptr() - __p;
  }
  ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
  __str_ = std::__1::move(__rhs.__str_);
  __p = const_cast<char_type *>(__str_.data());
  if (__binp != -1)
    this->setg(__p + __binp, __p + __ninp, __p + __einp);
  else
    this->setg(nullptr, nullptr, nullptr);
  if (__bout != -1) {
    this->setp(__p + __bout, __p + __eout);
    this->pbump(__nout);
  } else
    this->setp(nullptr, nullptr);

  __hm_ = __hm == -1 ? nullptr : __p + __hm;
  __mode_ = __rhs.__mode_;
  __p = const_cast<char_type *>(__rhs.__str_.data());
  __rhs.setg(__p, __p, __p);
  __rhs.setp(__p, __p);
  __rhs.__hm_ = __p;
  this->pubimbue(__rhs.getloc());
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
void basic_stringbuf<_CharT, _Traits, _Allocator>::swap(
    basic_stringbuf &__rhs) {
  char_type *__p = const_cast<char_type *>(__rhs.__str_.data());
  ptrdiff_t __rbinp = -1;
  ptrdiff_t __rninp = -1;
  ptrdiff_t __reinp = -1;
  if (__rhs.eback() != nullptr) {
    __rbinp = __rhs.eback() - __p;
    __rninp = __rhs.gptr() - __p;
    __reinp = __rhs.egptr() - __p;
  }
  ptrdiff_t __rbout = -1;
  ptrdiff_t __rnout = -1;
  ptrdiff_t __reout = -1;
  if (__rhs.pbase() != nullptr) {
    __rbout = __rhs.pbase() - __p;
    __rnout = __rhs.pptr() - __p;
    __reout = __rhs.epptr() - __p;
  }
  ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;
  __p = const_cast<char_type *>(__str_.data());
  ptrdiff_t __lbinp = -1;
  ptrdiff_t __lninp = -1;
  ptrdiff_t __leinp = -1;
  if (this->eback() != nullptr) {
    __lbinp = this->eback() - __p;
    __lninp = this->gptr() - __p;
    __leinp = this->egptr() - __p;
  }
  ptrdiff_t __lbout = -1;
  ptrdiff_t __lnout = -1;
  ptrdiff_t __leout = -1;
  if (this->pbase() != nullptr) {
    __lbout = this->pbase() - __p;
    __lnout = this->pptr() - __p;
    __leout = this->epptr() - __p;
  }
  ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;
  std::__1::swap(__mode_, __rhs.__mode_);
  __str_.swap(__rhs.__str_);
  __p = const_cast<char_type *>(__str_.data());
  if (__rbinp != -1)
    this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);
  else
    this->setg(nullptr, nullptr, nullptr);
  if (__rbout != -1) {
    this->setp(__p + __rbout, __p + __reout);
    this->pbump(__rnout);
  } else
    this->setp(nullptr, nullptr);
  __hm_ = __rhm == -1 ? nullptr : __p + __rhm;
  __p = const_cast<char_type *>(__rhs.__str_.data());
  if (__lbinp != -1)
    __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);
  else
    __rhs.setg(nullptr, nullptr, nullptr);
  if (__lbout != -1) {
    __rhs.setp(__p + __lbout, __p + __leout);
    __rhs.pbump(__lnout);
  } else
    __rhs.setp(nullptr, nullptr);
  __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;
  locale __tl = __rhs.getloc();
  __rhs.pubimbue(this->getloc());
  this->pubimbue(__tl);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(basic_stringbuf<_CharT, _Traits, _Allocator> &__x,
     basic_stringbuf<_CharT, _Traits, _Allocator> &__y) {
  __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator>::str() const {
  if (__mode_ & ios_base::out) {
    if (__hm_ < this->pptr())
      __hm_ = this->pptr();
    return string_type(this->pbase(), __hm_, __str_.get_allocator());
  } else if (__mode_ & ios_base::in)
    return string_type(this->eback(), this->egptr(), __str_.get_allocator());
  return string_type(__str_.get_allocator());
}

template <class _CharT, class _Traits, class _Allocator>
void basic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type &__s) {
  __str_ = __s;
  __hm_ = 0;
  if (__mode_ & ios_base::in) {
    __hm_ = const_cast<char_type *>(__str_.data()) + __str_.size();
    this->setg(const_cast<char_type *>(__str_.data()),
               const_cast<char_type *>(__str_.data()), __hm_);
  }
  if (__mode_ & ios_base::out) {
    typename string_type::size_type __sz = __str_.size();
    __hm_ = const_cast<char_type *>(__str_.data()) + __sz;
    __str_.resize(__str_.capacity());
    this->setp(const_cast<char_type *>(__str_.data()),
               const_cast<char_type *>(__str_.data()) + __str_.size());
    if (__mode_ & (ios_base::app | ios_base::ate))
      this->pbump(__sz);
  }
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::underflow() {
  if (__hm_ < this->pptr())
    __hm_ = this->pptr();
  if (__mode_ & ios_base::in) {
    if (this->egptr() < __hm_)
      this->setg(this->eback(), this->gptr(), __hm_);
    if (this->gptr() < this->egptr())
      return traits_type::to_int_type(*this->gptr());
  }
  return traits_type::eof();
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c) {
  if (__hm_ < this->pptr())
    __hm_ = this->pptr();
  if (this->eback() < this->gptr()) {
    if (traits_type::eq_int_type(__c, traits_type::eof())) {
      this->setg(this->eback(), this->gptr() - 1, __hm_);
      return traits_type::not_eof(__c);
    }
    if ((__mode_ & ios_base::out) ||
        traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])) {
      this->setg(this->eback(), this->gptr() - 1, __hm_);
      *this->gptr() = traits_type::to_char_type(__c);
      return __c;
    }
  }
  return traits_type::eof();
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type
basic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c) {
  if (!traits_type::eq_int_type(__c, traits_type::eof())) {
    ptrdiff_t __ninp = this->gptr() - this->eback();
    if (this->pptr() == this->epptr()) {
      if (!(__mode_ & ios_base::out))
        return traits_type::eof();

      try {

        ptrdiff_t __nout = this->pptr() - this->pbase();
        ptrdiff_t __hm = __hm_ - this->pbase();
        __str_.push_back(char_type());
        __str_.resize(__str_.capacity());
        char_type *__p = const_cast<char_type *>(__str_.data());
        this->setp(__p, __p + __str_.size());
        this->pbump(__nout);
        __hm_ = this->pbase() + __hm;

      } catch (...) {
        return traits_type::eof();
      }

    }
    __hm_ = std::__1::max(this->pptr() + 1, __hm_);
    if (__mode_ & ios_base::in) {
      char_type *__p = const_cast<char_type *>(__str_.data());
      this->setg(__p, __p + __ninp, __hm_);
    }
    return this->sputc(traits_type::to_char_type(__c));
  }
  return traits_type::not_eof(__c);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type
basic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(
    off_type __off, ios_base::seekdir __way, ios_base::openmode __wch) {
  if (__hm_ < this->pptr())
    __hm_ = this->pptr();
  if ((__wch & (ios_base::in | ios_base::out)) == 0)
    return pos_type(-1);
  if ((__wch & (ios_base::in | ios_base::out)) ==
          (ios_base::in | ios_base::out) &&
      __way == ios_base::cur)
    return pos_type(-1);
  off_type __noff;
  switch (__way) {
  case ios_base::beg:
    __noff = 0;
    break;
  case ios_base::cur:
    if (__wch & ios_base::in)
      __noff = this->gptr() - this->eback();
    else
      __noff = this->pptr() - this->pbase();
    break;
  case ios_base::end:
    __noff = __hm_ - __str_.data();
    break;
  default:
    return pos_type(-1);
  }
  __noff += __off;
  if (__noff < 0 || __hm_ - __str_.data() < __noff)
    return pos_type(-1);
  if (__noff != 0) {
    if ((__wch & ios_base::in) && this->gptr() == 0)
      return pos_type(-1);
    if ((__wch & ios_base::out) && this->pptr() == 0)
      return pos_type(-1);
  }
  if (__wch & ios_base::in)
    this->setg(this->eback(), this->eback() + __noff, __hm_);
  if (__wch & ios_base::out) {
    this->setp(this->pbase(), this->epptr());
    this->pbump(__noff);
  }
  return pos_type(__noff);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type
basic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(
    pos_type __sp, ios_base::openmode __wch) {
  return seekoff(__sp, ios_base::beg, __wch);
}



template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__visibility__("default"))) basic_istringstream
    : public basic_istream<_CharT, _Traits> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;
  typedef _Allocator allocator_type;

  typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
  basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:

  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_istringstream(
      ios_base::openmode __wch = ios_base::in);
  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_istringstream(
      const string_type &__s, ios_base::openmode __wch = ios_base::in);

  inline __attribute__((__visibility__("hidden"), __always_inline__))
  basic_istringstream(basic_istringstream &&__rhs);


  basic_istringstream &operator=(basic_istringstream &&__rhs);

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(basic_istringstream &__rhs);


  inline __attribute__((__visibility__("hidden"), __always_inline__))
      basic_stringbuf<char_type, traits_type, allocator_type> *
      rdbuf() const;
  inline __attribute__((__visibility__("hidden"), __always_inline__)) string_type str() const;
  inline __attribute__((__visibility__("hidden"), __always_inline__)) void str(const string_type &__s);
};

template <class _CharT, class _Traits, class _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(
    ios_base::openmode __wch)
    : basic_istream<_CharT, _Traits>(&__sb_), __sb_(__wch | ios_base::in) {}

template <class _CharT, class _Traits, class _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(
    const string_type &__s, ios_base::openmode __wch)
    : basic_istream<_CharT, _Traits>(&__sb_), __sb_(__s, __wch | ios_base::in) {
}



template <class _CharT, class _Traits, class _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(
    basic_istringstream &&__rhs)
    : basic_istream<_CharT, _Traits>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_)) {
  basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator> &
basic_istringstream<_CharT, _Traits, _Allocator>::
operator=(basic_istringstream &&__rhs) {
  basic_istream<char_type, traits_type>::operator=(std::__1::move(__rhs));
  __sb_ = std::__1::move(__rhs.__sb_);
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
void basic_istringstream<_CharT, _Traits, _Allocator>::swap(
    basic_istringstream &__rhs) {
  basic_istream<char_type, traits_type>::swap(__rhs);
  __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(basic_istringstream<_CharT, _Traits, _Allocator> &__x,
     basic_istringstream<_CharT, _Traits, _Allocator> &__y) {
  __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator> *
basic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const {
  return const_cast<basic_stringbuf<char_type, traits_type, allocator_type> *>(
      &__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_istringstream<_CharT, _Traits, _Allocator>::str() const {
  return __sb_.str();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_istringstream<_CharT, _Traits, _Allocator>::str(
    const string_type &__s) {
  __sb_.str(__s);
}



template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__visibility__("default"))) basic_ostringstream
    : public basic_ostream<_CharT, _Traits> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;
  typedef _Allocator allocator_type;

  typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
  basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:

  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_ostringstream(
      ios_base::openmode __wch = ios_base::out);
  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_ostringstream(
      const string_type &__s, ios_base::openmode __wch = ios_base::out);

  inline __attribute__((__visibility__("hidden"), __always_inline__))
  basic_ostringstream(basic_ostringstream &&__rhs);


  basic_ostringstream &operator=(basic_ostringstream &&__rhs);

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(basic_ostringstream &__rhs);


  inline __attribute__((__visibility__("hidden"), __always_inline__))
      basic_stringbuf<char_type, traits_type, allocator_type> *
      rdbuf() const;
  inline __attribute__((__visibility__("hidden"), __always_inline__)) string_type str() const;
  inline __attribute__((__visibility__("hidden"), __always_inline__)) void str(const string_type &__s);
};

template <class _CharT, class _Traits, class _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(
    ios_base::openmode __wch)
    : basic_ostream<_CharT, _Traits>(&__sb_), __sb_(__wch | ios_base::out) {}

template <class _CharT, class _Traits, class _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(
    const string_type &__s, ios_base::openmode __wch)
    : basic_ostream<_CharT, _Traits>(&__sb_),
      __sb_(__s, __wch | ios_base::out) {}



template <class _CharT, class _Traits, class _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(
    basic_ostringstream &&__rhs)
    : basic_ostream<_CharT, _Traits>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_)) {
  basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator> &
basic_ostringstream<_CharT, _Traits, _Allocator>::
operator=(basic_ostringstream &&__rhs) {
  basic_ostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
  __sb_ = std::__1::move(__rhs.__sb_);
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
void basic_ostringstream<_CharT, _Traits, _Allocator>::swap(
    basic_ostringstream &__rhs) {
  basic_ostream<char_type, traits_type>::swap(__rhs);
  __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(basic_ostringstream<_CharT, _Traits, _Allocator> &__x,
     basic_ostringstream<_CharT, _Traits, _Allocator> &__y) {
  __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator> *
basic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const {
  return const_cast<basic_stringbuf<char_type, traits_type, allocator_type> *>(
      &__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_ostringstream<_CharT, _Traits, _Allocator>::str() const {
  return __sb_.str();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_ostringstream<_CharT, _Traits, _Allocator>::str(
    const string_type &__s) {
  __sb_.str(__s);
}



template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__visibility__("default"))) basic_stringstream
    : public basic_iostream<_CharT, _Traits> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename traits_type::int_type int_type;
  typedef typename traits_type::pos_type pos_type;
  typedef typename traits_type::off_type off_type;
  typedef _Allocator allocator_type;

  typedef basic_string<char_type, traits_type, allocator_type> string_type;

private:
  basic_stringbuf<char_type, traits_type, allocator_type> __sb_;

public:

  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_stringstream(
      ios_base::openmode __wch = ios_base::in | ios_base::out);
  inline __attribute__((__visibility__("hidden"), __always_inline__)) explicit basic_stringstream(
      const string_type &__s,
      ios_base::openmode __wch = ios_base::in | ios_base::out);

  inline __attribute__((__visibility__("hidden"), __always_inline__))
  basic_stringstream(basic_stringstream &&__rhs);


  basic_stringstream &operator=(basic_stringstream &&__rhs);

  inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(basic_stringstream &__rhs);


  inline __attribute__((__visibility__("hidden"), __always_inline__))
      basic_stringbuf<char_type, traits_type, allocator_type> *
      rdbuf() const;
  inline __attribute__((__visibility__("hidden"), __always_inline__)) string_type str() const;
  inline __attribute__((__visibility__("hidden"), __always_inline__)) void str(const string_type &__s);
};

template <class _CharT, class _Traits, class _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(
    ios_base::openmode __wch)
    : basic_iostream<_CharT, _Traits>(&__sb_), __sb_(__wch) {}

template <class _CharT, class _Traits, class _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(
    const string_type &__s, ios_base::openmode __wch)
    : basic_iostream<_CharT, _Traits>(&__sb_), __sb_(__s, __wch) {}



template <class _CharT, class _Traits, class _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(
    basic_stringstream &&__rhs)
    : basic_iostream<_CharT, _Traits>(std::__1::move(__rhs)),
      __sb_(std::__1::move(__rhs.__sb_)) {
  basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator> &
basic_stringstream<_CharT, _Traits, _Allocator>::
operator=(basic_stringstream &&__rhs) {
  basic_iostream<char_type, traits_type>::operator=(std::__1::move(__rhs));
  __sb_ = std::__1::move(__rhs.__sb_);
  return *this;
}



template <class _CharT, class _Traits, class _Allocator>
void basic_stringstream<_CharT, _Traits, _Allocator>::swap(
    basic_stringstream &__rhs) {
  basic_iostream<char_type, traits_type>::swap(__rhs);
  __sb_.swap(__rhs.__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(basic_stringstream<_CharT, _Traits, _Allocator> &__x,
     basic_stringstream<_CharT, _Traits, _Allocator> &__y) {
  __x.swap(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_stringbuf<_CharT, _Traits, _Allocator> *
basic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const {
  return const_cast<basic_stringbuf<char_type, traits_type, allocator_type> *>(
      &__sb_);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_stringstream<_CharT, _Traits, _Allocator>::str() const {
  return __sb_.str();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_stringstream<_CharT, _Traits, _Allocator>::str(
    const string_type &__s) {
  __sb_.str(__s);
}

} }




extern "C" __attribute__((noreturn)) void V8_Fatal(const char* file, int line,
                                     const char* format, ...);

extern "C" void V8_RuntimeError(const char* file, int line,
                                const char* message);
namespace v8 {
namespace base {
template <typename Lhs, typename Rhs>
std::string* MakeCheckOpString(Lhs const& lhs, Rhs const& rhs,
                               char const* msg) {
  std::ostringstream ss;
  ss << msg << " (" << lhs << " vs. " << rhs << ")";
  return new std::string(ss.str());
}






extern template std::string* MakeCheckOpString<int, int>( int const&, int const&, char const*);
extern template std::string* MakeCheckOpString<long, long>( long const&, long const&, char const*);
extern template std::string* MakeCheckOpString<long long, long long>( long long const&, long long const&, char const*);
extern template std::string* MakeCheckOpString<unsigned int, unsigned int>( unsigned int const&, unsigned int const&, char const*);
extern template std::string* MakeCheckOpString<unsigned long, unsigned long>( unsigned long const&, unsigned long const&, char const*);
extern template std::string* MakeCheckOpString<unsigned long long, unsigned long long>( unsigned long long const&, unsigned long long const&, char const*);
extern template std::string* MakeCheckOpString<char const*, char const*>( char const* const&, char const* const&, char const*);
extern template std::string* MakeCheckOpString<void const*, void const*>( void const* const&, void const* const&, char const*);
template <typename Lhs, typename Rhs> inline std::string* CheckEQImpl(Lhs const& lhs, Rhs const& rhs, char const* msg) { return (lhs == rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } inline std::string* CheckEQImpl(int lhs, int rhs, char const* msg) { return (lhs == rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } extern template std::string* CheckEQImpl<float, float>( float const& lhs, float const& rhs, char const* msg); extern template std::string* CheckEQImpl<double, double>( double const& lhs, double const& rhs, char const* msg);
template <typename Lhs, typename Rhs> inline std::string* CheckNEImpl(Lhs const& lhs, Rhs const& rhs, char const* msg) { return (lhs != rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } inline std::string* CheckNEImpl(int lhs, int rhs, char const* msg) { return (lhs != rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } extern template std::string* CheckNEImpl<float, float>( float const& lhs, float const& rhs, char const* msg); extern template std::string* CheckNEImpl<double, double>( double const& lhs, double const& rhs, char const* msg);
template <typename Lhs, typename Rhs> inline std::string* CheckLEImpl(Lhs const& lhs, Rhs const& rhs, char const* msg) { return (lhs <= rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } inline std::string* CheckLEImpl(int lhs, int rhs, char const* msg) { return (lhs <= rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } extern template std::string* CheckLEImpl<float, float>( float const& lhs, float const& rhs, char const* msg); extern template std::string* CheckLEImpl<double, double>( double const& lhs, double const& rhs, char const* msg);
template <typename Lhs, typename Rhs> inline std::string* CheckLTImpl(Lhs const& lhs, Rhs const& rhs, char const* msg) { return (lhs < rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } inline std::string* CheckLTImpl(int lhs, int rhs, char const* msg) { return (lhs < rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } extern template std::string* CheckLTImpl<float, float>( float const& lhs, float const& rhs, char const* msg); extern template std::string* CheckLTImpl<double, double>( double const& lhs, double const& rhs, char const* msg);
template <typename Lhs, typename Rhs> inline std::string* CheckGEImpl(Lhs const& lhs, Rhs const& rhs, char const* msg) { return (lhs >= rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } inline std::string* CheckGEImpl(int lhs, int rhs, char const* msg) { return (lhs >= rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } extern template std::string* CheckGEImpl<float, float>( float const& lhs, float const& rhs, char const* msg); extern template std::string* CheckGEImpl<double, double>( double const& lhs, double const& rhs, char const* msg);
template <typename Lhs, typename Rhs> inline std::string* CheckGTImpl(Lhs const& lhs, Rhs const& rhs, char const* msg) { return (lhs > rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } inline std::string* CheckGTImpl(int lhs, int rhs, char const* msg) { return (lhs > rhs) ? nullptr : MakeCheckOpString(lhs, rhs, msg); } extern template std::string* CheckGTImpl<float, float>( float const& lhs, float const& rhs, char const* msg); extern template std::string* CheckGTImpl<double, double>( double const& lhs, double const& rhs, char const* msg);
void DumpBacktrace();

}
}













template <typename T, size_t N>
char (&ArraySizeHelper(T (&array)[N]))[N];






template <typename T, size_t N>
char (&ArraySizeHelper(const T (&array)[N]))[N];
template <class Dest, class Source>
inline Dest bit_cast(Source const& source) {
  static_assert(sizeof(Dest) == sizeof(Source),
                "source and dest must be same size");
  Dest dest;
  memcpy(&dest, &source, sizeof(dest));
  return dest;
}
template <typename T>
inline void USE(T) { }
template <typename T>
inline intptr_t OffsetFrom(T x) {
  return x - static_cast<T>(0);
}





template <typename T>
inline T AddressFrom(intptr_t x) {
  return static_cast<T>(static_cast<T>(0) + x);
}



template <typename T>
inline T RoundDown(T x, intptr_t m) {
  do { if ((!(((m) != 0 && (((m) & ((m) - 1)) == 0))))) { V8_Fatal(".././src/base/macros.h", 322, "Check failed: %s.", "((m) != 0 && (((m) & ((m) - 1)) == 0))"); } } while (0);
  return AddressFrom<T>(OffsetFrom(x) & -m);
}



template <typename T>
inline T RoundUp(T x, intptr_t m) {
  return RoundDown<T>(static_cast<T>(x + m - 1), m);
}


namespace v8 {
namespace base {



template <typename T>
inline bool is_fundamental() {
  return false;
}

template <>
inline bool is_fundamental<uint8_t>() {
  return true;
}

}
}


inline const uint8_t& Ascii2Ebcdic(const char letter) {
  static unsigned char a2e[256] = {
  0,1,2,3,55,45,46,47,22,5,21,11,12,13,14,15,
  16,17,18,19,60,61,50,38,24,25,63,39,28,29,30,31,
  64,79,127,123,91,108,80,125,77,93,92,78,107,96,75,97,
  240,241,242,243,244,245,246,247,248,249,122,94,76,126,110,111,
  124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
  215,216,217,226,227,228,229,230,231,232,233,74,224,90,95,109,
  121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
  151,152,153,162,163,164,165,166,167,168,169,192,106,208,161,7,
  32,33,34,35,36,21,6,23,40,41,42,43,44,9,10,27,
  48,49,26,51,52,53,54,8,56,57,58,59,4,20,62,225,
  65,66,67,68,69,70,71,72,73,81,82,83,84,85,86,87,
  88,89,98,99,100,101,102,103,104,105,112,113,114,115,116,117,
  118,119,120,128,138,139,140,141,142,143,144,154,155,156,157,158,
  159,160,170,171,172,173,174,175,176,177,178,179,180,181,182,183,
  184,185,186,187,188,189,190,191,202,203,204,205,206,207,218,219,
  220,221,222,223,234,235,236,237,238,239,250,251,252,253,254,255
  };
  return a2e[letter];
}

inline const uint8_t& Ebcdic2Ascii(const char letter) {
  static const uint8_t e2a[256] = {
  0,1,2,3,156,9,134,127,151,141,142,11,12,13,14,15,
  16,17,18,19,157,10,8,135,24,25,146,143,28,29,30,31,
  128,129,130,131,132,10,23,27,136,137,138,139,140,5,6,7,
  144,145,22,147,148,149,150,4,152,153,154,155,20,21,158,26,
  32,160,161,162,163,164,165,166,167,168,91,46,60,40,43,33,
  38,169,170,171,172,173,174,175,176,177,93,36,42,41,59,94,
  45,47,178,179,180,181,182,183,184,185,124,44,37,95,62,63,
  186,187,188,189,190,191,192,193,194,96,58,35,64,39,61,34,
  195,97,98,99,100,101,102,103,104,105,196,197,198,199,200,201,
  202,106,107,108,109,110,111,112,113,114,203,204,205,206,207,208,
  209,126,115,116,117,118,119,120,121,122,210,211,212,213,214,215,
  216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,
  123,65,66,67,68,69,70,71,72,73,232,233,234,235,236,237,
  125,74,75,76,77,78,79,80,81,82,238,239,240,241,242,243,
  92,159,83,84,85,86,87,88,89,90,244,245,246,247,248,249,
  48,49,50,51,52,53,54,55,56,57,250,251,252,253,254,255
  };
  return e2a[letter];
}
namespace v8 {

namespace base {
class Mutex;
class RecursiveMutex;
class VirtualMemory;
}

namespace internal {
typedef uint8_t byte;
typedef byte* Address;




const int KB = 1024;
const int MB = KB * KB;
const int GB = KB * KB * KB;
const int kMaxInt = 0x7FFFFFFF;
const int kMinInt = -kMaxInt - 1;
const int kMaxInt8 = (1 << 7) - 1;
const int kMinInt8 = -(1 << 7);
const int kMaxUInt8 = (1 << 8) - 1;
const int kMinUInt8 = 0;
const int kMaxInt16 = (1 << 15) - 1;
const int kMinInt16 = -(1 << 15);
const int kMaxUInt16 = (1 << 16) - 1;
const int kMinUInt16 = 0;

const uint32_t kMaxUInt32 = 0xFFFFFFFFu;
const int kMinUInt32 = 0;

const int kCharSize = sizeof(char);
const int kShortSize = sizeof(short);
const int kIntSize = sizeof(int);
const int kInt32Size = sizeof(int32_t);
const int kInt64Size = sizeof(int64_t);
const int kFloatSize = sizeof(float);
const int kDoubleSize = sizeof(double);
const int kIntptrSize = sizeof(intptr_t);
const int kPointerSize = sizeof(void*);



const int kFrameAlignmentInBytes = kPointerSize;




const int kRegisterSize = kPointerSize;

const int kPCOnStackSize = kRegisterSize;
const int kFPOnStackSize = kRegisterSize;




const int kElidedFrameSlots = 0;


const int kDoubleSizeLog2 = 3;


const int kPointerSizeLog2 = 3;
const intptr_t kIntptrSignBit = (0x8000000000000000L);
const uintptr_t kUintptrAllBitsSet = (0xFFFFFFFFFFFFFFFFUL);
const bool kRequiresCodeRange = true;






const size_t kMaximalCodeRangeSize = 512 * MB;





const size_t kMinimumCodeRangeSize = 3 * MB;
const size_t kReservedCodeRangePages = 0;
static_assert(kPointerSize == (1 << kPointerSizeLog2), "kPointerSize == (1 << kPointerSizeLog2)");

const int kBitsPerByte = 8;
const int kBitsPerByteLog2 = 3;
const int kBitsPerPointer = kPointerSize * kBitsPerByte;
const int kBitsPerInt = kIntSize * kBitsPerByte;


const uint32_t kBinary32SignMask = 0x80000000u;
const uint32_t kBinary32ExponentMask = 0x7f800000u;
const uint32_t kBinary32MantissaMask = 0x007fffffu;
const int kBinary32ExponentBias = 127;
const int kBinary32MaxExponent = 0xFE;
const int kBinary32MinExponent = 0x01;
const int kBinary32MantissaBits = 23;
const int kBinary32ExponentShift = 23;



const uint64_t kQuietNaNMask = static_cast<uint64_t>(0xfff) << 51;




typedef uint16_t uc16;
typedef int32_t uc32;
const int kOneByteSize = kCharSize;
const int kUC16Size = sizeof(uc16);


const int kSimd128Size = 16;
template <typename F>
F FUNCTION_CAST(Address addr) {
  return reinterpret_cast<F>(reinterpret_cast<intptr_t>(addr));
}
class FreeStoreAllocationPolicy;
template <typename T, class P = FreeStoreAllocationPolicy> class List;






enum LanguageMode { SLOPPY, STRICT, LANGUAGE_END = 3 };


inline std::ostream& operator<<(std::ostream& os, const LanguageMode& mode) {
  switch (mode) {
    case SLOPPY: return os << u8"sloppy";
    case STRICT: return os << u8"strict";
    default: V8_Fatal(".././src/globals.h", 268, "unreachable code");
  }
  return os;
}


inline bool is_sloppy(LanguageMode language_mode) {
  return language_mode == SLOPPY;
}


inline bool is_strict(LanguageMode language_mode) {
  return language_mode != SLOPPY;
}


inline bool is_valid_language_mode(int language_mode) {
  return language_mode == SLOPPY || language_mode == STRICT;
}


inline LanguageMode construct_language_mode(bool strict_bit) {
  return static_cast<LanguageMode>(strict_bit);
}



const intptr_t kSmiSignMask = kIntptrSignBit;

const int kObjectAlignmentBits = kPointerSizeLog2;
const intptr_t kObjectAlignment = 1 << kObjectAlignmentBits;
const intptr_t kObjectAlignmentMask = kObjectAlignment - 1;


const intptr_t kPointerAlignment = (1 << kPointerSizeLog2);
const intptr_t kPointerAlignmentMask = kPointerAlignment - 1;


const intptr_t kDoubleAlignment = 8;
const intptr_t kDoubleAlignmentMask = kDoubleAlignment - 1;


const intptr_t kSimd128Alignment = 16;
const intptr_t kSimd128AlignmentMask = kSimd128Alignment - 1;



const int kCodeAlignmentBits = 5;
const intptr_t kCodeAlignment = 1 << kCodeAlignmentBits;
const intptr_t kCodeAlignmentMask = kCodeAlignment - 1;







const int kPageHeaderTag = 3;
const int kPageHeaderTagSize = 2;
const intptr_t kPageHeaderTagMask = (1 << kPageHeaderTagSize) - 1;





const Address kZapValue =
    reinterpret_cast<Address>((0xdeadbeedbeadbeefUL));
const Address kHandleZapValue =
    reinterpret_cast<Address>((0x1baddead0baddeafUL));
const Address kGlobalHandleZapValue =
    reinterpret_cast<Address>((0x1baffed00baffedfUL));
const Address kFromSpaceZapValue =
    reinterpret_cast<Address>((0x1beefdad0beefdafUL));
const uint64_t kDebugZapValue = (0xbadbaddbbadbaddbUL);
const uint64_t kSlotsZapValue = (0xbeefdeadbeefdeefUL);
const uint64_t kFreeListZapValue = 0xfeed1eaffeed1eaf;
const int kCodeZapValue = 0xbadc0de;
const uint32_t kPhantomReferenceZap = 0xca11bac;
const uint32_t kQuietNaNHighBitsMask = 0xfff << (51 - 32);





class AccessorInfo;
class Allocation;
class Arguments;
class Assembler;
class Code;
class CodeGenerator;
class CodeStub;
class Context;
class Debug;
class DebugInfo;
class Descriptor;
class DescriptorArray;
class TransitionArray;
class ExternalReference;
class FixedArray;
class FunctionTemplateInfo;
class MemoryChunk;
class SeededNumberDictionary;
class UnseededNumberDictionary;
class NameDictionary;
class GlobalDictionary;
template <typename T> class MaybeHandle;
template <typename T> class Handle;
class Heap;
class HeapObject;
class IC;
class InterceptorInfo;
class Isolate;
class JSReceiver;
class JSArray;
class JSFunction;
class JSObject;
class LargeObjectSpace;
class MacroAssembler;
class Map;
class MapSpace;
class MarkCompactCollector;
class NewSpace;
class Object;
class OldSpace;
class ParameterCount;
class Foreign;
class Scope;
class ScopeInfo;
class Script;
class Smi;
template <typename Config, class Allocator = FreeStoreAllocationPolicy>
class SplayTree;
class String;
class Symbol;
class Name;
class Struct;
class TypeFeedbackVector;
class Variable;
class RelocInfo;
class Deserializer;
class MessageLocation;

typedef bool (*WeakSlotCallback)(Object** pointer);

typedef bool (*WeakSlotCallbackWithHeap)(Heap* heap, Object** pointer);







enum AllocationSpace {
  NEW_SPACE,
  OLD_SPACE,
  CODE_SPACE,
  MAP_SPACE,
  LO_SPACE,

  FIRST_SPACE = NEW_SPACE,
  LAST_SPACE = LO_SPACE,
  FIRST_PAGED_SPACE = OLD_SPACE,
  LAST_PAGED_SPACE = MAP_SPACE
};
const int kSpaceTagSize = 3;
const int kSpaceTagMask = (1 << kSpaceTagSize) - 1;

enum AllocationAlignment {
  kWordAligned,
  kDoubleAligned,
  kDoubleUnaligned,
  kSimd128Unaligned
};





enum PretenureFlag { NOT_TENURED, TENURED };

inline std::ostream& operator<<(std::ostream& os, const PretenureFlag& flag) {
  switch (flag) {
    case NOT_TENURED:
      return os << u8"NotTenured";
    case TENURED:
      return os << u8"Tenured";
  }
  V8_Fatal(".././src/globals.h", 473, "unreachable code");
  return os;
}

enum MinimumCapacity {
  USE_DEFAULT_MINIMUM_CAPACITY,
  USE_CUSTOM_MINIMUM_CAPACITY
};

enum GarbageCollector { SCAVENGER, MARK_COMPACTOR };

enum Executability { NOT_EXECUTABLE, EXECUTABLE };

enum VisitMode {
  VISIT_ALL,
  VISIT_ALL_IN_SCAVENGE,
  VISIT_ALL_IN_SWEEP_NEWSPACE,
  VISIT_ONLY_STRONG,
  VISIT_ONLY_STRONG_FOR_SERIALIZATION,
  VISIT_ONLY_STRONG_ROOT_LIST,
};


enum NativesFlag { NOT_NATIVES_CODE, EXTENSION_CODE, NATIVES_CODE };


enum NilValue { kNullValue, kUndefinedValue };



enum ParseRestriction {
  NO_PARSE_RESTRICTION,
  ONLY_SINGLE_FUNCTION_LITERAL
};
struct CodeDesc {
  byte* buffer;
  int buffer_size;
  int instr_size;
  int reloc_size;
  int constant_pool_size;
  Assembler* origin;
};





typedef bool (*ConstraintCallback)(Address new_addr, Address old_addr);




typedef void (*InlineCacheCallback)(Code* code, Address ic);



enum InlineCacheState {

  UNINITIALIZED,

  PREMONOMORPHIC,

  MONOMORPHIC,

  PROTOTYPE_FAILURE,

  POLYMORPHIC,

  MEGAMORPHIC,

  GENERIC,

  DEBUG_STUB
};


enum CacheHolderFlag {
  kCacheOnPrototype,
  kCacheOnPrototypeReceiverIsDictionary,
  kCacheOnPrototypeReceiverIsPrimitive,
  kCacheOnReceiver
};



typedef enum {
  kStoreBufferFullEvent,
  kStoreBufferStartScanningPagesEvent,
  kStoreBufferScanningPageEvent
} StoreBufferEvent;


typedef void (*StoreBufferCallback)(Heap* heap,
                                    MemoryChunk* page,
                                    StoreBufferEvent event);



union DoubleRepresentation {
  double value;
  int64_t bits;
  DoubleRepresentation(double x) { value = x; }
  bool operator==(const DoubleRepresentation& other) const {
    return bits == other.bits;
  }
};





union IeeeDoubleLittleEndianArchType {
  double d;
  struct {
    unsigned int man_low :32;
    unsigned int man_high :20;
    unsigned int exp :11;
    unsigned int sign :1;
  } bits;
};


union IeeeDoubleBigEndianArchType {
  double d;
  struct {
    unsigned int sign :1;
    unsigned int exp :11;
    unsigned int man_high :20;
    unsigned int man_low :32;
  } bits;
};



struct AccessorDescriptor {
  Object* (*getter)(Isolate* isolate, Object* object, void* data);
  Object* (*setter)(
      Isolate* isolate, JSObject* object, Object* value, void* data);
  void* data;
};
enum CpuFeature {

  SSE4_1,
  SSE3,
  SAHF,
  AVX,
  FMA3,
  BMI1,
  BMI2,
  LZCNT,
  POPCNT,
  ATOM,

  VFP3,
  ARMv7,
  ARMv8,
  SUDIV,
  MLS,
  UNALIGNED_ACCESSES,
  MOVW_MOVT_IMMEDIATE_LOADS,
  VFP32DREGS,
  NEON,

  FPU,
  FP64FPU,
  MIPSr1,
  MIPSr2,
  MIPSr6,

  ALWAYS_ALIGN_CSP,
  COHERENT_CACHE,

  FPR_GPR_MOV,
  LWSYNC,
  ISELECT,

  DISTINCT_OPS,
  GENERAL_INSTR_EXT,
  FLOATING_POINT_EXT,
  NUMBER_OF_CPU_FEATURES
};


enum class ConvertReceiverMode : unsigned {
  kNullOrUndefined,
  kNotNullOrUndefined,
  kAny
};

inline size_t hash_value(ConvertReceiverMode mode) {
  return bit_cast<unsigned>(mode);
}

inline std::ostream& operator<<(std::ostream& os, ConvertReceiverMode mode) {
  switch (mode) {
    case ConvertReceiverMode::kNullOrUndefined:
      return os << u8"NULL_OR_UNDEFINED";
    case ConvertReceiverMode::kNotNullOrUndefined:
      return os << u8"NOT_NULL_OR_UNDEFINED";
    case ConvertReceiverMode::kAny:
      return os << u8"ANY";
  }
  V8_Fatal(".././src/globals.h", 720, "unreachable code");
  return os;
}


enum class TailCallMode : unsigned { kAllow, kDisallow };

inline size_t hash_value(TailCallMode mode) { return bit_cast<unsigned>(mode); }

inline std::ostream& operator<<(std::ostream& os, TailCallMode mode) {
  switch (mode) {
    case TailCallMode::kAllow:
      return os << u8"ALLOW_TAIL_CALLS";
    case TailCallMode::kDisallow:
      return os << u8"DISALLOW_TAIL_CALLS";
  }
  V8_Fatal(".././src/globals.h", 736, "unreachable code");
  return os;
}


enum class CreateArgumentsType : uint8_t {
  kMappedArguments,
  kUnmappedArguments,
  kRestParameter
};

inline size_t hash_value(CreateArgumentsType type) {
  return bit_cast<uint8_t>(type);
}

inline std::ostream& operator<<(std::ostream& os, CreateArgumentsType type) {
  switch (type) {
    case CreateArgumentsType::kMappedArguments:
      return os << u8"MAPPED_ARGUMENTS";
    case CreateArgumentsType::kUnmappedArguments:
      return os << u8"UNMAPPED_ARGUMENTS";
    case CreateArgumentsType::kRestParameter:
      return os << u8"REST_PARAMETER";
  }
  V8_Fatal(".././src/globals.h", 760, "unreachable code");
  return os;
}



enum SmiCheckType {
  DONT_DO_SMI_CHECK,
  DO_SMI_CHECK
};


enum ScopeType {
  EVAL_SCOPE,
  FUNCTION_SCOPE,
  MODULE_SCOPE,
  SCRIPT_SCOPE,
  CATCH_SCOPE,
  BLOCK_SCOPE,
  WITH_SCOPE
};







const uint32_t kHoleNanUpper32 = 0xFFF7FFFF;
const uint32_t kHoleNanLower32 = 0xFFF7FFFF;


const uint64_t kHoleNanInt64 =
    (static_cast<uint64_t>(kHoleNanUpper32) << 32) | kHoleNanLower32;



const double kMaxSafeInteger = 9007199254740991.0;



enum VariableMode {

  VAR,

  CONST_LEGACY,

  LET,

  CONST,

  IMPORT,


  TEMPORARY,


  DYNAMIC,


  DYNAMIC_GLOBAL,



  DYNAMIC_LOCAL



};


inline bool IsDynamicVariableMode(VariableMode mode) {
  return mode >= DYNAMIC && mode <= DYNAMIC_LOCAL;
}


inline bool IsDeclaredVariableMode(VariableMode mode) {
  return mode >= VAR && mode <= IMPORT;
}


inline bool IsLexicalVariableMode(VariableMode mode) {
  return mode >= LET && mode <= IMPORT;
}


inline bool IsImmutableVariableMode(VariableMode mode) {
  return mode == CONST || mode == CONST_LEGACY || mode == IMPORT;
}


enum class VariableLocation {




  UNALLOCATED,




  PARAMETER,



  LOCAL,




  CONTEXT,





  GLOBAL,




  LOOKUP
};
enum InitializationFlag {
  kNeedsInitialization,
  kCreatedInitialized
};


enum MaybeAssignedFlag { kNotAssigned, kMaybeAssigned };



enum ParseErrorType { kSyntaxError = 0, kReferenceError = 1 };


enum MinusZeroMode {
  TREAT_MINUS_ZERO_AS_ZERO,
  FAIL_ON_MINUS_ZERO
};


enum Signedness { kSigned, kUnsigned };

enum FunctionKind {
  kNormalFunction = 0,
  kArrowFunction = 1 << 0,
  kGeneratorFunction = 1 << 1,
  kConciseMethod = 1 << 2,
  kConciseGeneratorMethod = kGeneratorFunction | kConciseMethod,
  kDefaultConstructor = 1 << 3,
  kSubclassConstructor = 1 << 4,
  kBaseConstructor = 1 << 5,
  kGetterFunction = 1 << 6,
  kSetterFunction = 1 << 7,
  kAccessorFunction = kGetterFunction | kSetterFunction,
  kDefaultBaseConstructor = kDefaultConstructor | kBaseConstructor,
  kDefaultSubclassConstructor = kDefaultConstructor | kSubclassConstructor,
  kClassConstructor =
      kBaseConstructor | kSubclassConstructor | kDefaultConstructor,
};

inline bool IsValidFunctionKind(FunctionKind kind) {
  return kind == FunctionKind::kNormalFunction ||
         kind == FunctionKind::kArrowFunction ||
         kind == FunctionKind::kGeneratorFunction ||
         kind == FunctionKind::kConciseMethod ||
         kind == FunctionKind::kConciseGeneratorMethod ||
         kind == FunctionKind::kGetterFunction ||
         kind == FunctionKind::kSetterFunction ||
         kind == FunctionKind::kAccessorFunction ||
         kind == FunctionKind::kDefaultBaseConstructor ||
         kind == FunctionKind::kDefaultSubclassConstructor ||
         kind == FunctionKind::kBaseConstructor ||
         kind == FunctionKind::kSubclassConstructor;
}


inline bool IsArrowFunction(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 972, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kArrowFunction;
}


inline bool IsGeneratorFunction(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 978, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kGeneratorFunction;
}


inline bool IsConciseMethod(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 984, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kConciseMethod;
}

inline bool IsGetterFunction(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 989, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kGetterFunction;
}

inline bool IsSetterFunction(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 994, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kSetterFunction;
}

inline bool IsAccessorFunction(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 999, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kAccessorFunction;
}


inline bool IsDefaultConstructor(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 1005, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kDefaultConstructor;
}


inline bool IsBaseConstructor(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 1011, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kBaseConstructor;
}


inline bool IsSubclassConstructor(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 1017, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kSubclassConstructor;
}


inline bool IsClassConstructor(FunctionKind kind) {
  do { if ((!(IsValidFunctionKind(kind)))) { V8_Fatal(".././src/globals.h", 1023, "Check failed: %s.", "IsValidFunctionKind(kind)"); } } while (0);
  return kind & FunctionKind::kClassConstructor;
}


inline bool IsConstructable(FunctionKind kind, LanguageMode mode) {
  if (IsAccessorFunction(kind)) return false;
  if (IsConciseMethod(kind)) return false;
  if (IsArrowFunction(kind)) return false;
  if (IsGeneratorFunction(kind)) return false;
  return true;
}


inline uint32_t ObjectHash(Address address) {


  return static_cast<uint32_t>(bit_cast<uintptr_t>(address) >>
                               kPointerSizeLog2);
}

}
}

namespace i = v8::internal;

namespace v8 {
namespace internal {




struct JSArguments {
 public:
  inline const char*& operator[](int idx) const { return argv[idx]; }
  static JSArguments Create(int argc, const char** argv) {
    JSArguments args;
    args.argc = argc;
    args.argv = argv;
    return args;
  }
  int argc;
  const char** argv;
};

struct MaybeBoolFlag {
  static MaybeBoolFlag Create(bool has_value, bool value) {
    MaybeBoolFlag flag;
    flag.has_value = has_value;
    flag.value = value;
    return flag;
  }
  bool has_value;
  bool value;
};
extern bool FLAG_experimental_extras;



extern bool FLAG_use_strict;

extern bool FLAG_es_staging;

extern bool FLAG_harmony;
extern bool FLAG_harmony_shipping;


extern bool FLAG_promise_extra;
extern bool FLAG_harmony_object_observe; extern bool FLAG_harmony_function_sent; extern bool FLAG_harmony_sharedarraybuffer; extern bool FLAG_harmony_simd; extern bool FLAG_harmony_do_expressions; extern bool FLAG_harmony_regexp_property; extern bool FLAG_harmony_string_padding;





extern bool FLAG_harmony_regexp_lookbehind; extern bool FLAG_harmony_tailcalls; extern bool FLAG_harmony_object_values_entries; extern bool FLAG_harmony_object_own_property_descriptors; extern bool FLAG_harmony_exponentiation_operator;





extern bool FLAG_harmony_array_prototype_values; extern bool FLAG_harmony_function_name; extern bool FLAG_harmony_instanceof; extern bool FLAG_harmony_iterator_close; extern bool FLAG_harmony_unicode_regexps; extern bool FLAG_harmony_regexp_exec; extern bool FLAG_harmony_sloppy; extern bool FLAG_harmony_sloppy_let; extern bool FLAG_harmony_sloppy_function; extern bool FLAG_harmony_regexp_subclass; extern bool FLAG_harmony_restrictive_declarations; extern bool FLAG_harmony_species;
extern bool FLAG_compiled_keyed_generic_loads;

extern bool FLAG_allocation_site_pretenuring;

extern bool FLAG_trace_pretenuring;

extern bool FLAG_trace_pretenuring_statistics;

extern bool FLAG_track_fields;
extern bool FLAG_track_double_fields;
extern bool FLAG_track_heap_object_fields;
extern bool FLAG_track_computed_fields;
extern bool FLAG_harmony_instanceof_opt;



extern bool FLAG_track_field_types;


extern bool FLAG_smi_binop;


extern bool FLAG_optimize_for_size;






extern bool FLAG_unbox_double_arrays;
extern bool FLAG_string_slices;


extern bool FLAG_ignition;
extern bool FLAG_ignition_eager;
extern const char* FLAG_ignition_filter;
extern bool FLAG_print_bytecode;

extern bool FLAG_trace_ignition;

extern bool FLAG_trace_ignition_codegen;



extern bool FLAG_crankshaft;
extern const char* FLAG_hydrogen_filter;
extern bool FLAG_use_gvn;
extern int FLAG_gvn_iterations;
extern bool FLAG_use_canonicalizing;
extern bool FLAG_use_inlining;
extern bool FLAG_use_escape_analysis;
extern bool FLAG_use_allocation_folding;
extern bool FLAG_use_local_allocation_folding;
extern bool FLAG_use_write_barrier_elimination;

extern int FLAG_max_inlining_levels;
extern int FLAG_max_inlined_source_size;

extern int FLAG_max_inlined_nodes;

extern int FLAG_max_inlined_nodes_cumulative;

extern bool FLAG_loop_invariant_code_motion;
extern bool FLAG_fast_math;
extern bool FLAG_collect_megamorphic_maps_from_stub_cache;

extern bool FLAG_hydrogen_stats;
extern bool FLAG_trace_check_elimination;
extern bool FLAG_trace_environment_liveness;

extern bool FLAG_trace_hydrogen;
extern const char* FLAG_trace_hydrogen_filter;
extern bool FLAG_trace_hydrogen_stubs;
extern const char* FLAG_trace_hydrogen_file;
extern const char* FLAG_trace_phase;
extern bool FLAG_trace_inlining;
extern bool FLAG_trace_load_elimination;
extern bool FLAG_trace_store_elimination;
extern bool FLAG_trace_alloc;
extern bool FLAG_trace_all_uses;
extern bool FLAG_trace_range;
extern bool FLAG_trace_gvn;
extern bool FLAG_trace_representation;
extern bool FLAG_trace_removable_simulates;
extern bool FLAG_trace_escape_analysis;
extern bool FLAG_trace_allocation_folding;
extern bool FLAG_trace_track_allocation_sites;

extern bool FLAG_trace_migration;
extern bool FLAG_trace_generalization;
extern bool FLAG_stress_pointer_maps;
extern bool FLAG_stress_environments;
extern int FLAG_deopt_every_n_times;

extern int FLAG_deopt_every_n_garbage_collections;

extern bool FLAG_print_deopt_stress;
extern bool FLAG_trap_on_deopt;
extern bool FLAG_trap_on_stub_deopt;

extern bool FLAG_deoptimize_uncommon_cases;
extern bool FLAG_polymorphic_inlining;
extern bool FLAG_use_osr;
extern bool FLAG_array_bounds_checks_elimination;

extern bool FLAG_trace_bce;
extern bool FLAG_array_index_dehoisting;
extern bool FLAG_analyze_environment_liveness;

extern bool FLAG_load_elimination;
extern bool FLAG_check_elimination;
extern bool FLAG_store_elimination;
extern bool FLAG_dead_code_elimination;
extern bool FLAG_fold_constants;
extern bool FLAG_trace_dead_code_elimination;
extern bool FLAG_unreachable_code_elimination;
extern bool FLAG_trace_osr;
extern int FLAG_stress_runs;
extern bool FLAG_lookup_sample_by_shared;


extern bool FLAG_flush_optimized_code_cache;

extern bool FLAG_inline_construct;
extern bool FLAG_inline_arguments;
extern bool FLAG_inline_accessors;
extern int FLAG_escape_analysis_iterations;


extern bool FLAG_concurrent_recompilation;

extern bool FLAG_trace_concurrent_recompilation;

extern int FLAG_concurrent_recompilation_queue_length;

extern int FLAG_concurrent_recompilation_delay;

extern bool FLAG_block_concurrent_recompilation;


extern bool FLAG_omit_map_checks_for_leaf_maps;




extern bool FLAG_turbo;

extern bool FLAG_turbo_shipping;
extern bool FLAG_turbo_greedy_regalloc;
extern bool FLAG_turbo_sp_frame_access;

extern bool FLAG_turbo_preprocess_ranges;

extern bool FLAG_turbo_loop_stackcheck;
extern const char* FLAG_turbo_filter;
extern bool FLAG_trace_turbo;
extern bool FLAG_trace_turbo_graph;

extern const char* FLAG_trace_turbo_cfg_file;

extern bool FLAG_trace_turbo_types;
extern bool FLAG_trace_turbo_scheduler;
extern bool FLAG_trace_turbo_reduction;
extern bool FLAG_trace_turbo_jt;
extern bool FLAG_trace_turbo_ceq;
extern bool FLAG_turbo_asm;
extern bool FLAG_turbo_asm_deoptimization;

extern bool FLAG_turbo_verify;
extern bool FLAG_turbo_stats;
extern bool FLAG_turbo_splitting;
extern bool FLAG_turbo_types;
extern bool FLAG_turbo_source_positions;


extern bool FLAG_function_context_specialization;

extern bool FLAG_native_context_specialization;

extern bool FLAG_turbo_inlining;
extern bool FLAG_trace_turbo_inlining;
extern bool FLAG_loop_assignment_analysis;
extern bool FLAG_turbo_profiling;
extern bool FLAG_turbo_verify_allocation;

extern bool FLAG_turbo_move_optimization;
extern bool FLAG_turbo_jt;
extern bool FLAG_turbo_osr;
extern bool FLAG_turbo_stress_loop_peeling;

extern bool FLAG_turbo_cf_optimization;
extern bool FLAG_turbo_frame_elision;
extern bool FLAG_turbo_cache_shared_code;
extern bool FLAG_turbo_preserve_shared_code;
extern bool FLAG_turbo_escape;
extern bool FLAG_turbo_instruction_scheduling;

extern bool FLAG_turbo_stress_instruction_scheduling;



extern bool FLAG_expose_wasm;
extern bool FLAG_trace_wasm_encoder;
extern bool FLAG_trace_wasm_decoder;
extern bool FLAG_trace_wasm_decode_time;
extern bool FLAG_trace_wasm_compiler;
extern int FLAG_trace_wasm_ast_start;

extern int FLAG_trace_wasm_ast_end;
extern int FLAG_skip_compiling_wasm_funcs;
extern bool FLAG_wasm_break_on_decoder_error;

extern bool FLAG_wasm_loop_assignment_analysis;


extern bool FLAG_enable_simd_asmjs;

extern bool FLAG_dump_wasm_module;
extern const char* FLAG_dump_wasm_module_path;

extern int FLAG_typed_array_max_size_in_heap;



extern int FLAG_frame_count;

extern int FLAG_interrupt_budget;

extern int FLAG_type_info_threshold;

extern int FLAG_generic_ic_threshold;

extern int FLAG_self_opt_count;

extern bool FLAG_trace_opt_verbose;



extern bool FLAG_debug_code;
extern bool FLAG_code_comments;
extern bool FLAG_enable_sse3;
extern bool FLAG_enable_sse4_1;

extern bool FLAG_enable_sahf;

extern bool FLAG_enable_avx;
extern bool FLAG_enable_fma3;
extern bool FLAG_enable_bmi1;
extern bool FLAG_enable_bmi2;
extern bool FLAG_enable_lzcnt;
extern bool FLAG_enable_popcnt;

extern bool FLAG_enable_vfp3;

extern bool FLAG_enable_armv7;

extern bool FLAG_enable_armv8;

extern bool FLAG_enable_neon;

extern bool FLAG_enable_sudiv;

extern bool FLAG_enable_mls;

extern bool FLAG_enable_movw_movt;


extern bool FLAG_enable_unaligned_accesses;

extern bool FLAG_enable_32dregs;

extern bool FLAG_enable_vldr_imm;

extern bool FLAG_force_long_branches;

extern const char* FLAG_mcpu;
extern const char* FLAG_expose_natives_as;
extern const char* FLAG_expose_debug_as;
extern bool FLAG_expose_free_buffer;
extern bool FLAG_expose_gc;
extern const char* FLAG_expose_gc_as;


extern bool FLAG_expose_externalize_string;

extern bool FLAG_expose_trigger_failure;
extern int FLAG_stack_trace_limit;
extern bool FLAG_builtins_in_stack_traces;

extern bool FLAG_disable_native_files;


extern bool FLAG_inline_new;


extern bool FLAG_trace_codegen;

extern bool FLAG_trace;
extern bool FLAG_mask_constants_with_cookie;



extern bool FLAG_lazy;
extern bool FLAG_trace_opt;
extern bool FLAG_trace_opt_stats;
extern bool FLAG_opt;
extern bool FLAG_always_opt;
extern bool FLAG_always_osr;
extern bool FLAG_prepare_always_opt;
extern bool FLAG_trace_deopt;
extern bool FLAG_trace_stub_failures;


extern bool FLAG_serialize_toplevel;
extern bool FLAG_serialize_eager;
extern bool FLAG_serialize_age_code;
extern bool FLAG_trace_serializer;


extern int FLAG_min_preparse_length;

extern int FLAG_max_opt_count;



extern bool FLAG_compilation_cache;

extern bool FLAG_cache_prototype_transitions;


extern int FLAG_cpu_profiler_sampling_interval;



extern bool FLAG_trace_js_array_abuse;

extern bool FLAG_trace_external_array_abuse;

extern bool FLAG_trace_array_abuse;





extern bool FLAG_trace_debug_json;
extern bool FLAG_enable_liveedit;
extern bool FLAG_hard_abort;


extern int FLAG_stack_size;



extern int FLAG_max_stack_trace_source_length;



extern bool FLAG_always_inline_smi_code;

extern bool FLAG_verify_operand_stack_depth;




extern int FLAG_min_semi_space_size;


extern int FLAG_max_semi_space_size;


extern int FLAG_semi_space_growth_factor;
extern bool FLAG_experimental_new_space_growth_heuristic;


extern int FLAG_max_old_space_size;
extern int FLAG_initial_old_space_size;
extern int FLAG_max_executable_size;
extern bool FLAG_gc_global;
extern int FLAG_gc_interval;
extern int FLAG_retain_maps_for_n_gc;

extern bool FLAG_trace_gc;

extern bool FLAG_trace_gc_nvp;


extern bool FLAG_trace_gc_ignore_scavenger;

extern bool FLAG_trace_idle_notification;

extern bool FLAG_trace_idle_notification_verbose;

extern bool FLAG_print_cumulative_gc_stat;

extern bool FLAG_print_max_heap_committed;


extern bool FLAG_trace_gc_verbose;

extern int FLAG_trace_allocation_stack_interval;

extern bool FLAG_trace_fragmentation;
extern bool FLAG_trace_fragmentation_verbose;

extern bool FLAG_trace_evacuation;
extern bool FLAG_trace_mutator_utilization;

extern bool FLAG_weak_embedded_maps_in_optimized_code;

extern bool FLAG_weak_embedded_objects_in_optimized_code;

extern bool FLAG_flush_code;
extern bool FLAG_trace_code_flushing;
extern bool FLAG_age_code;


extern bool FLAG_incremental_marking;
extern int FLAG_min_progress_during_incremental_marking_finalization;


extern int FLAG_max_incremental_marking_finalization_rounds;

extern bool FLAG_black_allocation;
extern bool FLAG_concurrent_sweeping;
extern bool FLAG_parallel_compaction;
extern bool FLAG_parallel_pointer_update;

extern bool FLAG_trace_incremental_marking;

extern bool FLAG_track_gc_object_stats;

extern bool FLAG_trace_gc_object_stats;


extern bool FLAG_track_detached_contexts;

extern bool FLAG_trace_detached_contexts;



extern bool FLAG_verify_heap;

extern bool FLAG_move_object_start;
extern bool FLAG_memory_reducer;
extern bool FLAG_scavenge_reclaim_unmodified_objects;

extern int FLAG_heap_growing_percent;



extern int FLAG_histogram_interval;



extern bool FLAG_trace_object_groups;



extern bool FLAG_heap_profiler_trace_objects;




extern bool FLAG_sampling_heap_profiler_suppress_randomness;




extern bool FLAG_use_idle_notification;


extern bool FLAG_use_ic;
extern bool FLAG_trace_ic;


extern bool FLAG_native_code_counters;



extern bool FLAG_always_compact;
extern bool FLAG_never_compact;

extern bool FLAG_compact_code_space;
extern bool FLAG_cleanup_code_caches_at_gc;


extern bool FLAG_use_marking_progress_bar;


extern bool FLAG_zap_code_space;

extern int FLAG_random_seed;




extern bool FLAG_trace_weak_arrays;
extern bool FLAG_track_prototype_users;

extern bool FLAG_trace_prototype_users;

extern bool FLAG_eliminate_prototype_chain_checks;


extern bool FLAG_use_verbose_printer;
extern bool FLAG_trace_for_in_enumerate;

extern bool FLAG_trace_maps;



extern bool FLAG_allow_natives_syntax;
extern bool FLAG_trace_parse;


extern bool FLAG_trace_sim;
extern bool FLAG_debug_sim;
extern bool FLAG_check_icache;

extern int FLAG_stop_sim_at;






extern int FLAG_sim_stack_alignment;


extern int FLAG_sim_stack_size;


extern bool FLAG_log_regs_modified;

extern bool FLAG_log_colour;

extern bool FLAG_ignore_asm_unimplemented_break;

extern bool FLAG_trace_sim_messages;



extern bool FLAG_stack_trace_on_illegal;

extern bool FLAG_abort_on_uncaught_exception;

extern bool FLAG_randomize_hashes;


extern int FLAG_hash_seed;




extern bool FLAG_runtime_call_stats;


extern bool FLAG_profile_deserialization;

extern bool FLAG_serialization_statistics;



extern bool FLAG_regexp_optimization;


extern bool FLAG_testing_bool_flag;
extern MaybeBoolFlag FLAG_testing_maybe_bool_flag;
extern int FLAG_testing_int_flag;
extern double FLAG_testing_float_flag;
extern const char* FLAG_testing_string_flag;
extern int FLAG_testing_prng_seed;




extern const char* FLAG_testing_serialization_file;




extern const char* FLAG_startup_src;

extern const char* FLAG_startup_blob;



extern bool FLAG_profile_hydrogen_code_stub_compilation;


extern bool FLAG_predictable;






extern bool FLAG_force_marking_deque_overflows;



extern bool FLAG_stress_compaction;



extern bool FLAG_manual_evacuation_candidates_selection;




extern int FLAG_external_allocation_limit_incremental_time;



extern bool FLAG_disable_old_api_accessors;







extern bool FLAG_help;
extern bool FLAG_dump_counters;

extern const char* FLAG_map_counters;
extern JSArguments FLAG_js_arguments;
static bool const FLAG_gdbjit = false;
static bool const FLAG_gdbjit_full = false;
static bool const FLAG_gdbjit_dump = false;
static const char* const FLAG_gdbjit_dump_filter = "";
extern bool FLAG_enable_slow_asserts;




extern bool FLAG_print_source;
extern bool FLAG_print_builtin_source;

extern bool FLAG_print_ast;
extern bool FLAG_print_builtin_ast;
extern bool FLAG_trap_on_abort;


extern bool FLAG_print_builtin_scopes;
extern bool FLAG_print_scopes;


extern bool FLAG_trace_contexts;


extern bool FLAG_gc_verbose;
extern bool FLAG_heap_stats;
extern bool FLAG_code_stats;
extern bool FLAG_print_handles;
extern bool FLAG_check_handle_count;

extern bool FLAG_print_global_handles;


extern bool FLAG_print_turbo_replay;

extern bool FLAG_trace_turbo_escape;


extern bool FLAG_trace_normalization;



extern bool FLAG_trace_lazy;


extern bool FLAG_collect_heap_spill_statistics;


extern bool FLAG_trace_live_bytes;


extern bool FLAG_trace_isolates;


extern bool FLAG_regexp_possessive_quantifier;

extern bool FLAG_trace_regexp_bytecodes;
extern bool FLAG_trace_regexp_assembler;

extern bool FLAG_trace_regexp_parser;


extern bool FLAG_print_break_location;
extern bool FLAG_log;

extern bool FLAG_log_all;
extern bool FLAG_log_api;
extern bool FLAG_log_code;

extern bool FLAG_log_gc;

extern bool FLAG_log_handles;
extern bool FLAG_log_suspect;
extern bool FLAG_prof;

extern bool FLAG_prof_cpp;

extern bool FLAG_prof_browser_mode;

extern bool FLAG_log_regexp;
extern const char* FLAG_logfile;
extern bool FLAG_logfile_per_isolate;
extern bool FLAG_ll_prof;
extern bool FLAG_perf_basic_prof;


extern bool FLAG_perf_basic_prof_only_functions;


extern bool FLAG_perf_prof;


extern bool FLAG_perf_prof_debug_info;

extern const char* FLAG_gc_fake_mmap;

extern bool FLAG_log_internal_timer_events;
extern bool FLAG_log_timer_events;



extern bool FLAG_log_instruction_stats;
extern const char* FLAG_log_instruction_file;

extern int FLAG_log_instruction_period;


extern bool FLAG_redirect_code_traces;


extern const char* FLAG_redirect_code_traces_to;


extern bool FLAG_hydrogen_track_positions;
extern bool FLAG_trace_elements_transitions;

extern bool FLAG_trace_creation_allocation_sites;



extern bool FLAG_print_code_stubs;
extern bool FLAG_test_secondary_stub_cache;


extern bool FLAG_test_primary_stub_cache;




extern bool FLAG_print_code;
extern bool FLAG_print_opt_code;
extern bool FLAG_print_unopt_code;


extern bool FLAG_print_code_verbose;
extern bool FLAG_print_builtin_code;


extern bool FLAG_sodium;
extern bool FLAG_print_all_code;
static bool const FLAG_verify_predictable = false;

static int const FLAG_dump_allocations_digest_at_alloc = -1;
static bool const FLAG_enable_embedded_constant_pool = 0;


static bool const FLAG_unbox_double_fields = 1;



static bool const FLAG_global_var_shortcuts = false;


class FlagList {
 public:







  static List<const char*>* argv();
  static int SetFlagsFromCommandLine(int* argc,
                                     char** argv,
                                     bool remove_flags);




  static int SetFlagsFromString(const char* str, int len);


  static void ResetAllFlags();


  static void PrintHelp();


  static void EnforceFlagImplications();



  static uint32_t Hash();
};

}
}






#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
#pragma map (getlogin, "\174\174GETLG2")
#pragma map (__getlogin1, "\174\174GETLOG")
#pragma map (__pid_affinity,"\174\174PID\174AF")


#pragma map(__login_applid,"\174\174LOGNAP")

#pragma map(__certificate,"\174\174CERTIF")
 void _exit(int);
           int access(const char *, int );
           int __certificate(int, int, char *, ...);
           unsigned int alarm(unsigned int);
           int chdir(const char *);
           int chown(const char *, uid_t, gid_t);
           int close(int);
           char *ctermid(char *);
           int dup(int);
           int dup2(int, int);
           int execl(const char *, const char *, ... );
           int execle(const char *, const char *, ... );
           int execlp(const char *, const char *, ... );
           int execv(const char *, char *const []);
           int execve(const char *, char *const [], char * const []);
           int execvp(const char *, char *const [] );
           pid_t fork(void);
           long fpathconf(int, int);
           char *getcwd(char *, size_t);
           gid_t getegid(void);
           uid_t geteuid(void);
           gid_t getgid(void);
           int getgroups(int, gid_t []);




           char *__getlogin1(void);
           char *getlogin(void);
           pid_t getpgrp(void);
           pid_t getpid(void);
           pid_t getppid(void);
           uid_t getuid(void);
           int isatty(int);
           int link(const char *, const char *);
           int __login(int, int, int, void *, int, char *,
                         int, char *, int);
           off_t lseek(int, off_t, int);
           long pathconf(const char *, int);
           int pause(void);
           int __pid_affinity(int, pid_t, pid_t, int);
           int pipe(int [2]);
           ssize_t read(int, void *, size_t);
           int rmdir(const char *);
           int setgid(gid_t);
           int setpgid(pid_t, pid_t);
           pid_t setsid(void);
           int setuid(uid_t);
           unsigned int sleep(unsigned int );
           long sysconf(int);
           pid_t tcgetpgrp(int);
           int tcsetpgrp(int, pid_t);
           char *ttyname(int);
           int unlink(const char *);
           ssize_t write(int, const void *, size_t);


         int __login_applid (int, int, int, void *, int, char *, int, char *, int, const char *);
           int fchown(int , uid_t, gid_t);
           int fsync(int);
           int ftruncate(int, off_t);
           int readlink(const char *, char *, size_t );
           int setegid(gid_t);
           int seteuid(uid_t);
           int symlink(const char *, const char *);
          extern char *optarg;
          extern int optind, opterr, optopt;
             void __cnvblk(char [], char [], int);

               int chroot(const char *);

             char *crypt(const char *, const char *);
             void encrypt(char [64], int);
             int nice(int);

           extern char **__opargf(void);
           extern int *__operrf(void);
           extern int *__opindf(void);
           extern int *__opoptf(void);
           size_t confstr(int, char *, size_t);

             char *cuserid(char *);




           int getopt(int, char * const [], const char *);

             char *getpass(const char *);

           void swab(const void *,
                                   void *, ssize_t);


#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
          typedef struct {
            intmax_t quot;
            intmax_t rem;
          }imaxdiv_t;
        intmax_t imaxabs (intmax_t);
        imaxdiv_t imaxdiv (intmax_t,intmax_t);
        intmax_t strtoimax (const char * , char ** , int);



        uintmax_t strtoumax (const char * , char ** , int);



        intmax_t wcstoimax (const wchar_t * , wchar_t ** , int);



        uintmax_t wcstoumax (const wchar_t * , wchar_t ** , int);
    extern "C++" {






    }





    }


#pragma checkout(resume)
             int fchdir(int);

               int getdtablesize(void);

             pid_t getpgid(pid_t);
             pid_t getsid(pid_t);
             char *getwd(char *);
             int lchown(const char *, uid_t, gid_t);
             int setregid(gid_t, gid_t);
             int setreuid(uid_t, uid_t);
             void sync(void);
             int truncate(const char *, off_t);
             useconds_t ualarm(useconds_t, useconds_t);
             int getpagesize(void);
           int lockf(int, int, off_t);
           pid_t setpgrp(void);
           int usleep(useconds_t);
           pid_t vfork(void);
      int getlogin_r (char *, size_t );




      int ttyname_r (int, char *, size_t );
      ssize_t pread (int, void *, size_t, off_t);





      ssize_t pwrite (int, const void *, size_t, off_t);
      int __atoe(char *);
      int __atoe_l(char *, int);
      int __check_resource_auth_np(char *, char *, char *,
                                            char *, char *, int);
      int __convert_id_np( int, char *, char *, char *);
      int __etoa(char *);
      int __etoa_l(char *, int);
      int __isPosixOn(void);
      int __openMvsRel(void);
      int __openVmRel(void);
      int __smf_record(int, int, int, char *);
      int __wsinit(void (*)());


    int __smf_record2 (int, int, int, char *, unsigned int);
      size_t __a2e_s (char *);
      size_t __e2a_s (char *);
      size_t __a2e_l (char *, size_t);
      size_t __e2a_l (char *, size_t);
          long gethostid(void);
          int gethostname(char *, size_t);
  }


#pragma checkout(resume)




















namespace std { inline namespace __1 {

template <bool> class __split_buffer_common {
protected:
  void __throw_length_error() const;
  void __throw_out_of_range() const;
};

template <class _Tp, class _Allocator = allocator<_Tp>>
struct __split_buffer : private __split_buffer_common<true> {
private:
  __split_buffer(const __split_buffer &);
  __split_buffer &operator=(const __split_buffer &);

public:
  typedef _Tp value_type;
  typedef _Allocator allocator_type;
  typedef typename remove_reference<allocator_type>::type __alloc_rr;
  typedef allocator_traits<__alloc_rr> __alloc_traits;
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;

  pointer __first_;
  pointer __begin_;
  pointer __end_;
  __compressed_pair<pointer, allocator_type> __end_cap_;

  typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
  typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;

  __attribute__((__visibility__("hidden"), __always_inline__)) __alloc_rr &__alloc() noexcept {
    return __end_cap_.second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const __alloc_rr &__alloc() const noexcept {
    return __end_cap_.second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer &__end_cap() noexcept {
    return __end_cap_.first();
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const pointer &__end_cap() const noexcept {
    return __end_cap_.first();
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __split_buffer()
      noexcept(is_nothrow_default_constructible<allocator_type>::value);
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __split_buffer(__alloc_rr &__a);
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __split_buffer(const __alloc_rr &__a);
  __split_buffer(size_type __cap, size_type __start, __alloc_rr &__a);
  ~__split_buffer();


  __split_buffer(__split_buffer &&__c)
      noexcept(is_nothrow_move_constructible<allocator_type>::value);
  __split_buffer(__split_buffer &&__c, const __alloc_rr &__a);
  __split_buffer &operator=(__split_buffer &&__c) noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value);





  __attribute__((__visibility__("hidden"), __always_inline__)) iterator begin() noexcept { return __begin_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator begin() const noexcept {
    return __begin_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator end() noexcept { return __end_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator end() const noexcept {
    return __end_;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept { __destruct_at_end(__begin_); }
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type size() const {
    return static_cast<size_type>(__end_ - __begin_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) bool empty() const { return __end_ == __begin_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type capacity() const {
    return static_cast<size_type>(__end_cap() - __first_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type __front_spare() const {
    return static_cast<size_type>(__begin_ - __first_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type __back_spare() const {
    return static_cast<size_type>(__end_cap() - __end_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) reference front() { return *__begin_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference front() const { return *__begin_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference back() { return *(__end_ - 1); }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference back() const {
    return *(__end_ - 1);
  }

  void reserve(size_type __n);
  void shrink_to_fit() noexcept;
  void push_front(const_reference __x);
  __attribute__((__visibility__("hidden"), __always_inline__)) void push_back(const_reference __x);

  void push_front(value_type &&__x);
  void push_back(value_type &&__x);

  template <class... _Args> void emplace_back(_Args &&... __args);



  __attribute__((__visibility__("hidden"), __always_inline__)) void pop_front() {
    __destruct_at_begin(__begin_ + 1);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) void pop_back() { __destruct_at_end(__end_ - 1); }

  void __construct_at_end(size_type __n);
  void __construct_at_end(size_type __n, const_reference __x);
  template <class _InputIter>
  typename enable_if<__is_input_iterator<_InputIter>::value &&
                         !__is_forward_iterator<_InputIter>::value,
                     void>::type
  __construct_at_end(_InputIter __first, _InputIter __last);
  template <class _ForwardIterator>
  typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type
  __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

  __attribute__((__visibility__("hidden"), __always_inline__)) void __destruct_at_begin(pointer __new_begin) {
    __destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __destruct_at_begin(pointer __new_begin, false_type);
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __destruct_at_begin(pointer __new_begin, true_type);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __destruct_at_end(pointer __new_last) noexcept {
    __destruct_at_end(__new_last, false_type());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __destruct_at_end(pointer __new_last, false_type) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __destruct_at_end(pointer __new_last, true_type) noexcept;

  void swap(__split_buffer &__x)
      noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<__alloc_rr>::value);


  bool __invariants() const;

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__split_buffer &__c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::__1::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__split_buffer &, false_type) noexcept {}
};

template <class _Tp, class _Allocator>
bool __split_buffer<_Tp, _Allocator>::__invariants() const {
  if (__first_ == nullptr) {
    if (__begin_ != nullptr)
      return false;
    if (__end_ != nullptr)
      return false;
    if (__end_cap() != nullptr)
      return false;
  } else {
    if (__begin_ < __first_)
      return false;
    if (__end_ < __begin_)
      return false;
    if (__end_cap() < __end_)
      return false;
  }
  return true;
}






template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n) {
  __alloc_rr &__a = this->__alloc();
  do {
    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_));
    ++this->__end_;
    --__n;
  } while (__n > 0);
}







template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n,
                                                         const_reference __x) {
  __alloc_rr &__a = this->__alloc();
  do {
    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), __x);
    ++this->__end_;
    --__n;
  } while (__n > 0);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename enable_if<__is_input_iterator<_InputIter>::value &&
                       !__is_forward_iterator<_InputIter>::value,
                   void>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first,
                                                    _InputIter __last) {
  __alloc_rr &__a = this->__alloc();
  for (; __first != __last; ++__first) {
    if (__end_ == __end_cap()) {
      size_type __old_cap = __end_cap() - __first_;
      size_type __new_cap = std::__1::max<size_type>(2 * __old_cap, 8);
      __split_buffer __buf(__new_cap, 0, __a);
      for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)
        __alloc_traits::construct(__buf.__alloc(),
                                  std::__1::__to_raw_pointer(__buf.__end_),
                                  std::__1::move(*__p));
      swap(__buf);
    }
    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_),
                              *__first);
    ++this->__end_;
  }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first,
                                                    _ForwardIterator __last) {
  __alloc_rr &__a = this->__alloc();
  for (; __first != __last; ++__first) {
    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_),
                              *__first);
    ++this->__end_;
  }
}

template <class _Tp, class _Allocator>
inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin,
                                                     false_type) {
  while (__begin_ != __new_begin)
    __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));
}

template <class _Tp, class _Allocator>
inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin,
                                                     true_type) {
  __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last,
                                                   false_type) noexcept {
  while (__new_last != __end_)
    __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last,
                                                   true_type) noexcept {
  __end_ = __new_last;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap,
                                                size_type __start,
                                                __alloc_rr &__a)
    : __end_cap_(nullptr, __a) {
  __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;
  __begin_ = __end_ = __first_ + __start;
  __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
inline __split_buffer<_Tp, _Allocator>::__split_buffer()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr),
      __end_cap_(nullptr) {}

template <class _Tp, class _Allocator>
inline __split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr &__a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr),
      __end_cap_(nullptr, __a) {}

template <class _Tp, class _Allocator>
inline __split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr &__a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr),
      __end_cap_(nullptr, __a) {}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::~__split_buffer() {
  clear();
  if (__first_)
    __alloc_traits::deallocate(__alloc(), __first_, capacity());
}



template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer &&__c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __first_(std::__1::move(__c.__first_)), __begin_(std::__1::move(__c.__begin_)),
      __end_(std::__1::move(__c.__end_)), __end_cap_(std::__1::move(__c.__end_cap_)) {
  __c.__first_ = nullptr;
  __c.__begin_ = nullptr;
  __c.__end_ = nullptr;
  __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer &&__c,
                                                const __alloc_rr &__a)
    : __end_cap_(__a) {
  if (__a == __c.__alloc()) {
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __c.__first_ = nullptr;
    __c.__begin_ = nullptr;
    __c.__end_ = nullptr;
    __c.__end_cap() = nullptr;
  } else {
    size_type __cap = __c.size();
    __first_ = __alloc_traits::allocate(__alloc(), __cap);
    __begin_ = __end_ = __first_;
    __end_cap() = __first_ + __cap;
    typedef move_iterator<iterator> _Ip;
    __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
  }
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator> &__split_buffer<_Tp, _Allocator>::
operator=(__split_buffer &&__c)
    noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value) {


  clear();
  shrink_to_fit();
  __first_ = __c.__first_;
  __begin_ = __c.__begin_;
  __end_ = __c.__end_;
  __end_cap() = __c.__end_cap();
  __move_assign_alloc(
      __c,
      integral_constant<
          bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
  __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
  return *this;
}



template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::swap(__split_buffer &__x)
    noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<__alloc_rr>::value) {

  std::__1::swap(__first_, __x.__first_);
  std::__1::swap(__begin_, __x.__begin_);
  std::__1::swap(__end_, __x.__end_);
  std::__1::swap(__end_cap(), __x.__end_cap());
  __swap_allocator(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::reserve(size_type __n) {
  if (__n < capacity()) {
    __split_buffer<value_type, __alloc_rr &> __t(__n, 0, __alloc());
    __t.__construct_at_end(move_iterator<pointer>(__begin_),
                           move_iterator<pointer>(__end_));
    std::__1::swap(__first_, __t.__first_);
    std::__1::swap(__begin_, __t.__begin_);
    std::__1::swap(__end_, __t.__end_);
    std::__1::swap(__end_cap(), __t.__end_cap());
  }
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::shrink_to_fit() noexcept {
  if (capacity() > size()) {

    try {

      __split_buffer<value_type, __alloc_rr &> __t(size(), 0, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      __t.__end_ = __t.__begin_ + (__end_ - __begin_);
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());

    } catch (...) {
    }

  }
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::push_front(const_reference __x) {
  if (__begin_ == __first_) {
    if (__end_ < __end_cap()) {
      difference_type __d = __end_cap() - __end_;
      __d = (__d + 1) / 2;
      __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
      __end_ += __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, (__c + 3) / 4,
                                                   __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__begin_ - 1),
                            __x);
  --__begin_;
}



template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::push_front(value_type &&__x) {
  if (__begin_ == __first_) {
    if (__end_ < __end_cap()) {
      difference_type __d = __end_cap() - __end_;
      __d = (__d + 1) / 2;
      __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
      __end_ += __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, (__c + 3) / 4,
                                                   __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__begin_ - 1),
                            std::__1::move(__x));
  --__begin_;
}



template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x) {
  if (__end_ == __end_cap()) {
    if (__begin_ > __first_) {
      difference_type __d = __begin_ - __first_;
      __d = (__d + 1) / 2;
      __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
      __begin_ -= __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, __c / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__end_), __x);
  ++__end_;
}



template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::push_back(value_type &&__x) {
  if (__end_ == __end_cap()) {
    if (__begin_ > __first_) {
      difference_type __d = __begin_ - __first_;
      __d = (__d + 1) / 2;
      __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
      __begin_ -= __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, __c / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__end_),
                            std::__1::move(__x));
  ++__end_;
}



template <class _Tp, class _Allocator>
template <class... _Args>
void __split_buffer<_Tp, _Allocator>::emplace_back(_Args &&... __args) {
  if (__end_ == __end_cap()) {
    if (__begin_ > __first_) {
      difference_type __d = __begin_ - __first_;
      __d = (__d + 1) / 2;
      __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
      __begin_ -= __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, __c / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_raw_pointer(__end_),
                            std::__1::forward<_Args>(__args)...);
  ++__end_;
}





template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(__split_buffer<_Tp, _Allocator> &__x,
                                           __split_buffer<_Tp, _Allocator> &__y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

} }


namespace std { inline namespace __1 {

template <bool> class __vector_base_common {
protected:
  __attribute__((__visibility__("hidden"), __always_inline__)) __vector_base_common() {}
  [[noreturn]] void __throw_length_error() const;
  [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void __vector_base_common<__b>::__throw_length_error() const {
  std::__1::__throw_length_error("vector");
}

template <bool __b>
void __vector_base_common<__b>::__throw_out_of_range() const {
  std::__1::__throw_out_of_range("vector");
}





extern template class __vector_base_common<true>;





template <class _Tp, class _Allocator>
class __vector_base : protected __vector_base_common<true> {
protected:
  typedef _Tp value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;

  pointer __begin_;
  pointer __end_;
  __compressed_pair<pointer, allocator_type> __end_cap_;

  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type &__alloc() noexcept { return __end_cap_.second(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const allocator_type &__alloc() const noexcept {
    return __end_cap_.second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pointer &__end_cap() noexcept { return __end_cap_.first(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const pointer &__end_cap() const noexcept { return __end_cap_.first(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __vector_base()
      noexcept(is_nothrow_default_constructible<allocator_type>::value);
  __attribute__((__visibility__("hidden"), __always_inline__)) __vector_base(const allocator_type &__a);
  ~__vector_base();

  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept { __destruct_at_end(__begin_); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type capacity() const noexcept {
    return static_cast<size_type>(__end_cap() - __begin_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __destruct_at_end(pointer __new_last) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const __vector_base &__c) {
    __copy_assign_alloc(
        __c,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__vector_base &__c) noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value) {


    __move_assign_alloc(
        __c,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_move_assignment::value>());
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const __vector_base &__c, true_type) {
    if (__alloc() != __c.__alloc()) {
      clear();
      __alloc_traits::deallocate(__alloc(), __begin_, capacity());
      __begin_ = __end_ = __end_cap() = nullptr;
    }
    __alloc() = __c.__alloc();
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const __vector_base &, false_type) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__vector_base &__c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::__1::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__vector_base &, false_type) noexcept {}
};

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
__vector_base<_Tp, _Allocator>::__destruct_at_end(
    pointer __new_last) noexcept {
  while (__new_last != __end_)
    __alloc_traits::destroy(__alloc(), std::__1::__to_raw_pointer(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) __vector_base<_Tp, _Allocator>::__vector_base()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr) {}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type &__a)
    : __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a) {}

template <class _Tp, class _Allocator>
__vector_base<_Tp, _Allocator>::~__vector_base() {
  if (__begin_ != nullptr) {
    clear();
    __alloc_traits::deallocate(__alloc(), __begin_, capacity());
  }
}

template <class _Tp, class _Allocator >
class __attribute__((__visibility__("default"))) vector : private __vector_base<_Tp, _Allocator> {
private:
  typedef __vector_base<_Tp, _Allocator> __base;
  typedef allocator<_Tp> __default_allocator_type;

public:
  typedef vector __self;
  typedef _Tp value_type;
  typedef _Allocator allocator_type;
  typedef typename __base::__alloc_traits __alloc_traits;
  typedef typename __base::reference reference;
  typedef typename __base::const_reference const_reference;
  typedef typename __base::size_type size_type;
  typedef typename __base::difference_type difference_type;
  typedef typename __base::pointer pointer;
  typedef typename __base::const_pointer const_pointer;
  typedef __wrap_iter<pointer> iterator;
  typedef __wrap_iter<const_pointer> const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

  __attribute__((__visibility__("hidden"), __always_inline__))
  vector() noexcept(is_nothrow_default_constructible<allocator_type>::value) {



  }
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit vector(const allocator_type &__a)

      noexcept(is_nothrow_copy_constructible<allocator_type>::value)



      : __base(__a) {



  }
  explicit vector(size_type __n);



  vector(size_type __n, const_reference __x);
  vector(size_type __n, const_reference __x, const allocator_type &__a);
  template <class _InputIterator>
  vector(
      _InputIterator __first,
      typename enable_if<
          __is_input_iterator<_InputIterator>::value &&
              !__is_forward_iterator<_InputIterator>::value &&
              is_constructible<
                  value_type,
                  typename iterator_traits<_InputIterator>::reference>::value,
          _InputIterator>::type __last);
  template <class _InputIterator>
  vector(
      _InputIterator __first, _InputIterator __last, const allocator_type &__a,
      typename enable_if<
          __is_input_iterator<_InputIterator>::value &&
          !__is_forward_iterator<_InputIterator>::value &&
          is_constructible<value_type,
                           typename iterator_traits<
                               _InputIterator>::reference>::value>::type * = 0);
  template <class _ForwardIterator>
  vector(
      _ForwardIterator __first,
      typename enable_if<
          __is_forward_iterator<_ForwardIterator>::value &&
              is_constructible<
                  value_type,
                  typename iterator_traits<_ForwardIterator>::reference>::value,
          _ForwardIterator>::type __last);
  template <class _ForwardIterator>
  vector(_ForwardIterator __first, _ForwardIterator __last,
         const allocator_type &__a,
         typename enable_if<
             __is_forward_iterator<_ForwardIterator>::value &&
             is_constructible<value_type,
                              typename iterator_traits<_ForwardIterator>::
                                  reference>::value>::type * = 0);

  __attribute__((__visibility__("hidden"), __always_inline__))
  vector(initializer_list<value_type> __il);
  __attribute__((__visibility__("hidden"), __always_inline__))
  vector(initializer_list<value_type> __il, const allocator_type &__a);






  vector(const vector &__x);
  vector(const vector &__x, const allocator_type &__a);
  __attribute__((__visibility__("hidden"), __always_inline__))
  vector &operator=(const vector &__x);

  __attribute__((__visibility__("hidden"), __always_inline__))
  vector(vector &&__x)



      noexcept(is_nothrow_move_constructible<allocator_type>::value);

  __attribute__((__visibility__("hidden"), __always_inline__))
  vector(vector &&__x, const allocator_type &__a);
  __attribute__((__visibility__("hidden"), __always_inline__))
  vector &operator=(vector &&__x) noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));



  __attribute__((__visibility__("hidden"), __always_inline__))
  vector &operator=(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
    return *this;
  }


  template <class _InputIterator>
  typename enable_if<
      __is_input_iterator<_InputIterator>::value &&
          !__is_forward_iterator<_InputIterator>::value &&
          is_constructible<value_type, typename iterator_traits<
                                           _InputIterator>::reference>::value,
      void>::type
  assign(_InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<
      __is_forward_iterator<_ForwardIterator>::value &&
          is_constructible<value_type, typename iterator_traits<
                                           _ForwardIterator>::reference>::value,
      void>::type
  assign(_ForwardIterator __first, _ForwardIterator __last);

  void assign(size_type __n, const_reference __u);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void assign(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type get_allocator() const noexcept { return this->__alloc(); }

  __attribute__((__visibility__("hidden"), __always_inline__)) iterator begin() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator begin() const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator end() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator end() const noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crend() const noexcept { return rend(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type size() const noexcept {
    return static_cast<size_type>(this->__end_ - this->__begin_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type capacity() const noexcept { return __base::capacity(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool empty() const noexcept { return this->__begin_ == this->__end_; }
  size_type max_size() const noexcept;
  void reserve(size_type __n);
  void shrink_to_fit() noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __n);
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference operator[](size_type __n) const;
  reference at(size_type __n);
  const_reference at(size_type __n) const;

  __attribute__((__visibility__("hidden"), __always_inline__)) reference front() {
    ((void)0);
    return *this->__begin_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference front() const {
    ((void)0);
    return *this->__begin_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference back() {
    ((void)0);
    return *(this->__end_ - 1);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference back() const {
    ((void)0);
    return *(this->__end_ - 1);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  value_type *data() noexcept {
    return std::__1::__to_raw_pointer(this->__begin_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const value_type *data() const noexcept {
    return std::__1::__to_raw_pointer(this->__begin_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) void push_back(const_reference __x);

  __attribute__((__visibility__("hidden"), __always_inline__)) void push_back(value_type &&__x);

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) reference emplace_back(_Args &&... __args);


  __attribute__((__visibility__("hidden"), __always_inline__))
  void pop_back();

  iterator insert(const_iterator __position, const_reference __x);

  iterator insert(const_iterator __position, value_type &&__x);

  template <class... _Args>
  iterator emplace(const_iterator __position, _Args &&... __args);


  iterator insert(const_iterator __position, size_type __n,
                  const_reference __x);
  template <class _InputIterator>
  typename enable_if<
      __is_input_iterator<_InputIterator>::value &&
          !__is_forward_iterator<_InputIterator>::value &&
          is_constructible<value_type, typename iterator_traits<
                                           _InputIterator>::reference>::value,
      iterator>::type
  insert(const_iterator __position, _InputIterator __first,
         _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<
      __is_forward_iterator<_ForwardIterator>::value &&
          is_constructible<value_type, typename iterator_traits<
                                           _ForwardIterator>::reference>::value,
      iterator>::type
  insert(const_iterator __position, _ForwardIterator __first,
         _ForwardIterator __last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __position,
                  initializer_list<value_type> __il) {
    return insert(__position, __il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"), __always_inline__)) iterator erase(const_iterator __position);
  iterator erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept {
    size_type __old_size = size();
    __base::clear();
    __annotate_shrink(__old_size);
    __invalidate_all_iterators();
  }

  void resize(size_type __sz);
  void resize(size_type __sz, const_reference __x);

  void swap(vector &)



      noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value);



  bool __invariants() const;
private:
  __attribute__((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
  void allocate(size_type __n);
  void deallocate() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type __recommend(size_type __new_size) const;
  void __construct_at_end(size_type __n);
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __construct_at_end(size_type __n, const_reference __x);
  template <class _ForwardIterator>
  typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type
  __construct_at_end(_ForwardIterator __first, _ForwardIterator __last,
                     size_type __n);
  void __append(size_type __n);
  void __append(size_type __n, const_reference __x);
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator __make_iter(pointer __p) noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator __make_iter(const_pointer __p) const noexcept;
  void
  __swap_out_circular_buffer(__split_buffer<value_type, allocator_type &> &__v);
  pointer
  __swap_out_circular_buffer(__split_buffer<value_type, allocator_type &> &__v,
                             pointer __p);
  void __move_range(pointer __from_s, pointer __from_e, pointer __to);
  void __move_assign(vector &__c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value);
  void __move_assign(vector &__c, false_type)
      noexcept(__alloc_traits::is_always_equal::value);
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __destruct_at_end(pointer __new_last) noexcept {
    size_type __old_size = size();
    __base::__destruct_at_end(__new_last);
    __annotate_shrink(__old_size);
  }
  template <class _Up>
  void

  __push_back_slow_path(_Up &&__x);





  template <class... _Args> void __emplace_back_slow_path(_Args &&... __args);







  void __annotate_contiguous_container(const void *__beg, const void *__end,
                                       const void *__old_mid,
                                       const void *__new_mid) const {





  }

  void __annotate_new(size_type __current_size) const {
    __annotate_contiguous_container(data(), data() + capacity(),
                                    data() + capacity(),
                                    data() + __current_size);
  }
  void __annotate_delete() const {
    __annotate_contiguous_container(data(), data() + capacity(),
                                    data() + size(), data() + capacity());
  }
  void __annotate_increase(size_type __n) const {
    __annotate_contiguous_container(data(), data() + capacity(),
                                    data() + size(), data() + size() + __n);
  }
  void __annotate_shrink(size_type __old_size) const {
    __annotate_contiguous_container(data(), data() + capacity(),
                                    data() + __old_size, data() + size());
  }
  struct __RAII_IncreaseAnnotator {
    inline __RAII_IncreaseAnnotator(const vector &, size_type __n = 1) {}
    inline void __done() {}
  };

};

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__swap_out_circular_buffer(
    __split_buffer<value_type, allocator_type &> &__v) {
  __annotate_delete();
  __alloc_traits::__construct_backward(this->__alloc(), this->__begin_,
                                       this->__end_, __v.__begin_);
  std::__1::swap(this->__begin_, __v.__begin_);
  std::__1::swap(this->__end_, __v.__end_);
  std::__1::swap(this->__end_cap(), __v.__end_cap());
  __v.__first_ = __v.__begin_;
  __annotate_new(size());
  __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(
    __split_buffer<value_type, allocator_type &> &__v, pointer __p) {
  __annotate_delete();
  pointer __r = __v.__begin_;
  __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p,
                                       __v.__begin_);
  __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_,
                                      __v.__end_);
  std::__1::swap(this->__begin_, __v.__begin_);
  std::__1::swap(this->__end_, __v.__end_);
  std::__1::swap(this->__end_cap(), __v.__end_cap());
  __v.__first_ = __v.__begin_;
  __annotate_new(size());
  __invalidate_all_iterators();
  return __r;
}
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::allocate(size_type __n) {
  if (__n > max_size())
    this->__throw_length_error();
  this->__begin_ = this->__end_ =
      __alloc_traits::allocate(this->__alloc(), __n);
  this->__end_cap() = this->__begin_ + __n;
  __annotate_new(0);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::deallocate() noexcept {
  if (this->__begin_ != nullptr) {
    clear();
    __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
    this->__begin_ = this->__end_ = this->__end_cap() = nullptr;
  }
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const noexcept {
  return std::__1::min<size_type>(__alloc_traits::max_size(this->__alloc()),
                               numeric_limits<size_type>::max() /
                                   2);
}


template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const {
  const size_type __ms = max_size();
  if (__new_size > __ms)
    this->__throw_length_error();
  const size_type __cap = capacity();
  if (__cap >= __ms / 2)
    return __ms;
  return std::__1::max<size_type>(2 * __cap, __new_size);
}






template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__construct_at_end(size_type __n) {
  allocator_type &__a = this->__alloc();
  do {
    __RAII_IncreaseAnnotator __annotator(*this);
    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_));
    ++this->__end_;
    --__n;
    __annotator.__done();
  } while (__n > 0);
}







template <class _Tp, class _Allocator>
inline void vector<_Tp, _Allocator>::__construct_at_end(size_type __n,
                                                        const_reference __x) {
  allocator_type &__a = this->__alloc();
  do {
    __RAII_IncreaseAnnotator __annotator(*this);
    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_), __x);
    ++this->__end_;
    --__n;
    __annotator.__done();
  } while (__n > 0);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first,
                                            _ForwardIterator __last,
                                            size_type __n) {
  allocator_type &__a = this->__alloc();
  __RAII_IncreaseAnnotator __annotator(*this, __n);
  __alloc_traits::__construct_range_forward(__a, __first, __last, this->__end_);
  __annotator.__done();
}





template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__append(size_type __n) {
  if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
    this->__construct_at_end(__n);
  else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + __n),
                                                     size(), __a);
    __v.__construct_at_end(__n);
    __swap_out_circular_buffer(__v);
  }
}





template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x) {
  if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
    this->__construct_at_end(__n, __x);
  else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + __n),
                                                     size(), __a);
    __v.__construct_at_end(__n, __x);
    __swap_out_circular_buffer(__v);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n) {



  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__n);
  }
}
template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x) {



  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const_reference __x,
                                const allocator_type &__a)
    : __base(__a) {



  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(
    _InputIterator __first,
    typename enable_if<
        __is_input_iterator<_InputIterator>::value &&
            !__is_forward_iterator<_InputIterator>::value &&
            is_constructible<value_type, typename iterator_traits<
                                             _InputIterator>::reference>::value,
        _InputIterator>::type __last) {



  for (; __first != __last; ++__first)
    push_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(
    _InputIterator __first, _InputIterator __last, const allocator_type &__a,
    typename enable_if<
        __is_input_iterator<_InputIterator>::value &&
        !__is_forward_iterator<_InputIterator>::value &&
        is_constructible<value_type, typename iterator_traits<_InputIterator>::
                                         reference>::value>::type *)
    : __base(__a) {



  for (; __first != __last; ++__first)
    push_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(
    _ForwardIterator __first,
    typename enable_if<
        __is_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                value_type,
                typename iterator_traits<_ForwardIterator>::reference>::value,
        _ForwardIterator>::type __last) {



  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__first, __last, __n);
  }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(
    _ForwardIterator __first, _ForwardIterator __last,
    const allocator_type &__a,
    typename enable_if<
        __is_forward_iterator<_ForwardIterator>::value &&
        is_constructible<value_type,
                         typename iterator_traits<
                             _ForwardIterator>::reference>::value>::type *)
    : __base(__a) {



  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__first, __last, __n);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector &__x)
    : __base(__alloc_traits::select_on_container_copy_construction(
          __x.__alloc())) {



  size_type __n = __x.size();
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__x.__begin_, __x.__end_, __n);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector &__x, const allocator_type &__a)
    : __base(__a) {



  size_type __n = __x.size();
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__x.__begin_, __x.__end_, __n);
  }
}



template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) vector<_Tp, _Allocator>::vector(vector &&__x)



    noexcept(is_nothrow_move_constructible<allocator_type>::value)

    : __base(std::__1::move(__x.__alloc())) {




  this->__begin_ = __x.__begin_;
  this->__end_ = __x.__end_;
  this->__end_cap() = __x.__end_cap();
  __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
vector<_Tp, _Allocator>::vector(vector &&__x, const allocator_type &__a)
    : __base(__a) {



  if (__a == __x.__alloc()) {
    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;



  } else {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__x.begin()), _Ip(__x.end()));
  }
}



template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il) {



  if (__il.size() > 0) {
    allocate(__il.size());
    __construct_at_end(__il.begin(), __il.end(), __il.size());
  }
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il,
                                const allocator_type &__a)
    : __base(__a) {



  if (__il.size() > 0) {
    allocate(__il.size());
    __construct_at_end(__il.begin(), __il.end(), __il.size());
  }
}



template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) vector<_Tp, _Allocator> &
vector<_Tp, _Allocator>::operator=(vector &&__x) noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {

  __move_assign(
      __x,
      integral_constant<
          bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__move_assign(vector &__c, false_type)
    noexcept(__alloc_traits::is_always_equal::value) {
  if (__base::__alloc() != __c.__alloc()) {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__c.begin()), _Ip(__c.end()));
  } else
    __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__move_assign(vector &__c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value) {
  deallocate();
  __base::__move_assign_alloc(__c);
  this->__begin_ = __c.__begin_;
  this->__end_ = __c.__end_;
  this->__end_cap() = __c.__end_cap();
  __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;



}



template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) vector<_Tp, _Allocator> &
vector<_Tp, _Allocator>::operator=(const vector &__x) {
  if (this != &__x) {
    __base::__copy_assign_alloc(__x);
    assign(__x.__begin_, __x.__end_);
  }
  return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if<
    __is_input_iterator<_InputIterator>::value &&
        !__is_forward_iterator<_InputIterator>::value &&
        is_constructible<
            _Tp, typename iterator_traits<_InputIterator>::reference>::value,
    void>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last) {
  clear();
  for (; __first != __last; ++__first)
    push_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_forward_iterator<_ForwardIterator>::value &&
        is_constructible<
            _Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
    void>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first,
                                _ForwardIterator __last) {
  size_type __new_size =
      static_cast<size_type>(std::__1::distance(__first, __last));
  if (__new_size <= capacity()) {
    _ForwardIterator __mid = __last;
    bool __growing = false;
    if (__new_size > size()) {
      __growing = true;
      __mid = __first;
      std::__1::advance(__mid, size());
    }
    pointer __m = std::__1::copy(__first, __mid, this->__begin_);
    if (__growing)
      __construct_at_end(__mid, __last, __new_size - size());
    else
      this->__destruct_at_end(__m);
  } else {
    deallocate();
    allocate(__recommend(__new_size));
    __construct_at_end(__first, __last, __new_size);
  }
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u) {
  if (__n <= capacity()) {
    size_type __s = size();
    std::__1::fill_n(this->__begin_, std::__1::min(__n, __s), __u);
    if (__n > __s)
      __construct_at_end(__n - __s, __u);
    else
      this->__destruct_at_end(this->__begin_ + __n);
  } else {
    deallocate();
    allocate(__recommend(static_cast<size_type>(__n)));
    __construct_at_end(__n, __u);
  }
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__make_iter(pointer __p) noexcept {



  return iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename vector<_Tp, _Allocator>::const_iterator
    vector<_Tp, _Allocator>::__make_iter(const_pointer __p) const noexcept {



  return const_iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() noexcept {
  return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename vector<_Tp, _Allocator>::const_iterator
    vector<_Tp, _Allocator>::begin() const noexcept {
  return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() noexcept {
  return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename vector<_Tp, _Allocator>::const_iterator
    vector<_Tp, _Allocator>::end() const noexcept {
  return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename vector<_Tp, _Allocator>::reference
    vector<_Tp, _Allocator>::operator[](size_type __n) {
  ((void)0);
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename vector<_Tp, _Allocator>::const_reference vector<_Tp, _Allocator>::
    operator[](size_type __n) const {
  ((void)0);
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n) {
  if (__n >= size())
    this->__throw_out_of_range();
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    this->__throw_out_of_range();
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::reserve(size_type __n) {
  if (__n > capacity()) {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__n, size(), __a);
    __swap_out_circular_buffer(__v);
  }
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::shrink_to_fit() noexcept {
  if (capacity() > size()) {

    try {

      allocator_type &__a = this->__alloc();
      __split_buffer<value_type, allocator_type &> __v(size(), size(), __a);
      __swap_out_circular_buffer(__v);

    } catch (...) {
    }

  }
}

template <class _Tp, class _Allocator>
template <class _Up>
void

vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)



{
  allocator_type &__a = this->__alloc();
  __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                   size(), __a);

  __alloc_traits::construct(__a, std::__1::__to_raw_pointer(__v.__end_),
                            std::__1::forward<_Up>(__x));
  __v.__end_++;
  __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
vector<_Tp, _Allocator>::push_back(const_reference __x) {
  if (this->__end_ != this->__end_cap()) {
    __RAII_IncreaseAnnotator __annotator(*this);
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_raw_pointer(this->__end_), __x);
    __annotator.__done();
    ++this->__end_;
  } else
    __push_back_slow_path(__x);
}



template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
vector<_Tp, _Allocator>::push_back(value_type &&__x) {
  if (this->__end_ < this->__end_cap()) {
    __RAII_IncreaseAnnotator __annotator(*this);
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_raw_pointer(this->__end_),
                              std::__1::move(__x));
    __annotator.__done();
    ++this->__end_;
  } else
    __push_back_slow_path(std::__1::move(__x));
}



template <class _Tp, class _Allocator>
template <class... _Args>
void vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args &&... __args) {
  allocator_type &__a = this->__alloc();
  __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                   size(), __a);

  __alloc_traits::construct(__a, std::__1::__to_raw_pointer(__v.__end_),
                            std::__1::forward<_Args>(__args)...);
  __v.__end_++;
  __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
template <class... _Args>
inline typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::emplace_back(_Args &&... __args) {
  if (this->__end_ < this->__end_cap()) {
    __RAII_IncreaseAnnotator __annotator(*this);
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_raw_pointer(this->__end_),
                              std::__1::forward<_Args>(__args)...);
    __annotator.__done();
    ++this->__end_;
  } else
    __emplace_back_slow_path(std::__1::forward<_Args>(__args)...);
  return this->back();
}




template <class _Tp, class _Allocator>
inline void vector<_Tp, _Allocator>::pop_back() {
  ((void)0);
  this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position) {





  ((void)0);


  difference_type __ps = __position - cbegin();
  pointer __p = this->__begin_ + __ps;
  iterator __r = __make_iter(__p);
  this->__destruct_at_end(std::__1::move(__p + 1, this->__end_, __p));
  return __r;
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last) {






  ((void)0);

  pointer __p = this->__begin_ + (__first - begin());
  iterator __r = __make_iter(__p);
  if (__first != __last)
    this->__destruct_at_end(
        std::__1::move(__p + (__last - __first), this->__end_, __p));
  return __r;
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e,
                                           pointer __to) {
  pointer __old_last = this->__end_;
  difference_type __n = __old_last - __to;
  for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_raw_pointer(this->__end_),
                              std::__1::move(*__i));
  std::__1::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position,
                                const_reference __x) {





  pointer __p = this->__begin_ + (__position - begin());
  if (this->__end_ < this->__end_cap()) {
    __RAII_IncreaseAnnotator __annotator(*this);
    if (__p == this->__end_) {
      __alloc_traits::construct(this->__alloc(),
                                std::__1::__to_raw_pointer(this->__end_), __x);
      ++this->__end_;
    } else {
      __move_range(__p, this->__end_, __p + 1);
      const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
      if (__p <= __xr && __xr < this->__end_)
        ++__xr;
      *__p = *__xr;
    }
    __annotator.__done();
  } else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                     __p - this->__begin_, __a);
    __v.push_back(__x);
    __p = __swap_out_circular_buffer(__v, __p);
  }
  return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type &&__x) {





  pointer __p = this->__begin_ + (__position - begin());
  if (this->__end_ < this->__end_cap()) {
    __RAII_IncreaseAnnotator __annotator(*this);
    if (__p == this->__end_) {
      __alloc_traits::construct(this->__alloc(),
                                std::__1::__to_raw_pointer(this->__end_),
                                std::__1::move(__x));
      ++this->__end_;
    } else {
      __move_range(__p, this->__end_, __p + 1);
      *__p = std::__1::move(__x);
    }
    __annotator.__done();
  } else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                     __p - this->__begin_, __a);
    __v.push_back(std::__1::move(__x));
    __p = __swap_out_circular_buffer(__v, __p);
  }
  return __make_iter(__p);
}



template <class _Tp, class _Allocator>
template <class... _Args>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position,
                                 _Args &&... __args) {





  pointer __p = this->__begin_ + (__position - begin());
  if (this->__end_ < this->__end_cap()) {
    __RAII_IncreaseAnnotator __annotator(*this);
    if (__p == this->__end_) {
      __alloc_traits::construct(this->__alloc(),
                                std::__1::__to_raw_pointer(this->__end_),
                                std::__1::forward<_Args>(__args)...);
      ++this->__end_;
    } else {
      __temp_value<value_type, _Allocator> __tmp(
          this->__alloc(), std::__1::forward<_Args>(__args)...);
      __move_range(__p, this->__end_, __p + 1);
      *__p = std::__1::move(__tmp.get());
    }
    __annotator.__done();
  } else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                     __p - this->__begin_, __a);
    __v.emplace_back(std::__1::forward<_Args>(__args)...);
    __p = __swap_out_circular_buffer(__v, __p);
  }
  return __make_iter(__p);
}




template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n,
                                const_reference __x) {





  pointer __p = this->__begin_ + (__position - begin());
  if (__n > 0) {
    if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_)) {
      size_type __old_n = __n;
      pointer __old_last = this->__end_;
      if (__n > static_cast<size_type>(this->__end_ - __p)) {
        size_type __cx = __n - (this->__end_ - __p);
        __construct_at_end(__cx, __x);
        __n -= __cx;
      }
      if (__n > 0) {
        __RAII_IncreaseAnnotator __annotator(*this, __n);
        __move_range(__p, __old_last, __p + __old_n);
        __annotator.__done();
        const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
        if (__p <= __xr && __xr < this->__end_)
          __xr += __old_n;
        std::__1::fill_n(__p, __n, *__xr);
      }
    } else {
      allocator_type &__a = this->__alloc();
      __split_buffer<value_type, allocator_type &> __v(
          __recommend(size() + __n), __p - this->__begin_, __a);
      __v.__construct_at_end(__n, __x);
      __p = __swap_out_circular_buffer(__v, __p);
    }
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if<
    __is_input_iterator<_InputIterator>::value &&
        !__is_forward_iterator<_InputIterator>::value &&
        is_constructible<
            _Tp, typename iterator_traits<_InputIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator>::type
vector<_Tp, _Allocator>::insert(const_iterator __position,
                                _InputIterator __first, _InputIterator __last) {





  difference_type __off = __position - begin();
  pointer __p = this->__begin_ + __off;
  allocator_type &__a = this->__alloc();
  pointer __old_last = this->__end_;
  for (; this->__end_ != this->__end_cap() && __first != __last; ++__first) {
    __RAII_IncreaseAnnotator __annotator(*this);
    __alloc_traits::construct(__a, std::__1::__to_raw_pointer(this->__end_),
                              *__first);
    ++this->__end_;
    __annotator.__done();
  }
  __split_buffer<value_type, allocator_type &> __v(__a);
  if (__first != __last) {

    try {

      __v.__construct_at_end(__first, __last);
      difference_type __old_size = __old_last - this->__begin_;
      difference_type __old_p = __p - this->__begin_;
      reserve(__recommend(size() + __v.size()));
      __p = this->__begin_ + __old_p;
      __old_last = this->__begin_ + __old_size;

    } catch (...) {
      erase(__make_iter(__old_last), end());
      throw;
    }

  }
  __p = std::__1::rotate(__p, __old_last, this->__end_);
  insert(__make_iter(__p), make_move_iterator(__v.begin()),
         make_move_iterator(__v.end()));
  return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_forward_iterator<_ForwardIterator>::value &&
        is_constructible<
            _Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator>::type
vector<_Tp, _Allocator>::insert(const_iterator __position,
                                _ForwardIterator __first,
                                _ForwardIterator __last) {





  pointer __p = this->__begin_ + (__position - begin());
  difference_type __n = std::__1::distance(__first, __last);
  if (__n > 0) {
    if (__n <= this->__end_cap() - this->__end_) {
      size_type __old_n = __n;
      pointer __old_last = this->__end_;
      _ForwardIterator __m = __last;
      difference_type __dx = this->__end_ - __p;
      if (__n > __dx) {
        __m = __first;
        difference_type __diff = this->__end_ - __p;
        std::__1::advance(__m, __diff);
        __construct_at_end(__m, __last, __n - __diff);
        __n = __dx;
      }
      if (__n > 0) {
        __RAII_IncreaseAnnotator __annotator(*this, __n);
        __move_range(__p, __old_last, __p + __old_n);
        __annotator.__done();
        std::__1::copy(__first, __m, __p);
      }
    } else {
      allocator_type &__a = this->__alloc();
      __split_buffer<value_type, allocator_type &> __v(
          __recommend(size() + __n), __p - this->__begin_, __a);
      __v.__construct_at_end(__first, __last);
      __p = __swap_out_circular_buffer(__v, __p);
    }
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::resize(size_type __sz) {
  size_type __cs = size();
  if (__cs < __sz)
    this->__append(__sz - __cs);
  else if (__cs > __sz)
    this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x) {
  size_type __cs = size();
  if (__cs < __sz)
    this->__append(__sz - __cs, __x);
  else if (__cs > __sz)
    this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::swap(vector &__x)



    noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value)


{
  ((void)0);



  std::__1::swap(this->__begin_, __x.__begin_);
  std::__1::swap(this->__end_, __x.__end_);
  std::__1::swap(this->__end_cap(), __x.__end_cap());
  __swap_allocator(
      this->__alloc(), __x.__alloc(),
      integral_constant<bool,
                        __alloc_traits::propagate_on_container_swap::value>());



}

template <class _Tp, class _Allocator>
bool vector<_Tp, _Allocator>::__invariants() const {
  if (this->__begin_ == nullptr) {
    if (this->__end_ != nullptr || this->__end_cap() != nullptr)
      return false;
  } else {
    if (this->__begin_ > this->__end_)
      return false;
    if (this->__begin_ == this->__end_cap())
      return false;
    if (this->__end_ > this->__end_cap())
      return false;
  }
  return true;
}
template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
vector<_Tp, _Allocator>::__invalidate_all_iterators() {



}



template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator>>;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator>> {
  static const bool value = true;
};

template <class _Allocator>
class __attribute__((__visibility__("default"))) vector<bool, _Allocator>
    : private __vector_base_common<true> {
public:
  typedef vector __self;
  typedef bool value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef size_type __storage_type;
  typedef __bit_iterator<vector, false> pointer;
  typedef __bit_iterator<vector, true> const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
  typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type
      __storage_allocator;
  typedef allocator_traits<__storage_allocator> __storage_traits;
  typedef typename __storage_traits::pointer __storage_pointer;
  typedef typename __storage_traits::const_pointer __const_storage_pointer;

  __storage_pointer __begin_;
  size_type __size_;
  __compressed_pair<size_type, __storage_allocator> __cap_alloc_;

public:
  typedef __bit_reference<vector> reference;
  typedef __bit_const_reference<vector> const_reference;

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type &__cap() noexcept { return __cap_alloc_.first(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const size_type &__cap() const noexcept { return __cap_alloc_.first(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __storage_allocator &__alloc() noexcept { return __cap_alloc_.second(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const __storage_allocator &__alloc() const noexcept {
    return __cap_alloc_.second();
  }

  static const unsigned __bits_per_word =
      static_cast<unsigned>(sizeof(__storage_type) * 8);

  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_type __internal_cap_to_external(size_type __n) noexcept {
    return __n * __bits_per_word;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_type __external_cap_to_internal(size_type __n) noexcept {
    return (__n - 1) / __bits_per_word + 1;
  }

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  vector() noexcept(is_nothrow_default_constructible<allocator_type>::value);

  __attribute__((__visibility__("hidden"), __always_inline__)) explicit vector(const allocator_type &__a)

      noexcept(is_nothrow_copy_constructible<allocator_type>::value);



  ~vector();
  explicit vector(size_type __n);



  vector(size_type __n, const value_type &__v);
  vector(size_type __n, const value_type &__v, const allocator_type &__a);
  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
         typename enable_if<__is_input_iterator<_InputIterator>::value &&
                            !__is_forward_iterator<_InputIterator>::value>::type
             * = 0);
  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
         const allocator_type &__a,
         typename enable_if<__is_input_iterator<_InputIterator>::value &&
                            !__is_forward_iterator<_InputIterator>::value>::type
             * = 0);
  template <class _ForwardIterator>
  vector(_ForwardIterator __first, _ForwardIterator __last,
         typename enable_if<
             __is_forward_iterator<_ForwardIterator>::value>::type * = 0);
  template <class _ForwardIterator>
  vector(_ForwardIterator __first, _ForwardIterator __last,
         const allocator_type &__a,
         typename enable_if<
             __is_forward_iterator<_ForwardIterator>::value>::type * = 0);

  vector(const vector &__v);
  vector(const vector &__v, const allocator_type &__a);
  vector &operator=(const vector &__v);

  vector(initializer_list<value_type> __il);
  vector(initializer_list<value_type> __il, const allocator_type &__a);



  __attribute__((__visibility__("hidden"), __always_inline__))
  vector(vector &&__v)



      noexcept(is_nothrow_move_constructible<allocator_type>::value);

  vector(vector &&__v, const allocator_type &__a);
  __attribute__((__visibility__("hidden"), __always_inline__))
  vector &operator=(vector &&__v) noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));



  __attribute__((__visibility__("hidden"), __always_inline__))
  vector &operator=(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
    return *this;
  }


  template <class _InputIterator>
  typename enable_if<__is_input_iterator<_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value,
                     void>::type
  assign(_InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type
  assign(_ForwardIterator __first, _ForwardIterator __last);

  void assign(size_type __n, const value_type &__x);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void assign(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"), __always_inline__)) allocator_type get_allocator() const noexcept {
    return allocator_type(this->__alloc());
  }

  size_type max_size() const noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type capacity() const noexcept {
    return __internal_cap_to_external(__cap());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type size() const noexcept { return __size_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool empty() const noexcept { return __size_ == 0; }
  void reserve(size_type __n);
  void shrink_to_fit() noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator begin() noexcept { return __make_iter(0); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator begin() const noexcept { return __make_iter(0); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator end() noexcept { return __make_iter(__size_); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator end() const noexcept { return __make_iter(__size_); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cbegin() const noexcept { return __make_iter(0); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cend() const noexcept { return __make_iter(__size_); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crend() const noexcept { return rend(); }

  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator[](size_type __n) {
    return __make_ref(__n);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference operator[](size_type __n) const {
    return __make_ref(__n);
  }
  reference at(size_type __n);
  const_reference at(size_type __n) const;

  __attribute__((__visibility__("hidden"), __always_inline__)) reference front() { return __make_ref(0); }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference front() const {
    return __make_ref(0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) reference back() { return __make_ref(__size_ - 1); }
  __attribute__((__visibility__("hidden"), __always_inline__)) const_reference back() const {
    return __make_ref(__size_ - 1);
  }

  void push_back(const value_type &__x);
  __attribute__((__visibility__("hidden"), __always_inline__)) void pop_back() { --__size_; }
  iterator insert(const_iterator __position, const value_type &__x);
  iterator insert(const_iterator __position, size_type __n,
                  const value_type &__x);
  iterator insert(const_iterator __position, size_type __n,
                  const_reference __x);
  template <class _InputIterator>
  typename enable_if<__is_input_iterator<_InputIterator>::value &&
                         !__is_forward_iterator<_InputIterator>::value,
                     iterator>::type
  insert(const_iterator __position, _InputIterator __first,
         _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<__is_forward_iterator<_ForwardIterator>::value,
                     iterator>::type
  insert(const_iterator __position, _ForwardIterator __first,
         _ForwardIterator __last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __position,
                  initializer_list<value_type> __il) {
    return insert(__position, __il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"), __always_inline__)) iterator erase(const_iterator __position);
  iterator erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept { __size_ = 0; }

  void swap(vector &)



      noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value);


  static void swap(reference __x, reference __y) noexcept {
    std::__1::swap(__x, __y);
  }

  void resize(size_type __sz, value_type __x = false);
  void flip() noexcept;

  bool __invariants() const;

private:
  __attribute__((__visibility__("hidden"), __always_inline__)) void __invalidate_all_iterators();
  void allocate(size_type __n);
  void deallocate() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_type __align_it(size_type __new_size) noexcept {
    return __new_size + (__bits_per_word - 1) &
           ~((size_type)__bits_per_word - 1);
  };
  __attribute__((__visibility__("hidden"), __always_inline__)) size_type __recommend(size_type __new_size) const;
  __attribute__((__visibility__("hidden"), __always_inline__)) void __construct_at_end(size_type __n, bool __x);
  template <class _ForwardIterator>
  typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type
  __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
  void __append(size_type __n, const_reference __x);
  __attribute__((__visibility__("hidden"), __always_inline__))
  reference __make_ref(size_type __pos) noexcept {
    return reference(__begin_ + __pos / __bits_per_word,
                     __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reference __make_ref(size_type __pos) const noexcept {
    return const_reference(__begin_ + __pos / __bits_per_word,
                           __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator __make_iter(size_type __pos) noexcept {
    return iterator(__begin_ + __pos / __bits_per_word,
                    static_cast<unsigned>(__pos % __bits_per_word));
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator __make_iter(size_type __pos) const noexcept {
    return const_iterator(__begin_ + __pos / __bits_per_word,
                          static_cast<unsigned>(__pos % __bits_per_word));
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator __const_iterator_cast(const_iterator __p) noexcept {
    return begin() + (__p - cbegin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const vector &__v) {
    __copy_assign_alloc(
        __v,
        integral_constant<
            bool,
            __storage_traits::propagate_on_container_copy_assignment::value>());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const vector &__c, true_type) {
    if (__alloc() != __c.__alloc())
      deallocate();
    __alloc() = __c.__alloc();
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const vector &, false_type) {}

  void __move_assign(vector &__c, false_type);
  void __move_assign(vector &__c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value);
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(vector &__c) noexcept(!__storage_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value) {


    __move_assign_alloc(
        __c,
        integral_constant<
            bool,
            __storage_traits::propagate_on_container_move_assignment::value>());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(vector &__c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::__1::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(vector &, false_type) noexcept {}

  size_t __hash_code() const noexcept;

  friend class __bit_reference<vector>;
  friend class __bit_const_reference<vector>;
  friend class __bit_iterator<vector, false>;
  friend class __bit_iterator<vector, true>;
  friend struct __bit_array<vector>;
  friend struct __attribute__((__visibility__("default"))) hash<vector>;
};

template <class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
vector<bool, _Allocator>::__invalidate_all_iterators() {}
template <class _Allocator>
void vector<bool, _Allocator>::allocate(size_type __n) {
  if (__n > max_size())
    this->__throw_length_error();
  __n = __external_cap_to_internal(__n);
  this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
  this->__size_ = 0;
  this->__cap() = __n;
}

template <class _Allocator>
void vector<bool, _Allocator>::deallocate() noexcept {
  if (this->__begin_ != nullptr) {
    __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
    __invalidate_all_iterators();
    this->__begin_ = nullptr;
    this->__size_ = this->__cap() = 0;
  }
}

template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const noexcept {
  size_type __amax = __storage_traits::max_size(__alloc());
  size_type __nmax =
      numeric_limits<size_type>::max() / 2;
  if (__nmax / __bits_per_word <= __amax)
    return __nmax;
  return __internal_cap_to_external(__amax);
}


template <class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const {
  const size_type __ms = max_size();
  if (__new_size > __ms)
    this->__throw_length_error();
  const size_type __cap = capacity();
  if (__cap >= __ms / 2)
    return __ms;
  return std::__1::max(2 * __cap, __align_it(__new_size));
}





template <class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x) {
  size_type __old_size = this->__size_;
  this->__size_ += __n;
  std::__1::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first,
                                             _ForwardIterator __last) {
  size_type __old_size = this->__size_;
  this->__size_ += std::__1::distance(__first, __last);
  std::__1::copy(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) vector<bool, _Allocator>::vector()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0) {}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__))
vector<bool, _Allocator>::vector(const allocator_type &__a)

    noexcept(is_nothrow_copy_constructible<allocator_type>::value)



    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0) {
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__n, false);
  }
}
template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type &__x)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0) {
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type &__x,
                                 const allocator_type &__a)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(
    _InputIterator __first, _InputIterator __last,
    typename enable_if<__is_input_iterator<_InputIterator>::value &&
                       !__is_forward_iterator<_InputIterator>::value>::type *)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0) {

  try {

    for (; __first != __last; ++__first)
      push_back(*__first);

  } catch (...) {
    if (__begin_ != nullptr)
      __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
    throw;
  }

}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(
    _InputIterator __first, _InputIterator __last, const allocator_type &__a,
    typename enable_if<__is_input_iterator<_InputIterator>::value &&
                       !__is_forward_iterator<_InputIterator>::value>::type *)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {

  try {

    for (; __first != __last; ++__first)
      push_back(*__first);

  } catch (...) {
    if (__begin_ != nullptr)
      __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
    throw;
  }

}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(
    _ForwardIterator __first, _ForwardIterator __last,
    typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type *)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0) {
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__first, __last);
  }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(
    _ForwardIterator __first, _ForwardIterator __last,
    const allocator_type &__a,
    typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type *)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__first, __last);
  }
}



template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0) {
  size_type __n = static_cast<size_type>(__il.size());
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__il.begin(), __il.end());
  }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il,
                                 const allocator_type &__a)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  size_type __n = static_cast<size_type>(__il.size());
  if (__n > 0) {
    allocate(__n);
    __construct_at_end(__il.begin(), __il.end());
  }
}



template <class _Allocator> vector<bool, _Allocator>::~vector() {
  if (__begin_ != nullptr)
    __storage_traits::deallocate(__alloc(), __begin_, __cap());
  __invalidate_all_iterators();
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector &__v)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(
                          __v.__alloc())) {
  if (__v.size() > 0) {
    allocate(__v.size());
    __construct_at_end(__v.begin(), __v.end());
  }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector &__v, const allocator_type &__a)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __a) {
  if (__v.size() > 0) {
    allocate(__v.size());
    __construct_at_end(__v.begin(), __v.end());
  }
}

template <class _Allocator>
vector<bool, _Allocator> &vector<bool, _Allocator>::
operator=(const vector &__v) {
  if (this != &__v) {
    __copy_assign_alloc(__v);
    if (__v.__size_) {
      if (__v.__size_ > capacity()) {
        deallocate();
        allocate(__v.__size_);
      }
      std::__1::copy(__v.__begin_,
                  __v.__begin_ + __external_cap_to_internal(__v.__size_),
                  __begin_);
    }
    __size_ = __v.__size_;
  }
  return *this;
}



template <class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) vector<bool, _Allocator>::vector(vector &&__v)



    noexcept(is_nothrow_move_constructible<allocator_type>::value)

    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(__v.__cap_alloc_) {
  __v.__begin_ = nullptr;
  __v.__size_ = 0;
  __v.__cap() = 0;
}

template <class _Allocator>
vector<bool, _Allocator>::vector(vector &&__v, const allocator_type &__a)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __a) {
  if (__a == allocator_type(__v.__alloc())) {
    this->__begin_ = __v.__begin_;
    this->__size_ = __v.__size_;
    this->__cap() = __v.__cap();
    __v.__begin_ = nullptr;
    __v.__cap() = __v.__size_ = 0;
  } else if (__v.size() > 0) {
    allocate(__v.size());
    __construct_at_end(__v.begin(), __v.end());
  }
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) vector<bool, _Allocator> &
vector<bool, _Allocator>::operator=(vector &&__v) noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {

  __move_assign(
      __v,
      integral_constant<
          bool,
          __storage_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Allocator>
void vector<bool, _Allocator>::__move_assign(vector &__c, false_type) {
  if (__alloc() != __c.__alloc())
    assign(__c.begin(), __c.end());
  else
    __move_assign(__c, true_type());
}

template <class _Allocator>
void vector<bool, _Allocator>::__move_assign(vector &__c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value) {
  deallocate();
  __move_assign_alloc(__c);
  this->__begin_ = __c.__begin_;
  this->__size_ = __c.__size_;
  this->__cap() = __c.__cap();
  __c.__begin_ = nullptr;
  __c.__cap() = __c.__size_ = 0;
}



template <class _Allocator>
void vector<bool, _Allocator>::assign(size_type __n, const value_type &__x) {
  __size_ = 0;
  if (__n > 0) {
    size_type __c = capacity();
    if (__n <= __c)
      __size_ = __n;
    else {
      vector __v(__alloc());
      __v.reserve(__recommend(__n));
      __v.__size_ = __n;
      swap(__v);
    }
    std::__1::fill_n(begin(), __n, __x);
  }
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if<__is_input_iterator<_InputIterator>::value &&
                       !__is_forward_iterator<_InputIterator>::value,
                   void>::type
vector<bool, _Allocator>::assign(_InputIterator __first,
                                 _InputIterator __last) {
  clear();
  for (; __first != __last; ++__first)
    push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_forward_iterator<_ForwardIterator>::value, void>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first,
                                 _ForwardIterator __last) {
  clear();
  difference_type __n = std::__1::distance(__first, __last);
  if (__n) {
    if (__n > capacity()) {
      deallocate();
      allocate(__n);
    }
    __construct_at_end(__first, __last);
  }
}

template <class _Allocator>
void vector<bool, _Allocator>::reserve(size_type __n) {
  if (__n > capacity()) {
    vector __v(this->__alloc());
    __v.allocate(__n);
    __v.__construct_at_end(this->begin(), this->end());
    swap(__v);
    __invalidate_all_iterators();
  }
}

template <class _Allocator>
void vector<bool, _Allocator>::shrink_to_fit() noexcept {
  if (__external_cap_to_internal(size()) > __cap()) {

    try {

      vector(*this, allocator_type(__alloc())).swap(*this);

    } catch (...) {
    }

  }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n) {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _Allocator>
void vector<bool, _Allocator>::push_back(const value_type &__x) {
  if (this->__size_ == this->capacity())
    reserve(__recommend(this->__size_ + 1));
  ++this->__size_;
  back() = __x;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position,
                                 const value_type &__x) {
  iterator __r;
  if (size() < capacity()) {
    const_iterator __old_end = end();
    ++__size_;
    std::__1::copy_backward(__position, __old_end, end());
    __r = __const_iterator_cast(__position);
  } else {
    vector __v(__alloc());
    __v.reserve(__recommend(__size_ + 1));
    __v.__size_ = __size_ + 1;
    __r = std::__1::copy(cbegin(), __position, __v.begin());
    std::__1::copy_backward(__position, cend(), __v.end());
    swap(__v);
  }
  *__r = __x;
  return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n,
                                 const value_type &__x) {
  iterator __r;
  size_type __c = capacity();
  if (__n <= __c && size() <= __c - __n) {
    const_iterator __old_end = end();
    __size_ += __n;
    std::__1::copy_backward(__position, __old_end, end());
    __r = __const_iterator_cast(__position);
  } else {
    vector __v(__alloc());
    __v.reserve(__recommend(__size_ + __n));
    __v.__size_ = __size_ + __n;
    __r = std::__1::copy(cbegin(), __position, __v.begin());
    std::__1::copy_backward(__position, cend(), __v.end());
    swap(__v);
  }
  std::__1::fill_n(__r, __n, __x);
  return __r;
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if<__is_input_iterator<_InputIterator>::value &&
                       !__is_forward_iterator<_InputIterator>::value,
                   typename vector<bool, _Allocator>::iterator>::type
vector<bool, _Allocator>::insert(const_iterator __position,
                                 _InputIterator __first,
                                 _InputIterator __last) {
  difference_type __off = __position - begin();
  iterator __p = __const_iterator_cast(__position);
  iterator __old_end = end();
  for (; size() != capacity() && __first != __last; ++__first) {
    ++this->__size_;
    back() = *__first;
  }
  vector __v(__alloc());
  if (__first != __last) {

    try {

      __v.assign(__first, __last);
      difference_type __old_size =
          static_cast<difference_type>(__old_end - begin());
      difference_type __old_p = __p - begin();
      reserve(__recommend(size() + __v.size()));
      __p = begin() + __old_p;
      __old_end = begin() + __old_size;

    } catch (...) {
      erase(__old_end, end());
      throw;
    }

  }
  __p = std::__1::rotate(__p, __old_end, end());
  insert(__p, __v.begin(), __v.end());
  return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_forward_iterator<_ForwardIterator>::value,
                   typename vector<bool, _Allocator>::iterator>::type
vector<bool, _Allocator>::insert(const_iterator __position,
                                 _ForwardIterator __first,
                                 _ForwardIterator __last) {
  difference_type __n = std::__1::distance(__first, __last);
  iterator __r;
  size_type __c = capacity();
  if (__n <= __c && size() <= __c - __n) {
    const_iterator __old_end = end();
    __size_ += __n;
    std::__1::copy_backward(__position, __old_end, end());
    __r = __const_iterator_cast(__position);
  } else {
    vector __v(__alloc());
    __v.reserve(__recommend(__size_ + __n));
    __v.__size_ = __size_ + __n;
    __r = std::__1::copy(cbegin(), __position, __v.begin());
    std::__1::copy_backward(__position, cend(), __v.end());
    swap(__v);
  }
  std::__1::copy(__first, __last, __r);
  return __r;
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position) {
  iterator __r = __const_iterator_cast(__position);
  std::__1::copy(__position + 1, this->cend(), __r);
  --__size_;
  return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last) {
  iterator __r = __const_iterator_cast(__first);
  difference_type __d = __last - __first;
  std::__1::copy(__last, this->cend(), __r);
  __size_ -= __d;
  return __r;
}

template <class _Allocator>
void vector<bool, _Allocator>::swap(vector &__x)



    noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value)


{
  std::__1::swap(this->__begin_, __x.__begin_);
  std::__1::swap(this->__size_, __x.__size_);
  std::__1::swap(this->__cap(), __x.__cap());
  __swap_allocator(
      this->__alloc(), __x.__alloc(),
      integral_constant<bool,
                        __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Allocator>
void vector<bool, _Allocator>::resize(size_type __sz, value_type __x) {
  size_type __cs = size();
  if (__cs < __sz) {
    iterator __r;
    size_type __c = capacity();
    size_type __n = __sz - __cs;
    if (__n <= __c && __cs <= __c - __n) {
      __r = end();
      __size_ += __n;
    } else {
      vector __v(__alloc());
      __v.reserve(__recommend(__size_ + __n));
      __v.__size_ = __size_ + __n;
      __r = std::__1::copy(cbegin(), cend(), __v.begin());
      swap(__v);
    }
    std::__1::fill_n(__r, __n, __x);
  } else
    __size_ = __sz;
}

template <class _Allocator> void vector<bool, _Allocator>::flip() noexcept {

  size_type __n = __size_;
  __storage_pointer __p = __begin_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    *__p = ~*__p;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = *__p & __m;
    *__p &= ~__m;
    *__p |= ~__b & __m;
  }
}

template <class _Allocator>
bool vector<bool, _Allocator>::__invariants() const {
  if (this->__begin_ == nullptr) {
    if (this->__size_ != 0 || this->__cap() != 0)
      return false;
  } else {
    if (this->__cap() == 0)
      return false;
    if (this->__size_ > this->capacity())
      return false;
  }
  return true;
}

template <class _Allocator>
size_t vector<bool, _Allocator>::__hash_code() const noexcept {
  size_t __h = 0;

  size_type __n = __size_;
  __storage_pointer __p = __begin_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    __h ^= *__p;

  if (__n > 0) {
    const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __h ^= *__p & __m;
  }
  return __h;
}

template <class _Allocator>
struct __attribute__((__visibility__("default"))) hash<vector<bool, _Allocator>>
    : public unary_function<vector<bool, _Allocator>, size_t> {
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_t operator()(const vector<bool, _Allocator> &__vec) const noexcept {
    return __vec.__hash_code();
  }
};

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const vector<_Tp, _Allocator> &__x,
           const vector<_Tp, _Allocator> &__y) {
  const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
  return __sz == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const vector<_Tp, _Allocator> &__x,
           const vector<_Tp, _Allocator> &__y) {
  return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const vector<_Tp, _Allocator> &__x,
          const vector<_Tp, _Allocator> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                        __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const vector<_Tp, _Allocator> &__x,
          const vector<_Tp, _Allocator> &__y) {
  return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const vector<_Tp, _Allocator> &__x,
           const vector<_Tp, _Allocator> &__y) {
  return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const vector<_Tp, _Allocator> &__x,
           const vector<_Tp, _Allocator> &__y) {
  return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(vector<_Tp, _Allocator> &__x,
                                           vector<_Tp, _Allocator> &__y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

} }






#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {





  void __abort(void);
  void assert(int);
  }






extern "C" {
      inline __FILEP* const * __gtab_filep(int e) { return (__FILEP* const *)_Gtab(e); }
}

#pragma checkout(resume)
namespace v8 {

class AccessorSignature;
class Array;
class Boolean;
class BooleanObject;
class Context;
class CpuProfiler;
class Data;
class Date;
class External;
class Function;
class FunctionTemplate;
class HeapProfiler;
class ImplementationUtilities;
class Int32;
class Integer;
class Isolate;
template <class T>
class Maybe;
class Name;
class Number;
class NumberObject;
class Object;
class ObjectOperationDescriptor;
class ObjectTemplate;
class Platform;
class Primitive;
class Promise;
class Proxy;
class RawOperationDescriptor;
class Script;
class SharedArrayBuffer;
class Signature;
class StartupData;
class StackFrame;
class StackTrace;
class String;
class StringObject;
class Symbol;
class SymbolObject;
class Private;
class Uint32;
class Utils;
class Value;
template <class T> class Local;
template <class T>
class MaybeLocal;
template <class T> class Eternal;
template<class T> class NonCopyablePersistentTraits;
template<class T> class PersistentBase;
template <class T, class M = NonCopyablePersistentTraits<T> >
class Persistent;
template <class T>
class Global;
template<class K, class V, class T> class PersistentValueMap;
template <class K, class V, class T>
class PersistentValueMapBase;
template <class K, class V, class T>
class GlobalValueMap;
template<class V, class T> class PersistentValueVector;
template<class T, class P> class WeakCallbackObject;
class FunctionTemplate;
class ObjectTemplate;
class Data;
template<typename T> class FunctionCallbackInfo;
template<typename T> class PropertyCallbackInfo;
class StackTrace;
class StackFrame;
class Isolate;
class CallHandlerHelper;
class EscapableHandleScope;
template<typename T> class ReturnValue;

namespace experimental {
class FastAccessorBuilder;
}

namespace internal {
class Arguments;
class Heap;
class HeapObject;
class Isolate;
class Object;
struct StreamedSource;
template<typename T> class CustomArguments;
class PropertyCallbackArguments;
class FunctionCallbackArguments;
class GlobalHandles;
}





class UniqueId {
 public:
  explicit UniqueId(intptr_t data)
      : data_(data) {}

  bool operator==(const UniqueId& other) const {
    return data_ == other.data_;
  }

  bool operator!=(const UniqueId& other) const {
    return data_ != other.data_;
  }

  bool operator<(const UniqueId& other) const {
    return data_ < other.data_;
  }

 private:
  intptr_t data_;
};
template <class T>
class Local {
 public:
  inline Local() : val_(0) {}
  template <class S>
  inline Local(Local<S> that)
      : val_(reinterpret_cast<T*>(*that)) {





    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }




  inline bool IsEmpty() const { return val_ == 0; }




  inline void Clear() { val_ = 0; }

  inline T* operator->() const { return val_; }

  inline T* operator*() const { return val_; }







  template <class S>
  inline bool operator==(const Local<S>& that) const {
    internal::Object** a = reinterpret_cast<internal::Object**>(this->val_);
    internal::Object** b = reinterpret_cast<internal::Object**>(that.val_);
    if (a == 0) return b == 0;
    if (b == 0) return false;
    return *a == *b;
  }

  template <class S> inline bool operator==(
      const PersistentBase<S>& that) const {
    internal::Object** a = reinterpret_cast<internal::Object**>(this->val_);
    internal::Object** b = reinterpret_cast<internal::Object**>(that.val_);
    if (a == 0) return b == 0;
    if (b == 0) return false;
    return *a == *b;
  }







  template <class S>
  inline bool operator!=(const Local<S>& that) const {
    return !operator==(that);
  }

  template <class S> inline bool operator!=(
      const Persistent<S>& that) const {
    return !operator==(that);
  }

  template <class S> inline static Local<T> Cast(Local<S> that) {



    if (that.IsEmpty()) return Local<T>();

    return Local<T>(T::Cast(*that));
  }


  template <class S> inline Local<S> As() {
    return Local<S>::Cast(*this);
  }






  inline static Local<T> New(Isolate* isolate, Local<T> that);
  inline static Local<T> New(Isolate* isolate,
                                const PersistentBase<T>& that);

 private:
  friend class Utils;
  template<class F> friend class Eternal;
  template<class F> friend class PersistentBase;
  template<class F, class M> friend class Persistent;
  template<class F> friend class Local;
  template <class F>
  friend class MaybeLocal;
  template<class F> friend class FunctionCallbackInfo;
  template<class F> friend class PropertyCallbackInfo;
  friend class String;
  friend class Object;
  friend class Context;
  friend class Private;
  template<class F> friend class internal::CustomArguments;
  friend Local<Primitive> Undefined(Isolate* isolate);
  friend Local<Primitive> Null(Isolate* isolate);
  friend Local<Boolean> True(Isolate* isolate);
  friend Local<Boolean> False(Isolate* isolate);
  friend class HandleScope;
  friend class EscapableHandleScope;
  template <class F1, class F2, class F3>
  friend class PersistentValueMapBase;
  template<class F1, class F2> friend class PersistentValueVector;

  explicit inline Local(T* that) : val_(that) {}
  inline static Local<T> New(Isolate* isolate, T* that);
  T* val_;
};
template <class T>
class MaybeLocal {
 public:
  inline MaybeLocal() : val_(nullptr) {}
  template <class S>
  inline MaybeLocal(Local<S> that)
      : val_(reinterpret_cast<T*>(*that)) {
    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }

  inline bool IsEmpty() const { return val_ == nullptr; }

  template <class S>
  __attribute__((warn_unused_result)) inline bool ToLocal(Local<S>* out) const {
    out->val_ = IsEmpty() ? nullptr : this->val_;
    return !IsEmpty();
  }


  inline Local<T> ToLocalChecked();

  template <class S>
  inline Local<S> FromMaybe(Local<S> default_value) const {
    return IsEmpty() ? default_value : Local<S>(val_);
  }

 private:
  T* val_;
};



template <class T> class Eternal {
 public:
  inline Eternal() : index_(kInitialValue) { }
  template<class S>
  inline Eternal(Isolate* isolate, Local<S> handle) : index_(kInitialValue) {
    Set(isolate, handle);
  }

  inline Local<T> Get(Isolate* isolate);
  inline bool IsEmpty() { return index_ == kInitialValue; }
  template<class S> inline void Set(Isolate* isolate, Local<S> handle);

 private:
  static const int kInitialValue = -1;
  int index_;
};


static const int kInternalFieldsInWeakCallback = 2;


template <typename T>
class WeakCallbackInfo {
 public:
  typedef void (*Callback)(const WeakCallbackInfo<T>& data);

  WeakCallbackInfo(Isolate* isolate, T* parameter,
                   void* internal_fields[kInternalFieldsInWeakCallback],
                   Callback* callback)
      : isolate_(isolate), parameter_(parameter), callback_(callback) {
    for (int i = 0; i < kInternalFieldsInWeakCallback; ++i) {
      internal_fields_[i] = internal_fields[i];
    }
  }

  inline Isolate* GetIsolate() const { return isolate_; }
  inline T* GetParameter() const { return parameter_; }
  inline void* GetInternalField(int index) const;

  inline void* GetInternalField1() const __attribute__((deprecated)) {

    return internal_fields_[0];
  }
  inline void* GetInternalField2() const __attribute__((deprecated)) {

    return internal_fields_[1];
  }

  bool IsFirstPass() const __attribute__((deprecated)) {

    return callback_ != nullptr;
  }







  void SetSecondPassCallback(Callback callback) const { *callback_ = callback; }

 private:
  Isolate* isolate_;
  T* parameter_;
  Callback* callback_;
  void* internal_fields_[kInternalFieldsInWeakCallback];
};


template <class T, class P>
class WeakCallbackData {
 public:
  typedef void (*Callback)(const WeakCallbackData<T, P>& data);

  WeakCallbackData(Isolate* isolate, P* parameter, Local<T> handle)
      : isolate_(isolate), parameter_(parameter), handle_(handle) {}

  inline Isolate* GetIsolate() const { return isolate_; }
  inline P* GetParameter() const { return parameter_; }
  inline Local<T> GetValue() const { return handle_; }

 private:
  Isolate* isolate_;
  P* parameter_;
  Local<T> handle_;
};



template <class T>
using PhantomCallbackData = WeakCallbackInfo<T>;


enum class WeakCallbackType { kParameter, kInternalFields };
template <class T> class PersistentBase {
 public:




  inline void Reset();




  template <class S>
  inline void Reset(Isolate* isolate, const Local<S>& other);





  template <class S>
  inline void Reset(Isolate* isolate, const PersistentBase<S>& other);

  inline bool IsEmpty() const { return val_ == 0; }
  inline void Empty() { val_ = 0; }

  inline Local<T> Get(Isolate* isolate) const {
    return Local<T>::New(isolate, *this);
  }

  template <class S>
  inline bool operator==(const PersistentBase<S>& that) const {
    internal::Object** a = reinterpret_cast<internal::Object**>(this->val_);
    internal::Object** b = reinterpret_cast<internal::Object**>(that.val_);
    if (a == 0) return b == 0;
    if (b == 0) return false;
    return *a == *b;
  }

  template <class S>
  inline bool operator==(const Local<S>& that) const {
    internal::Object** a = reinterpret_cast<internal::Object**>(this->val_);
    internal::Object** b = reinterpret_cast<internal::Object**>(that.val_);
    if (a == 0) return b == 0;
    if (b == 0) return false;
    return *a == *b;
  }

  template <class S>
  inline bool operator!=(const PersistentBase<S>& that) const {
    return !operator==(that);
  }

  template <class S>
  inline bool operator!=(const Local<S>& that) const {
    return !operator==(that);
  }
  template <typename P>
  inline void SetWeak(P* parameter, typename WeakCallbackData<T, P>::Callback callback) __attribute__((deprecated));




  template <typename S, typename P>
  inline void SetWeak(P* parameter, typename WeakCallbackData<S, P>::Callback callback) __attribute__((deprecated));
  template <typename P>
  inline void SetPhantom(P* parameter, typename WeakCallbackInfo<P>::Callback callback, int internal_field_index1 = -1, int internal_field_index2 = -1) __attribute__((deprecated));






  template <typename P>
  inline void SetWeak(P* parameter,
                         typename WeakCallbackInfo<P>::Callback callback,
                         WeakCallbackType type);

  template<typename P>
  inline P* ClearWeak();


  inline void ClearWeak() { ClearWeak<void>(); }






  inline void RegisterExternalReference(Isolate* isolate);







  inline void MarkIndependent();
  inline void MarkPartiallyDependent();






  inline void MarkActive();

  inline bool IsIndependent() const;


  inline bool IsNearDeath() const;


  inline bool IsWeak() const;





  inline void SetWrapperClassId(uint16_t class_id);





  inline uint16_t WrapperClassId() const;

 private:
  friend class Isolate;
  friend class Utils;
  template<class F> friend class Local;
  template<class F1, class F2> friend class Persistent;
  template <class F>
  friend class Global;
  template<class F> friend class PersistentBase;
  template<class F> friend class ReturnValue;
  template <class F1, class F2, class F3>
  friend class PersistentValueMapBase;
  template<class F1, class F2> friend class PersistentValueVector;
  friend class Object;

  explicit inline PersistentBase(T* val) : val_(val) {}
  PersistentBase(const PersistentBase& other) = delete;
  void operator=(const PersistentBase&) = delete;
  inline static T* New(Isolate* isolate, T* that);

  T* val_;
};
template<class T>
class NonCopyablePersistentTraits {
 public:
  typedef Persistent<T, NonCopyablePersistentTraits<T> > NonCopyablePersistent;
  static const bool kResetInDestructor = false;
  template<class S, class M>
  inline static void Copy(const Persistent<S, M>& source,
                             NonCopyablePersistent* dest) {
    Uncompilable<Object>();
  }

  template<class O> inline static void Uncompilable() {
    while (false) { *(static_cast<O* volatile*>(0)) = static_cast<Primitive*>(0); };
  }
};






template<class T>
struct CopyablePersistentTraits {
  typedef Persistent<T, CopyablePersistentTraits<T> > CopyablePersistent;
  static const bool kResetInDestructor = true;
  template<class S, class M>
  static inline void Copy(const Persistent<S, M>& source,
                             CopyablePersistent* dest) {

  }
};
template <class T, class M> class Persistent : public PersistentBase<T> {
 public:



  inline Persistent() : PersistentBase<T>(0) { }





  template <class S>
  inline Persistent(Isolate* isolate, Local<S> that)
      : PersistentBase<T>(PersistentBase<T>::New(isolate, *that)) {
    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }





  template <class S, class M2>
  inline Persistent(Isolate* isolate, const Persistent<S, M2>& that)
    : PersistentBase<T>(PersistentBase<T>::New(isolate, *that)) {
    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }






  inline Persistent(const Persistent& that) : PersistentBase<T>(0) {
    Copy(that);
  }
  template <class S, class M2>
  inline Persistent(const Persistent<S, M2>& that) : PersistentBase<T>(0) {
    Copy(that);
  }
  inline Persistent& operator=(const Persistent& that) {
    Copy(that);
    return *this;
  }
  template <class S, class M2>
  inline Persistent& operator=(const Persistent<S, M2>& that) {
    Copy(that);
    return *this;
  }





  inline ~Persistent() {
    if (M::kResetInDestructor) this->Reset();
  }


  template <class S>
  inline static Persistent<T>& Cast(Persistent<S>& that) {



    if (!that.IsEmpty()) T::Cast(*that);

    return reinterpret_cast<Persistent<T>&>(that);
  }


  template <class S> inline Persistent<S>& As() {
    return Persistent<S>::Cast(*this);
  }

 private:
  friend class Isolate;
  friend class Utils;
  template<class F> friend class Local;
  template<class F1, class F2> friend class Persistent;
  template<class F> friend class ReturnValue;

  explicit inline Persistent(T* that) : PersistentBase<T>(that) {}
  inline T* operator*() const { return this->val_; }
  template<class S, class M2>
  inline void Copy(const Persistent<S, M2>& that);
};







template <class T>
class Global : public PersistentBase<T> {
 public:



  inline Global() : PersistentBase<T>(nullptr) {}





  template <class S>
  inline Global(Isolate* isolate, Local<S> that)
      : PersistentBase<T>(PersistentBase<T>::New(isolate, *that)) {
    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }





  template <class S>
  inline Global(Isolate* isolate, const PersistentBase<S>& that)
      : PersistentBase<T>(PersistentBase<T>::New(isolate, that.val_)) {
    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }



  inline Global(Global&& other) : PersistentBase<T>(other.val_) {
    other.val_ = nullptr;
  }
  inline ~Global() { this->Reset(); }



  template <class S>
  inline Global& operator=(Global<S>&& rhs) {
    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
    if (this != &rhs) {
      this->Reset();
      this->val_ = rhs.val_;
      rhs.val_ = nullptr;
    }
    return *this;
  }



  Global Pass() { return static_cast<Global&&>(*this); }




  typedef void MoveOnlyTypeForCPP03;

 private:
  template <class F>
  friend class ReturnValue;
  Global(const Global&) = delete;
  void operator=(const Global&) = delete;
  inline T* operator*() const { return this->val_; }
};



template <class T>
using UniquePersistent = Global<T>;
class HandleScope {
 public:
  explicit HandleScope(Isolate* isolate);

  ~HandleScope();




  static int NumberOfHandles(Isolate* isolate);

  inline Isolate* GetIsolate() const {
    return reinterpret_cast<Isolate*>(isolate_);
  }

 protected:
  inline HandleScope() {}

  void Initialize(Isolate* isolate);

  static internal::Object** CreateHandle(internal::Isolate* isolate,
                                         internal::Object* value);

 private:

  static internal::Object** CreateHandle(internal::HeapObject* heap_object,
                                         internal::Object* value);



  HandleScope(const HandleScope&);
  void operator=(const HandleScope&);
  void* operator new(size_t size);
  void operator delete(void*, size_t);

  internal::Isolate* isolate_;
  internal::Object** prev_next_;
  internal::Object** prev_limit_;


  template<class F> friend class Local;



  friend class Object;
  friend class Context;
};






class EscapableHandleScope : public HandleScope {
 public:
  explicit EscapableHandleScope(Isolate* isolate);
  inline ~EscapableHandleScope() {}





  template <class T>
  inline Local<T> Escape(Local<T> value) {
    internal::Object** slot =
        Escape(reinterpret_cast<internal::Object**>(*value));
    return Local<T>(reinterpret_cast<T*>(slot));
  }

 private:
  internal::Object** Escape(internal::Object** escape_value);



  EscapableHandleScope(const EscapableHandleScope&);
  void operator=(const EscapableHandleScope&);
  void* operator new(size_t size);
  void operator delete(void*, size_t);

  internal::Object** escape_slot_;
};

class SealHandleScope {
 public:
  SealHandleScope(Isolate* isolate);
  ~SealHandleScope();

 private:


  SealHandleScope(const SealHandleScope&);
  void operator=(const SealHandleScope&);
  void* operator new(size_t size);
  void operator delete(void*, size_t) {
   (void)((0 && "should not reach this part of the code") ? 0 : (fprintf(*((__FILEP * const) (*(__gtab_filep(4))) ), "Assertion failed: %s, file: %s, line: %d\n", "0 && \"should not reach this part of the code\"", ".././include/v8.h", 995 ), __abort(), 0));
  };

  internal::Isolate* isolate_;
  int prev_level_;
  internal::Object** prev_limit_;
  int prev_sealed_level_;
};
class Data {
 private:
  Data();
};





class ScriptOriginOptions {
 public:
  inline ScriptOriginOptions(bool is_embedder_debug_script = false,
                                bool is_shared_cross_origin = false,
                                bool is_opaque = false)
      : flags_((is_embedder_debug_script ? kIsEmbedderDebugScript : 0) |
               (is_shared_cross_origin ? kIsSharedCrossOrigin : 0) |
               (is_opaque ? kIsOpaque : 0)) {}
  inline ScriptOriginOptions(int flags)
      : flags_(flags &
               (kIsEmbedderDebugScript | kIsSharedCrossOrigin | kIsOpaque)) {}
  bool IsEmbedderDebugScript() const {
    return (flags_ & kIsEmbedderDebugScript) != 0;
  }
  bool IsSharedCrossOrigin() const {
    return (flags_ & kIsSharedCrossOrigin) != 0;
  }
  bool IsOpaque() const { return (flags_ & kIsOpaque) != 0; }
  int Flags() const { return flags_; }

 private:
  enum {
    kIsEmbedderDebugScript = 1,
    kIsSharedCrossOrigin = 1 << 1,
    kIsOpaque = 1 << 2
  };
  const int flags_;
};




class ScriptOrigin {
 public:
  inline ScriptOrigin(
      Local<Value> resource_name,
      Local<Integer> resource_line_offset = Local<Integer>(),
      Local<Integer> resource_column_offset = Local<Integer>(),
      Local<Boolean> resource_is_shared_cross_origin = Local<Boolean>(),
      Local<Integer> script_id = Local<Integer>(),
      Local<Boolean> resource_is_embedder_debug_script = Local<Boolean>(),
      Local<Value> source_map_url = Local<Value>(),
      Local<Boolean> resource_is_opaque = Local<Boolean>());
  inline Local<Value> ResourceName() const;
  inline Local<Integer> ResourceLineOffset() const;
  inline Local<Integer> ResourceColumnOffset() const;



  inline Local<Integer> ScriptID() const;
  inline Local<Value> SourceMapUrl() const;
  inline ScriptOriginOptions Options() const { return options_; }

 private:
  Local<Value> resource_name_;
  Local<Integer> resource_line_offset_;
  Local<Integer> resource_column_offset_;
  ScriptOriginOptions options_;
  Local<Integer> script_id_;
  Local<Value> source_map_url_;
};





class UnboundScript {
 public:



  Local<Script> BindToCurrentContext();

  int GetId();
  Local<Value> GetScriptName();




  Local<Value> GetSourceURL();



  Local<Value> GetSourceMappingURL();





  int GetLineNumber(int code_pos);

  static const int kNoScriptId = 0;
};






class Script {
 public:



  static Local<Script> Compile(Local<String> source, ScriptOrigin* origin = nullptr) __attribute__((deprecated));



  static __attribute__((warn_unused_result)) MaybeLocal<Script> Compile(
      Local<Context> context, Local<String> source,
      ScriptOrigin* origin = nullptr);

  static Local<Script> Compile(Local<String> source, Local<String> file_name) __attribute__((deprecated));
  Local<Value> Run() __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Value> Run(Local<Context> context);




  Local<UnboundScript> GetUnboundScript();
};





class ScriptCompiler {
 public:







  struct CachedData {
    enum BufferPolicy {
      BufferNotOwned,
      BufferOwned
    };

    CachedData()
        : data(0),
          length(0),
          rejected(false),
          buffer_policy(BufferNotOwned) {}





    CachedData(const uint8_t* data, int length,
               BufferPolicy buffer_policy = BufferNotOwned);
    ~CachedData();


    const uint8_t* data;
    int length;
    bool rejected;
    BufferPolicy buffer_policy;

   private:

    CachedData(const CachedData&);
    CachedData& operator=(const CachedData&);
  };




  class Source {
   public:

    inline Source(Local<String> source_string, const ScriptOrigin& origin,
           CachedData* cached_data = 0);
    inline Source(Local<String> source_string,
                     CachedData* cached_data = 0);
    inline ~Source();




    inline const CachedData* GetCachedData() const;

   private:
    friend class ScriptCompiler;

    Source(const Source&);
    Source& operator=(const Source&);

    Local<String> source_string;


    Local<Value> resource_name;
    Local<Integer> resource_line_offset;
    Local<Integer> resource_column_offset;
    ScriptOriginOptions resource_options;
    Local<Value> source_map_url;




    CachedData* cached_data;
  };





  class ExternalSourceStream {
   public:
    virtual ~ExternalSourceStream() {}
    virtual size_t GetMoreData(const uint8_t** src) = 0;
    virtual bool SetBookmark();




    virtual void ResetToBookmark();
  };
  class StreamedSource {
   public:
    enum Encoding { ONE_BYTE, TWO_BYTE, UTF8 };

    StreamedSource(ExternalSourceStream* source_stream, Encoding encoding);
    ~StreamedSource();




    const CachedData* GetCachedData() const;

    internal::StreamedSource* impl() const { return impl_; }

   private:

    StreamedSource(const StreamedSource&);
    StreamedSource& operator=(const StreamedSource&);

    internal::StreamedSource* impl_;
  };





  class ScriptStreamingTask {
   public:
    virtual ~ScriptStreamingTask() {}
    virtual void Run() = 0;
  };

  enum CompileOptions {
    kNoCompileOptions = 0,
    kProduceParserCache,
    kConsumeParserCache,
    kProduceCodeCache,
    kConsumeCodeCache
  };
  static Local<UnboundScript> CompileUnbound( Isolate* isolate, Source* source, CompileOptions options = kNoCompileOptions) __attribute__((deprecated));



  static __attribute__((warn_unused_result)) MaybeLocal<UnboundScript> CompileUnboundScript(
      Isolate* isolate, Source* source,
      CompileOptions options = kNoCompileOptions);
  static Local<Script> Compile(Isolate* isolate, Source* source, CompileOptions options = kNoCompileOptions) __attribute__((deprecated));



  static __attribute__((warn_unused_result)) MaybeLocal<Script> Compile(
      Local<Context> context, Source* source,
      CompileOptions options = kNoCompileOptions);
  static ScriptStreamingTask* StartStreamingScript(
      Isolate* isolate, StreamedSource* source,
      CompileOptions options = kNoCompileOptions);
  static Local<Script> Compile(Isolate* isolate, StreamedSource* source, Local<String> full_source_string, const ScriptOrigin& origin) __attribute__((deprecated));




  static __attribute__((warn_unused_result)) MaybeLocal<Script> Compile(
      Local<Context> context, StreamedSource* source,
      Local<String> full_source_string, const ScriptOrigin& origin);
  static uint32_t CachedDataVersionTag();
  static __attribute__((warn_unused_result)) MaybeLocal<Script> CompileModule(
      Local<Context> context, Source* source,
      CompileOptions options = kNoCompileOptions);
  static Local<Function> CompileFunctionInContext( Isolate* isolate, Source* source, Local<Context> context, size_t arguments_count, Local<String> arguments[], size_t context_extension_count, Local<Object> context_extensions[]) __attribute__((deprecated));






  static __attribute__((warn_unused_result)) MaybeLocal<Function> CompileFunctionInContext(
      Local<Context> context, Source* source, size_t arguments_count,
      Local<String> arguments[], size_t context_extension_count,
      Local<Object> context_extensions[]);

 private:
  static __attribute__((warn_unused_result)) MaybeLocal<UnboundScript> CompileUnboundInternal(
      Isolate* isolate, Source* source, CompileOptions options, bool is_module);
};





class Message {
 public:
  Local<String> Get() const;

  Local<String> GetSourceLine() const __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<String> GetSourceLine(
      Local<Context> context) const;





  ScriptOrigin GetScriptOrigin() const;





  Local<Value> GetScriptResourceName() const;






  Local<StackTrace> GetStackTrace() const;




  int GetLineNumber() const __attribute__((deprecated));
  __attribute__((warn_unused_result)) Maybe<int> GetLineNumber(Local<Context> context) const;





  int GetStartPosition() const;





  int GetEndPosition() const;





  int GetStartColumn() const __attribute__((deprecated));
  __attribute__((warn_unused_result)) Maybe<int> GetStartColumn(Local<Context> context) const;





  int GetEndColumn() const __attribute__((deprecated));
  __attribute__((warn_unused_result)) Maybe<int> GetEndColumn(Local<Context> context) const;





  bool IsSharedCrossOrigin() const;
  bool IsOpaque() const;


  static void PrintCurrentStackTrace(Isolate* isolate, FILE* out);

  static const int kNoLineNumberInfo = 0;
  static const int kNoColumnInfo = 0;
  static const int kNoScriptIdInfo = 0;
};







class StackTrace {
 public:




  enum StackTraceOptions {
    kLineNumber = 1,
    kColumnOffset = 1 << 1 | kLineNumber,
    kScriptName = 1 << 2,
    kFunctionName = 1 << 3,
    kIsEval = 1 << 4,
    kIsConstructor = 1 << 5,
    kScriptNameOrSourceURL = 1 << 6,
    kScriptId = 1 << 7,
    kExposeFramesAcrossSecurityOrigins = 1 << 8,
    kOverview = kLineNumber | kColumnOffset | kScriptName | kFunctionName,
    kDetailed = kOverview | kIsEval | kIsConstructor | kScriptNameOrSourceURL
  };




  Local<StackFrame> GetFrame(uint32_t index) const;




  int GetFrameCount() const;




  Local<Array> AsArray();
  static Local<StackTrace> CurrentStackTrace(
      Isolate* isolate,
      int frame_limit,
      StackTraceOptions options = kOverview);
};





class StackFrame {
 public:






  int GetLineNumber() const;
  int GetColumn() const;







  int GetScriptId() const;





  Local<String> GetScriptName() const;







  Local<String> GetScriptNameOrSourceURL() const;




  Local<String> GetFunctionName() const;





  bool IsEval() const;





  bool IsConstructor() const;
};



enum StateTag { JS, GC, COMPILER, OTHER, EXTERNAL, IDLE };




struct RegisterState {
  RegisterState() : pc(0), sp(0), fp(0) {}
  void* pc;
  void* sp;
  void* fp;
};



struct SampleInfo {
  size_t frames_count;
  StateTag vm_state;
};





class JSON {
 public:







  static Local<Value> Parse(Local<String> json_string) __attribute__((deprecated));

  static __attribute__((warn_unused_result)) MaybeLocal<Value> Parse(
      Isolate* isolate, Local<String> json_string);
};







class NativeWeakMap : public Data {
 public:
  static Local<NativeWeakMap> New(Isolate* isolate);
  void Set(Local<Value> key, Local<Value> value);
  Local<Value> Get(Local<Value> key);
  bool Has(Local<Value> key);
  bool Delete(Local<Value> key);
};
class Value : public Data {
 public:




  inline bool IsUndefined() const;





  inline bool IsNull() const;




  bool IsTrue() const;




  bool IsFalse() const;





  bool IsName() const;





  inline bool IsString() const;





  bool IsSymbol() const;




  bool IsFunction() const;





  bool IsArray() const;




  bool IsObject() const;




  bool IsBoolean() const;




  bool IsNumber() const;




  bool IsExternal() const;




  bool IsInt32() const;




  bool IsUint32() const;




  bool IsDate() const;




  bool IsArgumentsObject() const;




  bool IsBooleanObject() const;




  bool IsNumberObject() const;




  bool IsStringObject() const;





  bool IsSymbolObject() const;




  bool IsNativeError() const;




  bool IsRegExp() const;





  bool IsGeneratorFunction() const;





  bool IsGeneratorObject() const;





  bool IsPromise() const;




  bool IsMap() const;




  bool IsSet() const;




  bool IsMapIterator() const;




  bool IsSetIterator() const;




  bool IsWeakMap() const;




  bool IsWeakSet() const;





  bool IsArrayBuffer() const;





  bool IsArrayBufferView() const;





  bool IsTypedArray() const;





  bool IsUint8Array() const;





  bool IsUint8ClampedArray() const;





  bool IsInt8Array() const;





  bool IsUint16Array() const;





  bool IsInt16Array() const;





  bool IsUint32Array() const;





  bool IsInt32Array() const;





  bool IsFloat32Array() const;





  bool IsFloat64Array() const;





  bool IsFloat32x4() const;





  bool IsDataView() const;





  bool IsSharedArrayBuffer() const;




  bool IsProxy() const;


  __attribute__((warn_unused_result)) MaybeLocal<Boolean> ToBoolean(
      Local<Context> context) const;
  __attribute__((warn_unused_result)) MaybeLocal<Number> ToNumber(
      Local<Context> context) const;
  __attribute__((warn_unused_result)) MaybeLocal<String> ToString(
      Local<Context> context) const;
  __attribute__((warn_unused_result)) MaybeLocal<String> ToDetailString(
      Local<Context> context) const;
  __attribute__((warn_unused_result)) MaybeLocal<Object> ToObject(
      Local<Context> context) const;
  __attribute__((warn_unused_result)) MaybeLocal<Integer> ToInteger(
      Local<Context> context) const;
  __attribute__((warn_unused_result)) MaybeLocal<Uint32> ToUint32(
      Local<Context> context) const;
  __attribute__((warn_unused_result)) MaybeLocal<Int32> ToInt32(Local<Context> context) const;

  Local<Boolean> ToBoolean(Isolate* isolate) const __attribute__((deprecated));

  Local<Number> ToNumber(Isolate* isolate) const __attribute__((deprecated));

  Local<String> ToString(Isolate* isolate) const __attribute__((deprecated));

  Local<String> ToDetailString(Isolate* isolate) const __attribute__((deprecated));

  Local<Object> ToObject(Isolate* isolate) const __attribute__((deprecated));

  Local<Integer> ToInteger(Isolate* isolate) const __attribute__((deprecated));

  Local<Uint32> ToUint32(Isolate* isolate) const __attribute__((deprecated));

  Local<Int32> ToInt32(Isolate* isolate) const __attribute__((deprecated));


  inline Local<Boolean> ToBoolean() const __attribute__((deprecated));

  inline Local<Number> ToNumber() const __attribute__((deprecated));
  inline Local<String> ToString() const __attribute__((deprecated));
  inline Local<String> ToDetailString() const __attribute__((deprecated));

  inline Local<Object> ToObject() const __attribute__((deprecated));
  inline Local<Integer> ToInteger() const __attribute__((deprecated));

  inline Local<Uint32> ToUint32() const __attribute__((deprecated));
  inline Local<Int32> ToInt32() const __attribute__((deprecated));





  Local<Uint32> ToArrayIndex() const __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Uint32> ToArrayIndex(
      Local<Context> context) const;

  __attribute__((warn_unused_result)) Maybe<bool> BooleanValue(Local<Context> context) const;
  __attribute__((warn_unused_result)) Maybe<double> NumberValue(Local<Context> context) const;
  __attribute__((warn_unused_result)) Maybe<int64_t> IntegerValue(
      Local<Context> context) const;
  __attribute__((warn_unused_result)) Maybe<uint32_t> Uint32Value(
      Local<Context> context) const;
  __attribute__((warn_unused_result)) Maybe<int32_t> Int32Value(Local<Context> context) const;

  bool BooleanValue() const __attribute__((deprecated));
  double NumberValue() const __attribute__((deprecated));
  int64_t IntegerValue() const __attribute__((deprecated));
  uint32_t Uint32Value() const __attribute__((deprecated));
  int32_t Int32Value() const __attribute__((deprecated));


  bool Equals(Local<Value> that) const __attribute__((deprecated));
  __attribute__((warn_unused_result)) Maybe<bool> Equals(Local<Context> context,
                                           Local<Value> that) const;
  bool StrictEquals(Local<Value> that) const;
  bool SameValue(Local<Value> that) const;

  template <class T> inline static Value* Cast(T* value);

 private:
  inline bool QuickIsUndefined() const;
  inline bool QuickIsNull() const;
  inline bool QuickIsString() const;
  bool FullIsUndefined() const;
  bool FullIsNull() const;
  bool FullIsString() const;
};





class Primitive : public Value { };






class Boolean : public Primitive {
 public:
  bool Value() const;
  inline static Boolean* Cast(v8::Value* obj);
  inline static Local<Boolean> New(Isolate* isolate, bool value);

 private:
  static void CheckCast(v8::Value* obj);
};





class Name : public Primitive {
 public:







  int GetIdentityHash();

  inline static Name* Cast(v8::Value* obj);
 private:
  static void CheckCast(v8::Value* obj);
};


enum class NewStringType { kNormal, kInternalized };





class String : public Name {
 public:
  static const int kMaxLength = (1 << 28) - 16;

  enum Encoding {
    UNKNOWN_ENCODING = 0x1,
    TWO_BYTE_ENCODING = 0x0,
    ONE_BYTE_ENCODING = 0x4
  };



  int Length() const;





  int Utf8Length() const;






  bool IsOneByte() const;





  bool ContainsOnlyOneByte() const;
  enum WriteOptions {
    NO_OPTIONS = 0,
    HINT_MANY_WRITES_EXPECTED = 1,
    NO_NULL_TERMINATION = 2,
    PRESERVE_ONE_BYTE_NULL = 4,



    REPLACE_INVALID_UTF8 = 8
  };


  int Write(uint16_t* buffer,
            int start = 0,
            int length = -1,
            int options = NO_OPTIONS) const;

  int WriteOneByte(uint8_t* buffer,
                   int start = 0,
                   int length = -1,
                   int options = NO_OPTIONS) const;

  int WriteUtf8(char* buffer,
                int length = -1,
                int* nchars_ref = 0,
                int options = NO_OPTIONS) const;




  inline static v8::Local<v8::String> Empty(Isolate* isolate);




  bool IsExternal() const;




  bool IsExternalOneByte() const;

  class ExternalStringResourceBase {
   public:
    virtual ~ExternalStringResourceBase() {}

    virtual bool IsCompressible() const { return false; }

   protected:
    ExternalStringResourceBase() {}







    virtual void Dispose() { delete this; }

   private:

    ExternalStringResourceBase(const ExternalStringResourceBase&);
    void operator=(const ExternalStringResourceBase&);

    friend class v8::internal::Heap;
  };







  class ExternalStringResource
      : public ExternalStringResourceBase {
   public:




    virtual ~ExternalStringResource() {}




    virtual const uint16_t* data() const = 0;




    virtual size_t length() const = 0;

   protected:
    ExternalStringResource() {}
  };
  class ExternalOneByteStringResource
      : public ExternalStringResourceBase {
   public:




    virtual ~ExternalOneByteStringResource() {}

    virtual const char* data() const = 0;

    virtual size_t length() const = 0;
   protected:
    ExternalOneByteStringResource() {}
  };






  inline ExternalStringResourceBase* GetExternalStringResourceBase(
      Encoding* encoding_out) const;





  inline ExternalStringResource* GetExternalStringResource() const;





  const ExternalOneByteStringResource* GetExternalOneByteStringResource() const;

  inline static String* Cast(v8::Value* obj);


  enum NewStringType {
    kNormalString = static_cast<int>(v8::NewStringType::kNormal),
    kInternalizedString = static_cast<int>(v8::NewStringType::kInternalized)
  };


  static Local<String> NewFromUtf8(Isolate* isolate, const char* data, NewStringType type = kNormalString, int length = -1) __attribute__((deprecated));







  static __attribute__((warn_unused_result)) MaybeLocal<String> NewFromUtf8(
      Isolate* isolate, const char* data, v8::NewStringType type,
      int length = -1);


  static Local<String> NewFromOneByte(Isolate* isolate, const uint8_t* data, NewStringType type = kNormalString, int length = -1) __attribute__((deprecated));







  static __attribute__((warn_unused_result)) MaybeLocal<String> NewFromOneByte(
      Isolate* isolate, const uint8_t* data, v8::NewStringType type,
      int length = -1);


  static Local<String> NewFromTwoByte(Isolate* isolate, const uint16_t* data, NewStringType type = kNormalString, int length = -1) __attribute__((deprecated));







  static __attribute__((warn_unused_result)) MaybeLocal<String> NewFromTwoByte(
      Isolate* isolate, const uint16_t* data, v8::NewStringType type,
      int length = -1);





  static Local<String> Concat(Local<String> left, Local<String> right);
  static Local<String> NewExternal( Isolate* isolate, ExternalStringResource* resource) __attribute__((deprecated));


  static __attribute__((warn_unused_result)) MaybeLocal<String> NewExternalTwoByte(
      Isolate* isolate, ExternalStringResource* resource);
  bool MakeExternal(ExternalStringResource* resource);
  static Local<String> NewExternal(Isolate* isolate, ExternalOneByteStringResource* resource) __attribute__((deprecated));



  static __attribute__((warn_unused_result)) MaybeLocal<String> NewExternalOneByte(
      Isolate* isolate, ExternalOneByteStringResource* resource);
  bool MakeExternal(ExternalOneByteStringResource* resource);




  bool CanMakeExternal();
  class Utf8Value {
   public:
    explicit Utf8Value(Local<v8::Value> obj);
    ~Utf8Value();
    char* operator*() { return str_; }
    const char* operator*() const { return str_; }
    int length() const { return length_; }
   private:
    char* str_;
    int length_;


    Utf8Value(const Utf8Value&);
    void operator=(const Utf8Value&);
  };







  class Value {
   public:
    explicit Value(Local<v8::Value> obj);
    ~Value();
    uint16_t* operator*() { return str_; }
    const uint16_t* operator*() const { return str_; }
    int length() const { return length_; }
   private:
    uint16_t* str_;
    int length_;


    Value(const Value&);
    void operator=(const Value&);
  };

 private:
  void VerifyExternalStringResourceBase(ExternalStringResourceBase* v,
                                        Encoding encoding) const;
  void VerifyExternalStringResource(ExternalStringResource* val) const;
  static void CheckCast(v8::Value* obj);
};







class Symbol : public Name {
 public:

  Local<Value> Name() const;


  static Local<Symbol> New(Isolate* isolate,
                           Local<String> name = Local<String>());






  static Local<Symbol> For(Isolate *isolate, Local<String> name);



  static Local<Symbol> ForApi(Isolate *isolate, Local<String> name);


  static Local<Symbol> GetIterator(Isolate* isolate);
  static Local<Symbol> GetUnscopables(Isolate* isolate);
  static Local<Symbol> GetToStringTag(Isolate* isolate);
  static Local<Symbol> GetIsConcatSpreadable(Isolate* isolate);

  inline static Symbol* Cast(v8::Value* obj);

 private:
  Symbol();
  static void CheckCast(v8::Value* obj);
};







class Private : public Data {
 public:

  Local<Value> Name() const;


  static Local<Private> New(Isolate* isolate,
                            Local<String> name = Local<String>());
  static Local<Private> ForApi(Isolate* isolate, Local<String> name);

 private:
  Private();
};





class Number : public Primitive {
 public:
  double Value() const;
  static Local<Number> New(Isolate* isolate, double value);
  inline static Number* Cast(v8::Value* obj);
 private:
  Number();
  static void CheckCast(v8::Value* obj);
};





class Integer : public Number {
 public:
  static Local<Integer> New(Isolate* isolate, int32_t value);
  static Local<Integer> NewFromUnsigned(Isolate* isolate, uint32_t value);
  int64_t Value() const;
  inline static Integer* Cast(v8::Value* obj);
 private:
  Integer();
  static void CheckCast(v8::Value* obj);
};





class Int32 : public Integer {
 public:
  int32_t Value() const;
  inline static Int32* Cast(v8::Value* obj);

 private:
  Int32();
  static void CheckCast(v8::Value* obj);
};





class Uint32 : public Integer {
 public:
  uint32_t Value() const;
  inline static Uint32* Cast(v8::Value* obj);

 private:
  Uint32();
  static void CheckCast(v8::Value* obj);
};


enum PropertyAttribute {
  None = 0,
  ReadOnly = 1 << 0,
  DontEnum = 1 << 1,
  DontDelete = 1 << 2
};






typedef void (*AccessorGetterCallback)(
    Local<String> property,
    const PropertyCallbackInfo<Value>& info);
typedef void (*AccessorNameGetterCallback)(
    Local<Name> property,
    const PropertyCallbackInfo<Value>& info);


typedef void (*AccessorSetterCallback)(
    Local<String> property,
    Local<Value> value,
    const PropertyCallbackInfo<void>& info);
typedef void (*AccessorNameSetterCallback)(
    Local<Name> property,
    Local<Value> value,
    const PropertyCallbackInfo<void>& info);
enum AccessControl {
  DEFAULT = 0,
  ALL_CAN_READ = 1,
  ALL_CAN_WRITE = 1 << 1,
  PROHIBITS_OVERWRITING = 1 << 2
};





class Object : public Value {
 public:
  bool Set(Local<Value> key, Local<Value> value) __attribute__((deprecated));

  __attribute__((warn_unused_result)) Maybe<bool> Set(Local<Context> context,
                                        Local<Value> key, Local<Value> value);

  bool Set(uint32_t index, Local<Value> value) __attribute__((deprecated));

  __attribute__((warn_unused_result)) Maybe<bool> Set(Local<Context> context, uint32_t index,
                                        Local<Value> value);
  __attribute__((warn_unused_result)) Maybe<bool> CreateDataProperty(Local<Context> context,
                                                       Local<Name> key,
                                                       Local<Value> value);
  __attribute__((warn_unused_result)) Maybe<bool> CreateDataProperty(Local<Context> context,
                                                       uint32_t index,
                                                       Local<Value> value);







  __attribute__((warn_unused_result)) Maybe<bool> DefineOwnProperty(
      Local<Context> context, Local<Name> key, Local<Value> value,
      PropertyAttribute attributes = None);
  bool ForceSet(Local<Value> key, Local<Value> value, PropertyAttribute attribs = None) __attribute__((deprecated));


  Maybe<bool> ForceSet(Local<Context> context, Local<Value> key, Local<Value> value, PropertyAttribute attribs = None) __attribute__((deprecated));




  Local<Value> Get(Local<Value> key) __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Value> Get(Local<Context> context,
                                              Local<Value> key);

  Local<Value> Get(uint32_t index) __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Value> Get(Local<Context> context,
                                              uint32_t index);






  PropertyAttribute GetPropertyAttributes(Local<Value> key) __attribute__((deprecated));

  __attribute__((warn_unused_result)) Maybe<PropertyAttribute> GetPropertyAttributes(
      Local<Context> context, Local<Value> key);




  Local<Value> GetOwnPropertyDescriptor(Local<String> key) __attribute__((deprecated));

  __attribute__((warn_unused_result)) MaybeLocal<Value> GetOwnPropertyDescriptor(
      Local<Context> context, Local<String> key);

  bool Has(Local<Value> key) __attribute__((deprecated));
  __attribute__((warn_unused_result)) Maybe<bool> Has(Local<Context> context,
                                        Local<Value> key);

  bool Delete(Local<Value> key) __attribute__((deprecated));

  Maybe<bool> Delete(Local<Context> context, Local<Value> key);

  bool Has(uint32_t index) __attribute__((deprecated));
  __attribute__((warn_unused_result)) Maybe<bool> Has(Local<Context> context, uint32_t index);

  bool Delete(uint32_t index) __attribute__((deprecated));

  Maybe<bool> Delete(Local<Context> context, uint32_t index);

  bool SetAccessor(Local<String> name, AccessorGetterCallback getter, AccessorSetterCallback setter = 0, Local<Value> data = Local<Value>(), AccessControl settings = DEFAULT, PropertyAttribute attribute = None) __attribute__((deprecated));






  bool SetAccessor(Local<Name> name, AccessorNameGetterCallback getter, AccessorNameSetterCallback setter = 0, Local<Value> data = Local<Value>(), AccessControl settings = DEFAULT, PropertyAttribute attribute = None) __attribute__((deprecated));







  Maybe<bool> SetAccessor(Local<Context> context, Local<Name> name,
                          AccessorNameGetterCallback getter,
                          AccessorNameSetterCallback setter = 0,
                          MaybeLocal<Value> data = MaybeLocal<Value>(),
                          AccessControl settings = DEFAULT,
                          PropertyAttribute attribute = None);

  void SetAccessorProperty(Local<Name> name, Local<Function> getter,
                           Local<Function> setter = Local<Function>(),
                           PropertyAttribute attribute = None,
                           AccessControl settings = DEFAULT);







  Maybe<bool> HasPrivate(Local<Context> context, Local<Private> key);
  Maybe<bool> SetPrivate(Local<Context> context, Local<Private> key,
                         Local<Value> value);
  Maybe<bool> DeletePrivate(Local<Context> context, Local<Private> key);
  MaybeLocal<Value> GetPrivate(Local<Context> context, Local<Private> key);







  Local<Array> GetPropertyNames() __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Array> GetPropertyNames(
      Local<Context> context);






  Local<Array> GetOwnPropertyNames() __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Array> GetOwnPropertyNames(
      Local<Context> context);






  Local<Value> GetPrototype();






  bool SetPrototype(Local<Value> prototype) __attribute__((deprecated));
  __attribute__((warn_unused_result)) Maybe<bool> SetPrototype(Local<Context> context,
                                                 Local<Value> prototype);





  Local<Object> FindInstanceInPrototypeChain(Local<FunctionTemplate> tmpl);






  Local<String> ObjectProtoToString() __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<String> ObjectProtoToString(
      Local<Context> context);




  Local<String> GetConstructorName();


  int InternalFieldCount();


  inline static int InternalFieldCount(
      const PersistentBase<Object>& object) {
    return object.val_->InternalFieldCount();
  }


  inline Local<Value> GetInternalField(int index);


  void SetInternalField(int index, Local<Value> value);






  inline void* GetAlignedPointerFromInternalField(int index);


  inline static void* GetAlignedPointerFromInternalField(
      const PersistentBase<Object>& object, int index) {
    return object.val_->GetAlignedPointerFromInternalField(index);
  }






  void SetAlignedPointerInInternalField(int index, void* value);


  bool HasOwnProperty(Local<String> key) __attribute__((deprecated));
  __attribute__((warn_unused_result)) Maybe<bool> HasOwnProperty(Local<Context> context,
                                                   Local<Name> key);
  bool HasRealNamedProperty(Local<String> key) __attribute__((deprecated));

  __attribute__((warn_unused_result)) Maybe<bool> HasRealNamedProperty(Local<Context> context,
                                                         Local<Name> key);
  bool HasRealIndexedProperty(uint32_t index) __attribute__((deprecated));

  __attribute__((warn_unused_result)) Maybe<bool> HasRealIndexedProperty(
      Local<Context> context, uint32_t index);
  bool HasRealNamedCallbackProperty(Local<String> key) __attribute__((deprecated));

  __attribute__((warn_unused_result)) Maybe<bool> HasRealNamedCallbackProperty(
      Local<Context> context, Local<Name> key);





  Local<Value> GetRealNamedPropertyInPrototypeChain(Local<String> key) __attribute__((deprecated));


  __attribute__((warn_unused_result)) MaybeLocal<Value> GetRealNamedPropertyInPrototypeChain(
      Local<Context> context, Local<Name> key);






  Maybe<PropertyAttribute> GetRealNamedPropertyAttributesInPrototypeChain( Local<String> key) __attribute__((deprecated));



  __attribute__((warn_unused_result)) Maybe<PropertyAttribute>
  GetRealNamedPropertyAttributesInPrototypeChain(Local<Context> context,
                                                 Local<Name> key);






  Local<Value> GetRealNamedProperty(Local<String> key) __attribute__((deprecated));

  __attribute__((warn_unused_result)) MaybeLocal<Value> GetRealNamedProperty(
      Local<Context> context, Local<Name> key);






  Maybe<PropertyAttribute> GetRealNamedPropertyAttributes( Local<String> key) __attribute__((deprecated));


  __attribute__((warn_unused_result)) Maybe<PropertyAttribute> GetRealNamedPropertyAttributes(
      Local<Context> context, Local<Name> key);


  bool HasNamedLookupInterceptor();


  bool HasIndexedLookupInterceptor();
  int GetIdentityHash();

  bool SetHiddenValue(Local<String> key, Local<Value> value) __attribute__((deprecated));

  Local<Value> GetHiddenValue(Local<String> key) __attribute__((deprecated));

  bool DeleteHiddenValue(Local<String> key) __attribute__((deprecated));







  Local<Object> Clone();




  Local<Context> CreationContext();






  bool IsCallable();





  Local<Value> CallAsFunction(Local<Value> recv, int argc, Local<Value> argv[]) __attribute__((deprecated));


  __attribute__((warn_unused_result)) MaybeLocal<Value> CallAsFunction(Local<Context> context,
                                                         Local<Value> recv,
                                                         int argc,
                                                         Local<Value> argv[]);






  Local<Value> CallAsConstructor(int argc, Local<Value> argv[]) __attribute__((deprecated));

  __attribute__((warn_unused_result)) MaybeLocal<Value> CallAsConstructor(
      Local<Context> context, int argc, Local<Value> argv[]);




  Isolate* GetIsolate() __attribute__((deprecated));

  static Local<Object> New(Isolate* isolate);

  inline static Object* Cast(Value* obj);

 private:
  Object();
  static void CheckCast(Value* obj);
  Local<Value> SlowGetInternalField(int index);
  void* SlowGetAlignedPointerFromInternalField(int index);
};





class Array : public Object {
 public:
  uint32_t Length() const;





  Local<Object> CloneElementAt(uint32_t index) __attribute__((deprecated));

  MaybeLocal<Object> CloneElementAt(Local<Context> context, uint32_t index) __attribute__((deprecated));







  static Local<Array> New(Isolate* isolate, int length = 0);

  inline static Array* Cast(Value* obj);
 private:
  Array();
  static void CheckCast(Value* obj);
};





class Map : public Object {
 public:
  size_t Size() const;
  void Clear();
  __attribute__((warn_unused_result)) MaybeLocal<Value> Get(Local<Context> context,
                                              Local<Value> key);
  __attribute__((warn_unused_result)) MaybeLocal<Map> Set(Local<Context> context,
                                            Local<Value> key,
                                            Local<Value> value);
  __attribute__((warn_unused_result)) Maybe<bool> Has(Local<Context> context,
                                        Local<Value> key);
  __attribute__((warn_unused_result)) Maybe<bool> Delete(Local<Context> context,
                                           Local<Value> key);





  Local<Array> AsArray() const;




  static Local<Map> New(Isolate* isolate);

  inline static Map* Cast(Value* obj);

 private:
  Map();
  static void CheckCast(Value* obj);
};





class Set : public Object {
 public:
  size_t Size() const;
  void Clear();
  __attribute__((warn_unused_result)) MaybeLocal<Set> Add(Local<Context> context,
                                            Local<Value> key);
  __attribute__((warn_unused_result)) Maybe<bool> Has(Local<Context> context,
                                        Local<Value> key);
  __attribute__((warn_unused_result)) Maybe<bool> Delete(Local<Context> context,
                                           Local<Value> key);




  Local<Array> AsArray() const;




  static Local<Set> New(Isolate* isolate);

  inline static Set* Cast(Value* obj);

 private:
  Set();
  static void CheckCast(Value* obj);
};


template<typename T>
class ReturnValue {
 public:
  template <class S> inline ReturnValue(const ReturnValue<S>& that)
      : value_(that.value_) {
    while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  }

  template <typename S>
  inline void Set(const Persistent<S>& handle) __attribute__((deprecated));

  template <typename S>
  inline void Set(const Global<S>& handle);
  template <typename S>
  inline void Set(const Local<S> handle);

  inline void Set(bool value);
  inline void Set(double i);
  inline void Set(int32_t i);
  inline void Set(uint32_t i);

  inline void SetNull();
  inline void SetUndefined();
  inline void SetEmptyString();

  inline Isolate* GetIsolate();


  template <typename S>
  inline void Set(S* whatever);

 private:
  template<class F> friend class ReturnValue;
  template<class F> friend class FunctionCallbackInfo;
  template<class F> friend class PropertyCallbackInfo;
  template <class F, class G, class H>
  friend class PersistentValueMapBase;
  inline void SetInternal(internal::Object* value) { *value_ = value; }
  inline internal::Object* GetDefaultValue();
  inline explicit ReturnValue(internal::Object** slot);
  internal::Object** value_;
};
template<typename T>
class FunctionCallbackInfo {
 public:
  inline int Length() const;
  inline Local<Value> operator[](int i) const;
  inline Local<Function> Callee() const __attribute__((deprecated));

  inline Local<Object> This() const;
  inline Local<Object> Holder() const;
  inline bool IsConstructCall() const;
  inline Local<Value> Data() const;
  inline Isolate* GetIsolate() const;
  inline ReturnValue<T> GetReturnValue() const;

  static const int kArgsLength = 7;

 protected:
  friend class internal::FunctionCallbackArguments;
  friend class internal::CustomArguments<FunctionCallbackInfo>;
  static const int kHolderIndex = 0;
  static const int kIsolateIndex = 1;
  static const int kReturnValueDefaultValueIndex = 2;
  static const int kReturnValueIndex = 3;
  static const int kDataIndex = 4;
  static const int kCalleeIndex = 5;
  static const int kContextSaveIndex = 6;

  inline FunctionCallbackInfo(internal::Object** implicit_args,
                   internal::Object** values,
                   int length,
                   bool is_construct_call);
  internal::Object** implicit_args_;
  internal::Object** values_;
  int length_;
  int is_construct_call_;
};






template<typename T>
class PropertyCallbackInfo {
 public:
  inline Isolate* GetIsolate() const;
  inline Local<Value> Data() const;
  inline Local<Object> This() const;
  inline Local<Object> Holder() const;
  inline ReturnValue<T> GetReturnValue() const;
  inline bool ShouldThrowOnError() const;

  static const int kArgsLength = 7;

 protected:
  friend class MacroAssembler;
  friend class internal::PropertyCallbackArguments;
  friend class internal::CustomArguments<PropertyCallbackInfo>;
  static const int kShouldThrowOnErrorIndex = 0;
  static const int kHolderIndex = 1;
  static const int kIsolateIndex = 2;
  static const int kReturnValueDefaultValueIndex = 3;
  static const int kReturnValueIndex = 4;
  static const int kDataIndex = 5;
  static const int kThisIndex = 6;

  inline PropertyCallbackInfo(internal::Object** args) : args_(args) {}
  internal::Object** args_;
};


typedef void (*FunctionCallback)(const FunctionCallbackInfo<Value>& info);





class Function : public Object {
 public:




  static MaybeLocal<Function> New(Local<Context> context,
                                  FunctionCallback callback,
                                  Local<Value> data = Local<Value>(),
                                  int length = 0);
  static Local<Function> New(Isolate* isolate, FunctionCallback callback, Local<Value> data = Local<Value>(), int length = 0) __attribute__((deprecated));




  Local<Object> NewInstance(int argc, Local<Value> argv[]) const __attribute__((deprecated));

  __attribute__((warn_unused_result)) MaybeLocal<Object> NewInstance(
      Local<Context> context, int argc, Local<Value> argv[]) const;

  Local<Object> NewInstance() const __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Object> NewInstance(
      Local<Context> context) const {
    return NewInstance(context, 0, nullptr);
  }

  Local<Value> Call(Local<Value> recv, int argc, Local<Value> argv[]) __attribute__((deprecated));


  __attribute__((warn_unused_result)) MaybeLocal<Value> Call(Local<Context> context,
                                               Local<Value> recv, int argc,
                                               Local<Value> argv[]);

  void SetName(Local<String> name);
  Local<Value> GetName() const;







  Local<Value> GetInferredName() const;





  Local<Value> GetDebugName() const;





  Local<Value> GetDisplayName() const;





  int GetScriptLineNumber() const;




  int GetScriptColumnNumber() const;




  bool IsBuiltin() const;




  int ScriptId() const;





  Local<Value> GetBoundFunction() const;

  ScriptOrigin GetScriptOrigin() const;
  inline static Function* Cast(Value* obj);
  static const int kLineOffsetNotFound;

 private:
  Function();
  static void CheckCast(Value* obj);
};






class Promise : public Object {
 public:
  class Resolver : public Object {
   public:



    static Local<Resolver> New(Isolate* isolate) __attribute__((deprecated));

    static __attribute__((warn_unused_result)) MaybeLocal<Resolver> New(
        Local<Context> context);




    Local<Promise> GetPromise();





    void Resolve(Local<Value> value) __attribute__((deprecated));

    Maybe<bool> Resolve(Local<Context> context, Local<Value> value);

    void Reject(Local<Value> value) __attribute__((deprecated));

    Maybe<bool> Reject(Local<Context> context, Local<Value> value);

    inline static Resolver* Cast(Value* obj);

   private:
    Resolver();
    static void CheckCast(Value* obj);
  };







  Local<Promise> Chain(Local<Function> handler) __attribute__((deprecated));

  __attribute__((warn_unused_result)) MaybeLocal<Promise> Chain( Local<Context> context, Local<Function> handler) __attribute__((deprecated));



  Local<Promise> Catch(Local<Function> handler) __attribute__((deprecated));

  __attribute__((warn_unused_result)) MaybeLocal<Promise> Catch(Local<Context> context,
                                                  Local<Function> handler);

  Local<Promise> Then(Local<Function> handler) __attribute__((deprecated));

  __attribute__((warn_unused_result)) MaybeLocal<Promise> Then(Local<Context> context,
                                                 Local<Function> handler);





  bool HasHandler();

  inline static Promise* Cast(Value* obj);

 private:
  Promise();
  static void CheckCast(Value* obj);
};






class Proxy : public Object {
 public:
  Local<Object> GetTarget();
  Local<Value> GetHandler();
  bool IsRevoked();
  void Revoke();




  static MaybeLocal<Proxy> New(Local<Context> context,
                               Local<Object> local_target,
                               Local<Object> local_handler);

  inline static Proxy* Cast(Value* obj);

 private:
  Proxy();
  static void CheckCast(Value* obj);
};
enum class ArrayBufferCreationMode { kInternalized, kExternalized };






class ArrayBuffer : public Object {
 public:







  class Allocator {
   public:
    virtual ~Allocator() {}





    virtual void* Allocate(size_t length) = 0;





    virtual void* AllocateUninitialized(size_t length) = 0;




    virtual void Free(void* data, size_t length) = 0;
  };
  class Contents {
   public:
    Contents() : data_(0), byte_length_(0) {}

    void* Data() const { return data_; }
    size_t ByteLength() const { return byte_length_; }

   private:
    void* data_;
    size_t byte_length_;

    friend class ArrayBuffer;
  };





  size_t ByteLength() const;







  static Local<ArrayBuffer> New(Isolate* isolate, size_t byte_length);







  static Local<ArrayBuffer> New(
      Isolate* isolate, void* data, size_t byte_length,
      ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);





  bool IsExternal() const;




  bool IsNeuterable() const;







  void Neuter();
  Contents Externalize();
  Contents GetContents();

  inline static ArrayBuffer* Cast(Value* obj);

  static const int kInternalFieldCount = 2;

 private:
  ArrayBuffer();
  static void CheckCast(Value* obj);
};
class ArrayBufferView : public Object {
 public:



  Local<ArrayBuffer> Buffer();



  size_t ByteOffset();



  size_t ByteLength();
  size_t CopyContents(void* dest, size_t byte_length);





  bool HasBuffer() const;

  inline static ArrayBufferView* Cast(Value* obj);

  static const int kInternalFieldCount =
      2;

 private:
  ArrayBufferView();
  static void CheckCast(Value* obj);
};







class TypedArray : public ArrayBufferView {
 public:




  size_t Length();

  inline static TypedArray* Cast(Value* obj);

 private:
  TypedArray();
  static void CheckCast(Value* obj);
};






class Uint8Array : public TypedArray {
 public:
  static Local<Uint8Array> New(Local<ArrayBuffer> array_buffer,
                               size_t byte_offset, size_t length);
  static Local<Uint8Array> New(Local<SharedArrayBuffer> shared_array_buffer,
                               size_t byte_offset, size_t length);
  inline static Uint8Array* Cast(Value* obj);

 private:
  Uint8Array();
  static void CheckCast(Value* obj);
};






class Uint8ClampedArray : public TypedArray {
 public:
  static Local<Uint8ClampedArray> New(Local<ArrayBuffer> array_buffer,
                                      size_t byte_offset, size_t length);
  static Local<Uint8ClampedArray> New(
      Local<SharedArrayBuffer> shared_array_buffer, size_t byte_offset,
      size_t length);
  inline static Uint8ClampedArray* Cast(Value* obj);

 private:
  Uint8ClampedArray();
  static void CheckCast(Value* obj);
};





class Int8Array : public TypedArray {
 public:
  static Local<Int8Array> New(Local<ArrayBuffer> array_buffer,
                              size_t byte_offset, size_t length);
  static Local<Int8Array> New(Local<SharedArrayBuffer> shared_array_buffer,
                              size_t byte_offset, size_t length);
  inline static Int8Array* Cast(Value* obj);

 private:
  Int8Array();
  static void CheckCast(Value* obj);
};






class Uint16Array : public TypedArray {
 public:
  static Local<Uint16Array> New(Local<ArrayBuffer> array_buffer,
                                size_t byte_offset, size_t length);
  static Local<Uint16Array> New(Local<SharedArrayBuffer> shared_array_buffer,
                                size_t byte_offset, size_t length);
  inline static Uint16Array* Cast(Value* obj);

 private:
  Uint16Array();
  static void CheckCast(Value* obj);
};






class Int16Array : public TypedArray {
 public:
  static Local<Int16Array> New(Local<ArrayBuffer> array_buffer,
                               size_t byte_offset, size_t length);
  static Local<Int16Array> New(Local<SharedArrayBuffer> shared_array_buffer,
                               size_t byte_offset, size_t length);
  inline static Int16Array* Cast(Value* obj);

 private:
  Int16Array();
  static void CheckCast(Value* obj);
};






class Uint32Array : public TypedArray {
 public:
  static Local<Uint32Array> New(Local<ArrayBuffer> array_buffer,
                                size_t byte_offset, size_t length);
  static Local<Uint32Array> New(Local<SharedArrayBuffer> shared_array_buffer,
                                size_t byte_offset, size_t length);
  inline static Uint32Array* Cast(Value* obj);

 private:
  Uint32Array();
  static void CheckCast(Value* obj);
};






class Int32Array : public TypedArray {
 public:
  static Local<Int32Array> New(Local<ArrayBuffer> array_buffer,
                               size_t byte_offset, size_t length);
  static Local<Int32Array> New(Local<SharedArrayBuffer> shared_array_buffer,
                               size_t byte_offset, size_t length);
  inline static Int32Array* Cast(Value* obj);

 private:
  Int32Array();
  static void CheckCast(Value* obj);
};






class Float32Array : public TypedArray {
 public:
  static Local<Float32Array> New(Local<ArrayBuffer> array_buffer,
                                 size_t byte_offset, size_t length);
  static Local<Float32Array> New(Local<SharedArrayBuffer> shared_array_buffer,
                                 size_t byte_offset, size_t length);
  inline static Float32Array* Cast(Value* obj);

 private:
  Float32Array();
  static void CheckCast(Value* obj);
};






class Float64Array : public TypedArray {
 public:
  static Local<Float64Array> New(Local<ArrayBuffer> array_buffer,
                                 size_t byte_offset, size_t length);
  static Local<Float64Array> New(Local<SharedArrayBuffer> shared_array_buffer,
                                 size_t byte_offset, size_t length);
  inline static Float64Array* Cast(Value* obj);

 private:
  Float64Array();
  static void CheckCast(Value* obj);
};






class DataView : public ArrayBufferView {
 public:
  static Local<DataView> New(Local<ArrayBuffer> array_buffer,
                             size_t byte_offset, size_t length);
  static Local<DataView> New(Local<SharedArrayBuffer> shared_array_buffer,
                             size_t byte_offset, size_t length);
  inline static DataView* Cast(Value* obj);

 private:
  DataView();
  static void CheckCast(Value* obj);
};






class SharedArrayBuffer : public Object {
 public:
  class Contents {
   public:
    Contents() : data_(0), byte_length_(0) {}

    void* Data() const { return data_; }
    size_t ByteLength() const { return byte_length_; }

   private:
    void* data_;
    size_t byte_length_;

    friend class SharedArrayBuffer;
  };





  size_t ByteLength() const;







  static Local<SharedArrayBuffer> New(Isolate* isolate, size_t byte_length);







  static Local<SharedArrayBuffer> New(
      Isolate* isolate, void* data, size_t byte_length,
      ArrayBufferCreationMode mode = ArrayBufferCreationMode::kExternalized);





  bool IsExternal() const;
  Contents Externalize();
  Contents GetContents();

  inline static SharedArrayBuffer* Cast(Value* obj);

  static const int kInternalFieldCount = 2;

 private:
  SharedArrayBuffer();
  static void CheckCast(Value* obj);
};





class Date : public Object {
 public:
  static Local<Value> New(Isolate* isolate, double time) __attribute__((deprecated));

  static __attribute__((warn_unused_result)) MaybeLocal<Value> New(Local<Context> context,
                                                     double time);





  double ValueOf() const;

  inline static Date* Cast(v8::Value* obj);
  static void DateTimeConfigurationChangeNotification(Isolate* isolate);

 private:
  static void CheckCast(v8::Value* obj);
};





class NumberObject : public Object {
 public:
  static Local<Value> New(Isolate* isolate, double value);

  double ValueOf() const;

  inline static NumberObject* Cast(v8::Value* obj);

 private:
  static void CheckCast(v8::Value* obj);
};





class BooleanObject : public Object {
 public:
  static Local<Value> New(Isolate* isolate, bool value);
  static Local<Value> New(bool value) __attribute__((deprecated));

  bool ValueOf() const;

  inline static BooleanObject* Cast(v8::Value* obj);

 private:
  static void CheckCast(v8::Value* obj);
};





class StringObject : public Object {
 public:
  static Local<Value> New(Local<String> value);

  Local<String> ValueOf() const;

  inline static StringObject* Cast(v8::Value* obj);

 private:
  static void CheckCast(v8::Value* obj);
};







class SymbolObject : public Object {
 public:
  static Local<Value> New(Isolate* isolate, Local<Symbol> value);

  Local<Symbol> ValueOf() const;

  inline static SymbolObject* Cast(v8::Value* obj);

 private:
  static void CheckCast(v8::Value* obj);
};





class RegExp : public Object {
 public:




  enum Flags {
    kNone = 0,
    kGlobal = 1,
    kIgnoreCase = 2,
    kMultiline = 4,
    kSticky = 8,
    kUnicode = 16
  };
  static Local<RegExp> New(Local<String> pattern, Flags flags) __attribute__((deprecated));


  static __attribute__((warn_unused_result)) MaybeLocal<RegExp> New(Local<Context> context,
                                                      Local<String> pattern,
                                                      Flags flags);





  Local<String> GetSource() const;




  Flags GetFlags() const;

  inline static RegExp* Cast(v8::Value* obj);

 private:
  static void CheckCast(v8::Value* obj);
};






class External : public Value {
 public:
  static Local<External> New(Isolate* isolate, void* value);
  inline static External* Cast(Value* obj);
  void* Value() const;
 private:
  static void CheckCast(v8::Value* obj);
};




enum Intrinsic {

  kArrayProto_values,

};
class Template : public Data {
 public:

  void Set(Local<Name> name, Local<Data> value,
           PropertyAttribute attributes = None);
  inline void Set(Isolate* isolate, const char* name, Local<Data> value);

  void SetAccessorProperty(
     Local<Name> name,
     Local<FunctionTemplate> getter = Local<FunctionTemplate>(),
     Local<FunctionTemplate> setter = Local<FunctionTemplate>(),
     PropertyAttribute attribute = None,
     AccessControl settings = DEFAULT);
  void SetNativeDataProperty(
      Local<String> name, AccessorGetterCallback getter,
      AccessorSetterCallback setter = 0,

      Local<Value> data = Local<Value>(), PropertyAttribute attribute = None,
      Local<AccessorSignature> signature = Local<AccessorSignature>(),
      AccessControl settings = DEFAULT);
  void SetNativeDataProperty(
      Local<Name> name, AccessorNameGetterCallback getter,
      AccessorNameSetterCallback setter = 0,

      Local<Value> data = Local<Value>(), PropertyAttribute attribute = None,
      Local<AccessorSignature> signature = Local<AccessorSignature>(),
      AccessControl settings = DEFAULT);





  void SetIntrinsicDataProperty(Local<Name> name, Intrinsic intrinsic,
                                PropertyAttribute attribute = None);

 private:
  Template();

  friend class ObjectTemplate;
  friend class FunctionTemplate;
};






typedef void (*NamedPropertyGetterCallback)(
    Local<String> property,
    const PropertyCallbackInfo<Value>& info);






typedef void (*NamedPropertySetterCallback)(
    Local<String> property,
    Local<Value> value,
    const PropertyCallbackInfo<Value>& info);







typedef void (*NamedPropertyQueryCallback)(
    Local<String> property,
    const PropertyCallbackInfo<Integer>& info);







typedef void (*NamedPropertyDeleterCallback)(
    Local<String> property,
    const PropertyCallbackInfo<Boolean>& info);






typedef void (*NamedPropertyEnumeratorCallback)(
    const PropertyCallbackInfo<Array>& info);
typedef void (*GenericNamedPropertyGetterCallback)(
    Local<Name> property, const PropertyCallbackInfo<Value>& info);






typedef void (*GenericNamedPropertySetterCallback)(
    Local<Name> property, Local<Value> value,
    const PropertyCallbackInfo<Value>& info);







typedef void (*GenericNamedPropertyQueryCallback)(
    Local<Name> property, const PropertyCallbackInfo<Integer>& info);







typedef void (*GenericNamedPropertyDeleterCallback)(
    Local<Name> property, const PropertyCallbackInfo<Boolean>& info);






typedef void (*GenericNamedPropertyEnumeratorCallback)(
    const PropertyCallbackInfo<Array>& info);






typedef void (*IndexedPropertyGetterCallback)(
    uint32_t index,
    const PropertyCallbackInfo<Value>& info);






typedef void (*IndexedPropertySetterCallback)(
    uint32_t index,
    Local<Value> value,
    const PropertyCallbackInfo<Value>& info);






typedef void (*IndexedPropertyQueryCallback)(
    uint32_t index,
    const PropertyCallbackInfo<Integer>& info);







typedef void (*IndexedPropertyDeleterCallback)(
    uint32_t index,
    const PropertyCallbackInfo<Boolean>& info);






typedef void (*IndexedPropertyEnumeratorCallback)(
    const PropertyCallbackInfo<Array>& info);





enum AccessType {
  ACCESS_GET,
  ACCESS_SET,
  ACCESS_HAS,
  ACCESS_DELETE,
  ACCESS_KEYS
};






typedef bool (*AccessCheckCallback)(Local<Context> accessing_context,
                                    Local<Object> accessed_object,
                                    Local<Value> data);
typedef bool (*DeprecatedAccessCheckCallback)(Local<Context> accessing_context,
                                              Local<Object> accessed_object);





typedef bool (*NamedSecurityCallback)(Local<Object> host,
                                      Local<Value> key,
                                      AccessType type,
                                      Local<Value> data);






typedef bool (*IndexedSecurityCallback)(Local<Object> host,
                                        uint32_t index,
                                        AccessType type,
                                        Local<Value> data);
class FunctionTemplate : public Template {
 public:

  static Local<FunctionTemplate> New(
      Isolate* isolate, FunctionCallback callback = 0,
      Local<Value> data = Local<Value>(),
      Local<Signature> signature = Local<Signature>(), int length = 0);





  static Local<FunctionTemplate> NewWithFastHandler(
      Isolate* isolate, FunctionCallback callback,
      experimental::FastAccessorBuilder* fast_handler = nullptr,
      Local<Value> data = Local<Value>(),
      Local<Signature> signature = Local<Signature>(), int length = 0);


  Local<Function> GetFunction() __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Function> GetFunction(
      Local<Context> context);






  void SetCallHandler(
      FunctionCallback callback, Local<Value> data = Local<Value>(),
      experimental::FastAccessorBuilder* fast_handler = nullptr);


  void SetLength(int length);


  Local<ObjectTemplate> InstanceTemplate();


  void Inherit(Local<FunctionTemplate> parent);





  Local<ObjectTemplate> PrototypeTemplate();






  void SetClassName(Local<String> name);






  void SetAcceptAnyReceiver(bool value);
  void SetHiddenPrototype(bool value);





  void ReadOnlyPrototype();





  void RemovePrototype();





  bool HasInstance(Local<Value> object);

 private:
  FunctionTemplate();
  friend class Context;
  friend class ObjectTemplate;
};


enum class PropertyHandlerFlags {
  kNone = 0,

  kAllCanRead = 1,


  kNonMasking = 1 << 1,


  kOnlyInterceptStrings = 1 << 2,
};


struct NamedPropertyHandlerConfiguration {
  NamedPropertyHandlerConfiguration(

      GenericNamedPropertyGetterCallback getter = 0,
      GenericNamedPropertySetterCallback setter = 0,
      GenericNamedPropertyQueryCallback query = 0,
      GenericNamedPropertyDeleterCallback deleter = 0,
      GenericNamedPropertyEnumeratorCallback enumerator = 0,
      Local<Value> data = Local<Value>(),
      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
      : getter(getter),
        setter(setter),
        query(query),
        deleter(deleter),
        enumerator(enumerator),
        data(data),
        flags(flags) {}

  GenericNamedPropertyGetterCallback getter;
  GenericNamedPropertySetterCallback setter;
  GenericNamedPropertyQueryCallback query;
  GenericNamedPropertyDeleterCallback deleter;
  GenericNamedPropertyEnumeratorCallback enumerator;
  Local<Value> data;
  PropertyHandlerFlags flags;
};


struct IndexedPropertyHandlerConfiguration {
  IndexedPropertyHandlerConfiguration(

      IndexedPropertyGetterCallback getter = 0,
      IndexedPropertySetterCallback setter = 0,
      IndexedPropertyQueryCallback query = 0,
      IndexedPropertyDeleterCallback deleter = 0,
      IndexedPropertyEnumeratorCallback enumerator = 0,
      Local<Value> data = Local<Value>(),
      PropertyHandlerFlags flags = PropertyHandlerFlags::kNone)
      : getter(getter),
        setter(setter),
        query(query),
        deleter(deleter),
        enumerator(enumerator),
        data(data),
        flags(flags) {}

  IndexedPropertyGetterCallback getter;
  IndexedPropertySetterCallback setter;
  IndexedPropertyQueryCallback query;
  IndexedPropertyDeleterCallback deleter;
  IndexedPropertyEnumeratorCallback enumerator;
  Local<Value> data;
  PropertyHandlerFlags flags;
};
class ObjectTemplate : public Template {
 public:

  static Local<ObjectTemplate> New(
      Isolate* isolate,
      Local<FunctionTemplate> constructor = Local<FunctionTemplate>());
  static Local<ObjectTemplate> New() __attribute__((deprecated));


  Local<Object> NewInstance() __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Object> NewInstance(Local<Context> context);
  void SetAccessor(
      Local<String> name, AccessorGetterCallback getter,
      AccessorSetterCallback setter = 0, Local<Value> data = Local<Value>(),
      AccessControl settings = DEFAULT, PropertyAttribute attribute = None,
      Local<AccessorSignature> signature = Local<AccessorSignature>());
  void SetAccessor(
      Local<Name> name, AccessorNameGetterCallback getter,
      AccessorNameSetterCallback setter = 0, Local<Value> data = Local<Value>(),
      AccessControl settings = DEFAULT, PropertyAttribute attribute = None,
      Local<AccessorSignature> signature = Local<AccessorSignature>());
  void SetNamedPropertyHandler(NamedPropertyGetterCallback getter,
                               NamedPropertySetterCallback setter = 0,
                               NamedPropertyQueryCallback query = 0,
                               NamedPropertyDeleterCallback deleter = 0,
                               NamedPropertyEnumeratorCallback enumerator = 0,
                               Local<Value> data = Local<Value>());
  void SetHandler(const NamedPropertyHandlerConfiguration& configuration);
  void SetHandler(const IndexedPropertyHandlerConfiguration& configuration);

  void SetIndexedPropertyHandler(
      IndexedPropertyGetterCallback getter,
      IndexedPropertySetterCallback setter = 0,
      IndexedPropertyQueryCallback query = 0,
      IndexedPropertyDeleterCallback deleter = 0,
      IndexedPropertyEnumeratorCallback enumerator = 0,
      Local<Value> data = Local<Value>()) {
    SetHandler(IndexedPropertyHandlerConfiguration(getter, setter, query,
                                                   deleter, enumerator, data));
  }






  void SetCallAsFunctionHandler(FunctionCallback callback,
                                Local<Value> data = Local<Value>());
  void MarkAsUndetectable();
  void SetAccessCheckCallback(AccessCheckCallback callback,
                              Local<Value> data = Local<Value>());
  void SetAccessCheckCallback(DeprecatedAccessCheckCallback callback, Local<Value> data = Local<Value>()) __attribute__((deprecated));




  void SetAccessCheckCallbacks(NamedSecurityCallback named_handler, IndexedSecurityCallback indexed_handler, Local<Value> data = Local<Value>()) __attribute__((deprecated));
  int InternalFieldCount();





  void SetInternalFieldCount(int value);

 private:
  ObjectTemplate();
  static Local<ObjectTemplate> New(internal::Isolate* isolate,
                                   Local<FunctionTemplate> constructor);
  friend class FunctionTemplate;
};





class Signature : public Data {
 public:
  static Local<Signature> New(
      Isolate* isolate,
      Local<FunctionTemplate> receiver = Local<FunctionTemplate>());

 private:
  Signature();
};






class AccessorSignature : public Data {
 public:
  static Local<AccessorSignature> New(
      Isolate* isolate,
      Local<FunctionTemplate> receiver = Local<FunctionTemplate>());

 private:
  AccessorSignature();
};




class ExternalOneByteStringResourceImpl
    : public String::ExternalOneByteStringResource {
 public:
  ExternalOneByteStringResourceImpl() : data_(0), length_(0) {}
  ExternalOneByteStringResourceImpl(const char* data, size_t length)
      : data_(data), length_(length) {}
  const char* data() const { return data_; }
  size_t length() const { return length_; }

 private:
  const char* data_;
  size_t length_;
};




class Extension {
 public:


  Extension(const char* name,
            const char* source = 0,
            int dep_count = 0,
            const char** deps = 0,
            int source_length = -1);
  virtual ~Extension() { }
  virtual v8::Local<v8::FunctionTemplate> GetNativeFunctionTemplate(
      v8::Isolate* isolate, v8::Local<v8::String> name) {
    return v8::Local<v8::FunctionTemplate>();
  }

  const char* name() const { return name_; }
  size_t source_length() const { return source_length_; }
  const String::ExternalOneByteStringResource* source() const {
    return &source_; }
  int dependency_count() { return dep_count_; }
  const char** dependencies() { return deps_; }
  void set_auto_enable(bool value) { auto_enable_ = value; }
  bool auto_enable() { return auto_enable_; }

 private:
  const char* name_;
  size_t source_length_;
  ExternalOneByteStringResourceImpl source_;
  int dep_count_;
  const char** deps_;
  bool auto_enable_;


  Extension(const Extension&);
  void operator=(const Extension&);
};


void RegisterExtension(Extension* extension);




inline Local<Primitive> Undefined(Isolate* isolate);
inline Local<Primitive> Null(Isolate* isolate);
inline Local<Boolean> True(Isolate* isolate);
inline Local<Boolean> False(Isolate* isolate);
class ResourceConstraints {
 public:
  ResourceConstraints();
  void ConfigureDefaults(uint64_t physical_memory,
                         uint64_t virtual_memory_limit);

  int max_semi_space_size() const { return max_semi_space_size_; }
  void set_max_semi_space_size(int limit_in_mb) {
    max_semi_space_size_ = limit_in_mb;
  }
  int max_old_space_size() const { return max_old_space_size_; }
  void set_max_old_space_size(int limit_in_mb) {
    max_old_space_size_ = limit_in_mb;
  }
  int max_executable_size() const { return max_executable_size_; }
  void set_max_executable_size(int limit_in_mb) {
    max_executable_size_ = limit_in_mb;
  }
  uint32_t* stack_limit() const { return stack_limit_; }

  void set_stack_limit(uint32_t* value) { stack_limit_ = value; }
  size_t code_range_size() const { return code_range_size_; }
  void set_code_range_size(size_t limit_in_mb) {
    code_range_size_ = limit_in_mb;
  }

 private:
  int max_semi_space_size_;
  int max_old_space_size_;
  int max_executable_size_;
  uint32_t* stack_limit_;
  size_t code_range_size_;
};





typedef void (*FatalErrorCallback)(const char* location, const char* message);


typedef void (*MessageCallback)(Local<Message> message, Local<Value> error);



typedef void (*LogEventCallback)(const char* name, int event);





class Exception {
 public:
  static Local<Value> RangeError(Local<String> message);
  static Local<Value> ReferenceError(Local<String> message);
  static Local<Value> SyntaxError(Local<String> message);
  static Local<Value> TypeError(Local<String> message);
  static Local<Value> Error(Local<String> message);






  static Local<Message> CreateMessage(Isolate* isolate, Local<Value> exception);
  static Local<Message> CreateMessage(Local<Value> exception) __attribute__((deprecated));






  static Local<StackTrace> GetStackTrace(Local<Value> exception);
};




typedef int* (*CounterLookupCallback)(const char* name);

typedef void* (*CreateHistogramCallback)(const char* name,
                                         int min,
                                         int max,
                                         size_t buckets);

typedef void (*AddHistogramSampleCallback)(void* histogram, int sample);


enum ObjectSpace {
  kObjectSpaceNewSpace = 1 << 0,
  kObjectSpaceOldSpace = 1 << 1,
  kObjectSpaceCodeSpace = 1 << 2,
  kObjectSpaceMapSpace = 1 << 3,
  kObjectSpaceLoSpace = 1 << 4,
  kObjectSpaceAll = kObjectSpaceNewSpace | kObjectSpaceOldSpace |
                    kObjectSpaceCodeSpace | kObjectSpaceMapSpace |
                    kObjectSpaceLoSpace
};

  enum AllocationAction {
    kAllocationActionAllocate = 1 << 0,
    kAllocationActionFree = 1 << 1,
    kAllocationActionAll = kAllocationActionAllocate | kAllocationActionFree
  };

typedef void (*MemoryAllocationCallback)(ObjectSpace space,
                                         AllocationAction action,
                                         int size);


typedef void (*BeforeCallEnteredCallback)(Isolate*);
typedef void (*CallCompletedCallback)(Isolate*);
typedef void (*DeprecatedCallCompletedCallback)();


enum PromiseRejectEvent {
  kPromiseRejectWithNoHandler = 0,
  kPromiseHandlerAddedAfterReject = 1
};

class PromiseRejectMessage {
 public:
  PromiseRejectMessage(Local<Promise> promise, PromiseRejectEvent event,
                       Local<Value> value, Local<StackTrace> stack_trace)
      : promise_(promise),
        event_(event),
        value_(value),
        stack_trace_(stack_trace) {}

  inline Local<Promise> GetPromise() const { return promise_; }
  inline PromiseRejectEvent GetEvent() const { return event_; }
  inline Local<Value> GetValue() const { return value_; }

  inline Local<StackTrace> GetStackTrace() const __attribute__((deprecated)) {

    return stack_trace_;
  }

 private:
  Local<Promise> promise_;
  PromiseRejectEvent event_;
  Local<Value> value_;
  Local<StackTrace> stack_trace_;
};

typedef void (*PromiseRejectCallback)(PromiseRejectMessage message);


typedef void (*MicrotasksCompletedCallback)(Isolate*);
typedef void (*MicrotaskCallback)(void* data);
enum class MicrotasksPolicy { kExplicit, kScoped, kAuto };
class MicrotasksScope {
 public:
  enum Type { kRunMicrotasks, kDoNotRunMicrotasks };

  MicrotasksScope(Isolate* isolate, Type type);
  ~MicrotasksScope();




  static void PerformCheckpoint(Isolate* isolate);




  static int GetCurrentDepth(Isolate* isolate);

 private:
  internal::Isolate* const isolate_;
  bool run_;


  MicrotasksScope(const MicrotasksScope&);
  MicrotasksScope& operator=(const MicrotasksScope&);
};



typedef void (*FailedAccessCheckCallback)(Local<Object> target,
                                          AccessType type,
                                          Local<Value> data);







typedef bool (*AllowCodeGenerationFromStringsCallback)(Local<Context> context);
enum GCType {
  kGCTypeScavenge = 1 << 0,
  kGCTypeMarkSweepCompact = 1 << 1,
  kGCTypeIncrementalMarking = 1 << 2,
  kGCTypeProcessWeakCallbacks = 1 << 3,
  kGCTypeAll = kGCTypeScavenge | kGCTypeMarkSweepCompact |
               kGCTypeIncrementalMarking | kGCTypeProcessWeakCallbacks
};
enum GCCallbackFlags {
  kNoGCCallbackFlags = 0,
  kGCCallbackFlagConstructRetainedObjectInfos = 1 << 1,
  kGCCallbackFlagForced = 1 << 2,
  kGCCallbackFlagSynchronousPhantomCallbackProcessing = 1 << 3,
  kGCCallbackFlagCollectAllAvailableGarbage = 1 << 4,
};

typedef void (*GCCallback)(GCType type, GCCallbackFlags flags);

typedef void (*InterruptCallback)(Isolate* isolate, void* data);
class HeapStatistics {
 public:
  HeapStatistics();
  size_t total_heap_size() { return total_heap_size_; }
  size_t total_heap_size_executable() { return total_heap_size_executable_; }
  size_t total_physical_size() { return total_physical_size_; }
  size_t total_available_size() { return total_available_size_; }
  size_t used_heap_size() { return used_heap_size_; }
  size_t heap_size_limit() { return heap_size_limit_; }
  size_t malloced_memory() { return malloced_memory_; }
  size_t does_zap_garbage() { return does_zap_garbage_; }

 private:
  size_t total_heap_size_;
  size_t total_heap_size_executable_;
  size_t total_physical_size_;
  size_t total_available_size_;
  size_t used_heap_size_;
  size_t heap_size_limit_;
  size_t malloced_memory_;
  bool does_zap_garbage_;

  friend class V8;
  friend class Isolate;
};


class HeapSpaceStatistics {
 public:
  HeapSpaceStatistics();
  const char* space_name() { return space_name_; }
  size_t space_size() { return space_size_; }
  size_t space_used_size() { return space_used_size_; }
  size_t space_available_size() { return space_available_size_; }
  size_t physical_space_size() { return physical_space_size_; }

 private:
  const char* space_name_;
  size_t space_size_;
  size_t space_used_size_;
  size_t space_available_size_;
  size_t physical_space_size_;

  friend class Isolate;
};


class HeapObjectStatistics {
 public:
  HeapObjectStatistics();
  const char* object_type() { return object_type_; }
  const char* object_sub_type() { return object_sub_type_; }
  size_t object_count() { return object_count_; }
  size_t object_size() { return object_size_; }

 private:
  const char* object_type_;
  const char* object_sub_type_;
  size_t object_count_;
  size_t object_size_;

  friend class Isolate;
};


class RetainedObjectInfo;
typedef void (*FunctionEntryHook)(uintptr_t function,
                                  uintptr_t return_addr_location);






struct JitCodeEvent {
  enum EventType {
    CODE_ADDED,
    CODE_MOVED,
    CODE_REMOVED,
    CODE_ADD_LINE_POS_INFO,
    CODE_START_LINE_INFO_RECORDING,
    CODE_END_LINE_INFO_RECORDING
  };





  enum PositionType { POSITION, STATEMENT_POSITION };


  EventType type;

  void* code_start;

  size_t code_len;

  Local<UnboundScript> script;




  void* user_data;

  struct name_t {


    const char* str;

    size_t len;
  };

  struct line_info_t {

    size_t offset;

    size_t pos;

    PositionType position_type;
  };

  union {

    struct name_t name;


    struct line_info_t line_info;


    void* new_code_start;
  };
};




enum JitCodeEventOptions {
  kJitCodeEventDefault = 0,

  kJitCodeEventEnumExisting = 1
};







typedef void (*JitCodeEventHandler)(const JitCodeEvent* event);





class ExternalResourceVisitor {
 public:
  virtual ~ExternalResourceVisitor() {}
  virtual void VisitExternalString(Local<String> string) {}
};





class PersistentHandleVisitor {
 public:
  virtual ~PersistentHandleVisitor() {}
  virtual void VisitPersistentHandle(Persistent<Value>* value,
                                     uint16_t class_id) {}
};
enum class MemoryPressureLevel { kNone, kModerate, kCritical };
class EmbedderHeapTracer {
 public:



  virtual void TraceRoots(Isolate* isolate) = 0;







  virtual void TraceWrappableFrom(
      Isolate* isolate,
      const std::vector<std::pair<void*, void*> >& internal_fields) = 0;




  virtual void ClearTracingMarks(Isolate* isolate) = 0;

 protected:
  virtual ~EmbedderHeapTracer() = default;
};
class Isolate {
 public:



  struct CreateParams {
    CreateParams()
        : entry_hook(0),
          code_event_handler(0),
          snapshot_blob(0),
          counter_lookup_callback(0),
          create_histogram_callback(0),
          add_histogram_sample_callback(0),
          array_buffer_allocator(0) {}
    FunctionEntryHook entry_hook;





    JitCodeEventHandler code_event_handler;




    ResourceConstraints constraints;




    StartupData* snapshot_blob;






    CounterLookupCallback counter_lookup_callback;







    CreateHistogramCallback create_histogram_callback;
    AddHistogramSampleCallback add_histogram_sample_callback;





    ArrayBuffer::Allocator* array_buffer_allocator;
  };






  class Scope {
   public:
    explicit Scope(Isolate* isolate) : isolate_(isolate) {
      isolate->Enter();
    }

    ~Scope() { isolate_->Exit(); }

   private:
    Isolate* const isolate_;


    Scope(const Scope&);
    Scope& operator=(const Scope&);
  };





  class DisallowJavascriptExecutionScope {
   public:
    enum OnFailure { CRASH_ON_FAILURE, THROW_ON_FAILURE };

    DisallowJavascriptExecutionScope(Isolate* isolate, OnFailure on_failure);
    ~DisallowJavascriptExecutionScope();

   private:
    bool on_failure_;
    void* internal_;


    DisallowJavascriptExecutionScope(const DisallowJavascriptExecutionScope&);
    DisallowJavascriptExecutionScope& operator=(
        const DisallowJavascriptExecutionScope&);
  };





  class AllowJavascriptExecutionScope {
   public:
    explicit AllowJavascriptExecutionScope(Isolate* isolate);
    ~AllowJavascriptExecutionScope();

   private:
    void* internal_throws_;
    void* internal_assert_;


    AllowJavascriptExecutionScope(const AllowJavascriptExecutionScope&);
    AllowJavascriptExecutionScope& operator=(
        const AllowJavascriptExecutionScope&);
  };





  class SuppressMicrotaskExecutionScope {
   public:
    explicit SuppressMicrotaskExecutionScope(Isolate* isolate);
    ~SuppressMicrotaskExecutionScope();

   private:
    internal::Isolate* isolate_;


    SuppressMicrotaskExecutionScope(const SuppressMicrotaskExecutionScope&);
    SuppressMicrotaskExecutionScope& operator=(
        const SuppressMicrotaskExecutionScope&);
  };





  enum GarbageCollectionType {
    kFullGarbageCollection,
    kMinorGarbageCollection
  };






  enum UseCounterFeature {
    kUseAsm = 0,
    kBreakIterator = 1,
    kLegacyConst = 2,
    kMarkDequeOverflow = 3,
    kStoreBufferOverflow = 4,
    kSlotsBufferOverflow = 5,
    kObjectObserve = 6,
    kForcedGC = 7,
    kSloppyMode = 8,
    kStrictMode = 9,
    kStrongMode = 10,
    kRegExpPrototypeStickyGetter = 11,
    kRegExpPrototypeToString = 12,
    kRegExpPrototypeUnicodeGetter = 13,
    kIntlV8Parse = 14,
    kIntlPattern = 15,
    kIntlResolved = 16,
    kPromiseChain = 17,
    kPromiseAccept = 18,
    kPromiseDefer = 19,
    kHtmlCommentInExternalScript = 20,
    kHtmlComment = 21,
    kSloppyModeBlockScopedFunctionRedefinition = 22,
    kForInInitializer = 23,
    kArrayProtectorDirtied = 24,
    kArraySpeciesModified = 25,
    kArrayPrototypeConstructorModified = 26,
    kArrayInstanceProtoModified = 27,
    kArrayInstanceConstructorModified = 28,
    kLegacyFunctionDeclaration = 29,
    kRegExpPrototypeSourceGetter = 30,
    kRegExpPrototypeOldFlagGetter = 31,



    kUseCounterFeatureCount
  };

  typedef void (*UseCounterCallback)(Isolate* isolate,
                                     UseCounterFeature feature);
  static Isolate* New(const CreateParams& params);







  static Isolate* GetCurrent();
  typedef bool (*AbortOnUncaughtExceptionCallback)(Isolate*);
  void SetAbortOnUncaughtExceptionCallback(
      AbortOnUncaughtExceptionCallback callback);







  void MemoryPressureNotification(MemoryPressureLevel level);
  void Enter();
  void Exit();





  void Dispose();
  void DiscardThreadSpecificMetadata();





  inline void SetData(uint32_t slot, void* data);





  inline void* GetData(uint32_t slot);





  inline static uint32_t GetNumberOfDataSlots();




  void GetHeapStatistics(HeapStatistics* heap_statistics);




  size_t NumberOfHeapSpaces();
  bool GetHeapSpaceStatistics(HeapSpaceStatistics* space_statistics,
                              size_t index);




  size_t NumberOfTrackedHeapObjectTypes();
  bool GetHeapObjectStatisticsAtLastGC(HeapObjectStatistics* object_statistics,
                                       size_t type_index);
  void GetStackSample(const RegisterState& state, void** frames,
                      size_t frames_limit, SampleInfo* sample_info);
  inline int64_t
      AdjustAmountOfExternalAllocatedMemory(int64_t change_in_bytes);





  HeapProfiler* GetHeapProfiler();






  CpuProfiler* GetCpuProfiler();


  bool InContext();





  Local<Context> GetCurrentContext();






  Local<Context> GetCallingContext() __attribute__((deprecated));





  Local<Context> GetEnteredContext();







  Local<Value> ThrowException(Local<Value> exception);
  template<typename T> void SetObjectGroupId(const Persistent<T>& object,
                                             UniqueId id);
  template<typename T> void SetReferenceFromGroup(UniqueId id,
                                                  const Persistent<T>& child);







  template<typename T, typename S>
  void SetReference(const Persistent<T>& parent, const Persistent<S>& child);

  typedef void (*GCCallback)(Isolate* isolate, GCType type,
                             GCCallbackFlags flags);
  void AddGCPrologueCallback(GCCallback callback,
                             GCType gc_type_filter = kGCTypeAll);





  void RemoveGCPrologueCallback(GCCallback callback);




  void SetEmbedderHeapTracer(EmbedderHeapTracer* tracer);
  void AddGCEpilogueCallback(GCCallback callback,
                             GCType gc_type_filter = kGCTypeAll);





  void RemoveGCEpilogueCallback(GCCallback callback);
  void TerminateExecution();
  bool IsExecutionTerminating();
  void CancelTerminateExecution();
  void RequestInterrupt(InterruptCallback callback, void* data);
  void RequestGarbageCollectionForTesting(GarbageCollectionType type);




  void SetEventLogger(LogEventCallback that);







  void AddBeforeCallEnteredCallback(BeforeCallEnteredCallback callback);




  void RemoveBeforeCallEnteredCallback(BeforeCallEnteredCallback callback);
  void AddCallCompletedCallback(CallCompletedCallback callback);
  void AddCallCompletedCallback(DeprecatedCallCompletedCallback callback) __attribute__((deprecated));






  void RemoveCallCompletedCallback(CallCompletedCallback callback);
  void RemoveCallCompletedCallback( DeprecatedCallCompletedCallback callback) __attribute__((deprecated));
  void SetPromiseRejectCallback(PromiseRejectCallback callback);





  void RunMicrotasks();




  void EnqueueMicrotask(Local<Function> microtask);




  void EnqueueMicrotask(MicrotaskCallback microtask, void* data = 0);





  void SetMicrotasksPolicy(MicrotasksPolicy policy);
  void SetAutorunMicrotasks(bool autorun) __attribute__((deprecated));





  MicrotasksPolicy GetMicrotasksPolicy() const;
  bool WillAutorunMicrotasks() const __attribute__((deprecated));
  void AddMicrotasksCompletedCallback(MicrotasksCompletedCallback callback);




  void RemoveMicrotasksCompletedCallback(MicrotasksCompletedCallback callback);




  void SetUseCounterCallback(UseCounterCallback callback);





  void SetCounterFunction(CounterLookupCallback);







  void SetCreateHistogramFunction(CreateHistogramCallback);
  void SetAddHistogramSampleFunction(AddHistogramSampleCallback);
  bool IdleNotificationDeadline(double deadline_in_seconds);

  bool IdleNotification(int idle_time_in_ms) __attribute__((deprecated));






  void LowMemoryNotification();
  int ContextDisposedNotification(bool dependant_context = true);





  void IsolateInForegroundNotification();





  void IsolateInBackgroundNotification();
  void SetJitCodeEventHandler(JitCodeEventOptions options,
                              JitCodeEventHandler event_handler);
  void SetStackLimit(uintptr_t stack_limit);
  void GetCodeRange(void** start, size_t* length_in_bytes);


  void SetFatalErrorHandler(FatalErrorCallback that);





  void SetAllowCodeGenerationFromStringsCallback(
      AllowCodeGenerationFromStringsCallback callback);





  bool IsDead();
  bool AddMessageListener(MessageCallback that,
                          Local<Value> data = Local<Value>());




  void RemoveMessageListeners(MessageCallback that);


  void SetFailedAccessCheckCallbackFunction(FailedAccessCheckCallback);





  void SetCaptureStackTraceForUncaughtExceptions(
      bool capture, int frame_limit = 10,
      StackTrace::StackTraceOptions options = StackTrace::kOverview);





  void AddMemoryAllocationCallback(MemoryAllocationCallback callback,
                                   ObjectSpace space, AllocationAction action);




  void RemoveMemoryAllocationCallback(MemoryAllocationCallback callback);






  void VisitExternalResources(ExternalResourceVisitor* visitor);





  void VisitHandlesWithClassIds(PersistentHandleVisitor* visitor);
  void VisitHandlesForPartialDependence(PersistentHandleVisitor* visitor);






  void VisitWeakHandles(PersistentHandleVisitor* visitor);

 private:
  template <class K, class V, class Traits>
  friend class PersistentValueMapBase;

  Isolate();
  Isolate(const Isolate&);
  ~Isolate();
  Isolate& operator=(const Isolate&);
  void* operator new(size_t size);
  void operator delete(void*, size_t);

  void SetObjectGroupId(internal::Object** object, UniqueId id);
  void SetReferenceFromGroup(UniqueId id, internal::Object** object);
  void SetReference(internal::Object** parent, internal::Object** child);
  void ReportExternalAllocationLimitReached();
};

class StartupData {
 public:
  const char* data;
  int raw_size;
};






typedef bool (*EntropySource)(unsigned char* buffer, size_t length);
typedef uintptr_t (*ReturnAddressLocationResolver)(
    uintptr_t return_addr_location);





class V8 {
 public:

  inline static void SetFatalErrorHandler(FatalErrorCallback that) __attribute__((deprecated));







  inline static void SetAllowCodeGenerationFromStringsCallback( AllowCodeGenerationFromStringsCallback that) __attribute__((deprecated));







  inline static bool IsDead() __attribute__((deprecated));
  static void SetNativesDataBlob(StartupData* startup_blob);
  static void SetSnapshotDataBlob(StartupData* startup_blob);







  static StartupData CreateSnapshotDataBlob(const char* embedded_source = 0);
  static StartupData WarmUpSnapshotDataBlob(StartupData cold_startup_blob,
                                            const char* warmup_source);
  inline static bool AddMessageListener(MessageCallback that, Local<Value> data = Local<Value>()) __attribute__((deprecated));







  inline static void RemoveMessageListeners(MessageCallback that) __attribute__((deprecated));






  inline static void SetCaptureStackTraceForUncaughtExceptions( bool capture, int frame_limit = 10, StackTrace::StackTraceOptions options = StackTrace::kOverview) __attribute__((deprecated));
  static void SetFlagsFromString(const char* str, int length);




  static void SetFlagsFromCommandLine(int* argc,
                                      char** argv,
                                      bool remove_flags);


  static const char* GetVersion();


  inline static void SetFailedAccessCheckCallbackFunction(FailedAccessCheckCallback) __attribute__((deprecated));
  static void AddGCPrologueCallback(GCCallback callback, GCType gc_type_filter = kGCTypeAll) __attribute__((deprecated));
  inline static void RemoveGCPrologueCallback(GCCallback callback) __attribute__((deprecated));
  static void AddGCEpilogueCallback(GCCallback callback, GCType gc_type_filter = kGCTypeAll) __attribute__((deprecated));
  inline static void RemoveGCEpilogueCallback(GCCallback callback) __attribute__((deprecated));







  inline static void AddMemoryAllocationCallback(MemoryAllocationCallback callback, ObjectSpace space, AllocationAction action) __attribute__((deprecated));
  inline static void RemoveMemoryAllocationCallback(MemoryAllocationCallback callback) __attribute__((deprecated));







  static bool Initialize();





  static void SetEntropySource(EntropySource source);





  static void SetReturnAddressLocationResolver(
      ReturnAddressLocationResolver return_address_resolver);
  inline static void TerminateExecution(Isolate* isolate) __attribute__((deprecated));
  inline static bool IsExecutionTerminating(Isolate* isolate = 0) __attribute__((deprecated));
  inline static void CancelTerminateExecution(Isolate* isolate) __attribute__((deprecated));
  static bool Dispose();






  inline static void VisitExternalResources(ExternalResourceVisitor* visitor) __attribute__((deprecated));







  inline static void VisitHandlesWithClassIds(PersistentHandleVisitor* visitor) __attribute__((deprecated));







  inline static void VisitHandlesWithClassIds(Isolate* isolate, PersistentHandleVisitor* visitor) __attribute__((deprecated));
  inline static void VisitHandlesForPartialDependence(Isolate* isolate, PersistentHandleVisitor* visitor) __attribute__((deprecated));
  static bool InitializeICU(const char* icu_data_file = 0);
  static void InitializeExternalStartupData(const char* directory_path);
  static void InitializeExternalStartupData(const char* natives_blob,
                                            const char* snapshot_blob);




  static void InitializePlatform(Platform* platform);





  static void ShutdownPlatform();

 private:
  V8();

  static internal::Object** GlobalizeReference(internal::Isolate* isolate,
                                               internal::Object** handle);
  static internal::Object** CopyPersistent(internal::Object** handle);
  static void DisposeGlobal(internal::Object** global_handle);
  typedef WeakCallbackData<Value, void>::Callback WeakCallback;
  static void RegisterExternallyReferencedObject(internal::Object** object,
                                                 internal::Isolate* isolate);
  static void MakeWeak(internal::Object** global_handle, void* data,
                       WeakCallback weak_callback);
  static void MakeWeak(internal::Object** global_handle, void* data,
                       WeakCallbackInfo<void>::Callback weak_callback,
                       WeakCallbackType type);
  static void MakeWeak(internal::Object** global_handle, void* data,

                       int internal_field_index1,

                       int internal_field_index2,
                       WeakCallbackInfo<void>::Callback weak_callback);
  static void* ClearWeak(internal::Object** global_handle);
  static void Eternalize(Isolate* isolate,
                         Value* handle,
                         int* index);
  static Local<Value> GetEternal(Isolate* isolate, int index);

  static void FromJustIsNothing();
  static void ToLocalEmpty();
  static void InternalFieldOutOfBounds(int index);
  template <class T> friend class Local;
  template <class T>
  friend class MaybeLocal;
  template <class T>
  friend class Maybe;
  template <class T>
  friend class WeakCallbackInfo;
  template <class T> friend class Eternal;
  template <class T> friend class PersistentBase;
  template <class T, class M> friend class Persistent;
  friend class Context;
};
template <class T>
class Maybe {
 public:
  inline bool IsNothing() const { return !has_value; }
  inline bool IsJust() const { return has_value; }


  inline T FromJust() const {
    if ((!IsJust())) V8::FromJustIsNothing();
    return value;
  }

  inline T FromMaybe(const T& default_value) const {
    return has_value ? value : default_value;
  }

  inline bool operator==(const Maybe& other) const {
    return (IsJust() == other.IsJust()) &&
           (!IsJust() || FromJust() == other.FromJust());
  }

  inline bool operator!=(const Maybe& other) const {
    return !operator==(other);
  }

 private:
  Maybe() : has_value(false) {}
  explicit Maybe(const T& t) : has_value(true), value(t) {}

  bool has_value;
  T value;

  template <class U>
  friend Maybe<U> Nothing();
  template <class U>
  friend Maybe<U> Just(const U& u);
};


template <class T>
inline Maybe<T> Nothing() {
  return Maybe<T>();
}


template <class T>
inline Maybe<T> Just(const T& t) {
  return Maybe<T>(t);
}





class TryCatch {
 public:





  TryCatch() __attribute__((deprecated));






  TryCatch(Isolate* isolate);




  ~TryCatch();




  bool HasCaught() const;
  bool CanContinue() const;
  bool HasTerminated() const;
  Local<Value> ReThrow();







  Local<Value> Exception() const;





  Local<Value> StackTrace() const __attribute__((deprecated));
  __attribute__((warn_unused_result)) MaybeLocal<Value> StackTrace(
      Local<Context> context) const;
  Local<v8::Message> Message() const;
  void Reset();
  void SetVerbose(bool value);






  void SetCaptureMessage(bool value);
  static void* JSStackComparableAddress(v8::TryCatch* handler) {
    if (handler == 0) return 0;
    return handler->js_stack_comparable_address_;
  }

 private:
  void ResetInternal();


  TryCatch(const TryCatch&);
  void operator=(const TryCatch&);
  void* operator new(size_t size);
  void operator delete(void*, size_t);

  v8::internal::Isolate* isolate_;
  v8::TryCatch* next_;
  void* exception_;
  void* message_obj_;
  void* js_stack_comparable_address_;
  bool is_verbose_ : 1;
  bool can_continue_ : 1;
  bool capture_message_ : 1;
  bool rethrow_ : 1;
  bool has_terminated_ : 1;

  friend class v8::internal::Isolate;
};
class ExtensionConfiguration {
 public:
  ExtensionConfiguration() : name_count_(0), names_(0) { }
  ExtensionConfiguration(int name_count, const char* names[])
      : name_count_(name_count), names_(names) { }

  const char** begin() const { return &names_[0]; }
  const char** end() const { return &names_[name_count_]; }

 private:
  const int name_count_;
  const char** names_;
};






class Context {
 public:
  Local<Object> Global();





  void DetachGlobal();
  static Local<Context> New(
      Isolate* isolate, ExtensionConfiguration* extensions = 0,
      Local<ObjectTemplate> global_template = Local<ObjectTemplate>(),
      Local<Value> global_object = Local<Value>());





  void SetSecurityToken(Local<Value> token);


  void UseDefaultSecurityToken();


  Local<Value> GetSecurityToken();







  void Enter();





  void Exit();


  v8::Isolate* GetIsolate();






  enum EmbedderDataFields { kDebugIdIndex = 0 };






  inline Local<Value> GetEmbedderData(int index);







  Local<Object> GetExtrasBindingObject();






  void SetEmbedderData(int index, Local<Value> value);







  inline void* GetAlignedPointerFromEmbedderData(int index);






  void SetAlignedPointerInEmbedderData(int index, void* value);
  void AllowCodeGenerationFromStrings(bool allow);





  bool IsCodeGenerationFromStringsAllowed();






  void SetErrorMessageForCodeGenerationFromStrings(Local<String> message);




  size_t EstimatedSize();





  class Scope {
   public:
    explicit inline Scope(Local<Context> context) : context_(context) {
      context_->Enter();
    }
    inline ~Scope() { context_->Exit(); }

   private:
    Local<Context> context_;
  };

 private:
  friend class Value;
  friend class Script;
  friend class Object;
  friend class Function;

  Local<Value> SlowGetEmbedderData(int index);
  void* SlowGetAlignedPointerFromEmbedderData(int index);
};
class Unlocker {
 public:



  inline explicit Unlocker(Isolate* isolate) { Initialize(isolate); }

  ~Unlocker();
 private:
  void Initialize(Isolate* isolate);

  internal::Isolate* isolate_;
};


class Locker {
 public:



  inline explicit Locker(Isolate* isolate) { Initialize(isolate); }

  ~Locker();





  static bool IsLocked(Isolate* isolate);




  static bool IsActive();

 private:
  void Initialize(Isolate* isolate);

  bool has_lock_;
  bool top_level_;
  internal::Isolate* isolate_;


  Locker(const Locker&);
  void operator=(const Locker&);
};





namespace internal {

const int kApiPointerSize = sizeof(void*);
const int kApiIntSize = sizeof(int);
const int kApiInt64Size = sizeof(int64_t);


const int kHeapObjectTag = 1;
const int kHeapObjectTagSize = 2;
const intptr_t kHeapObjectTagMask = (1 << kHeapObjectTagSize) - 1;


const int kSmiTag = 0;
const int kSmiTagSize = 1;
const intptr_t kSmiTagMask = (1 << kSmiTagSize) - 1;

template <size_t ptr_size> struct SmiTagging;

template<int kSmiShiftSize>
inline internal::Object* IntToSmi(int value) {
  int smi_shift_bits = kSmiTagSize + kSmiShiftSize;
  uintptr_t tagged_value =
      (static_cast<uintptr_t>(value) << smi_shift_bits) | kSmiTag;
  return reinterpret_cast<internal::Object*>(tagged_value);
}


template <> struct SmiTagging<4> {
  enum { kSmiShiftSize = 0, kSmiValueSize = 31 };
  static int SmiShiftSize() { return kSmiShiftSize; }
  static int SmiValueSize() { return kSmiValueSize; }
  inline static int SmiToInt(const internal::Object* value) {
    int shift_bits = kSmiTagSize + kSmiShiftSize;

    return static_cast<int>(reinterpret_cast<intptr_t>(value)) >> shift_bits;
  }
  inline static internal::Object* IntToSmi(int value) {
    return internal::IntToSmi<kSmiShiftSize>(value);
  }
  inline static bool IsValidSmi(intptr_t value) {
    return static_cast<uintptr_t>(value + 0x40000000U) < 0x80000000U;
  }
};


template <> struct SmiTagging<8> {
  enum { kSmiShiftSize = 31, kSmiValueSize = 32 };
  static int SmiShiftSize() { return kSmiShiftSize; }
  static int SmiValueSize() { return kSmiValueSize; }
  inline static int SmiToInt(const internal::Object* value) {
    int shift_bits = kSmiTagSize + kSmiShiftSize;

    return static_cast<int>(reinterpret_cast<intptr_t>(value) >> shift_bits);
  }
  inline static internal::Object* IntToSmi(int value) {
    return internal::IntToSmi<kSmiShiftSize>(value);
  }
  inline static bool IsValidSmi(intptr_t value) {

    return (value == static_cast<int32_t>(value));
  }
};

typedef SmiTagging<kApiPointerSize> PlatformSmiTagging;
const int kSmiShiftSize = PlatformSmiTagging::kSmiShiftSize;
const int kSmiValueSize = PlatformSmiTagging::kSmiValueSize;
inline static bool SmiValuesAre31Bits() { return kSmiValueSize == 31; }
inline static bool SmiValuesAre32Bits() { return kSmiValueSize == 32; }






class Internals {
 public:


  static const int kHeapObjectMapOffset = 0;
  static const int kMapInstanceTypeAndBitFieldOffset =
      1 * kApiPointerSize + kApiIntSize;
  static const int kStringResourceOffset = 3 * kApiPointerSize;

  static const int kOddballKindOffset = 5 * kApiPointerSize;
  static const int kForeignAddressOffset = kApiPointerSize;
  static const int kJSObjectHeaderSize = 3 * kApiPointerSize;
  static const int kFixedArrayHeaderSize = 2 * kApiPointerSize;
  static const int kContextHeaderSize = 2 * kApiPointerSize;
  static const int kContextEmbedderDataIndex = 5;
  static const int kFullStringRepresentationMask = 0x07;
  static const int kStringEncodingMask = 0x4;
  static const int kExternalTwoByteRepresentationTag = 0x02;
  static const int kExternalOneByteRepresentationTag = 0x06;

  static const int kIsolateEmbedderDataOffset = 0 * kApiPointerSize;
  static const int kAmountOfExternalAllocatedMemoryOffset =
      4 * kApiPointerSize;
  static const int kAmountOfExternalAllocatedMemoryAtLastGlobalGCOffset =
      kAmountOfExternalAllocatedMemoryOffset + kApiInt64Size;
  static const int kIsolateRootsOffset =
      kAmountOfExternalAllocatedMemoryAtLastGlobalGCOffset + kApiInt64Size +
      kApiPointerSize;
  static const int kUndefinedValueRootIndex = 4;
  static const int kNullValueRootIndex = 6;
  static const int kTrueValueRootIndex = 7;
  static const int kFalseValueRootIndex = 8;
  static const int kEmptyStringRootIndex = 9;



  static const int kExternalAllocationLimit = 192 * 1024 * 1024;

  static const int kNodeClassIdOffset = 1 * kApiPointerSize;
  static const int kNodeFlagsOffset = 1 * kApiPointerSize + 3;
  static const int kNodeStateMask = 0x7;
  static const int kNodeStateIsWeakValue = 2;
  static const int kNodeStateIsPendingValue = 3;
  static const int kNodeStateIsNearDeathValue = 4;
  static const int kNodeIsIndependentShift = 3;
  static const int kNodeIsPartiallyDependentShift = 4;
  static const int kNodeIsActiveShift = 4;

  static const int kJSObjectType = 0xb8;
  static const int kFirstNonstringType = 0x80;
  static const int kOddballType = 0x83;
  static const int kForeignType = 0x87;

  static const int kUndefinedOddballKind = 5;
  static const int kNullOddballKind = 3;

  static const uint32_t kNumIsolateDataSlots = 4;

            static void CheckInitializedImpl(v8::Isolate* isolate);
  inline static void CheckInitialized(v8::Isolate* isolate) {

    CheckInitializedImpl(isolate);

  }

  inline static bool HasHeapObjectTag(const internal::Object* value) {
    return ((reinterpret_cast<intptr_t>(value) & kHeapObjectTagMask) ==
            kHeapObjectTag);
  }

  inline static int SmiValue(const internal::Object* value) {
    return PlatformSmiTagging::SmiToInt(value);
  }

  inline static internal::Object* IntToSmi(int value) {
    return PlatformSmiTagging::IntToSmi(value);
  }

  inline static bool IsValidSmi(intptr_t value) {
    return PlatformSmiTagging::IsValidSmi(value);
  }

  inline static int GetInstanceType(const internal::Object* obj) {
    typedef internal::Object O;
    O* map = ReadField<O*>(obj, kHeapObjectMapOffset);


    return ReadField<uint16_t>(map, kMapInstanceTypeAndBitFieldOffset) & 0xff;
  }

  inline static int GetOddballKind(const internal::Object* obj) {
    typedef internal::Object O;
    return SmiValue(ReadField<O*>(obj, kOddballKindOffset));
  }

  inline static bool IsExternalTwoByteString(int instance_type) {
    int representation = (instance_type & kFullStringRepresentationMask);
    return representation == kExternalTwoByteRepresentationTag;
  }

  inline static uint8_t GetNodeFlag(internal::Object** obj, int shift) {
      uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + kNodeFlagsOffset;
      return *addr & static_cast<uint8_t>(1U << shift);
  }

  inline static void UpdateNodeFlag(internal::Object** obj,
                                       bool value, int shift) {
      uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + kNodeFlagsOffset;
      uint8_t mask = static_cast<uint8_t>(1U << shift);
      *addr = static_cast<uint8_t>((*addr & ~mask) | (value << shift));
  }

  inline static uint8_t GetNodeState(internal::Object** obj) {
    uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + kNodeFlagsOffset;
    return *addr & kNodeStateMask;
  }

  inline static void UpdateNodeState(internal::Object** obj,
                                        uint8_t value) {
    uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + kNodeFlagsOffset;
    *addr = static_cast<uint8_t>((*addr & ~kNodeStateMask) | value);
  }

  inline static void SetEmbedderData(v8::Isolate* isolate,
                                        uint32_t slot,
                                        void* data) {
    uint8_t* addr = reinterpret_cast<uint8_t*>(isolate) +
                    kIsolateEmbedderDataOffset + slot * kApiPointerSize;
    *reinterpret_cast<void**>(addr) = data;
  }

  inline static void* GetEmbedderData(const v8::Isolate* isolate,
                                         uint32_t slot) {
    const uint8_t* addr = reinterpret_cast<const uint8_t*>(isolate) +
        kIsolateEmbedderDataOffset + slot * kApiPointerSize;
    return *reinterpret_cast<void* const*>(addr);
  }

  inline static internal::Object** GetRoot(v8::Isolate* isolate,
                                              int index) {
    uint8_t* addr = reinterpret_cast<uint8_t*>(isolate) + kIsolateRootsOffset;
    return reinterpret_cast<internal::Object**>(addr + index * kApiPointerSize);
  }

  template <typename T>
  inline static T ReadField(const internal::Object* ptr, int offset) {
    const uint8_t* addr =
        reinterpret_cast<const uint8_t*>(ptr) + offset - kHeapObjectTag;
    return *reinterpret_cast<const T*>(addr);
  }

  template <typename T>
  inline static T ReadEmbedderData(const v8::Context* context, int index) {
    typedef internal::Object O;
    typedef internal::Internals I;
    O* ctx = *reinterpret_cast<O* const*>(context);
    int embedder_data_offset = I::kContextHeaderSize +
        (internal::kApiPointerSize * I::kContextEmbedderDataIndex);
    O* embedder_data = I::ReadField<O*>(ctx, embedder_data_offset);
    int value_offset =
        I::kFixedArrayHeaderSize + (internal::kApiPointerSize * index);
    return I::ReadField<T>(embedder_data, value_offset);
  }
};

}


template <class T>
Local<T> Local<T>::New(Isolate* isolate, Local<T> that) {
  return New(isolate, that.val_);
}

template <class T>
Local<T> Local<T>::New(Isolate* isolate, const PersistentBase<T>& that) {
  return New(isolate, that.val_);
}


template <class T>
Local<T> Local<T>::New(Isolate* isolate, T* that) {
  if (that == 0) return Local<T>();
  T* that_ptr = that;
  internal::Object** p = reinterpret_cast<internal::Object**>(that_ptr);
  return Local<T>(reinterpret_cast<T*>(HandleScope::CreateHandle(
      reinterpret_cast<internal::Isolate*>(isolate), *p)));
}


template<class T>
template<class S>
void Eternal<T>::Set(Isolate* isolate, Local<S> handle) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  V8::Eternalize(isolate, reinterpret_cast<Value*>(*handle), &this->index_);
}


template<class T>
Local<T> Eternal<T>::Get(Isolate* isolate) {
  return Local<T>(reinterpret_cast<T*>(*V8::GetEternal(isolate, index_)));
}


template <class T>
Local<T> MaybeLocal<T>::ToLocalChecked() {
  if ((val_ == nullptr)) V8::ToLocalEmpty();
  return Local<T>(val_);
}


template <class T>
void* WeakCallbackInfo<T>::GetInternalField(int index) const {

  if (index < 0 || index >= kInternalFieldsInWeakCallback) {
    V8::InternalFieldOutOfBounds(index);
  }

  return internal_fields_[index];
}


template <class T>
T* PersistentBase<T>::New(Isolate* isolate, T* that) {
  if (that == 0) return 0;
  internal::Object** p = reinterpret_cast<internal::Object**>(that);
  return reinterpret_cast<T*>(
      V8::GlobalizeReference(reinterpret_cast<internal::Isolate*>(isolate),
                             p));
}


template <class T, class M>
template <class S, class M2>
void Persistent<T, M>::Copy(const Persistent<S, M2>& that) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  this->Reset();
  if (that.IsEmpty()) return;
  internal::Object** p = reinterpret_cast<internal::Object**>(that.val_);
  this->val_ = reinterpret_cast<T*>(V8::CopyPersistent(p));
  M::Copy(that, this);
}


template <class T>
bool PersistentBase<T>::IsIndependent() const {
  typedef internal::Internals I;
  if (this->IsEmpty()) return false;
  return I::GetNodeFlag(reinterpret_cast<internal::Object**>(this->val_),
                        I::kNodeIsIndependentShift);
}


template <class T>
bool PersistentBase<T>::IsNearDeath() const {
  typedef internal::Internals I;
  if (this->IsEmpty()) return false;
  uint8_t node_state =
      I::GetNodeState(reinterpret_cast<internal::Object**>(this->val_));
  return node_state == I::kNodeStateIsNearDeathValue ||
      node_state == I::kNodeStateIsPendingValue;
}


template <class T>
bool PersistentBase<T>::IsWeak() const {
  typedef internal::Internals I;
  if (this->IsEmpty()) return false;
  return I::GetNodeState(reinterpret_cast<internal::Object**>(this->val_)) ==
      I::kNodeStateIsWeakValue;
}


template <class T>
void PersistentBase<T>::Reset() {
  if (this->IsEmpty()) return;
  V8::DisposeGlobal(reinterpret_cast<internal::Object**>(this->val_));
  val_ = 0;
}


template <class T>
template <class S>
void PersistentBase<T>::Reset(Isolate* isolate, const Local<S>& other) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  Reset();
  if (other.IsEmpty()) return;
  this->val_ = New(isolate, other.val_);
}


template <class T>
template <class S>
void PersistentBase<T>::Reset(Isolate* isolate,
                              const PersistentBase<S>& other) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  Reset();
  if (other.IsEmpty()) return;
  this->val_ = New(isolate, other.val_);
}


template <class T>
template <typename S, typename P>
void PersistentBase<T>::SetWeak(
    P* parameter,
    typename WeakCallbackData<S, P>::Callback callback) {
  while (false) { *(static_cast<S* volatile*>(0)) = static_cast<T*>(0); };
  typedef typename WeakCallbackData<Value, void>::Callback Callback;
  V8::MakeWeak(reinterpret_cast<internal::Object**>(this->val_), parameter,
               reinterpret_cast<Callback>(callback));
}


template <class T>
template <typename P>
void PersistentBase<T>::SetWeak(
    P* parameter,
    typename WeakCallbackData<T, P>::Callback callback) {
  SetWeak<T, P>(parameter, callback);
}


template <class T>
template <typename P>
void PersistentBase<T>::SetPhantom(
    P* parameter, typename WeakCallbackInfo<P>::Callback callback,
    int internal_field_index1, int internal_field_index2) {
  typedef typename WeakCallbackInfo<void>::Callback Callback;
  V8::MakeWeak(reinterpret_cast<internal::Object**>(this->val_), parameter,
               internal_field_index1, internal_field_index2,
               reinterpret_cast<Callback>(callback));
}


template <class T>
template <typename P>
inline void PersistentBase<T>::SetWeak(
    P* parameter, typename WeakCallbackInfo<P>::Callback callback,
    WeakCallbackType type) {
  typedef typename WeakCallbackInfo<void>::Callback Callback;
  V8::MakeWeak(reinterpret_cast<internal::Object**>(this->val_), parameter,
               reinterpret_cast<Callback>(callback), type);
}


template <class T>
template <typename P>
P* PersistentBase<T>::ClearWeak() {
  return reinterpret_cast<P*>(
    V8::ClearWeak(reinterpret_cast<internal::Object**>(this->val_)));
}

template <class T>
void PersistentBase<T>::RegisterExternalReference(Isolate* isolate) {
  if (IsEmpty()) return;
  V8::RegisterExternallyReferencedObject(
      reinterpret_cast<internal::Object**>(this->val_),
      reinterpret_cast<internal::Isolate*>(isolate));
}

template <class T>
void PersistentBase<T>::MarkIndependent() {
  typedef internal::Internals I;
  if (this->IsEmpty()) return;
  I::UpdateNodeFlag(reinterpret_cast<internal::Object**>(this->val_),
                    true,
                    I::kNodeIsIndependentShift);
}


template <class T>
void PersistentBase<T>::MarkPartiallyDependent() {
  typedef internal::Internals I;
  if (this->IsEmpty()) return;
  I::UpdateNodeFlag(reinterpret_cast<internal::Object**>(this->val_),
                    true,
                    I::kNodeIsPartiallyDependentShift);
}


template <class T>
void PersistentBase<T>::MarkActive() {
  typedef internal::Internals I;
  if (this->IsEmpty()) return;
  I::UpdateNodeFlag(reinterpret_cast<internal::Object**>(this->val_), true,
                    I::kNodeIsActiveShift);
}


template <class T>
void PersistentBase<T>::SetWrapperClassId(uint16_t class_id) {
  typedef internal::Internals I;
  if (this->IsEmpty()) return;
  internal::Object** obj = reinterpret_cast<internal::Object**>(this->val_);
  uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + I::kNodeClassIdOffset;
  *reinterpret_cast<uint16_t*>(addr) = class_id;
}


template <class T>
uint16_t PersistentBase<T>::WrapperClassId() const {
  typedef internal::Internals I;
  if (this->IsEmpty()) return 0;
  internal::Object** obj = reinterpret_cast<internal::Object**>(this->val_);
  uint8_t* addr = reinterpret_cast<uint8_t*>(obj) + I::kNodeClassIdOffset;
  return *reinterpret_cast<uint16_t*>(addr);
}


template<typename T>
ReturnValue<T>::ReturnValue(internal::Object** slot) : value_(slot) {}

template<typename T>
template<typename S>
void ReturnValue<T>::Set(const Persistent<S>& handle) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  if ((handle.IsEmpty())) {
    *value_ = GetDefaultValue();
  } else {
    *value_ = *reinterpret_cast<internal::Object**>(*handle);
  }
}

template <typename T>
template <typename S>
void ReturnValue<T>::Set(const Global<S>& handle) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  if ((handle.IsEmpty())) {
    *value_ = GetDefaultValue();
  } else {
    *value_ = *reinterpret_cast<internal::Object**>(*handle);
  }
}

template <typename T>
template <typename S>
void ReturnValue<T>::Set(const Local<S> handle) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<S*>(0); };
  if ((handle.IsEmpty())) {
    *value_ = GetDefaultValue();
  } else {
    *value_ = *reinterpret_cast<internal::Object**>(*handle);
  }
}

template<typename T>
void ReturnValue<T>::Set(double i) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<Number*>(0); };
  Set(Number::New(GetIsolate(), i));
}

template<typename T>
void ReturnValue<T>::Set(int32_t i) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<Integer*>(0); };
  typedef internal::Internals I;
  if ((I::IsValidSmi(i))) {
    *value_ = I::IntToSmi(i);
    return;
  }
  Set(Integer::New(GetIsolate(), i));
}

template<typename T>
void ReturnValue<T>::Set(uint32_t i) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<Integer*>(0); };

  bool fits_into_int32_t = (i & (1U << 31)) == 0;
  if ((fits_into_int32_t)) {
    Set(static_cast<int32_t>(i));
    return;
  }
  Set(Integer::NewFromUnsigned(GetIsolate(), i));
}

template<typename T>
void ReturnValue<T>::Set(bool value) {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<Boolean*>(0); };
  typedef internal::Internals I;
  int root_index;
  if (value) {
    root_index = I::kTrueValueRootIndex;
  } else {
    root_index = I::kFalseValueRootIndex;
  }
  *value_ = *I::GetRoot(GetIsolate(), root_index);
}

template<typename T>
void ReturnValue<T>::SetNull() {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<Primitive*>(0); };
  typedef internal::Internals I;
  *value_ = *I::GetRoot(GetIsolate(), I::kNullValueRootIndex);
}

template<typename T>
void ReturnValue<T>::SetUndefined() {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<Primitive*>(0); };
  typedef internal::Internals I;
  *value_ = *I::GetRoot(GetIsolate(), I::kUndefinedValueRootIndex);
}

template<typename T>
void ReturnValue<T>::SetEmptyString() {
  while (false) { *(static_cast<T* volatile*>(0)) = static_cast<String*>(0); };
  typedef internal::Internals I;
  *value_ = *I::GetRoot(GetIsolate(), I::kEmptyStringRootIndex);
}

template<typename T>
Isolate* ReturnValue<T>::GetIsolate() {

  return *reinterpret_cast<Isolate**>(&value_[-2]);
}

template<typename T>
template<typename S>
void ReturnValue<T>::Set(S* whatever) {

  while (false) { *(static_cast<S** volatile*>(0)) = static_cast<Primitive*>(0); };
}

template<typename T>
internal::Object* ReturnValue<T>::GetDefaultValue() {

  return value_[-1];
}


template<typename T>
FunctionCallbackInfo<T>::FunctionCallbackInfo(internal::Object** implicit_args,
                                              internal::Object** values,
                                              int length,
                                              bool is_construct_call)
    : implicit_args_(implicit_args),
      values_(values),
      length_(length),
      is_construct_call_(is_construct_call) { }


template<typename T>
Local<Value> FunctionCallbackInfo<T>::operator[](int i) const {
  if (i < 0 || length_ <= i) return Local<Value>(*Undefined(GetIsolate()));
  return Local<Value>(reinterpret_cast<Value*>(values_ - i));
}


template<typename T>
Local<Function> FunctionCallbackInfo<T>::Callee() const {
  return Local<Function>(reinterpret_cast<Function*>(
      &implicit_args_[kCalleeIndex]));
}


template<typename T>
Local<Object> FunctionCallbackInfo<T>::This() const {
  return Local<Object>(reinterpret_cast<Object*>(values_ + 1));
}


template<typename T>
Local<Object> FunctionCallbackInfo<T>::Holder() const {
  return Local<Object>(reinterpret_cast<Object*>(
      &implicit_args_[kHolderIndex]));
}


template<typename T>
Local<Value> FunctionCallbackInfo<T>::Data() const {
  return Local<Value>(reinterpret_cast<Value*>(&implicit_args_[kDataIndex]));
}


template<typename T>
Isolate* FunctionCallbackInfo<T>::GetIsolate() const {
  return *reinterpret_cast<Isolate**>(&implicit_args_[kIsolateIndex]);
}


template<typename T>
ReturnValue<T> FunctionCallbackInfo<T>::GetReturnValue() const {
  return ReturnValue<T>(&implicit_args_[kReturnValueIndex]);
}


template<typename T>
bool FunctionCallbackInfo<T>::IsConstructCall() const {
  return is_construct_call_ & 0x1;
}


template<typename T>
int FunctionCallbackInfo<T>::Length() const {
  return length_;
}

ScriptOrigin::ScriptOrigin(Local<Value> resource_name,
                           Local<Integer> resource_line_offset,
                           Local<Integer> resource_column_offset,
                           Local<Boolean> resource_is_shared_cross_origin,
                           Local<Integer> script_id,
                           Local<Boolean> resource_is_embedder_debug_script,
                           Local<Value> source_map_url,
                           Local<Boolean> resource_is_opaque)
    : resource_name_(resource_name),
      resource_line_offset_(resource_line_offset),
      resource_column_offset_(resource_column_offset),
      options_(!resource_is_embedder_debug_script.IsEmpty() &&
                   resource_is_embedder_debug_script->IsTrue(),
               !resource_is_shared_cross_origin.IsEmpty() &&
                   resource_is_shared_cross_origin->IsTrue(),
               !resource_is_opaque.IsEmpty() && resource_is_opaque->IsTrue()),
      script_id_(script_id),
      source_map_url_(source_map_url) {}

Local<Value> ScriptOrigin::ResourceName() const { return resource_name_; }


Local<Integer> ScriptOrigin::ResourceLineOffset() const {
  return resource_line_offset_;
}


Local<Integer> ScriptOrigin::ResourceColumnOffset() const {
  return resource_column_offset_;
}


Local<Integer> ScriptOrigin::ScriptID() const { return script_id_; }


Local<Value> ScriptOrigin::SourceMapUrl() const { return source_map_url_; }


ScriptCompiler::Source::Source(Local<String> string, const ScriptOrigin& origin,
                               CachedData* data)
    : source_string(string),
      resource_name(origin.ResourceName()),
      resource_line_offset(origin.ResourceLineOffset()),
      resource_column_offset(origin.ResourceColumnOffset()),
      resource_options(origin.Options()),
      source_map_url(origin.SourceMapUrl()),
      cached_data(data) {}


ScriptCompiler::Source::Source(Local<String> string,
                               CachedData* data)
    : source_string(string), cached_data(data) {}


ScriptCompiler::Source::~Source() {
  delete cached_data;
}


const ScriptCompiler::CachedData* ScriptCompiler::Source::GetCachedData()
    const {
  return cached_data;
}


Local<Boolean> Boolean::New(Isolate* isolate, bool value) {
  return value ? True(isolate) : False(isolate);
}


void Template::Set(Isolate* isolate, const char* name, v8::Local<Data> value) {
  Set(v8::String::NewFromUtf8(isolate, name, NewStringType::kNormal)
          .ToLocalChecked(),
      value);
}


Local<Value> Object::GetInternalField(int index) {
  return SlowGetInternalField(index);
}


void* Object::GetAlignedPointerFromInternalField(int index) {
  return SlowGetAlignedPointerFromInternalField(index);
}


String* String::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<String*>(value);
}


Local<String> String::Empty(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  I::CheckInitialized(isolate);
  S* slot = I::GetRoot(isolate, I::kEmptyStringRootIndex);
  return Local<String>(reinterpret_cast<String*>(slot));
}


String::ExternalStringResource* String::GetExternalStringResource() const {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O* const*>(this);
  String::ExternalStringResource* result;
  if (I::IsExternalTwoByteString(I::GetInstanceType(obj))) {
    void* value = I::ReadField<void*>(obj, I::kStringResourceOffset);
    result = reinterpret_cast<String::ExternalStringResource*>(value);
  } else {
    result = 0;
  }

  VerifyExternalStringResource(result);

  return result;
}


String::ExternalStringResourceBase* String::GetExternalStringResourceBase(
    String::Encoding* encoding_out) const {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O* const*>(this);
  int type = I::GetInstanceType(obj) & I::kFullStringRepresentationMask;
  *encoding_out = static_cast<Encoding>(type & I::kStringEncodingMask);
  ExternalStringResourceBase* resource = 0;
  if (type == I::kExternalOneByteRepresentationTag ||
      type == I::kExternalTwoByteRepresentationTag) {
    void* value = I::ReadField<void*>(obj, I::kStringResourceOffset);
    resource = static_cast<ExternalStringResourceBase*>(value);
  }

    VerifyExternalStringResourceBase(resource, *encoding_out);

  return resource;
}


bool Value::IsUndefined() const {

  return FullIsUndefined();



}

bool Value::QuickIsUndefined() const {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O* const*>(this);
  if (!I::HasHeapObjectTag(obj)) return false;
  if (I::GetInstanceType(obj) != I::kOddballType) return false;
  return (I::GetOddballKind(obj) == I::kUndefinedOddballKind);
}


bool Value::IsNull() const {

  return FullIsNull();



}

bool Value::QuickIsNull() const {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O* const*>(this);
  if (!I::HasHeapObjectTag(obj)) return false;
  if (I::GetInstanceType(obj) != I::kOddballType) return false;
  return (I::GetOddballKind(obj) == I::kNullOddballKind);
}


bool Value::IsString() const {

  return FullIsString();



}

bool Value::QuickIsString() const {
  typedef internal::Object O;
  typedef internal::Internals I;
  O* obj = *reinterpret_cast<O* const*>(this);
  if (!I::HasHeapObjectTag(obj)) return false;
  return (I::GetInstanceType(obj) < I::kFirstNonstringType);
}


template <class T> Value* Value::Cast(T* value) {
  return static_cast<Value*>(value);
}


Local<Boolean> Value::ToBoolean() const {
  return ToBoolean(Isolate::GetCurrent()->GetCurrentContext())
      .FromMaybe(Local<Boolean>());
}


Local<Number> Value::ToNumber() const {
  return ToNumber(Isolate::GetCurrent()->GetCurrentContext())
      .FromMaybe(Local<Number>());
}


Local<String> Value::ToString() const {
  return ToString(Isolate::GetCurrent()->GetCurrentContext())
      .FromMaybe(Local<String>());
}


Local<String> Value::ToDetailString() const {
  return ToDetailString(Isolate::GetCurrent()->GetCurrentContext())
      .FromMaybe(Local<String>());
}


Local<Object> Value::ToObject() const {
  return ToObject(Isolate::GetCurrent()->GetCurrentContext())
      .FromMaybe(Local<Object>());
}


Local<Integer> Value::ToInteger() const {
  return ToInteger(Isolate::GetCurrent()->GetCurrentContext())
      .FromMaybe(Local<Integer>());
}


Local<Uint32> Value::ToUint32() const {
  return ToUint32(Isolate::GetCurrent()->GetCurrentContext())
      .FromMaybe(Local<Uint32>());
}


Local<Int32> Value::ToInt32() const {
  return ToInt32(Isolate::GetCurrent()->GetCurrentContext())
      .FromMaybe(Local<Int32>());
}


Boolean* Boolean::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Boolean*>(value);
}


Name* Name::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Name*>(value);
}


Symbol* Symbol::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Symbol*>(value);
}


Number* Number::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Number*>(value);
}


Integer* Integer::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Integer*>(value);
}


Int32* Int32::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Int32*>(value);
}


Uint32* Uint32::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Uint32*>(value);
}


Date* Date::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Date*>(value);
}


StringObject* StringObject::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<StringObject*>(value);
}


SymbolObject* SymbolObject::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<SymbolObject*>(value);
}


NumberObject* NumberObject::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<NumberObject*>(value);
}


BooleanObject* BooleanObject::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<BooleanObject*>(value);
}


RegExp* RegExp::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<RegExp*>(value);
}


Object* Object::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Object*>(value);
}


Array* Array::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Array*>(value);
}


Map* Map::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Map*>(value);
}


Set* Set::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Set*>(value);
}


Promise* Promise::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Promise*>(value);
}


Proxy* Proxy::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Proxy*>(value);
}


Promise::Resolver* Promise::Resolver::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Promise::Resolver*>(value);
}


ArrayBuffer* ArrayBuffer::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<ArrayBuffer*>(value);
}


ArrayBufferView* ArrayBufferView::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<ArrayBufferView*>(value);
}


TypedArray* TypedArray::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<TypedArray*>(value);
}


Uint8Array* Uint8Array::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Uint8Array*>(value);
}


Int8Array* Int8Array::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Int8Array*>(value);
}


Uint16Array* Uint16Array::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Uint16Array*>(value);
}


Int16Array* Int16Array::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Int16Array*>(value);
}


Uint32Array* Uint32Array::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Uint32Array*>(value);
}


Int32Array* Int32Array::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Int32Array*>(value);
}


Float32Array* Float32Array::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Float32Array*>(value);
}


Float64Array* Float64Array::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Float64Array*>(value);
}


Uint8ClampedArray* Uint8ClampedArray::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Uint8ClampedArray*>(value);
}


DataView* DataView::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<DataView*>(value);
}


SharedArrayBuffer* SharedArrayBuffer::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<SharedArrayBuffer*>(value);
}


Function* Function::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<Function*>(value);
}


External* External::Cast(v8::Value* value) {

  CheckCast(value);

  return static_cast<External*>(value);
}


template<typename T>
Isolate* PropertyCallbackInfo<T>::GetIsolate() const {
  return *reinterpret_cast<Isolate**>(&args_[kIsolateIndex]);
}


template<typename T>
Local<Value> PropertyCallbackInfo<T>::Data() const {
  return Local<Value>(reinterpret_cast<Value*>(&args_[kDataIndex]));
}


template<typename T>
Local<Object> PropertyCallbackInfo<T>::This() const {
  return Local<Object>(reinterpret_cast<Object*>(&args_[kThisIndex]));
}


template<typename T>
Local<Object> PropertyCallbackInfo<T>::Holder() const {
  return Local<Object>(reinterpret_cast<Object*>(&args_[kHolderIndex]));
}


template<typename T>
ReturnValue<T> PropertyCallbackInfo<T>::GetReturnValue() const {
  return ReturnValue<T>(&args_[kReturnValueIndex]);
}

template <typename T>
bool PropertyCallbackInfo<T>::ShouldThrowOnError() const {
  typedef internal::Internals I;
  return args_[kShouldThrowOnErrorIndex] != I::IntToSmi(0);
}


Local<Primitive> Undefined(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  I::CheckInitialized(isolate);
  S* slot = I::GetRoot(isolate, I::kUndefinedValueRootIndex);
  return Local<Primitive>(reinterpret_cast<Primitive*>(slot));
}


Local<Primitive> Null(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  I::CheckInitialized(isolate);
  S* slot = I::GetRoot(isolate, I::kNullValueRootIndex);
  return Local<Primitive>(reinterpret_cast<Primitive*>(slot));
}


Local<Boolean> True(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  I::CheckInitialized(isolate);
  S* slot = I::GetRoot(isolate, I::kTrueValueRootIndex);
  return Local<Boolean>(reinterpret_cast<Boolean*>(slot));
}


Local<Boolean> False(Isolate* isolate) {
  typedef internal::Object* S;
  typedef internal::Internals I;
  I::CheckInitialized(isolate);
  S* slot = I::GetRoot(isolate, I::kFalseValueRootIndex);
  return Local<Boolean>(reinterpret_cast<Boolean*>(slot));
}


void Isolate::SetData(uint32_t slot, void* data) {
  typedef internal::Internals I;
  I::SetEmbedderData(this, slot, data);
}


void* Isolate::GetData(uint32_t slot) {
  typedef internal::Internals I;
  return I::GetEmbedderData(this, slot);
}


uint32_t Isolate::GetNumberOfDataSlots() {
  typedef internal::Internals I;
  return I::kNumIsolateDataSlots;
}


int64_t Isolate::AdjustAmountOfExternalAllocatedMemory(
    int64_t change_in_bytes) {
  typedef internal::Internals I;
  int64_t* amount_of_external_allocated_memory =
      reinterpret_cast<int64_t*>(reinterpret_cast<uint8_t*>(this) +
                                 I::kAmountOfExternalAllocatedMemoryOffset);
  int64_t* amount_of_external_allocated_memory_at_last_global_gc =
      reinterpret_cast<int64_t*>(
          reinterpret_cast<uint8_t*>(this) +
          I::kAmountOfExternalAllocatedMemoryAtLastGlobalGCOffset);
  int64_t amount = *amount_of_external_allocated_memory + change_in_bytes;
  if (change_in_bytes > 0 &&
      amount - *amount_of_external_allocated_memory_at_last_global_gc >
          I::kExternalAllocationLimit) {
    ReportExternalAllocationLimitReached();
  }
  *amount_of_external_allocated_memory = amount;
  return *amount_of_external_allocated_memory;
}


template<typename T>
void Isolate::SetObjectGroupId(const Persistent<T>& object,
                               UniqueId id) {
  while (false) { *(static_cast<Value* volatile*>(0)) = static_cast<T*>(0); };
  SetObjectGroupId(reinterpret_cast<v8::internal::Object**>(object.val_), id);
}


template<typename T>
void Isolate::SetReferenceFromGroup(UniqueId id,
                                    const Persistent<T>& object) {
  while (false) { *(static_cast<Value* volatile*>(0)) = static_cast<T*>(0); };
  SetReferenceFromGroup(id,
                        reinterpret_cast<v8::internal::Object**>(object.val_));
}


template<typename T, typename S>
void Isolate::SetReference(const Persistent<T>& parent,
                           const Persistent<S>& child) {
  while (false) { *(static_cast<Object* volatile*>(0)) = static_cast<T*>(0); };
  while (false) { *(static_cast<Value* volatile*>(0)) = static_cast<S*>(0); };
  SetReference(reinterpret_cast<v8::internal::Object**>(parent.val_),
               reinterpret_cast<v8::internal::Object**>(child.val_));
}


Local<Value> Context::GetEmbedderData(int index) {
  return SlowGetEmbedderData(index);

}


void* Context::GetAlignedPointerFromEmbedderData(int index) {




  return SlowGetAlignedPointerFromEmbedderData(index);

}


void V8::SetAllowCodeGenerationFromStringsCallback(
    AllowCodeGenerationFromStringsCallback callback) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->SetAllowCodeGenerationFromStringsCallback(callback);
}


bool V8::IsDead() {
  Isolate* isolate = Isolate::GetCurrent();
  return isolate->IsDead();
}


bool V8::AddMessageListener(MessageCallback that, Local<Value> data) {
  Isolate* isolate = Isolate::GetCurrent();
  return isolate->AddMessageListener(that, data);
}


void V8::RemoveMessageListeners(MessageCallback that) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->RemoveMessageListeners(that);
}


void V8::SetFailedAccessCheckCallbackFunction(
    FailedAccessCheckCallback callback) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->SetFailedAccessCheckCallbackFunction(callback);
}


void V8::SetCaptureStackTraceForUncaughtExceptions(
    bool capture, int frame_limit, StackTrace::StackTraceOptions options) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->SetCaptureStackTraceForUncaughtExceptions(capture, frame_limit,
                                                     options);
}


void V8::SetFatalErrorHandler(FatalErrorCallback callback) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->SetFatalErrorHandler(callback);
}


void V8::RemoveGCPrologueCallback(GCCallback callback) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->RemoveGCPrologueCallback(
      reinterpret_cast<v8::Isolate::GCCallback>(callback));
}


void V8::RemoveGCEpilogueCallback(GCCallback callback) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->RemoveGCEpilogueCallback(
      reinterpret_cast<v8::Isolate::GCCallback>(callback));
}


void V8::AddMemoryAllocationCallback(MemoryAllocationCallback callback,
                                     ObjectSpace space,
                                     AllocationAction action) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->AddMemoryAllocationCallback(callback, space, action);
}


void V8::RemoveMemoryAllocationCallback(MemoryAllocationCallback callback) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->RemoveMemoryAllocationCallback(callback);
}


void V8::TerminateExecution(Isolate* isolate) { isolate->TerminateExecution(); }


bool V8::IsExecutionTerminating(Isolate* isolate) {
  if (isolate == 0) {
    isolate = Isolate::GetCurrent();
  }
  return isolate->IsExecutionTerminating();
}


void V8::CancelTerminateExecution(Isolate* isolate) {
  isolate->CancelTerminateExecution();
}


void V8::VisitExternalResources(ExternalResourceVisitor* visitor) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->VisitExternalResources(visitor);
}


void V8::VisitHandlesWithClassIds(PersistentHandleVisitor* visitor) {
  Isolate* isolate = Isolate::GetCurrent();
  isolate->VisitHandlesWithClassIds(visitor);
}


void V8::VisitHandlesWithClassIds(Isolate* isolate,
                                  PersistentHandleVisitor* visitor) {
  isolate->VisitHandlesWithClassIds(visitor);
}


void V8::VisitHandlesForPartialDependence(Isolate* isolate,
                                          PersistentHandleVisitor* visitor) {
  isolate->VisitHandlesForPartialDependence(visitor);
}
}
namespace v8 {
namespace internal {




void FatalProcessOutOfMemory(const char* message);


class Malloced {
 public:
  void* operator new(size_t size) { return New(size); }
  void operator delete(void* p) { Delete(p); }

  static void* New(size_t size);
  static void Delete(void* p);
};
class Embedded {
 public:
  void* operator new(size_t size);
  void operator delete(void* p);
};







class AllStatic {

 public:
  void* operator new(size_t size);
  void operator delete(void* p);

};


template <typename T>
T* NewArray(size_t size) {
  T* result = new T[size];
  if (result == 0) FatalProcessOutOfMemory(u8"NewArray");
  return result;
}


template <typename T>
void DeleteArray(T* array) {
  delete[] array;
}





char* StrDup(const char* str);
char* StrNDup(const char* str, int n);




class FreeStoreAllocationPolicy {
 public:
  inline void* New(size_t size) { return Malloced::New(size); }
  inline static void Delete(void* p) { Malloced::Delete(p); }
};


void* AlignedAlloc(size_t size, size_t alignment);
void AlignedFree(void *ptr);

}
}

namespace v8 {
namespace internal {

class V8 : public AllStatic {
 public:


  static bool Initialize();
  static void TearDown();



  static void FatalProcessOutOfMemory(const char* location,
                                      bool take_snapshot = false);

  static void InitializePlatform(v8::Platform* platform);
  static void ShutdownPlatform();
  static v8::Platform* GetCurrentPlatform();


  static void SetPlatformForTesting(v8::Platform* platform);

  static void SetNativesBlob(StartupData* natives_blob);
  static void SetSnapshotBlob(StartupData* snapshot_blob);

 private:
  static void InitializeOncePerProcessImpl();
  static void InitializeOncePerProcess();


  static v8::Platform* platform_;
};

}
}












namespace v8 {
namespace base {
template <typename T, typename S = int>
class Flags final {
 public:
  typedef T flag_type;
  typedef S mask_type;

  Flags() : mask_(0) {}
  Flags(flag_type flag)
      : mask_(static_cast<S>(flag)) {}
  explicit Flags(mask_type mask) : mask_(static_cast<S>(mask)) {}

  bool operator==(flag_type flag) const {
    return mask_ == static_cast<S>(flag);
  }
  bool operator!=(flag_type flag) const {
    return mask_ != static_cast<S>(flag);
  }

  Flags& operator&=(const Flags& flags) {
    mask_ &= flags.mask_;
    return *this;
  }
  Flags& operator|=(const Flags& flags) {
    mask_ |= flags.mask_;
    return *this;
  }
  Flags& operator^=(const Flags& flags) {
    mask_ ^= flags.mask_;
    return *this;
  }

  Flags operator&(const Flags& flags) const { return Flags(*this) &= flags; }
  Flags operator|(const Flags& flags) const { return Flags(*this) |= flags; }
  Flags operator^(const Flags& flags) const { return Flags(*this) ^= flags; }

  Flags& operator&=(flag_type flag) { return operator&=(Flags(flag)); }
  Flags& operator|=(flag_type flag) { return operator|=(Flags(flag)); }
  Flags& operator^=(flag_type flag) { return operator^=(Flags(flag)); }

  Flags operator&(flag_type flag) const { return operator&(Flags(flag)); }
  Flags operator|(flag_type flag) const { return operator|(Flags(flag)); }
  Flags operator^(flag_type flag) const { return operator^(Flags(flag)); }

  Flags operator~() const { return Flags(~mask_); }

  operator mask_type() const { return mask_; }
  bool operator!() const { return !mask_; }

  friend size_t hash_value(const Flags& flags) { return flags.mask_; }

 private:
  mask_type mask_;
};
}
}















namespace v8 {
namespace base {
template <typename>
struct hash;


inline size_t hash_combine() { return 0u; }
inline size_t hash_combine(size_t seed) { return seed; }
size_t hash_combine(size_t seed, size_t value);
template <typename T, typename... Ts>
inline size_t hash_combine(T const& v, Ts const&... vs) {
  return hash_combine(hash_combine(vs...), hash<T>()(v));
}


template <typename Iterator>
inline size_t hash_range(Iterator first, Iterator last) {
  size_t seed = 0;
  for (; first != last; ++first) {
    seed = hash_combine(seed, *first);
  }
  return seed;
}




inline size_t hash_value(bool v) { return static_cast<size_t>(v); }
inline size_t hash_value(unsigned char v) { return static_cast<size_t>(v); }
inline size_t hash_value(unsigned short v) { return static_cast<size_t>(v); }


size_t hash_value(unsigned int);
size_t hash_value(unsigned long);
size_t hash_value(unsigned long long);





inline size_t hash_value(signed char v) { return hash_value(bit_cast<unsigned char>(v)); }
inline size_t hash_value(signed short v) { return hash_value(bit_cast<unsigned short>(v)); }
inline size_t hash_value(signed int v) { return hash_value(bit_cast<unsigned int>(v)); }
inline size_t hash_value(signed long v) { return hash_value(bit_cast<unsigned long>(v)); }
inline size_t hash_value(signed long long v) { return hash_value(bit_cast<unsigned long long>(v)); }


inline size_t hash_value(float v) {

  return v != 0.0f ? hash_value(bit_cast<uint32_t>(v)) : 0;
}

inline size_t hash_value(double v) {

  return v != 0.0 ? hash_value(bit_cast<uint64_t>(v)) : 0;
}

template <typename T, size_t N>
inline size_t hash_value(const T (&v)[N]) {
  return hash_range(v, v + N);
}

template <typename T, size_t N>
inline size_t hash_value(T (&v)[N]) {
  return hash_range(v, v + N);
}

template <typename T>
inline size_t hash_value(T* const& v) {
  return hash_value(bit_cast<uintptr_t>(v));
}

template <typename T1, typename T2>
inline size_t hash_value(std::pair<T1, T2> const& v) {
  return hash_combine(v.first, v.second);
}


template <typename T>
struct hash : public std::unary_function<T, size_t> {
  inline size_t operator()(T const& v) const { return hash_value(v); }
};
template <> struct hash<bool> : public std::unary_function<bool, size_t> { inline size_t operator()(bool const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<signed char> : public std::unary_function<signed char, size_t> { inline size_t operator()(signed char const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<unsigned char> : public std::unary_function<unsigned char, size_t> { inline size_t operator()(unsigned char const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<short> : public std::unary_function<short, size_t> { inline size_t operator()(short const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<unsigned short> : public std::unary_function<unsigned short, size_t> { inline size_t operator()(unsigned short const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<int> : public std::unary_function<int, size_t> { inline size_t operator()(int const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<unsigned int> : public std::unary_function<unsigned int, size_t> { inline size_t operator()(unsigned int const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<long> : public std::unary_function<long, size_t> { inline size_t operator()(long const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<unsigned long> : public std::unary_function<unsigned long, size_t> { inline size_t operator()(unsigned long const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<long long> : public std::unary_function<long long, size_t> { inline size_t operator()(long long const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<unsigned long long> : public std::unary_function<unsigned long long, size_t> { inline size_t operator()(unsigned long long const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<float> : public std::unary_function<float, size_t> { inline size_t operator()(float const v) const { return ::v8::base::hash_value(v); } };
template <> struct hash<double> : public std::unary_function<double, size_t> { inline size_t operator()(double const v) const { return ::v8::base::hash_value(v); } };


template <typename T>
struct hash<T*> : public std::unary_function<T*, size_t> {
  inline size_t operator()(T* const v) const {
    return ::v8::base::hash_value(v);
  }
};
template <typename T>
struct bit_equal_to : public std::binary_function<T, T, bool> {};

template <typename T>
struct bit_hash : public std::unary_function<T, size_t> {};






template <> struct bit_equal_to<signed char> : public std::equal_to<signed char> {}; template <> struct bit_hash<signed char> : public hash<signed char> {};
template <> struct bit_equal_to<unsigned char> : public std::equal_to<unsigned char> {}; template <> struct bit_hash<unsigned char> : public hash<unsigned char> {};
template <> struct bit_equal_to<short> : public std::equal_to<short> {}; template <> struct bit_hash<short> : public hash<short> {};
template <> struct bit_equal_to<unsigned short> : public std::equal_to<unsigned short> {}; template <> struct bit_hash<unsigned short> : public hash<unsigned short> {};
template <> struct bit_equal_to<int> : public std::equal_to<int> {}; template <> struct bit_hash<int> : public hash<int> {};
template <> struct bit_equal_to<unsigned int> : public std::equal_to<unsigned int> {}; template <> struct bit_hash<unsigned int> : public hash<unsigned int> {};
template <> struct bit_equal_to<long> : public std::equal_to<long> {}; template <> struct bit_hash<long> : public hash<long> {};
template <> struct bit_equal_to<unsigned long> : public std::equal_to<unsigned long> {}; template <> struct bit_hash<unsigned long> : public hash<unsigned long> {};
template <> struct bit_equal_to<long long> : public std::equal_to<long long> {}; template <> struct bit_hash<long long> : public hash<long long> {};
template <> struct bit_equal_to<unsigned long long> : public std::equal_to<unsigned long long> {}; template <> struct bit_hash<unsigned long long> : public hash<unsigned long long> {};
template <> struct bit_equal_to<float> : public std::binary_function<float, float, bool> { inline bool operator()(float lhs, float rhs) const { return bit_cast<uint32_t>(lhs) == bit_cast<uint32_t>(rhs); } }; template <> struct bit_hash<float> : public std::unary_function<float, size_t> { inline size_t operator()(float v) const { hash<uint32_t> h; return h(bit_cast<uint32_t>(v)); } };
template <> struct bit_equal_to<double> : public std::binary_function<double, double, bool> { inline bool operator()(double lhs, double rhs) const { return bit_cast<uint64_t>(lhs) == bit_cast<uint64_t>(rhs); } }; template <> struct bit_hash<double> : public std::unary_function<double, size_t> { inline size_t operator()(double v) const { hash<uint64_t> h; return h(bit_cast<uint64_t>(v)); } };


}
}

namespace v8 {

class Value;

namespace internal {




extern bool FLAG_enable_slow_asserts;





}
}








namespace v8 {
namespace base {

typedef char Atomic8;
typedef int32_t Atomic32;
typedef intptr_t Atomic64;





typedef intptr_t AtomicWord;
Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,
                                  Atomic32 old_value,
                                  Atomic32 new_value);



Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr, Atomic32 new_value);



Atomic32 NoBarrier_AtomicIncrement(volatile Atomic32* ptr, Atomic32 increment);

Atomic32 Barrier_AtomicIncrement(volatile Atomic32* ptr,
                                 Atomic32 increment);
Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,
                                Atomic32 old_value,
                                Atomic32 new_value);
Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,
                                Atomic32 old_value,
                                Atomic32 new_value);

void MemoryBarrier();
void NoBarrier_Store(volatile Atomic8* ptr, Atomic8 value);
void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value);
void Acquire_Store(volatile Atomic32* ptr, Atomic32 value);
void Release_Store(volatile Atomic32* ptr, Atomic32 value);

Atomic8 NoBarrier_Load(volatile const Atomic8* ptr);
Atomic32 NoBarrier_Load(volatile const Atomic32* ptr);
Atomic32 Acquire_Load(volatile const Atomic32* ptr);
Atomic32 Release_Load(volatile const Atomic32* ptr);



Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,
                                  Atomic64 old_value,
                                  Atomic64 new_value);
Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr, Atomic64 new_value);
Atomic64 NoBarrier_AtomicIncrement(volatile Atomic64* ptr, Atomic64 increment);
Atomic64 Barrier_AtomicIncrement(volatile Atomic64* ptr, Atomic64 increment);

Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,
                                Atomic64 old_value,
                                Atomic64 new_value);
Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,
                                Atomic64 old_value,
                                Atomic64 new_value);
void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value);
void Acquire_Store(volatile Atomic64* ptr, Atomic64 value);
void Release_Store(volatile Atomic64* ptr, Atomic64 value);
Atomic64 NoBarrier_Load(volatile const Atomic64* ptr);
Atomic64 Acquire_Load(volatile const Atomic64* ptr);
Atomic64 Release_Load(volatile const Atomic64* ptr);


}
}
namespace v8 {
namespace base {

inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,
                                         Atomic32 old_value,
                                         Atomic32 new_value) {
  return (__sync_val_compare_and_swap(ptr, old_value, new_value));
}

inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,
                                         Atomic32 new_value) {
  Atomic32 old_value;
  do {
    old_value = *ptr;
  } while (__sync_bool_compare_and_swap(ptr, old_value, new_value) == false);
  return old_value;
}

inline Atomic32 NoBarrier_AtomicIncrement(volatile Atomic32* ptr,
                                          Atomic32 increment) {
  return Barrier_AtomicIncrement(ptr, increment);
}

inline Atomic32 Barrier_AtomicIncrement(volatile Atomic32* ptr,
                                        Atomic32 increment) {
  return __sync_add_and_fetch(ptr, increment);
}

inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,
                                       Atomic32 old_value, Atomic32 new_value) {
  return NoBarrier_CompareAndSwap(ptr, old_value, new_value);
}

inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,
                                       Atomic32 old_value, Atomic32 new_value) {
  return NoBarrier_CompareAndSwap(ptr, old_value, new_value);
}

inline void NoBarrier_Store(volatile Atomic8* ptr, Atomic8 value) {
  *ptr = value;
}

inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {
  *ptr = value;
}

inline void MemoryBarrier() { __sync_synchronize(); }

inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {
  *ptr = value;
  MemoryBarrier();
}

inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {
  MemoryBarrier();
  *ptr = value;
}

inline Atomic8 NoBarrier_Load(volatile const Atomic8* ptr) { return *ptr; }

inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) { return *ptr; }

inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {
  Atomic32 value = *ptr;
  MemoryBarrier();
  return value;
}

inline Atomic32 Release_Load(volatile const Atomic32* ptr) {
  MemoryBarrier();
  return *ptr;
}


inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,
                                         Atomic64 old_value,
                                         Atomic64 new_value) {
  return (__sync_val_compare_and_swap(ptr, old_value, new_value));
}

inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,
                                         Atomic64 new_value) {
  Atomic64 old_value;
  do {
    old_value = *ptr;
  } while (__sync_bool_compare_and_swap(ptr, old_value, new_value) == false);
  return old_value;
}

inline Atomic64 NoBarrier_AtomicIncrement(volatile Atomic64* ptr,
                                          Atomic64 increment) {
  return Barrier_AtomicIncrement(ptr, increment);
}

inline Atomic64 Barrier_AtomicIncrement(volatile Atomic64* ptr,
                                        Atomic64 increment) {
  return __sync_add_and_fetch(ptr, increment);
}


inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,
                                       Atomic64 old_value, Atomic64 new_value) {
  return NoBarrier_CompareAndSwap(ptr, old_value, new_value);
}

inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,
                                       Atomic64 old_value, Atomic64 new_value) {
  return NoBarrier_CompareAndSwap(ptr, old_value, new_value);
}

inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {
  *ptr = value;
}

inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {
  *ptr = value;
  MemoryBarrier();
}

inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {
  MemoryBarrier();
  *ptr = value;
}

inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) { return *ptr; }

inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {
  Atomic64 value = *ptr;
  MemoryBarrier();
  return value;
}

inline Atomic64 Release_Load(volatile const Atomic64* ptr) {
  MemoryBarrier();
  return *ptr;
}



}
}


namespace v8 {
namespace base {

class AccountingAllocator final {
 public:
  AccountingAllocator() = default;
  ~AccountingAllocator() = default;


  void* Allocate(size_t bytes);
  void Free(void* memory, size_t bytes);

  size_t GetCurrentMemoryUsage() const;

 private:
  AtomicWord current_memory_usage_ = 0;

  AccountingAllocator(const AccountingAllocator&) = delete; void operator=(const AccountingAllocator&) = delete;
};

}
}










namespace v8 {
namespace base {
namespace bits {


inline unsigned CountPopulation32(uint32_t value) {



  value = ((value >> 1) & 0x55555555) + (value & 0x55555555);
  value = ((value >> 2) & 0x33333333) + (value & 0x33333333);
  value = ((value >> 4) & 0x0f0f0f0f) + (value & 0x0f0f0f0f);
  value = ((value >> 8) & 0x00ff00ff) + (value & 0x00ff00ff);
  value = ((value >> 16) & 0x0000ffff) + (value & 0x0000ffff);
  return static_cast<unsigned>(value);

}



inline unsigned CountPopulation64(uint64_t value) {



  return CountPopulation32(static_cast<uint32_t>(value)) +
         CountPopulation32(static_cast<uint32_t>(value >> 32));

}



inline unsigned CountPopulation(uint32_t value) {
  return CountPopulation32(value);
}


inline unsigned CountPopulation(uint64_t value) {
  return CountPopulation64(value);
}




inline unsigned CountLeadingZeros32(uint32_t value) {







  value = value | (value >> 1);
  value = value | (value >> 2);
  value = value | (value >> 4);
  value = value | (value >> 8);
  value = value | (value >> 16);
  return CountPopulation32(~value);

}




inline unsigned CountLeadingZeros64(uint64_t value) {



  value = value | (value >> 1);
  value = value | (value >> 2);
  value = value | (value >> 4);
  value = value | (value >> 8);
  value = value | (value >> 16);
  value = value | (value >> 32);
  return CountPopulation64(~value);

}



template <typename T>
T ReverseBits(T value) {
  do { if ((!((sizeof(value) == 1) || (sizeof(value) == 2) || (sizeof(value) == 4) || (sizeof(value) == 8)))) { V8_Fatal(".././src/base/bits.h", 99, "Check failed: %s.", "(sizeof(value) == 1) || (sizeof(value) == 2) || (sizeof(value) == 4) || (sizeof(value) == 8)"); } } while (0);

  T result = 0;
  for (unsigned i = 0; i < (sizeof(value) * 8); i++) {
    result = (result << 1) | (value & 1);
    value >>= 1;
  }
  return result;
}





inline unsigned CountTrailingZeros32(uint32_t value) {







  if (value == 0) return 32;
  unsigned count = 0;
  for (value ^= value - 1; value >>= 1; ++count) {
  }
  return count;

}





inline unsigned CountTrailingZeros64(uint64_t value) {



  if (value == 0) return 64;
  unsigned count = 0;
  for (value ^= value - 1; value >>= 1; ++count) {
  }
  return count;

}



inline bool IsPowerOfTwo32(uint32_t value) {
  return value && !(value & (value - 1));
}



inline bool IsPowerOfTwo64(uint64_t value) {
  return value && !(value & (value - 1));
}







uint32_t RoundUpToPowerOfTwo32(uint32_t value);





inline uint32_t RoundDownToPowerOfTwo32(uint32_t value) {
  if (value > 0x80000000u) return 0x80000000u;
  uint32_t result = RoundUpToPowerOfTwo32(value);
  if (result > value) result >>= 1;
  return result;
}



inline uint32_t RotateRight32(uint32_t value, uint32_t shift) {
  if (shift == 0) return value;
  return (value >> shift) | (value << (32 - shift));
}


inline uint32_t RotateLeft32(uint32_t value, uint32_t shift) {
  if (shift == 0) return value;
  return (value << shift) | (value >> (32 - shift));
}


inline uint64_t RotateRight64(uint64_t value, uint64_t shift) {
  if (shift == 0) return value;
  return (value >> shift) | (value << (64 - shift));
}


inline uint64_t RotateLeft64(uint64_t value, uint64_t shift) {
  if (shift == 0) return value;
  return (value << shift) | (value >> (64 - shift));
}





inline bool SignedAddOverflow32(int32_t lhs, int32_t rhs, int32_t* val) {



  uint32_t res = static_cast<uint32_t>(lhs) + static_cast<uint32_t>(rhs);
  *val = bit_cast<int32_t>(res);
  return ((res ^ lhs) & (res ^ rhs) & (1U << 31)) != 0;

}





inline bool SignedSubOverflow32(int32_t lhs, int32_t rhs, int32_t* val) {



  uint32_t res = static_cast<uint32_t>(lhs) - static_cast<uint32_t>(rhs);
  *val = bit_cast<int32_t>(res);
  return ((res ^ lhs) & (res ^ ~rhs) & (1U << 31)) != 0;

}





inline bool SignedAddOverflow64(int64_t lhs, int64_t rhs, int64_t* val) {
  uint64_t res = static_cast<uint64_t>(lhs) + static_cast<uint64_t>(rhs);
  *val = bit_cast<int64_t>(res);
  return ((res ^ lhs) & (res ^ rhs) & (1ULL << 63)) != 0;
}





inline bool SignedSubOverflow64(int64_t lhs, int64_t rhs, int64_t* val) {
  uint64_t res = static_cast<uint64_t>(lhs) - static_cast<uint64_t>(rhs);
  *val = bit_cast<int64_t>(res);
  return ((res ^ lhs) & (res ^ ~rhs) & (1ULL << 63)) != 0;
}





int32_t SignedMulHigh32(int32_t lhs, int32_t rhs);





int32_t SignedMulHighAndAdd32(int32_t lhs, int32_t rhs, int32_t acc);





int32_t SignedDiv32(int32_t lhs, int32_t rhs);





int32_t SignedMod32(int32_t lhs, int32_t rhs);





inline bool UnsignedAddOverflow32(uint32_t lhs, uint32_t rhs, uint32_t* val) {



  *val = lhs + rhs;
  return *val < (lhs | rhs);

}




inline uint32_t UnsignedDiv32(uint32_t lhs, uint32_t rhs) {
  return rhs ? lhs / rhs : 0u;
}




inline uint32_t UnsignedMod32(uint32_t lhs, uint32_t rhs) {
  return rhs ? lhs % rhs : 0u;
}

}
}
}














#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {








#pragma map(__fp_class ,"\174\174FPCLAS")
#pragma map(__fp_finite,"\174\174FPFINI")
#pragma map(__fp_isnan ,"\174\174FPISNA")
#pragma map(__fp_unordered,"\174\174FPUNOR")







 int __fp_class(double);
    int __fp_finite(double);
    int __fp_isnan(double);
    int __fp_unordered(double, double);
#pragma map(__pow_ii ,"\174\174IXPI\174H")
 int __pow_ii (int, int);
#pragma map(__pow_i ,"\174\174DXPI\174B")
 double __pow_i (double, int);
      extern "C++" {
                  inline double fabs(double x) { return __fabs(x); }
          }
#pragma map (__hypot, "\174\174WHPT\174B")
#pragma map (__erf, "\174\174SERF\174B")
#pragma map (__erfc, "\174\174SEFC\174B")
 double __erf( double );
        double __erfc( double );
      double gamma(double);
      double j0(double);
      double j1(double);
      double jn(int, double);
      double y0(double);
      double y1(double);
      double yn(int, double);
#pragma map (j0, "\174\174WJ0\174B")
#pragma map (y0, "\174\174WY0\174B")
#pragma map (j1, "\174\174WJ1\174B")
#pragma map (y1, "\174\174WY1\174B")
#pragma map (jn, "\174\174WJN\174B")
#pragma map (yn, "\174\174WYN\174B")
#pragma map (__gamma, "\174\174WGAM\174B")
 double __gamma( double );
#pragma map (__acos, "\174\174WACS\174B")
#pragma map (__asin, "\174\174WASN\174B")
#pragma map (__atan, "\174\174SATN\174B")
#pragma map (__atan2, "\174\174WAT2\174B")

#pragma map (__cos(double), "\174\174SCOS\174B")
#pragma map (__cosh(double), "\174\174WCSH\174B")
#pragma map (__exp(double), "\174\174WEXP\174B")
#pragma map (__log(double), "\174\174WLOG\174B")
#pragma map (__pow(double, double), "\174\174WPOW\174B")
#pragma map (__sin(double), "\174\174SSIN\174B")
#pragma map (__sinh(double), "\174\174WSNH\174B")
#pragma map (__log10, "\174\174WLG1\174B")
#pragma map (__tan, "\174\174STAN\174B")
#pragma map (__tanh, "\174\174STNH\174B")

#pragma map (__ceil, "\174\174SCEL\174B")
#pragma map (__floor, "\174\174SFLR\174B")
#pragma map (__fmod, "\174\174WFMD\174B")
#pragma map (__frexp, "\174\174SFXP\174B")
#pragma map (__ldexp, "\174\174SLXP\174B")
#pragma map (__modf, "\174\174SMDF\174B")

#pragma map (__sqrt(double), "\174\174WSQT\174B")




#pragma map (__absd , "\174\174SABS\174B")
#pragma map (__acosf, "\174\174FACS\174B")
#pragma map (__acosl, "\174\174LACS\174B")
#pragma map (__asinf, "\174\174FASN\174B")
#pragma map (__asinl, "\174\174LASN\174B")
#pragma map (__atanf, "\174\174FATN\174B")
#pragma map (__atanl, "\174\174LATN\174B")
#pragma map (__atan2f, "\174\174FAT2\174B")
#pragma map (__atan2l, "\174\174LAT2\174B")
#pragma map (__ceilf, "\174\174FCEL\174B")
#pragma map (__ceill, "\174\174LCEL\174B")
#pragma map (__cosf, "\174\174FCOS\174B")
#pragma map (__cosl, "\174\174LCOS\174B")
#pragma map (__coshf, "\174\174FCSH\174B")
#pragma map (__coshl, "\174\174LCSH\174B")
#pragma map (__expf, "\174\174FEXP\174B")
#pragma map (__expl, "\174\174LEXP\174B")
#pragma map (__fabsf, "\174\174FFAB\174B")
#pragma map (__fabsl, "\174\174LFAB\174B")
#pragma map (__floorf, "\174\174FFLR\174B")
#pragma map (__floorl, "\174\174LFLR\174B")
#pragma map (__fmodf, "\174\174FFMD\174B")
#pragma map (__fmodl, "\174\174LFMD\174B")
#pragma map (__frexpf, "\174\174FFXP\174B")
#pragma map (__frexpl, "\174\174LFXP\174B")
#pragma map (__ldexpf, "\174\174FLXP\174B")
#pragma map (__ldexpl, "\174\174LLXP\174B")
#pragma map (__logf, "\174\174FLOG\174B")
#pragma map (__logl, "\174\174LLOG\174B")
#pragma map (__log10f, "\174\174FLG1\174B")
#pragma map (__log10l, "\174\174LLG1\174B")
#pragma map (__modff, "\174\174FMDF\174B")
#pragma map (__modfl, "\174\174LMDF\174B")
#pragma map (__powf, "\174\174FPOW\174B")
#pragma map (__powl, "\174\174LPOW\174B")
#pragma map (__sinf, "\174\174FSIN\174B")
#pragma map (__sinl, "\174\174LSIN\174B")
#pragma map (__sinhf, "\174\174FSNH\174B")
#pragma map (__sinhl, "\174\174LSNH\174B")
#pragma map (__sqrtf, "\174\174FSQT\174B")
#pragma map (__sqrtl, "\174\174LSQT\174B")
#pragma map (__tanf, "\174\174FTAN\174B")
#pragma map (__tanl, "\174\174LTAN\174B")
#pragma map (__tanhf, "\174\174FTNH\174B")
#pragma map (__tanhl, "\174\174LTNH\174B")
 double __atan( double );
      double __tanh( double );
      double __asin( double );
      double __acos( double );
      double __atan2( double, double );
      double __cos( double );
      double __sin( double );
      double __tan( double );
      double __cosh( double );
      double __sinh( double );
      double __exp( double );
      double __log( double );
      double __log10( double );
      double __pow( double, double );
      double __sqrt( double ) throw();


    double __absd (double);
    float __acosf (float);
    long double __acosl (long double);
    float __asinf (float);
    long double __asinl (long double);
    float __atanf (float);
    long double __atanl (long double);
    float __atan2f (float, float);
    long double __atan2l (long double, long double);
    float __cosf (float);
    long double __cosl (long double);
    float __coshf (float);
    long double __coshl (long double);
    float __expf (float);
    long double __expl (long double);
    float __logf (float);
    long double __logl (long double);
    float __log10f (float);
    long double __log10l (long double);
    float __powf (float, float);
    long double __powl (long double, long double);
    float __sinf (float);
    long double __sinl (long double);
    float __sinhf (float);
    long double __sinhl (long double);
    float __sqrtf (float);
    long double __sqrtl (long double);
    float __tanf (float);
    long double __tanl (long double);
    float __tanhf (float);
    long double __tanhl (long double);
      double __ceil(double);
      double __floor(double);
      double __fmod(double, double);
      double __frexp(double, int *);
      double __hypot( double, double );
      double __ldexp(double, int);
      double __modf(double, double *);



    float __ceilf (float);
    long double __ceill (long double);
    float __fabsf (float);
    long double __fabsl (long double);
    float __floorf (float);
    long double __floorl (long double);
    float __fmodf (float, float);
    long double __fmodl (long double, long double);
    float __frexpf (float, int*);
    long double __frexpl (long double, int*);
    float __ldexpf (float, int);
    long double __ldexpl (long double, int);
    float __modff (float, float*);
    long double __modfl (long double, long double*);



      extern "C++" {
        inline float abs(float _F) {return __fabsf(_F);}
        inline double abs(double _D) {return __absd(_D);}
        inline long double abs(long double _L) {return __fabsl(_L);}
        inline float acos(float _F) {return __acosf(_F);}
        inline double acos(double _D) {return __acos(_D);}
        inline long double acos(long double _L) {return __acosl(_L);}
        inline float asin(float _F) {return __asinf(_F);}
        inline double asin(double _D) {return __asin(_D);}
        inline long double asin(long double _L) {return __asinl(_L);}
        inline float atan(float _F) {return __atanf(_F);}
        inline double atan(double _D) {return __atan(_D);}
        inline long double atan(long double _L) {return __atanl(_L);}
        inline float atan2(float _F1, float _F2)
                                     {return __atan2f(_F1,_F2);}
        inline double atan2(double _D1, double _D2)
                                     {return __atan2(_D1, _D2);}
        inline long double atan2(long double _L1, long double _L2)
                                     {return __atan2l(_L1,_L2);}
        inline float ceil(float _F) {return __fiebr(6,_F);}


            inline double ceil(double _D) {return __fidbr(6,_D);}
            inline double floor(double _D) {return __fidbr(7,_D);}




        inline long double ceil(long double _L) {return __fixbr(6,_L);}
        inline float cos(float _F) {return __cosf(_F);}
        inline double cos(double _D) {return __cos(_D);}
        inline long double cos(long double _L) {return __cosl(_L);}
        inline float cosh(float _F) {return __coshf(_F);}
        inline double cosh(double _D) {return __cosh(_D);}
        inline long double cosh(long double _L) {return __coshl(_L);}
        inline float exp(float _F) {return __expf(_F);}
        inline double exp(double _D) {return __exp(_D);}
        inline long double exp(long double _L) {return __expl(_L);}
        inline float fabs(float _F) {return __fabsf(_F);}

        inline long double fabs(long double _L) {return __fabsl(_L);}
        inline float floor(float _F) {return __fiebr(7,_F);}
        inline long double floor(long double _L) {return __fixbr(7,_L);}
        inline float fmod(float _F1, float _F2)
                                     {return __fmodf(_F1,_F2);}
        inline double fmod(double _D1, double _D2)
                                     {return __fmod(_D1, _D2);}
        inline long double fmod(long double _L1, long double _L2)
                                     {return __fmodl(_L1,_L2);}
        inline float frexp(float _F, int *_I) {return __frexpf(_F,_I);}
        inline double frexp(double _D, int *_I) {return __frexp(_D, _I);}
        inline long double frexp(long double _L, int *_I)
                                     {return __frexpl(_L,_I);}
        inline float ldexp(float _F, int _I) {return __ldexpf(_F,_I);}
        inline double ldexp(double _D, int _I) {return __ldexp(_D, _I);}
        inline long double ldexp(long double _L, int _I)
                                     {return __ldexpl(_L,_I);}
        inline float log(float _F) {return __logf(_F);}
        inline double log(double _D) {return __log(_D);}
        inline long double log(long double _L) {return __logl(_L);}
        inline float log10(float _F) {return __log10f(_F);}
        inline double log10(double _D) {return __log10(_D);}
        inline long double log10(long double _L) {return __log10l(_L);}
        inline float modf(float _F1, float *_F2)
                                     {return __modff(_F1,_F2);}
        inline double modf(double _D1, double *_D2)
                                     {return __modf(_D1, _D2);}
        inline long double modf(long double _L1, long double *_L2)
                                     {return __modfl(_L1,_L2);}
        inline float pow(float _F1, float _F2)
                                     {return __powf(_F1,_F2);}
        inline double pow(double _D1, double _D2)
                                     {return __pow(_D1, _D2);}
        inline long double pow(long double _L1, long double _L2)
                                     {return __powl(_L1,_L2);}
        inline float pow(float _F, int _I) {return __powf(_F,(float)_I);}
        inline double pow(double _D, int _I)
                                     {return __pow(_D, (double)_I);}
        inline long double pow(long double _L, int _I)
                                     {return __powl(_L,(long double)_I);}
        inline float sin(float _F) {return __sinf(_F);}
        inline double sin(double _D) {return __sin(_D);}
        inline long double sin(long double _L) {return __sinl(_L);}
        inline float sinh(float _F) {return __sinhf(_F);}
        inline double sinh(double _D) {return __sinh(_D);}
        inline long double sinh(long double _L) {return __sinhl(_L);}
        inline float sqrt(float _F) {return __sqrtf(_F);}
        inline double sqrt(double _D) {return __sqrt(_D);}
        inline long double sqrt(long double _L) {return __sqrtl(_L);}
        inline float tan(float _F) {return __tanf(_F);}
        inline double tan(double _D) {return __tan(_D);}
        inline long double tan(long double _L) {return __tanl(_L);}
        inline float tanh(float _F) {return __tanhf(_F);}
        inline double tanh(double _D) {return __tanh(_D);}
        inline long double tanh(long double _L) {return __tanhl(_L);}
      }
     extern int signgam;
         double gamma( double );


       double j0 ( double );
       double j1 ( double );
       double jn ( int, double );



       double y0 ( double );
       double y1 ( double );
       double yn ( int, double );
       int *__signgam( void );
       double __hypot( double, double );
       double scalb( double, double );





#pragma map (scalb, "\174\174WSCB\174B")
#pragma map (__acosh, "\174\174WACH\174B")
#pragma map (__asinh, "\174\174SASH\174B")
#pragma map (__atanh, "\174\174WATH\174B")
#pragma map (__cbrt, "\174\174SCRT\174B")
#pragma map (__expm1, "\174\174SEX1\174B")
#pragma map (__log1p, "\174\174SL1P\174B")
#pragma map (__rint, "\174\174SRNT\174B")


#pragma map (__logb, "\174\174SLGB\174B")
#pragma map (__ilogb, "\174\174SILB\174B")
#pragma map (__nextafter, "\174\174SNXA\174B")
#pragma map (__remainder, "\174\174WREM\174B")
 double __acosh( double );
       double __asinh( double );
       double __atanh( double );
       double __cbrt ( double );
       double __expm1( double );
       int __ilogb( double );
       double __logb ( double );
       double __log1p( double );
       double __nextafter( double, double );
       double __remainder( double, double );
       double __rint ( double );
       typedef double float_t;
       typedef double double_t;

       int __class (const long double, const int, int);





#pragma map (__class, "\174\174CLASSB")
 float __cotanf (float);
     double __cotan (double);
     long double __cotanl (long double);
#pragma map (__acoshf, "\174\174FACH\174B")
#pragma map (__acoshl, "\174\174LACH\174B")
#pragma map (__asinhf, "\174\174FASH\174B")
#pragma map (__asinhl, "\174\174LASH\174B")
#pragma map (__atanhf, "\174\174FATH\174B")
#pragma map (__atanhl, "\174\174LATH\174B")
#pragma map (__cbrtf, "\174\174FCBT\174B")
#pragma map (__cbrtl, "\174\174LCBT\174B")
#pragma map (__copysignf, "\174\174FCPY\174B")
#pragma map (__copysignl, "\174\174LCPY\174B")
#pragma map (____cotanf, "\174\174FCTN\174B")
#pragma map (____cotan, "\174\174CTNG\174B")
#pragma map (____cotanl, "\174\174LCTN\174B")
#pragma map (__erff, "\174\174FERF\174B")
#pragma map (__erfl, "\174\174LERF\174B")
#pragma map (__erfcf, "\174\174FEFC\174B")
#pragma map (__erfcl, "\174\174LEFC\174B")
#pragma map (__exp2f, "\174\174FXP2\174B")
#pragma map (__exp2, "\174\174EXP2\174B")
#pragma map (__exp2l, "\174\174LXP2\174B")
#pragma map (__expm1f, "\174\174FXPM\174B")
#pragma map (__expm1l, "\174\174LXPM\174B")
#pragma map (__fdimf, "\174\174FFDM\174B")
#pragma map (__fdim, "\174\174FDIM\174B")
#pragma map (__fdiml, "\174\174LFDM\174B")
#pragma map (__hypotf, "\174\174FHYP\174B")
#pragma map (__hypotl, "\174\174LHYP\174B")
#pragma map (__log1pf, "\174\174FLGP\174B")
#pragma map (__log1pl, "\174\174LLGP\174B")
#pragma map (__log2f, "\174\174FLG2\174B")
#pragma map (__log2, "\174\174LOG2\174B")
#pragma map (__log2l, "\174\174LLG2\174B")
#pragma map (__remainderf, "\174\174FREM\174B")
#pragma map (__remainderl, "\174\174LREM\174B")
#pragma map (__remquof, "\174\174FRMQ\174B")
#pragma map (__remquo, "\174\174REMQ\174B")
#pragma map (__remquol, "\174\174LRMQ\174B")
#pragma map (__tgammaf, "\174\174FTGM\174B")
#pragma map (__tgamma, "\174\174TGAM\174B")
#pragma map (__tgammal, "\174\174LTGM\174B")
#pragma map (__truncf, "\174\174FTRC\174B")
#pragma map (__trunc, "\174\174TRNC\174B")
#pragma map (__truncl, "\174\174LTRC\174B")
#pragma map (__lgammaf, "\174\174FLGA\174B")
#pragma map (__lgammal, "\174\174LLGA\174B")
#pragma map (__lroundf, "\174\174FRND\174B")
#pragma map (__lround, "\174\174ROND\174B")
#pragma map (__fmaxf, "\174\174FMAXFB")
#pragma map (__fmax, "\174\174FMAX\174B")
#pragma map (__fmaxl, "\174\174FMAXLB")
#pragma map (__fmaf, "\174\174FMAFB")
#pragma map (__fma, "\174\174FMA\174B")
#pragma map (__fmal, "\174\174FMALB")
#pragma map (__fminf, "\174\174FMINFB")
#pragma map (__fmin, "\174\174FMIN\174B")
#pragma map (__fminl, "\174\174FMINLB")
#pragma map (__ilogbf, "\174\174ILBFB")
#pragma map (__ilogbl, "\174\174ILBLB")

#pragma map (__llrintf, "\174\174LLRTFB")
#pragma map (__llrint, "\174\174LLRT\174B")
#pragma map (__llrintl, "\174\174LLRTLB")
#pragma map (__llroundf, "\174\174LLRDFB")
#pragma map (__llround, "\174\174LLRD\174B")
#pragma map (__llroundl, "\174\174LLRDLB")

#pragma map (__logbf, "\174\174LOGBFB")
#pragma map (__logbl, "\174\174LOGBLB")
#pragma map (__lrintf, "\174\174LRNTFB")
#pragma map (__lrint, "\174\174LRNT\174B")
#pragma map (__lrintl, "\174\174LRNTLB")
#pragma map (__lroundl, "\174\174LRND\174B")






#pragma map (__nanf, "\174\174NANFB")
#pragma map (__nan, "\174\174NAN\174B")
#pragma map (__nanl, "\174\174NANLB")
#pragma map (__nearbyintf, "\174\174NBYIFB")
#pragma map (__nearbyint, "\174\174NBYI\174B")
#pragma map (__nearbyintl, "\174\174NBYILB")
#pragma map (__nextafterf, "\174\174NXAFFB")
#pragma map (__nextafterl, "\174\174NXAFLB")
#pragma map (__nexttowardf,"\174\174NXTWFB")
#pragma map (__nexttoward, "\174\174NXTW\174B")
#pragma map (__nexttowardl,"\174\174NXTWLB")
#pragma map (__rintf, "\174\174RINTFB")
#pragma map (__rintl, "\174\174RINTLB")
#pragma map (__roundf, "\174\174ROUNFB")
#pragma map (__round, "\174\174ROUN\174B")
#pragma map (__roundl, "\174\174ROUNLB")
#pragma map (__scalblnf, "\174\174SCBLFB")
#pragma map (__scalbln, "\174\174SCBL\174B")
#pragma map (__scalblnl, "\174\174SCBLLB")
#pragma map (__scalbnf, "\174\174SCBNFB")
#pragma map (__scalbnl, "\174\174SCBNLB")

#pragma map (__copysign, "\174\174DCPY\174B")
#pragma map (__scalbn, "\174\174SCBN\174B")

#pragma map (__lgamma, "\174\174LGMAB9")
 float __atanhf (float);
     long double __atanhl (long double);
     float __copysignf (float, float);
     long double __copysignl (long double, long double);
     float ____cotanf (float);
     double ____cotan (double);
     long double ____cotanl (long double);
     float __erff (float);
     long double __erfl (long double);
     float __erfcf (float);
     long double __erfcl (long double);
     float __fdimf (float, float);
     double __fdim (double, double);
     long double __fdiml (long double, long double);
     float __log2f (float);
     double __log2 (double);
     long double __log2l (long double);
     float __tgammaf (float);
     double __tgamma (double);
     float __truncf (float);
     double __trunc (double);
     long double __truncl (long double);
     float __lgammaf (float);
     float __rintf (float);
     long double __rintl (long double);

     double __copysign (double, double);
     float __acoshf (float);
     long double __acoshl (long double);
     float __asinhf (float);
     long double __asinhl (long double);
     float __cbrtf (float);
     long double __cbrtl (long double);
     float __exp2f (float);
     double __exp2 (double);
     long double __exp2l (long double);
     float __expm1f (float);
     long double __expm1l (long double);
     float __hypotf (float, float);
     long double __hypotl (long double, long double);
     float __log1pf (float);
     long double __log1pl (long double);
     float __remainderf (float, float);
     long double __remainderl (long double, long double);
     float __remquof (float, float, int *);
     double __remquo (double, double, int *);
     long double __remquol (long double,long double,int *);
     long double __tgammal (long double);
     long double __lgammal (long double);
     long int __lroundf (float);
     long int __lround (double);
     float __fmaxf (float, float);
     double __fmax (double, double);
     long double __fmaxl (long double, long double);
     float __fmaf (float, float, float);
     double __fma (double, double, double);
     long double __fmal (long double, long double, long double);
     float __fminf (float, float);
     double __fmin (double, double);
     long double __fminl (long double, long double);
     int __ilogbf (float);
     int __ilogbl (long double);

       long long int __llrintf (float);
       long long int __llrint (double);
       long long int __llrintl (long double);
       long long int __llroundf (float);
       long long int __llround (double);
       long long int __llroundl (long double);

     float __logbf (float);
     long double __logbl (long double);
     long __lrintf (float);
     long __lrint (double);
     long __lrintl (long double);
     long __lroundl (long double);
     float __nanf (const char *);
     double __nan (const char *);
     long double __nanl (const char *);
     float __nearbyintf (float);
     double __nearbyint (double);
     long double __nearbyintl (long double);
     float __nextafterf (float, float);
     long double __nextafterl (long double, long double);
     float __nexttowardf (float, long double);
     double __nexttoward (double, long double);
     long double __nexttowardl (long double, long double);
     float __roundf (float);
     double __round (double);
     long double __roundl (long double);
     float __scalblnf (float, long int);
     double __scalbln (double, long int);
     long double __scalblnl (long double, long int);
     float __scalbnf (float, int);
     long double __scalbnl (long double, int);

     double __scalbn (double, int);

     double __lgamma (double);
#pragma map(__class2f , "\174\174FCL2\174B" )
#pragma map(__class2 , "\174\174CLAS2B" )
#pragma map(__class2l , "\174\174LCL2\174B" )







 int __class2f (const float , unsigned int, int);

    int __class2 (const double , unsigned int, int);

    int __class2l (const long double , unsigned int, int);
    extern "C++"
    {
      template<class T> int fpclassify(T v)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for fpclassify() must be floating point");
        return 0;
      }
      template<> inline int
      fpclassify<float> (float v)
      { return __class2f(v, 1U, 1); }

      template<> inline int
      fpclassify<double> (double v)
      { return __class2(v, 1U, 1); }

      template<> inline int
      fpclassify<long double> (long double v)
      { return __class2l(v, 1U, 1); }



      template<class T> bool isfinite(T v)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for isfinite() must be floating point");
        return 0;
      }
      template<> inline bool
      isfinite<float> (float v)
      { return __class2f(v, 2U, 2); }

      template<> inline bool
      isfinite<double> (double v)
      { return __class2(v, 2U, 2); }

      template<> inline bool
      isfinite<long double> (long double v)
      { return __class2l(v, 2U, 2); }

      template<class T> bool isinfinite(T v)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for isinfinite() must be floating point");
        return 0;
      }
      template<> inline bool
      isinfinite<float> (float v)
      { return __class2f(v, 3U, 3); }

      template<> inline bool
      isinfinite<double> (double v)
      { return __class2(v, 3U, 3); }

      template<> inline bool
      isinfinite<long double> (long double v)
      { return __class2l(v, 3U, 3); }

      template<class T> bool isinf(T v)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for isinf() must be floating point");
        return 0;
      }
      template<> inline bool
      isinf<float> (float v)
      { return __class2f(v, 3U, 3); }

      template<> inline bool
      isinf<double> (double v)
      { return __class2(v, 3U, 3); }

      template<> inline bool
      isinf<long double> (long double v)
      { return __class2l(v, 3U, 3); }

      template<class T> bool isnormal(T v)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for isnormal() must be floating point");
        return 0;
      }
      template<> inline bool
      isnormal<float> (float v)
      { return __class2f(v, 4U, 4); }

      template<> inline bool
      isnormal<double> (double v)
      { return __class2(v, 4U, 4); }

      template<> inline bool
      isnormal<long double> (long double v)
      { return __class2l(v, 4U, 4); }

      template<class T> bool signbit(T v)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for signbit() must be floating point");
        return 0;
      }
      template<> inline bool
      signbit<float> (float v)
      { return __class2f(v, 5U, 5); }

      template<> inline bool
      signbit<double> (double v)
      { return __class2(v, 5U, 5); }

      template<> inline bool
      signbit<long double> (long double v)
      { return __class2l(v, 5U, 5); }





      template<class T> bool isnan(T v)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for isnan() must be floating point");
        return 0;
      }
      template<> inline bool
      isnan<float> (float v)
      { return __class2f(v, 6U, 6); }

      template<> inline bool
      isnan<double> (double v)
      { return __class2(v, 6U, 6); }

      template<> inline bool
      isnan<long double> (long double v)
      { return __class2l(v, 6U, 6); }

      template<class T> bool isgreater(T x, T y)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for isgreater() must be floating point");
        return 0;
      }
      template<> inline bool
      isgreater<float> (float x, float y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) > (y)); }

      template<> inline bool
      isgreater<double> (double x, double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) > (y)); }

      template<> inline bool
      isgreater<long double> (long double x, long double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) > (y)); }

      template<class T> bool isgreaterequal(T x, T y)
      {
        static_assert((sizeof(T) < 0 ),
       "Operand for isgreaterequal() must be floating point");
        return 0;
      }
      template<> inline bool
      isgreaterequal<float> (float x, float y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) >= (y)); }

      template<> inline bool
      isgreaterequal<double> (double x, double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) >= (y)); }

      template<> inline bool
      isgreaterequal<long double> (long double x,
                                   long double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) >= (y)); }


      template<class T> bool isless(T x, T y)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for isless() must be floating point");
        return 0;
      }
      template<> inline bool
      isless<float> (float x, float y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) < (y)); }

      template<> inline bool
      isless<double> (double x, double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) < (y)); }

      template<> inline bool
      isless<long double> (long double x, long double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) < (y)); }

      template<class T> bool islessequal(T x, T y)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for islessequal() must be floating point");
        return 0;
      }
      template<> inline bool
      islessequal<float> (float x, float y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) <= (y)); }

      template<> inline bool
      islessequal<double> (double x, double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) <= (y)); }

      template<> inline bool
      islessequal<long double> (long double x, long double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) <= (y)); }

      template<class T> bool islessgreater(T x, T y)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for islessgreater() must be floating point");
        return 0;
      }
      template<> inline bool
      islessgreater<float> (float x, float y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) != (y)); }

      template<> inline bool
      islessgreater<double> (double x, double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) != (y)); }

      template<> inline bool
      islessgreater<long double> (long double x,
                                  long double y)
      { return ((isnan(x) || isnan(y)) ? 0 : (x) != (y)); }

      template<class T> bool isunordered(T x, T y)
      {
        static_assert((sizeof(T) < 0 ),
        "Operand for isunordered() must be floating point");
        return 0;
      }
      template<> inline bool
      isunordered<float> (float x, float y)
      { return ((isnan(x) || isnan(y))) ; }

      template<> inline bool
      isunordered<double> (double x, double y)
      { return ((isnan(x) || isnan(y))) ; }

      template<> inline bool
      isunordered<long double> (long double x, long double y)
      { return ((isnan(x) || isnan(y))) ; }



    }
      extern "C++" {




         inline double acosh(double _D)
         { return __acosh(_D); }

         inline double asinh(double _D)
         { return __asinh(_D); }

         inline double atanh(double _D)
         { return __atanh(_D); }

         inline int ilogb(double _D)
         { return __ilogb(_D); }

         inline double logb(double _D)
         { return __logb(_D); }

         inline double nextafter(double _D1, double _D2)
         { return __nextafter(_D1, _D2); }

         inline double remainder(double _D1, double _D2)
         { return __remainder(_D1, _D2); }

         inline double rint(double _D)
         { return __rint(_D); }

         inline double cbrt (double _D)
         { return __cbrt(_D); }

         inline double expm1(double _D)
         { return __expm1(_D); }

         inline double log1p(double _D)
         { return __log1p(_D); }





          inline double fdim(double _D1, double _D2)
          { return __fdim(_D1, _D2); }

          inline double fmax(double _D1, double _D2)
          { return __fmax(_D1, _D2); }

          inline double fmin(double _D1, double _D2)
          { return __fmin(_D1, _D2); }



            inline long long int llrint(double _D)
            { return __llrint(_D); }

            inline long long int llround(double _D)
            { return __llround(_D); }



          inline long int lrint(double _D)
          { return __lrint(_D); }

          inline long int lround(double _D)
          { return __lround(_D); }

          inline double nan(const char *_C)
          { return __nan(_C); }
          inline double nearbyint(double _D)
          { return __nearbyint(_D); }

          inline double nexttoward(double _D, long double _L)
          { return __nexttoward(_D, _L); }

          inline double round(double _D)
          { return __round(_D); }

          inline double scalbln(double _D, long int _I)
          { return __scalbln(_D, _I); }

          inline double tgamma(double _D)
          { return __tgamma(_D); }

          inline double trunc(double _D)
          { return __trunc(_D); }



            inline double copysign(double _D1, double _D2)
            { return __copysign(_D1, _D2); }

            inline double scalbn(double _D, int _I)
            { return __scalbn(_D, _I); }



          inline double exp2(double _D)
          { return __exp2(_D); }

          inline double fma(double _D1,
                            double _D2,
                            double _D3)
          { return __fma(_D1, _D2, _D3); }

          inline double log2(double _D)
          { return __log2(_D); }






          inline double lgamma(double _D)
          { return __lgamma(_D); }






          inline double erf(double _D)
          { return __erf(_D); }

          inline double erfc(double _D)
          { return __erfc(_D); }

          inline double hypot(double _D1, double _D2)
          { return __hypot(_D1, _D2); }
          inline float acosf(float _F) {return __acosf(_F);}
          inline long double acosl(long double _L) {return __acosl(_L);}
          inline float acoshf(float _F) {return __acoshf(_F);}
          inline long double acoshl(long double _L) {return __acoshl(_L);}
          inline float asinf(float _F) {return __asinf(_F);}
          inline long double asinl(long double _L) {return __asinl(_L);}
          inline float asinhf(float _F) {return __asinhf(_F);}
          inline long double asinhl(long double _L) {return __asinhl(_L);}
          inline float atanf(float _F) {return __atanf(_F);}
          inline long double atanl(long double _L) {return __atanl(_L);}
          inline float atan2f(float _F1, float _F2) {return __atan2f(_F1,_F2);}
          inline long double atan2l(long double _L1, long double _L2)
          { return __atan2l(_L1, _L2); }
          inline float atanhf(float _F) {return __atanhf(_F);}
          inline long double atanhl(long double _L) {return __atanhl(_L);}
          inline float cbrtf(float _F) {return __cbrtf(_F);}
          inline long double cbrtl(long double _L) {return __cbrtl(_L);}
          inline float copysignf(float _F1, float _F2)
          { return __copysignf(_F1, _F2); }
          inline long double copysignl(long double _L1, long double _L2)
          { return __copysignl(_L1, _L2); }
          inline float cosf(float _F) {return __cosf(_F);}
          inline long double cosl(long double _L) {return __cosl(_L);}
          inline float coshf(float _F) {return __coshf(_F);}
          inline long double coshl(long double _L) {return __coshl(_L);}
          inline float erff(float _F) {return __erff(_F);}
          inline long double erfl(long double _L) {return __erfl(_L);}
          inline float erfcf(float _F) {return __erfcf(_F);}
          inline long double erfcl(long double _L) {return __erfcl(_L);}
          inline float expf(float _F) {return __expf(_F);}
          inline long double expl(long double _L) {return __expl(_L);}
          inline float exp2f(float _F) {return __exp2f(_F);}
          inline long double exp2l(long double _L) {return __exp2l(_L);}
          inline float expm1f(float _F) {return __expm1f(_F);}
          inline long double expm1l(long double _L) {return __expm1l(_L);}
          inline float fabsf(float _F) {return __fabsf(_F);}
          inline long double fabsl(long double _L) {return __fabsl(_L);}
          inline float fdimf(float _F1, float _F2)
          { return __fdimf(_F1, _F2); }
          inline long double fdiml(long double _L1, long double _L2)
          { return __fdiml(_L1, _L2); }



              inline float ceilf(float _F) {return __fiebr(6,_F);}
              inline long double ceill(long double _L) {return __fixbr(6,_L);}
              inline float floorf(float _F) {return __fiebr(7,_F);}
              inline long double floorl(long double _L) {return __fixbr(7,_L);}
            inline float fmaf(float _F1, float _F2, float _F3)
            { return __fmadds(_F1, _F2, _F3); }
            inline long double fmal(long double _L1,
                                    long double _L2,
                                    long double _L3)
            { return __fmal(_L1, _L2, _L3); }
          inline float fmaxf(float _F1, float _F2)
          { return __fmaxf(_F1, _F2); }
          inline long double fmaxl(long double _L1, long double _L2)
          { return __fmaxl(_L1, _L2); }
          inline float fminf(float _F1, float _F2)
          { return __fminf(_F1, _F2); }
          inline long double fminl(long double _L1, long double _L2)
          { return __fminl(_L1, _L2); }
          inline float fmodf(float _F1, float _F2)
          { return __fmodf(_F1, _F2); }
          inline long double fmodl(long double _L1, long double _L2)
          { return __fmodl(_L1, _L2); }
          inline float frexpf(float _F, int *_I) {return __frexpf(_F, _I);}
          inline long double frexpl(long double _L, int *_I)
          { return __frexpl(_L, _I); }
          inline float hypotf(float _F1, float _F2)
          { return __hypotf(_F1, _F2); }
          inline long double hypotl(long double _L1, long double _L2)
          { return __hypotl(_L1, _L2); }
          inline int ilogbf(float _F) {return __ilogbf(_F);}
          inline int ilogbl(long double _L) {return __ilogbl(_L);}
          inline float ldexpf(float _F, int _I) {return __ldexpf(_F, _I);}
          inline long double ldexpl(long double _L, int _I)
          { return __ldexpl(_L, _I); }
          inline float lgammaf(float _F) {return __lgammaf(_F);}
          inline long double lgammal(long double _L) {return __lgammal(_L);}

            inline long long int llrintf(float _F) {return __llrintf(_F);}
            inline long long int llrintl(long double _L) {return __llrintl(_L);}
            inline long long int llroundf(float _F) {return __llroundf(_F);}
            inline long long int llroundl(long double _L)
            { return __llroundl(_L); }

          inline float logf(float _F) {return __logf(_F);}
          inline long double logl(long double _L) {return __logl(_L);}
          inline float log10f(float _F) {return __log10f(_F);}
          inline long double log10l(long double _L) {return __log10l(_L);}
          inline float log1pf(float _F) {return __log1pf(_F);}
          inline long double log1pl(long double _L) {return __log1pl(_L);}
          inline float log2f(float _F) {return __log2f(_F);}
          inline long double log2l(long double _L) {return __log2l(_L);}
          inline float logbf(float _F) {return __logbf(_F);}
          inline long double logbl(long double _L) {return __logbl(_L);}
          inline long int lrintf(float _F) {return __lrintf(_F);}
          inline long int lrintl(long double _L) {return __lrintl(_L);}
          inline long int lroundf(float _F) {return __lroundf(_F);}
          inline long int lroundl(long double _L) {return __lroundl(_L);}
          inline float modff(float _F, float *_FPTR)
          { return __modff(_F, _FPTR); }
          inline long double modfl(long double _L, long double *_LPTR)
          { return __modfl(_L, _LPTR); }
          inline float nanf(const char *_C) {return __nanf(_C);}
          inline long double nanl(const char *_C) {return __nanl(_C);}
          inline float nearbyintf(float _F) {return __nearbyintf(_F);}
          inline long double nearbyintl(long double _L)
          {return __nearbyintl(_L);}
          inline float nextafterf(float _F1, float _F2)
          { return __nextafterf(_F1, _F2); }
          inline long double nextafterl(long double _L1, long double _L2)
          { return __nextafterl(_L1, _L2); }
          inline float nexttowardf(float _F, long double _L)
          { return __nexttowardf(_F, _L); }
          inline long double nexttowardl(long double _L1, long double _L2)
          { return __nexttowardl(_L1, _L2); }
          inline float powf(float _F1, float _F2)
          { return __powf(_F1, _F2); }
          inline long double powl(long double _L1, long double _L2)
          { return __powl(_L1, _L2); }
          inline float remainderf(float _F1, float _F2)
          { return __remainderf(_F1, _F2); }
          inline long double remainderl(long double _L1, long double _L2)
          { return __remainderl(_L1, _L2); }
          inline float remquof(float _F1, float _F2, int *_I)
          { return __remquof(_F1, _F2, _I); }
          inline long double remquol(long double _L1, long double _L2, int *_I)
          { return __remquol(_L1, _L2, _I); }
          inline float rintf(float _F) {return __rintf(_F);}
          inline long double rintl(long double _L) {return __rintl(_L);}
          inline float roundf(float _F) {return __roundf(_F);}
          inline long double roundl(long double _L) {return __roundl(_L);}
          inline float scalblnf(float _F, long int _LI)
          { return __scalblnf(_F, _LI); }
          inline long double scalblnl(long double _L, long int _LI)
          { return __scalblnl(_L, _LI); }
          inline float scalbnf(float _F, int _I)
          { return __scalbnf(_F, _I); }
          inline long double scalbnl(long double _L, int _I)
          { return __scalbnl(_L, _I); }
          inline float sinf(float _F) {return __sinf(_F);}
          inline long double sinl(long double _L) {return __sinl(_L);}
          inline float sinhf(float _F) {return __sinhf(_F);}
          inline long double sinhl(long double _L) {return __sinhl(_L);}
          inline float sqrtf(float _F) {return __sqrtf(_F);}
          inline long double sqrtl(long double _L) {return __sqrtl(_L);}
          inline float tanf(float _F) {return __tanf(_F);}
          inline long double tanl(long double _L) {return __tanl(_L);}
          inline float tanhf(float _F) {return __tanhf(_F);}
          inline long double tanhl(long double _L) {return __tanhl(_L);}
          inline float tgammaf(float _F) {return __tgammaf(_F);}
          inline long double tgammal(long double _L) {return __tgammal(_L);}
          inline float truncf(float _F) {return __truncf(_F);}
          inline long double truncl(long double _L) {return __truncl(_L);}




         inline float acosh(float _F)
         { return acoshf(_F);}
         inline long double acosh(long double _L)
         { return acoshl(_L);}
         inline double acosh(int _I)
         {return __acosh((double)_I);}
         inline double acosh(unsigned int _UI)
         {return __acosh((double)_UI);}
         inline double acosh(long _LI)
         {return __acosh((double)_LI);}
         inline double acosh(unsigned long _ULI)
         {return __acosh((double)_ULI);}

            inline double acosh(long long _LLI)
            {return __acosh((double)_LLI);}
            inline double acosh(unsigned long long _ULLI)
            {return __acosh((double)_ULLI);}


         inline float asinh(float _F)
         { return asinhf(_F);}
         inline long double asinh(long double _L)
         { return asinhl(_L);}
         inline double asinh(int _I)
         {return __asinh((double)_I);}
         inline double asinh(unsigned int _UI)
         {return __asinh((double)_UI);}
         inline double asinh(long _LI)
         {return __asinh((double)_LI);}
         inline double asinh(unsigned long _ULI)
         {return __asinh((double)_ULI);}

            inline double asinh(long long _LLI)
            {return __asinh((double)_LLI);}
            inline double asinh(unsigned long long _ULLI)
            {return __asinh((double)_ULLI);}


         inline float atanh(float _F)
         { return atanhf(_F);}
         inline long double atanh(long double _L)
         { return atanhl(_L);}
         inline double atanh(int _I)
         {return __atanh((double)_I);}
         inline double atanh(unsigned int _UI)
         {return __atanh((double)_UI);}
         inline double atanh(long _LI)
         {return __atanh((double)_LI);}
         inline double atanh(unsigned long _ULI)
         {return __atanh((double)_ULI);}

            inline double atanh(long long _LLI)
            {return __atanh((double)_LLI);}
            inline double atanh(unsigned long long _ULLI)
            {return __atanh((double)_ULLI);}


         inline int ilogb(float _F)
         { return ilogbf(_F);}
         inline int ilogb(long double _L)
         { return ilogbl(_L);}
         inline int ilogb(int _I)
         {return __ilogb((double)_I);}
         inline int ilogb(unsigned int _UI)
         {return __ilogb((double)_UI);}
         inline int ilogb(long _LI)
         {return __ilogb((double)_LI);}
         inline int ilogb(unsigned long _ULI)
         {return __ilogb((double)_ULI);}

            inline int ilogb(long long _LLI)
            {return __ilogb((double)_LLI);}
            inline int ilogb(unsigned long long _ULLI)
            {return __ilogb((double)_ULLI);}


         inline float logb(float _F)
         { return logbf(_F);}
         inline long double logb(long double _L)
         { return logbl(_L);}
         inline double logb(int _I)
         {return __logb((double)_I);}
         inline double logb(unsigned int _UI)
         {return __logb((double)_UI);}
         inline double logb(long _LI)
         {return __logb((double)_LI);}
         inline double logb(unsigned long _ULI)
         {return __logb((double)_ULI);}

            inline double logb(long long _LLI)
            {return __logb((double)_LLI);}
            inline double logb(unsigned long long _ULLI)
            {return __logb((double)_ULLI);}


         inline float nextafter(float _F1, float _F2)
         { return nextafterf(_F1, _F2);}
         inline long double nextafter(long double _L1,
                                      long double _L2)
         { return nextafterl(_L1, _L2);}

         inline double nextafter(float _F, double _D)
         { return __nextafter((double)_F, _D); }
         inline long double nextafter(float _F, long double _L)
         { return nextafterl((long double)_F, _L); }
         inline double nextafter(float _F, int _I)
         { return __nextafter((double)_F, (double)_I); }
         inline double nextafter(float _F, unsigned int _UI)
         { return __nextafter((double)_F, (double)_UI); }
         inline double nextafter(float _F, long _LI)
         { return __nextafter((double)_F, (double)_LI); }
         inline double nextafter(float _F, unsigned long _ULI)
         { return __nextafter((double)_F, (double)_ULI); }

            inline double nextafter(float _F, long long _LLI)
            { return __nextafter((double)_F, (double)_LLI); }
            inline double nextafter(float _F,
                                    unsigned long long _ULLI)
            { return __nextafter((double)_F, (double)_ULLI); }


         inline double nextafter(double _D, float _F)
         { return __nextafter(_D, (double)_F); }
         inline long double nextafter(double _D, long double _L)
         { return nextafterl((long double)_D, _L); }
         inline double nextafter(double _D, int _I)
         { return __nextafter(_D, (double)_I); }
         inline double nextafter(double _D, unsigned int _UI)
         { return __nextafter(_D, (double)_UI); }
         inline double nextafter(double _D, long _LI)
         { return __nextafter(_D, (double)_LI); }
         inline double nextafter(double _D, unsigned long _ULI)
         { return __nextafter(_D, (double)_ULI); }

         inline double nextafter(double _D, long long _LLI)
            { return __nextafter(_D, (double)_LLI); }
            inline double nextafter(double _D,
                                    unsigned long long _ULLI)
            { return __nextafter(_D, (double)_ULLI); }


         inline long double nextafter(long double _L, float _F)
         { return nextafterl(_L, (long double)_F); }
         inline long double nextafter(long double _L, double _D)
         { return nextafterl(_L, (long double)_D); }
         inline long double nextafter(long double _L, int _I)
         { return nextafterl(_L, (long double)_I); }
         inline long double nextafter(long double _L,
                                      unsigned int _UI)
         { return nextafterl(_L, (long double)_UI); }
         inline long double nextafter(long double _L, long _LI)
         { return nextafterl(_L, (long double)_LI); }
         inline long double nextafter(long double _L,
                                      unsigned long _ULI)
         { return nextafterl(_L, (long double)_ULI); }

            inline long double nextafter(long double _L,
                                         long long _LLI)
            { return nextafterl(_L, (long double)_LLI); }
            inline long double nextafter(long double _L,
                                         unsigned long long _ULLI)
            { return nextafterl(_L, (long double)_ULLI); }


         inline double nextafter(int _I, float _F)
         { return __nextafter((double)_I, (double)_F); }
         inline double nextafter(int _I, double _D)
         { return __nextafter((double)_I, _D); }
         inline long double nextafter(int _I, long double _L)
         { return nextafterl((long double)_I, _L); }
         inline double nextafter(int _I1, int _I2)
         { return __nextafter((double)_I1, (double)_I2); }
         inline double nextafter(int _I, unsigned int _UI)
         { return __nextafter((double)_I, (double)_UI); }
         inline double nextafter(int _I, long _LI)
         { return __nextafter((double)_I, (double)_LI); }
         inline double nextafter(int _I, unsigned long _ULI)
         { return __nextafter((double)_I, (double)_ULI); }

            inline double nextafter(int _I, long long _LLI)
            { return __nextafter((double)_I, (double)_LLI); }
            inline double nextafter(int _I,
                                    unsigned long long _ULLI)
            { return __nextafter((double)_I, (double)_ULLI); }


         inline double nextafter(unsigned int _UI, float _F)
         { return __nextafter((double)_UI, (double)_F); }
         inline double nextafter(unsigned int _UI, double _D)
         { return __nextafter((double)_UI, _D); }
         inline long double nextafter(unsigned int _UI,
                                      long double _L)
         { return nextafterl((long double)_UI, _L); }
         inline double nextafter(unsigned int _UI, int _I)
         { return __nextafter((double)_UI, (double)_I); }
         inline double nextafter(unsigned int _UI1,
                                 unsigned int _UI2)
         { return __nextafter((double)_UI1, (double)_UI2); }
         inline double nextafter(unsigned int _UI, long _LI)
         { return __nextafter((double)_UI, (double)_LI); }
         inline double nextafter(unsigned int _UI,
                                 unsigned long _ULI)
         { return __nextafter((double)_UI, (double)_ULI); }

            inline double nextafter(unsigned int _UI,
                                    long long _LLI)
            { return __nextafter((double)_UI, (double)_LLI); }
            inline double nextafter(unsigned int _UI,
                                    unsigned long long _ULLI)
            { return __nextafter((double)_UI, (double)_ULLI); }


         inline double nextafter(long _LI, float _F)
         { return __nextafter((double)_LI, (double)_F); }
         inline double nextafter(long _LI, double _D)
         { return __nextafter((double)_LI, _D); }
         inline long double nextafter(long _LI, long double _L)
         { return nextafterl((long double)_LI, _L); }
         inline double nextafter(long _LI, int _I)
         { return __nextafter((double)_LI, (double)_I); }
         inline double nextafter(long _LI, unsigned int _UI)
         { return __nextafter((double)_LI, (double)_UI); }
         inline double nextafter(long _LI1, long _LI2)
         { return __nextafter((double)_LI1, (double)_LI2); }
         inline double nextafter(long _LI, unsigned long _ULI)
         { return __nextafter((double)_LI, (double)_ULI); }

            inline double nextafter(long _LI, long long _LLI)
            { return __nextafter((double)_LI, (double)_LLI); }
            inline double nextafter(long _LI,
                                    unsigned long long _ULLI)
            { return __nextafter((double)_LI, (double)_ULLI); }


         inline double nextafter(unsigned long _ULI, float _F)
         { return __nextafter((double)_ULI, (double)_F); }
         inline double nextafter(unsigned long _ULI, double _D)
         { return __nextafter((double)_ULI, _D); }
         inline long double nextafter(unsigned long _ULI,
                                      long double _L)
         { return nextafterl((long double)_ULI, _L); }
         inline double nextafter(unsigned long _ULI, int _I)
         { return __nextafter((double)_ULI, (double)_I); }
         inline double nextafter(unsigned long _ULI,
                                 unsigned int _UI)
         { return __nextafter((double)_ULI, (double)_UI); }
         inline double nextafter(unsigned long _ULI, long _LI)
         { return __nextafter((double)_ULI, (double)_LI); }
         inline double nextafter(unsigned long _ULI1,
                                 unsigned long _ULI2)
         { return __nextafter((double)_ULI1, (double)_ULI2); }

            inline double nextafter(unsigned long _ULI,
                                    long long _LLI)
            { return __nextafter((double)_ULI, (double)_LLI); }
            inline double nextafter(unsigned long _ULI,
                                    unsigned long long _ULLI)
            { return __nextafter((double)_ULI, (double)_ULLI); }



            inline double nextafter(long long _LLI, float _F)
            { return __nextafter((double)_LLI, (double)_F); }
            inline double nextafter(long long _LLI, double _D)
            { return __nextafter((double)_LLI, _D); }
            inline long double nextafter(long long _LLI,
                                         long double _L)
            { return nextafterl((long double)_LLI, _L); }
            inline double nextafter(long long _LLI, int _I)
            { return __nextafter((double)_LLI, (double)_I); }
            inline double nextafter(long long _LLI,
                                    unsigned int _UI)
            { return __nextafter((double)_LLI, (double)_UI); }
            inline double nextafter(long long _LLI, long _LI)
            { return __nextafter((double)_LLI, (double)_LI); }
            inline double nextafter(long long _LLI,
                                    unsigned long _ULI)
            { return __nextafter((double)_LLI, (double)_ULI);}
            inline double nextafter(long long _LLI1,
                                    long long _LLI2)
            { return __nextafter((double)_LLI1,
                                 (double)_LLI2); }
            inline double nextafter(long long _LLI,
                                    unsigned long long _ULLI)
            { return __nextafter((double)_LLI,
                                 (double)_ULLI); }

            inline double nextafter(unsigned long long _ULLI,
                                    float _F)
            { return __nextafter((double)_ULLI, (double)_F); }
            inline double nextafter(unsigned long long _ULLI,
                                    double _D)
            { return __nextafter((double)_ULLI, _D); }
            inline long double nextafter(unsigned long long _ULLI,
                                         long double _L)
            { return nextafterl((long double)_ULLI, _L); }
            inline double nextafter(unsigned long long _ULLI,
                                    int _I)
            { return __nextafter((double)_ULLI, (double)_I); }
            inline double nextafter(unsigned long long _ULLI,
                                    unsigned int _UI)
            { return __nextafter((double)_ULLI, (double)_UI); }
            inline double nextafter(unsigned long long _ULLI,
                                    long _LI)
            { return __nextafter((double)_ULLI, (double)_LI); }
            inline double nextafter(unsigned long long _ULLI,
                                    unsigned long _ULI)
            { return __nextafter((double)_ULLI, (double)_ULI); }
            inline double nextafter(unsigned long long _ULLI,
                                    long long _LLI)
            { return __nextafter((double)_ULLI, (double)_LLI); }
            inline double nextafter(unsigned long long _ULLI1,
                                    unsigned long long _ULLI2)
            { return __nextafter((double)_ULLI1, (double)_ULLI2); }


         inline float remainder(float _F1, float _F2)
         { return remainderf(_F1, _F2);}
         inline long double remainder(long double _L1,
                                      long double _L2)
         { return remainderl(_L1, _L2);}

         inline double remainder(float _F, double _D)
         { return __remainder((double)_F, _D); }
         inline long double remainder(float _F, long double _L)
         { return remainderl((long double)_F, _L); }
         inline double remainder(float _F, int _I)
         { return __remainder((double)_F, (double)_I); }
         inline double remainder(float _F, unsigned int _UI)
         { return __remainder((double)_F, (double)_UI); }
         inline double remainder(float _F, long _LI)
         { return __remainder((double)_F, (double)_LI); }
         inline double remainder(float _F, unsigned long _ULI)
         { return __remainder((double)_F, (double)_ULI); }

            inline double remainder(float _F, long long _LLI)
            { return __remainder((double)_F, (double)_LLI); }
            inline double remainder(float _F,
                                    unsigned long long _ULLI)
            { return __remainder((double)_F, (double)_ULLI); }


         inline double remainder(double _D, float _F)
         { return __remainder(_D, (double)_F); }
         inline long double remainder(double _D, long double _L)
         { return remainderl((long double)_D, _L); }
         inline double remainder(double _D, int _I)
         { return __remainder(_D, (double)_I); }
         inline double remainder(double _D, unsigned int _UI)
         { return __remainder(_D, (double)_UI); }
         inline double remainder(double _D, long _LI)
         { return __remainder(_D, (double)_LI); }
         inline double remainder(double _D, unsigned long _ULI)
         { return __remainder(_D, (double)_ULI); }

         inline double remainder(double _D, long long _LLI)
            { return __remainder(_D, (double)_LLI); }
            inline double remainder(double _D,
                                    unsigned long long _ULLI)
            { return __remainder(_D, (double)_ULLI); }


         inline long double remainder(long double _L, float _F)
         { return remainderl(_L, (long double)_F); }
         inline long double remainder(long double _L, double _D)
         { return remainderl(_L, (long double)_D); }
         inline long double remainder(long double _L, int _I)
         { return remainderl(_L, (long double)_I); }
         inline long double remainder(long double _L,
                                      unsigned int _UI)
         { return remainderl(_L, (long double)_UI); }
         inline long double remainder(long double _L, long _LI)
         { return remainderl(_L, (long double)_LI); }
         inline long double remainder(long double _L,
                                      unsigned long _ULI)
         { return remainderl(_L, (long double)_ULI); }

            inline long double remainder(long double _L,
                                         long long _LLI)
            { return remainderl(_L, (long double)_LLI); }
            inline long double remainder(long double _L,
                                         unsigned long long _ULLI)
            { return remainderl(_L, (long double)_ULLI); }


         inline double remainder(int _I, float _F)
         { return __remainder((double)_I, (double)_F); }
         inline double remainder(int _I, double _D)
         { return __remainder((double)_I, _D); }
         inline long double remainder(int _I, long double _L)
         { return remainderl((long double)_I, _L); }
         inline double remainder(int _I1, int _I2)
         { return __remainder((double)_I1, (double)_I2); }
         inline double remainder(int _I, unsigned int _UI)
         { return __remainder((double)_I, (double)_UI); }
         inline double remainder(int _I, long _LI)
         { return __remainder((double)_I, (double)_LI); }
         inline double remainder(int _I, unsigned long _ULI)
         { return __remainder((double)_I, (double)_ULI); }

            inline double remainder(int _I, long long _LLI)
            { return __remainder((double)_I, (double)_LLI); }
            inline double remainder(int _I,
                                    unsigned long long _ULLI)
            { return __remainder((double)_I, (double)_ULLI); }


         inline double remainder(unsigned int _UI, float _F)
         { return __remainder((double)_UI, (double)_F); }
         inline double remainder(unsigned int _UI, double _D)
         { return __remainder((double)_UI, _D); }
         inline long double remainder(unsigned int _UI,
                                      long double _L)
         { return remainderl((long double)_UI, _L); }
         inline double remainder(unsigned int _UI, int _I)
         { return __remainder((double)_UI, (double)_I); }
         inline double remainder(unsigned int _UI1,
                                 unsigned int _UI2)
         { return __remainder((double)_UI1, (double)_UI2); }
         inline double remainder(unsigned int _UI, long _LI)
         { return __remainder((double)_UI, (double)_LI); }
         inline double remainder(unsigned int _UI,
                                 unsigned long _ULI)
         { return __remainder((double)_UI, (double)_ULI); }

            inline double remainder(unsigned int _UI,
                                    long long _LLI)
            { return __remainder((double)_UI, (double)_LLI); }
            inline double remainder(unsigned int _UI,
                                    unsigned long long _ULLI)
            { return __remainder((double)_UI, (double)_ULLI); }


         inline double remainder(long _LI, float _F)
         { return __remainder((double)_LI, (double)_F); }
         inline double remainder(long _LI, double _D)
         { return __remainder((double)_LI, _D); }
         inline long double remainder(long _LI, long double _L)
         { return remainderl((long double)_LI, _L); }
         inline double remainder(long _LI, int _I)
         { return __remainder((double)_LI, (double)_I); }
         inline double remainder(long _LI, unsigned int _UI)
         { return __remainder((double)_LI, (double)_UI); }
         inline double remainder(long _LI1, long _LI2)
         { return __remainder((double)_LI1, (double)_LI2); }
         inline double remainder(long _LI, unsigned long _ULI)
         { return __remainder((double)_LI, (double)_ULI); }

            inline double remainder(long _LI, long long _LLI)
            { return __remainder((double)_LI, (double)_LLI); }
            inline double remainder(long _LI,
                                    unsigned long long _ULLI)
            { return __remainder((double)_LI, (double)_ULLI); }


         inline double remainder(unsigned long _ULI, float _F)
         { return __remainder((double)_ULI, (double)_F); }
         inline double remainder(unsigned long _ULI, double _D)
         { return __remainder((double)_ULI, _D); }
         inline long double remainder(unsigned long _ULI,
                                      long double _L)
         { return remainderl((long double)_ULI, _L); }
         inline double remainder(unsigned long _ULI, int _I)
         { return __remainder((double)_ULI, (double)_I); }
         inline double remainder(unsigned long _ULI,
                                 unsigned int _UI)
         { return __remainder((double)_ULI, (double)_UI); }
         inline double remainder(unsigned long _ULI, long _LI)
         { return __remainder((double)_ULI, (double)_LI); }
         inline double remainder(unsigned long _ULI1,
                                 unsigned long _ULI2)
         { return __remainder((double)_ULI1, (double)_ULI2); }

            inline double remainder(unsigned long _ULI,
                                    long long _LLI)
            { return __remainder((double)_ULI, (double)_LLI); }
            inline double remainder(unsigned long _ULI,
                                    unsigned long long _ULLI)
            { return __remainder((double)_ULI, (double)_ULLI); }



            inline double remainder(long long _LLI, float _F)
            { return __remainder((double)_LLI, (double)_F); }
            inline double remainder(long long _LLI, double _D)
            { return __remainder((double)_LLI, _D); }
            inline long double remainder(long long _LLI,
                                         long double _L)
            { return remainderl((long double)_LLI, _L); }
            inline double remainder(long long _LLI, int _I)
            { return __remainder((double)_LLI, (double)_I); }
            inline double remainder(long long _LLI,
                                    unsigned int _UI)
            { return __remainder((double)_LLI, (double)_UI); }
            inline double remainder(long long _LLI, long _LI)
            { return __remainder((double)_LLI, (double)_LI); }
            inline double remainder(long long _LLI,
                                    unsigned long _ULI)
            { return __remainder((double)_LLI, (double)_ULI); }
            inline double remainder(long long _LLI1,
                                    long long _LLI2)
            { return __remainder((double)_LLI1,
                                 (double)_LLI2); }
            inline double remainder(long long _LLI,
                                    unsigned long long _ULLI)
            { return __remainder((double)_LLI, (double)_ULLI); }

            inline double remainder(unsigned long long _ULLI,
                                    float _F)
            { return __remainder((double)_ULLI, (double)_F); }
            inline double remainder(unsigned long long _ULLI,
                                    double _D)
            { return __remainder((double)_ULLI, _D); }
            inline long double remainder(unsigned long long _ULLI,
                                         long double _L)
            { return remainderl((long double)_ULLI, _L); }
            inline double remainder(unsigned long long _ULLI,
                                    int _I)
            { return __remainder((double)_ULLI, (double)_I); }
            inline double remainder(unsigned long long _ULLI,
                                    unsigned int _UI)
            { return __remainder((double)_ULLI, (double)_UI); }
            inline double remainder(unsigned long long _ULLI,
                                    long _LI)
            { return __remainder((double)_ULLI, (double)_LI); }
            inline double remainder(unsigned long long _ULLI,
                                    unsigned long _ULI)
            { return __remainder((double)_ULLI, (double)_ULI); }
            inline double remainder(unsigned long long _ULLI,
                                    long long _LLI)
            { return __remainder((double)_ULLI, (double)_LLI); }
            inline double remainder(unsigned long long _ULLI1,
                                    unsigned long long _ULLI2)
            { return __remainder((double)_ULLI1, (double)_ULLI2); }


         inline float rint(float _F)
         { return rintf(_F);}
         inline long double rint(long double _L)
         { return rintl(_L);}
         inline double rint(int _I)
         {return __rint((double)_I);}
         inline double rint(unsigned int _UI)
         {return __rint((double)_UI);}
         inline double rint(long _LI)
         {return __rint((double)_LI);}
         inline double rint(unsigned long _ULI)
         {return __rint((double)_ULI);}

            inline double rint(long long _LLI)
            {return __rint((double)_LLI);}
            inline double rint(unsigned long long _ULLI)
            {return __rint((double)_ULLI);}


         inline float cbrt(float _F)
         { return cbrtf(_F);}
         inline long double cbrt(long double _L)
         { return cbrtl(_L);}
         inline double cbrt(int _I)
         {return __cbrt((double)_I);}
         inline double cbrt(unsigned int _UI)
         {return __cbrt((double)_UI);}
         inline double cbrt(long _LI)
         {return __cbrt((double)_LI);}
         inline double cbrt(unsigned long _ULI)
         {return __cbrt((double)_ULI);}

            inline double cbrt(long long _LLI)
            {return __cbrt((double)_LLI);}
            inline double cbrt(unsigned long long _ULLI)
            {return __cbrt((double)_ULLI);}


         inline float expm1(float _F)
         { return expm1f(_F);}
         inline long double expm1(long double _L)
         { return expm1l(_L);}
         inline double expm1(int _I)
         {return __expm1((double)_I);}
         inline double expm1(unsigned int _UI)
         {return __expm1((double)_UI);}
         inline double expm1(long _LI)
         {return __expm1((double)_LI);}
         inline double expm1(unsigned long _ULI)
         {return __expm1((double)_ULI);}

            inline double expm1(long long _LLI)
            {return __expm1((double)_LLI);}
            inline double expm1(unsigned long long _ULLI)
            {return __expm1((double)_ULLI);}


         inline float log1p(float _F)
         { return log1pf(_F);}
         inline long double log1p(long double _L)
         { return log1pl(_L);}
         inline double log1p(int _I)
         {return __log1p((double)_I);}
         inline double log1p(unsigned int _UI)
         {return __log1p((double)_UI);}
         inline double log1p(long _LI)
         {return __log1p((double)_LI);}
         inline double log1p(unsigned long _ULI)
         {return __log1p((double)_ULI);}

            inline double log1p(long long _LLI)
            {return __log1p((double)_LLI);}
            inline double log1p(unsigned long long _ULLI)
            {return __log1p((double)_ULLI);}


         inline float fdim(float _F1, float _F2)
         {return fdimf(_F1, _F2);}
         inline long double fdim(long double _L1,
                                 long double _L2)
         {return fdiml(_L1, _L2);}

         inline double fdim(float _F, double _D)
         { return __fdim((double)_F, _D); }
         inline long double fdim(float _F, long double _L)
         { return fdiml((long double)_F, _L); }
         inline double fdim(float _F, int _I)
         { return __fdim((double)_F, (double)_I); }
         inline double fdim(float _F, unsigned int _UI)
         { return __fdim((double)_F, (double)_UI); }
         inline double fdim(float _F, long _LI)
         { return __fdim((double)_F, (double)_LI); }
         inline double fdim(float _F, unsigned long _ULI)
         { return __fdim((double)_F, (double)_ULI); }

            inline double fdim(float _F, long long _LLI)
            { return __fdim((double)_F, (double)_LLI); }
            inline double fdim(float _F,
                               unsigned long long _ULLI)
            { return __fdim((double)_F, (double)_ULLI); }


         inline double fdim(double _D, float _F)
         { return __fdim(_D, (double)_F); }
         inline long double fdim(double _D, long double _L)
         { return fdiml((long double)_D, _L); }
         inline double fdim(double _D, int _I)
         { return __fdim(_D, (double)_I); }
         inline double fdim(double _D, unsigned int _UI)
         { return __fdim(_D, (double)_UI); }
         inline double fdim(double _D, long _LI)
         { return __fdim(_D, (double)_LI); }
         inline double fdim(double _D, unsigned long _ULI)
         { return __fdim(_D, (double)_ULI); }

         inline double fdim(double _D, long long _LLI)
            { return __fdim(_D, (double)_LLI); }
            inline double fdim(double _D,
                               unsigned long long _ULLI)
            { return __fdim(_D, (double)_ULLI); }


         inline long double fdim(long double _L, float _F)
         { return fdiml(_L, (long double)_F); }
         inline long double fdim(long double _L, double _D)
         { return fdiml(_L, (long double)_D); }
         inline long double fdim(long double _L, int _I)
         { return fdiml(_L, (long double)_I); }
         inline long double fdim(long double _L,
                                 unsigned int _UI)
         { return fdiml(_L, (long double)_UI); }
         inline long double fdim(long double _L, long _LI)
         { return fdiml(_L, (long double)_LI); }
         inline long double fdim(long double _L,
                                 unsigned long _ULI)
         { return fdiml(_L, (long double)_ULI); }

            inline long double fdim(long double _L,
                                    long long _LLI)
            { return fdiml(_L, (long double)_LLI); }
            inline long double fdim(long double _L,
                                    unsigned long long _ULLI)
            { return fdiml(_L, (long double)_ULLI); }


         inline double fdim(int _I, float _F)
         { return __fdim((double)_I, (double)_F); }
         inline double fdim(int _I, double _D)
         { return __fdim((double)_I, _D); }
         inline long double fdim(int _I, long double _L)
         { return fdiml((long double)_I, _L); }
         inline double fdim(int _I1, int _I2)
         { return __fdim((double)_I1, (double)_I2); }
         inline double fdim(int _I, unsigned int _UI)
         { return __fdim((double)_I, (double)_UI); }
         inline double fdim(int _I, long _LI)
         { return __fdim((double)_I, (double)_LI); }
         inline double fdim(int _I, unsigned long _ULI)
         { return __fdim((double)_I, (double)_ULI); }

            inline double fdim(int _I, long long _LLI)
            { return __fdim((double)_I, (double)_LLI); }
            inline double fdim(int _I,
                               unsigned long long _ULLI)
            { return __fdim((double)_I, (double)_ULLI); }


         inline double fdim(unsigned int _UI, float _F)
         { return __fdim((double)_UI, (double)_F); }
         inline double fdim(unsigned int _UI, double _D)
         { return __fdim((double)_UI, _D); }
         inline long double fdim(unsigned int _UI,
                                 long double _L)
         { return fdiml((long double)_UI, _L); }
         inline double fdim(unsigned int _UI, int _I)
         { return __fdim((double)_UI, (double)_I); }
         inline double fdim(unsigned int _UI1,
                            unsigned int _UI2)
         { return __fdim((double)_UI1, (double)_UI2); }
         inline double fdim(unsigned int _UI, long _LI)
         { return __fdim((double)_UI, (double)_LI); }
         inline double fdim(unsigned int _UI,
                            unsigned long _ULI)
         { return __fdim((double)_UI, (double)_ULI); }

            inline double fdim(unsigned int _UI,
                               long long _LLI)
            { return __fdim((double)_UI, (double)_LLI); }
            inline double fdim(unsigned int _UI,
                               unsigned long long _ULLI)
            { return __fdim((double)_UI, (double)_ULLI); }


         inline double fdim(long _LI, float _F)
         { return __fdim((double)_LI, (double)_F); }
         inline double fdim(long _LI, double _D)
         { return __fdim((double)_LI, _D); }
         inline long double fdim(long _LI, long double _L)
         { return fdiml((long double)_LI, _L); }
         inline double fdim(long _LI, int _I)
         { return __fdim((double)_LI, (double)_I); }
         inline double fdim(long _LI, unsigned int _UI)
         { return __fdim((double)_LI, (double)_UI); }
         inline double fdim(long _LI1, long _LI2)
         { return __fdim((double)_LI1, (double)_LI2); }
         inline double fdim(long _LI, unsigned long _ULI)
         { return __fdim((double)_LI, (double)_ULI); }

            inline double fdim(long _LI, long long _LLI)
            { return __fdim((double)_LI, (double)_LLI); }
            inline double fdim(long _LI,
                               unsigned long long _ULLI)
            { return __fdim((double)_LI, (double)_ULLI); }


         inline double fdim(unsigned long _ULI, float _F)
         { return __fdim((double)_ULI, (double)_F); }
         inline double fdim(unsigned long _ULI, double _D)
         { return __fdim((double)_ULI, _D); }
         inline long double fdim(unsigned long _ULI,
                                 long double _L)
         { return fdiml((long double)_ULI, _L); }
         inline double fdim(unsigned long _ULI, int _I)
         { return __fdim((double)_ULI, (double)_I); }
         inline double fdim(unsigned long _ULI,
                            unsigned int _UI)
         { return __fdim((double)_ULI, (double)_UI); }
         inline double fdim(unsigned long _ULI, long _LI)
         { return __fdim((double)_ULI, (double)_LI); }
         inline double fdim(unsigned long _ULI1,
                            unsigned long _ULI2)
         { return __fdim((double)_ULI1, (double)_ULI2); }

            inline double fdim(unsigned long _ULI,
                               long long _LLI)
            { return __fdim((double)_ULI, (double)_LLI); }
            inline double fdim(unsigned long _ULI,
                               unsigned long long _ULLI)
            { return __fdim((double)_ULI, (double)_ULLI); }



            inline double fdim(long long _LLI, float _F)
            { return __fdim((double)_LLI, (double)_F); }
            inline double fdim(long long _LLI, double _D)
            { return __fdim((double)_LLI, _D); }
            inline long double fdim(long long _LLI,
                                    long double _L)
            { return fdiml((long double)_LLI, _L); }
            inline double fdim(long long _LLI, int _I)
            { return __fdim((double)_LLI, (double)_I); }
            inline double fdim(long long _LLI,
                               unsigned int _UI)
            { return __fdim((double)_LLI, (double)_UI); }
            inline double fdim(long long _LLI, long _LI)
            { return __fdim((double)_LLI, (double)_LI); }
            inline double fdim(long long _LLI,
                               unsigned long _ULI)
            { return __fdim((double)_LLI, (double)_ULI); }
            inline double fdim(long long _LLI1,
                               long long _LLI2)
            { return __fdim((double)_LLI1, (double)_LLI2); }
            inline double fdim(long long _LLI,
                               unsigned long long _ULLI)
            { return __fdim((double)_LLI, (double)_ULLI); }

            inline double fdim(unsigned long long _ULLI,
                               float _F)
            { return __fdim((double)_ULLI, (double)_F); }
            inline double fdim(unsigned long long _ULLI,
                               double _D)
            { return __fdim((double)_ULLI, _D); }
            inline long double fdim(unsigned long long _ULLI,
                                    long double _L)
            { return fdiml((long double)_ULLI, _L); }
            inline double fdim(unsigned long long _ULLI,
                               int _I)
            { return __fdim((double)_ULLI, (double)_I); }
            inline double fdim(unsigned long long _ULLI,
                               unsigned int _UI)
            { return __fdim((double)_ULLI, (double)_UI); }
            inline double fdim(unsigned long long _ULLI,
                               long _LI)
            { return __fdim((double)_ULLI, (double)_LI); }
            inline double fdim(unsigned long long _ULLI,
                               unsigned long _ULI)
            { return __fdim((double)_ULLI, (double)_ULI); }
            inline double fdim(unsigned long long _ULLI,
                               long long _LLI)
            { return __fdim((double)_ULLI, (double)_LLI); }
            inline double fdim(unsigned long long _ULLI1,
                               unsigned long long _ULLI2)
            { return __fdim((double)_ULLI1, (double)_ULLI2); }


         inline float fmax(float _F1, float _F2)
         {return fmaxf(_F1, _F2);}
         inline long double fmax(long double _L1,
                                 long double _L2)
         {return fmaxl(_L1, _L2);}

         inline double fmax(float _F, double _D)
         { return __fmax((double)_F, _D); }
         inline long double fmax(float _F, long double _L)
         { return fmaxl((long double)_F, _L); }
         inline double fmax(float _F, int _I)
         { return __fmax((double)_F, (double)_I); }
         inline double fmax(float _F, unsigned int _UI)
         { return __fmax((double)_F, (double)_UI); }
         inline double fmax(float _F, long _LI)
         { return __fmax((double)_F, (double)_LI); }
         inline double fmax(float _F, unsigned long _ULI)
         { return __fmax((double)_F, (double)_ULI); }

            inline double fmax(float _F, long long _LLI)
            { return __fmax((double)_F, (double)_LLI); }
            inline double fmax(float _F,
                               unsigned long long _ULLI)
            { return __fmax((double)_F, (double)_ULLI); }


         inline double fmax(double _D, float _F)
         { return __fmax(_D, (double)_F); }
         inline long double fmax(double _D, long double _L)
         { return fmaxl((long double)_D, _L); }
         inline double fmax(double _D, int _I)
         { return __fmax(_D, (double)_I); }
         inline double fmax(double _D, unsigned int _UI)
         { return __fmax(_D, (double)_UI); }
         inline double fmax(double _D, long _LI)
         { return __fmax(_D, (double)_LI); }
         inline double fmax(double _D, unsigned long _ULI)
         { return __fmax(_D, (double)_ULI); }

         inline double fmax(double _D, long long _LLI)
            { return __fmax(_D, (double)_LLI); }
            inline double fmax(double _D,
                               unsigned long long _ULLI)
            { return __fmax(_D, (double)_ULLI); }


         inline long double fmax(long double _L, float _F)
         { return fmaxl(_L, (long double)_F); }
         inline long double fmax(long double _L, double _D)
         { return fmaxl(_L, (long double)_D); }
         inline long double fmax(long double _L, int _I)
         { return fmaxl(_L, (long double)_I); }
         inline long double fmax(long double _L,
                                 unsigned int _UI)
         { return fmaxl(_L, (long double)_UI); }
         inline long double fmax(long double _L, long _LI)
         { return fmaxl(_L, (long double)_LI); }
         inline long double fmax(long double _L,
                                 unsigned long _ULI)
         { return fmaxl(_L, (long double)_ULI); }

            inline long double fmax(long double _L,
                                    long long _LLI)
            { return fmaxl(_L, (long double)_LLI); }
            inline long double fmax(long double _L,
                                    unsigned long long _ULLI)
            { return fmaxl(_L, (long double)_ULLI); }


         inline double fmax(int _I, float _F)
         { return __fmax((double)_I, (double)_F); }
         inline double fmax(int _I, double _D)
         { return __fmax((double)_I, _D); }
         inline long double fmax(int _I, long double _L)
         { return fmaxl((long double)_I, _L); }
         inline double fmax(int _I1, int _I2)
         { return __fmax((double)_I1, (double)_I2); }
         inline double fmax(int _I, unsigned int _UI)
         { return __fmax((double)_I, (double)_UI); }
         inline double fmax(int _I, long _LI)
         { return __fmax((double)_I, (double)_LI); }
         inline double fmax(int _I, unsigned long _ULI)
         { return __fmax((double)_I, (double)_ULI); }

            inline double fmax(int _I, long long _LLI)
            { return __fmax((double)_I, (double)_LLI); }
            inline double fmax(int _I,
                               unsigned long long _ULLI)
            { return __fmax((double)_I, (double)_ULLI); }


         inline double fmax(unsigned int _UI, float _F)
         { return __fmax((double)_UI, (double)_F); }
         inline double fmax(unsigned int _UI, double _D)
         { return __fmax((double)_UI, _D); }
         inline long double fmax(unsigned int _UI,
                                 long double _L)
         { return fmaxl((long double)_UI, _L); }
         inline double fmax(unsigned int _UI, int _I)
         { return __fmax((double)_UI, (double)_I); }
         inline double fmax(unsigned int _UI1,
                            unsigned int _UI2)
         { return __fmax((double)_UI1, (double)_UI2); }
         inline double fmax(unsigned int _UI, long _LI)
         { return __fmax((double)_UI, (double)_LI); }
         inline double fmax(unsigned int _UI,
                            unsigned long _ULI)
         { return __fmax((double)_UI, (double)_ULI); }

            inline double fmax(unsigned int _UI,
                               long long _LLI)
            { return __fmax((double)_UI, (double)_LLI); }
            inline double fmax(unsigned int _UI,
                               unsigned long long _ULLI)
            { return __fmax((double)_UI, (double)_ULLI); }


         inline double fmax(long _LI, float _F)
         { return __fmax((double)_LI, (double)_F); }
         inline double fmax(long _LI, double _D)
         { return __fmax((double)_LI, _D); }
         inline long double fmax(long _LI, long double _L)
         { return fmaxl((long double)_LI, _L); }
         inline double fmax(long _LI, int _I)
         { return __fmax((double)_LI, (double)_I); }
         inline double fmax(long _LI, unsigned int _UI)
         { return __fmax((double)_LI, (double)_UI); }
         inline double fmax(long _LI1, long _LI2)
         { return __fmax((double)_LI1, (double)_LI2); }
         inline double fmax(long _LI, unsigned long _ULI)
         { return __fmax((double)_LI, (double)_ULI); }

            inline double fmax(long _LI, long long _LLI)
            { return __fmax((double)_LI, (double)_LLI); }
            inline double fmax(long _LI,
                               unsigned long long _ULLI)
            { return __fmax((double)_LI, (double)_ULLI); }


         inline double fmax(unsigned long _ULI, float _F)
         { return __fmax((double)_ULI, (double)_F); }
         inline double fmax(unsigned long _ULI, double _D)
         { return __fmax((double)_ULI, _D); }
         inline long double fmax(unsigned long _ULI,
                                 long double _L)
         { return fmaxl((long double)_ULI, _L); }
         inline double fmax(unsigned long _ULI, int _I)
         { return __fmax((double)_ULI, (double)_I); }
         inline double fmax(unsigned long _ULI,
                            unsigned int _UI)
         { return __fmax((double)_ULI, (double)_UI); }
         inline double fmax(unsigned long _ULI, long _LI)
         { return __fmax((double)_ULI, (double)_LI); }
         inline double fmax(unsigned long _ULI1,
                            unsigned long _ULI2)
         { return __fmax((double)_ULI1, (double)_ULI2); }

            inline double fmax(unsigned long _ULI,
                               long long _LLI)
            { return __fmax((double)_ULI, (double)_LLI); }
            inline double fmax(unsigned long _ULI,
                               unsigned long long _ULLI)
            { return __fmax((double)_ULI, (double)_ULLI); }



            inline double fmax(long long _LLI, float _F)
            { return __fmax((double)_LLI, (double)_F); }
            inline double fmax(long long _LLI, double _D)
            { return __fmax((double)_LLI, _D); }
            inline long double fmax(long long _LLI,
                                    long double _L)
            { return fmaxl((long double)_LLI, _L); }
            inline double fmax(long long _LLI, int _I)
            { return __fmax((double)_LLI, (double)_I); }
            inline double fmax(long long _LLI,
                               unsigned int _UI)
            { return __fmax((double)_LLI, (double)_UI); }
            inline double fmax(long long _LLI, long _LI)
            { return __fmax((double)_LLI, (double)_LI); }
            inline double fmax(long long _LLI,
                               unsigned long _ULI)
            { return __fmax((double)_LLI, (double)_ULI); }
            inline double fmax(long long _LLI1,
                               long long _LLI2)
            { return __fmax((double)_LLI1, (double)_LLI2); }
            inline double fmax(long long _LLI,
                               unsigned long long _ULLI)
            { return __fmax((double)_LLI, (double)_ULLI); }

            inline double fmax(unsigned long long _ULLI,
                               float _F)
            { return __fmax((double)_ULLI, (double)_F); }
            inline double fmax(unsigned long long _ULLI,
                               double _D)
            { return __fmax((double)_ULLI, _D); }
            inline long double fmax(unsigned long long _ULLI,
                                    long double _L)
            { return fmaxl((long double)_ULLI, _L); }
            inline double fmax(unsigned long long _ULLI,
                               int _I)
            { return __fmax((double)_ULLI, (double)_I); }
            inline double fmax(unsigned long long _ULLI,
                               unsigned int _UI)
            { return __fmax((double)_ULLI, (double)_UI); }
            inline double fmax(unsigned long long _ULLI,
                               long _LI)
            { return __fmax((double)_ULLI, (double)_LI); }
            inline double fmax(unsigned long long _ULLI,
                               unsigned long _ULI)
            { return __fmax((double)_ULLI, (double)_ULI); }
            inline double fmax(unsigned long long _ULLI,
                               long long _LLI)
            { return __fmax((double)_ULLI, (double)_LLI); }
            inline double fmax(unsigned long long _ULLI1,
                               unsigned long long _ULLI2)
            { return __fmax((double)_ULLI1, (double)_ULLI2); }


         inline float fmin(float _F1, float _F2)
         {return fminf(_F1, _F2);}
         inline long double fmin(long double _L1,
                                 long double _L2)
         {return fminl(_L1, _L2);}

         inline double fmin(float _F, double _D)
         { return __fmin((double)_F, _D); }
         inline long double fmin(float _F, long double _L)
         { return fminl((long double)_F, _L); }
         inline double fmin(float _F, int _I)
         { return __fmin((double)_F, (double)_I); }
         inline double fmin(float _F, unsigned int _UI)
         { return __fmin((double)_F, (double)_UI); }
         inline double fmin(float _F, long _LI)
         { return __fmin((double)_F, (double)_LI); }
         inline double fmin(float _F, unsigned long _ULI)
         { return __fmin((double)_F, (double)_ULI); }

            inline double fmin(float _F, long long _LLI)
            { return __fmin((double)_F, (double)_LLI); }
            inline double fmin(float _F,
                               unsigned long long _ULLI)
            { return __fmin((double)_F, (double)_ULLI); }


         inline double fmin(double _D, float _F)
         { return __fmin(_D, (double)_F); }
         inline long double fmin(double _D, long double _L)
         { return fminl((long double)_D, _L); }
         inline double fmin(double _D, int _I)
         { return __fmin(_D, (double)_I); }
         inline double fmin(double _D, unsigned int _UI)
         { return __fmin(_D, (double)_UI); }
         inline double fmin(double _D, long _LI)
         { return __fmin(_D, (double)_LI); }
         inline double fmin(double _D, unsigned long _ULI)
         { return __fmin(_D, (double)_ULI); }

         inline double fmin(double _D, long long _LLI)
            { return __fmin(_D, (double)_LLI); }
            inline double fmin(double _D,
                               unsigned long long _ULLI)
            { return __fmin(_D, (double)_ULLI); }


         inline long double fmin(long double _L, float _F)
         { return fminl(_L, (long double)_F); }
         inline long double fmin(long double _L, double _D)
         { return fminl(_L, (long double)_D); }
         inline long double fmin(long double _L, int _I)
         { return fminl(_L, (long double)_I); }
         inline long double fmin(long double _L,
                                 unsigned int _UI)
         { return fminl(_L, (long double)_UI); }
         inline long double fmin(long double _L, long _LI)
         { return fminl(_L, (long double)_LI); }
         inline long double fmin(long double _L,
                                 unsigned long _ULI)
         { return fminl(_L, (long double)_ULI); }

            inline long double fmin(long double _L,
                                    long long _LLI)
            { return fminl(_L, (long double)_LLI); }
            inline long double fmin(long double _L,
                                    unsigned long long _ULLI)
            { return fminl(_L, (long double)_ULLI); }


         inline double fmin(int _I, float _F)
         { return __fmin((double)_I, (double)_F); }
         inline double fmin(int _I, double _D)
         { return __fmin((double)_I, _D); }
         inline long double fmin(int _I, long double _L)
         { return fminl((long double)_I, _L); }
         inline double fmin(int _I1, int _I2)
         { return __fmin((double)_I1, (double)_I2); }
         inline double fmin(int _I, unsigned int _UI)
         { return __fmin((double)_I, (double)_UI); }
         inline double fmin(int _I, long _LI)
         { return __fmin((double)_I, (double)_LI); }
         inline double fmin(int _I, unsigned long _ULI)
         { return __fmin((double)_I, (double)_ULI); }

            inline double fmin(int _I, long long _LLI)
            { return __fmin((double)_I, (double)_LLI); }
            inline double fmin(int _I,
                               unsigned long long _ULLI)
            { return __fmin((double)_I, (double)_ULLI); }


         inline double fmin(unsigned int _UI, float _F)
         { return __fmin((double)_UI, (double)_F); }
         inline double fmin(unsigned int _UI, double _D)
         { return __fmin((double)_UI, _D); }
         inline long double fmin(unsigned int _UI,
                                 long double _L)
         { return fminl((long double)_UI, _L); }
         inline double fmin(unsigned int _UI, int _I)
         { return __fmin((double)_UI, (double)_I); }
         inline double fmin(unsigned int _UI1,
                            unsigned int _UI2)
         { return __fmin((double)_UI1, (double)_UI2); }
         inline double fmin(unsigned int _UI, long _LI)
         { return __fmin((double)_UI, (double)_LI); }
         inline double fmin(unsigned int _UI,
                            unsigned long _ULI)
         { return __fmin((double)_UI, (double)_ULI); }

            inline double fmin(unsigned int _UI,
                               long long _LLI)
            { return __fmin((double)_UI, (double)_LLI); }
            inline double fmin(unsigned int _UI,
                               unsigned long long _ULLI)
            { return __fmin((double)_UI, (double)_ULLI); }


         inline double fmin(long _LI, float _F)
         { return __fmin((double)_LI, (double)_F); }
         inline double fmin(long _LI, double _D)
         { return __fmin((double)_LI, _D); }
         inline long double fmin(long _LI, long double _L)
         { return fminl((long double)_LI, _L); }
         inline double fmin(long _LI, int _I)
         { return __fmin((double)_LI, (double)_I); }
         inline double fmin(long _LI, unsigned int _UI)
         { return __fmin((double)_LI, (double)_UI); }
         inline double fmin(long _LI1, long _LI2)
         { return __fmin((double)_LI1, (double)_LI2); }
         inline double fmin(long _LI, unsigned long _ULI)
         { return __fmin((double)_LI, (double)_ULI); }

            inline double fmin(long _LI, long long _LLI)
            { return __fmin((double)_LI, (double)_LLI); }
            inline double fmin(long _LI,
                               unsigned long long _ULLI)
            { return __fmin((double)_LI, (double)_ULLI); }


         inline double fmin(unsigned long _ULI, float _F)
         { return __fmin((double)_ULI, (double)_F); }
         inline double fmin(unsigned long _ULI, double _D)
         { return __fmin((double)_ULI, _D); }
         inline long double fmin(unsigned long _ULI,
                                 long double _L)
         { return fminl((long double)_ULI, _L); }
         inline double fmin(unsigned long _ULI, int _I)
         { return __fmin((double)_ULI, (double)_I); }
         inline double fmin(unsigned long _ULI,
                            unsigned int _UI)
         { return __fmin((double)_ULI, (double)_UI); }
         inline double fmin(unsigned long _ULI, long _LI)
         { return __fmin((double)_ULI, (double)_LI); }
         inline double fmin(unsigned long _ULI1,
                            unsigned long _ULI2)
         { return __fmin((double)_ULI1, (double)_ULI2); }

            inline double fmin(unsigned long _ULI,
                               long long _LLI)
            { return __fmin((double)_ULI, (double)_LLI); }
            inline double fmin(unsigned long _ULI,
                               unsigned long long _ULLI)
            { return __fmin((double)_ULI, (double)_ULLI); }



            inline double fmin(long long _LLI, float _F)
            { return __fmin((double)_LLI, (double)_F); }
            inline double fmin(long long _LLI, double _D)
            { return __fmin((double)_LLI, _D); }
            inline long double fmin(long long _LLI,
                                    long double _L)
            { return fminl((long double)_LLI, _L); }
            inline double fmin(long long _LLI, int _I)
            { return __fmin((double)_LLI, (double)_I); }
            inline double fmin(long long _LLI,
                               unsigned int _UI)
            { return __fmin((double)_LLI, (double)_UI); }
            inline double fmin(long long _LLI, long _LI)
            { return __fmin((double)_LLI, (double)_LI); }
            inline double fmin(long long _LLI,
                               unsigned long _ULI)
            { return __fmin((double)_LLI, (double)_ULI); }
            inline double fmin(long long _LLI1,
                               long long _LLI2)
            { return __fmin((double)_LLI1, (double)_LLI2); }
            inline double fmin(long long _LLI,
                               unsigned long long _ULLI)
            { return __fmin((double)_LLI, (double)_ULLI); }

            inline double fmin(unsigned long long _ULLI,
                               float _F)
            { return __fmin((double)_ULLI, (double)_F); }
            inline double fmin(unsigned long long _ULLI,
                               double _D)
            { return __fmin((double)_ULLI, _D); }
            inline long double fmin(unsigned long long _ULLI,
                                    long double _L)
            { return fminl((long double)_ULLI, _L); }
            inline double fmin(unsigned long long _ULLI,
                               int _I)
            { return __fmin((double)_ULLI, (double)_I); }
            inline double fmin(unsigned long long _ULLI,
                               unsigned int _UI)
            { return __fmin((double)_ULLI, (double)_UI); }
            inline double fmin(unsigned long long _ULLI,
                               long _LI)
            { return __fmin((double)_ULLI, (double)_LI); }
            inline double fmin(unsigned long long _ULLI,
                               unsigned long _ULI)
            { return __fmin((double)_ULLI, (double)_ULI); }
            inline double fmin(unsigned long long _ULLI,
                               long long _LLI)
            { return __fmin((double)_ULLI, (double)_LLI); }
            inline double fmin(unsigned long long _ULLI1,
                               unsigned long long _ULLI2)
            { return __fmin((double)_ULLI1, (double)_ULLI2); }



            inline long long llrint(float _F)
            {return llrintf(_F);}
            inline long long llrint(long double _L)
            {return llrintl(_L);}
            inline long long llrint(int _I)
            {return __llrint((double)_I);}
            inline long long llrint(unsigned int _UI)
            {return __llrint((double)_UI);}
            inline long long llrint(long _LI)
            {return __llrint((double)_LI);}
            inline long long llrint(unsigned long _ULI)
            {return __llrint((double)_ULI);}
            inline long long llrint(long long _LLI)
            {return __llrint((double)_LLI);}
            inline long long llrint(unsigned long long _ULLI)
            {return __llrint((double)_ULLI);}

            inline long long llround(float _F)
            {return llroundf(_F);}
            inline long long llround(long double _L)
            {return llroundl(_L);}
            inline long long llround(int _I)
            {return __llround((double)_I);}
            inline long long llround(unsigned int _UI)
            {return __llround((double)_UI);}
            inline long long llround(long _LI)
            {return __llround((double)_LI);}
            inline long long llround(unsigned long _ULI)
            {return __llround((double)_ULI);}
            inline long long llround(long long _LLI)
            {return __llround((double)_LLI);}
            inline long long llround(unsigned long long _ULLI)
            {return __llround((double)_ULLI);}



         inline long lrint(float _F)
         {return lrintf(_F);}
         inline long lrint(long double _L)
         {return lrintl(_L);}
         inline long lrint(int _I)
         {return __lrint((double)_I);}
         inline long lrint(unsigned int _UI)
         {return __lrint((double)_UI);}
         inline long lrint(long _LI)
         {return __lrint((double)_LI);}
         inline long lrint(unsigned long _ULI)
         {return __lrint((double)_ULI);}

            inline long lrint(long long _LLI)
            {return __lrint((double)_LLI);}
            inline long lrint(unsigned long long _ULLI)
            {return __lrint((double)_ULLI);}


         inline long lround(float _F)
         {return lroundf(_F);}
         inline long lround(long double _L)
         {return lroundl(_L);}
         inline long lround(int _I)
         {return __lround((double)_I);}
         inline long lround(unsigned int _UI)
         {return __lround((double)_UI);}
         inline long lround(long _LI)
         {return __lround((double)_LI);}
         inline long lround(unsigned long _ULI)
         {return __lround((double)_ULI);}

            inline long lround(long long _LLI)
            {return __lround((double)_LLI);}
            inline long lround(unsigned long long _ULLI)
            {return __lround((double)_ULLI);}


         inline float nearbyint(float _F)
         {return nearbyintf(_F);}
         inline long double nearbyint(long double _L)
         {return nearbyintl(_L);}
         inline double nearbyint(int _I)
         {return __nearbyint((double)_I);}
         inline double nearbyint(unsigned int _UI)
         {return __nearbyint((double)_UI);}
         inline double nearbyint(long _LI)
         {return __nearbyint((double)_LI);}
         inline double nearbyint(unsigned long _ULI)
         {return __nearbyint((double)_ULI);}

            inline double nearbyint(long long _LLI)
            {return __nearbyint((double)_LLI);}
            inline double nearbyint(unsigned long long _ULLI)
            {return __nearbyint((double)_ULLI);}


         inline float nexttoward(float _F, long double _L)
         {return nexttowardf(_F, _L);}
         inline long double nexttoward(long double _L1,
                                       long double _L2)
         {return nexttowardl(_L1, _L2);}
         inline double nexttoward(int _I, long double _L)
         { return __nexttoward((double)_I, _L); }
         inline double nexttoward(unsigned int _UI,
                                  long double _L)
         { return __nexttoward((double)_UI, _L); }
         inline double nexttoward(long _LI, long double _L)
         { return __nexttoward((double)_LI, _L); }
         inline double nexttoward(unsigned long _ULI,
                                  long double _L)
         { return __nexttoward((double)_ULI, _L); }

            inline double nexttoward(long long _LLI,
                                     long double _L)
            { return __nexttoward((double)_LLI, _L); }
            inline double nexttoward(unsigned long long _ULLI,
                                     long double _L)
            { return __nexttoward((double)_ULLI, _L); }


         inline float round(float _F)
         {return roundf(_F);}
         inline long double round(long double _L)
         {return roundl(_L);}
         inline double round(int _I)
         {return __round((double)_I);}
         inline double round(unsigned int _UI)
         {return __round((double)_UI);}
         inline double round(long _LI)
         {return __round((double)_LI);}
         inline double round(unsigned long _ULI)
         {return __round((double)_ULI);}

            inline double round(long long _LLI)
            {return __round((double)_LLI);}
            inline double round(unsigned long long _ULLI)
            {return __round((double)_ULLI);}


         inline float scalbln(float _F, long int _I)
         {return scalblnf(_F, _I);}
         inline long double scalbln(long double _L,
                                    long int _I)
         {return scalblnl(_L, _I);}
         inline double scalbln(int _I, long _LI)
         {return __scalbln((double)_I, _LI);}
         inline double scalbln(unsigned int _UI, long _LI)
         {return __scalbln((double)_UI, _LI);}
         inline double scalbln(long _LI1, long _LI2)
         {return __scalbln((double)_LI1, _LI2);}
         inline double scalbln(unsigned long _ULI, long _LI)
         {return __scalbln((double)_ULI, _LI);}

            inline double scalbln(long long _LLI, long _LI)
            {return __scalbln((double)_LLI, _LI);}
            inline double scalbln(unsigned long long _ULLI, long _LI)
            {return __scalbln((double)_ULLI, _LI);}


         inline float tgamma(float _F)
         {return tgammaf(_F);}
         inline long double tgamma(long double _L)
         {return tgammal(_L);}
         inline double tgamma(int _I)
         {return __tgamma((double)_I);}
         inline double tgamma(unsigned int _UI)
         {return __tgamma((double)_UI);}
         inline double tgamma(long _LI)
         {return __tgamma((double)_LI);}
         inline double tgamma(unsigned long _ULI)
         {return __tgamma((double)_ULI);}

            inline double tgamma(long long _LLI)
            {return __tgamma((double)_LLI);}
            inline double tgamma(unsigned long long _ULLI)
            {return __tgamma((double)_ULLI);}


         inline float trunc(float _F)
         {return truncf(_F);}
         inline long double trunc(long double _L)
         {return truncl(_L);}
         inline double trunc(int _I)
         {return __trunc((double)_I);}
         inline double trunc(unsigned int _UI)
         {return __trunc((double)_UI);}
         inline double trunc(long _LI)
         {return __trunc((double)_LI);}
         inline double trunc(unsigned long _ULI)
         {return __trunc((double)_ULI);}

            inline double trunc(long long _LLI)
            {return __trunc((double)_LLI);}
            inline double trunc(unsigned long long _ULLI)
            {return __trunc((double)_ULLI);}




           inline float copysign(float _F1, float _F2)
           {return copysignf(_F1, _F2);}
           inline long double copysign(long double _L1,
                                       long double _L2)
           {return copysignl(_L1, _L2);}

           inline double copysign(float _F, double _D)
           { return __copysign((double)_F, _D); }
           inline long double copysign(float _F, long double _L)
           { return copysignl((long double)_F, _L); }
           inline double copysign(float _F, int _I)
           { return __copysign((double)_F, (double)_I); }
           inline double copysign(float _F, unsigned int _UI)
           { return __copysign((double)_F, (double)_UI); }
           inline double copysign(float _F, long _LI)
           { return __copysign((double)_F, (double)_LI); }
           inline double copysign(float _F, unsigned long _ULI)
           { return __copysign((double)_F, (double)_ULI); }

              inline double copysign(float _F, long long _LLI)
              { return __copysign((double)_F, (double)_LLI); }
              inline double copysign(float _F,
                                     unsigned long long _ULLI)
              { return __copysign((double)_F, (double)_ULLI); }


           inline double copysign(double _D, float _F)
           { return __copysign(_D, (double)_F); }
           inline long double copysign(double _D, long double _L)
           { return copysignl((long double)_D, _L); }
           inline double copysign(double _D, int _I)
           { return __copysign(_D, (double)_I); }
           inline double copysign(double _D, unsigned int _UI)
           { return __copysign(_D, (double)_UI); }
           inline double copysign(double _D, long _LI)
           { return __copysign(_D, (double)_LI); }
           inline double copysign(double _D, unsigned long _ULI)
           { return __copysign(_D, (double)_ULI); }

           inline double copysign(double _D, long long _LLI)
              { return __copysign(_D, (double)_LLI); }
              inline double copysign(double _D,
                                     unsigned long long _ULLI)
              { return __copysign(_D, (double)_ULLI); }


           inline long double copysign(long double _L, float _F)
           { return copysignl(_L, (long double)_F); }
           inline long double copysign(long double _L, double _D)
           { return copysignl(_L, (long double)_D); }
           inline long double copysign(long double _L, int _I)
           { return copysignl(_L, (long double)_I); }
           inline long double copysign(long double _L,
                                       unsigned int _UI)
           { return copysignl(_L, (long double)_UI); }
           inline long double copysign(long double _L, long _LI)
           { return copysignl(_L, (long double)_LI); }
           inline long double copysign(long double _L,
                                       unsigned long _ULI)
           { return copysignl(_L, (long double)_ULI); }

              inline long double copysign(long double _L,
                                          long long _LLI)
              { return copysignl(_L, (long double)_LLI); }
              inline long double copysign(long double _L,
                                          unsigned long long _ULLI)
              { return copysignl(_L, (long double)_ULLI); }


           inline double copysign(int _I, float _F)
           { return __copysign((double)_I, (double)_F); }
           inline double copysign(int _I, double _D)
           { return __copysign((double)_I, _D); }
           inline long double copysign(int _I, long double _L)
           { return copysignl((long double)_I, _L); }
           inline double copysign(int _I1, int _I2)
           { return __copysign((double)_I1, (double)_I2); }
           inline double copysign(int _I, unsigned int _UI)
           { return __copysign((double)_I, (double)_UI); }
           inline double copysign(int _I, long _LI)
           { return __copysign((double)_I, (double)_LI); }
           inline double copysign(int _I, unsigned long _ULI)
           { return __copysign((double)_I, (double)_ULI); }

              inline double copysign(int _I, long long _LLI)
              { return __copysign((double)_I, (double)_LLI); }
              inline double copysign(int _I,
                                     unsigned long long _ULLI)
              { return __copysign((double)_I, (double)_ULLI); }


           inline double copysign(unsigned int _UI, float _F)
           { return __copysign((double)_UI, (double)_F); }
           inline double copysign(unsigned int _UI, double _D)
           { return __copysign((double)_UI, _D); }
           inline long double copysign(unsigned int _UI,
                                       long double _L)
           { return copysignl((long double)_UI, _L); }
           inline double copysign(unsigned int _UI, int _I)
           { return __copysign((double)_UI, (double)_I); }
           inline double copysign(unsigned int _UI1,
                                  unsigned int _UI2)
           { return __copysign((double)_UI1, (double)_UI2); }
           inline double copysign(unsigned int _UI, long _LI)
           { return __copysign((double)_UI, (double)_LI); }
           inline double copysign(unsigned int _UI,
                                  unsigned long _ULI)
           { return __copysign((double)_UI, (double)_ULI); }

              inline double copysign(unsigned int _UI,
                                     long long _LLI)
              { return __copysign((double)_UI, (double)_LLI); }
              inline double copysign(unsigned int _UI,
                                     unsigned long long _ULLI)
              { return __copysign((double)_UI, (double)_ULLI); }


           inline double copysign(long _LI, float _F)
           { return __copysign((double)_LI, (double)_F); }
           inline double copysign(long _LI, double _D)
           { return __copysign((double)_LI, _D); }
           inline long double copysign(long _LI, long double _L)
           { return copysignl((long double)_LI, _L); }
           inline double copysign(long _LI, int _I)
           { return __copysign((double)_LI, (double)_I); }
           inline double copysign(long _LI, unsigned int _UI)
           { return __copysign((double)_LI, (double)_UI); }
           inline double copysign(long _LI1, long _LI2)
           { return __copysign((double)_LI1, (double)_LI2); }
           inline double copysign(long _LI, unsigned long _ULI)
           { return __copysign((double)_LI, (double)_ULI); }

              inline double copysign(long _LI, long long _LLI)
              { return __copysign((double)_LI, (double)_LLI); }
              inline double copysign(long _LI,
                                     unsigned long long _ULLI)
              { return __copysign((double)_LI, (double)_ULLI); }


           inline double copysign(unsigned long _ULI, float _F)
           { return __copysign((double)_ULI, (double)_F); }
           inline double copysign(unsigned long _ULI, double _D)
           { return __copysign((double)_ULI, _D); }
           inline long double copysign(unsigned long _ULI,
                                       long double _L)
           { return copysignl((long double)_ULI, _L); }
           inline double copysign(unsigned long _ULI, int _I)
           { return __copysign((double)_ULI, (double)_I); }
           inline double copysign(unsigned long _ULI,
                                  unsigned int _UI)
           { return __copysign((double)_ULI, (double)_UI); }
           inline double copysign(unsigned long _ULI, long _LI)
           { return __copysign((double)_ULI, (double)_LI); }
           inline double copysign(unsigned long _ULI1,
                                  unsigned long _ULI2)
           { return __copysign((double)_ULI1, (double)_ULI2); }

              inline double copysign(unsigned long _ULI,
                                     long long _LLI)
              { return __copysign((double)_ULI, (double)_LLI); }
              inline double copysign(unsigned long _ULI,
                                     unsigned long long _ULLI)
              { return __copysign((double)_ULI, (double)_ULLI); }



              inline double copysign(long long _LLI, float _F)
              { return __copysign((double)_LLI, (double)_F); }
              inline double copysign(long long _LLI, double _D)
              { return __copysign((double)_LLI, _D); }
              inline long double copysign(long long _LLI,
                                          long double _L)
              { return copysignl((long double)_LLI, _L); }
              inline double copysign(long long _LLI, int _I)
              { return __copysign((double)_LLI, (double)_I); }
              inline double copysign(long long _LLI,
                                     unsigned int _UI)
              { return __copysign((double)_LLI, (double)_UI); }
              inline double copysign(long long _LLI, long _LI)
              { return __copysign((double)_LLI, (double)_LI); }
              inline double copysign(long long _LLI,
                                     unsigned long _ULI)
              { return __copysign((double)_LLI, (double)_ULI); }
              inline double copysign(long long _LLI1,
                                     long long _LLI2)
              { return __copysign((double)_LLI1, (double)_LLI2);}
              inline double copysign(long long _LLI,
                                     unsigned long long _ULLI)
              { return __copysign((double)_LLI, (double)_ULLI); }

              inline double copysign(unsigned long long _ULLI,
                                     float _F)
              { return __copysign((double)_ULLI, (double)_F); }
              inline double copysign(unsigned long long _ULLI,
                                     double _D)
              { return __copysign((double)_ULLI, _D); }
              inline long double copysign(unsigned long long _ULLI,
                                          long double _L)
              { return copysignl((long double)_ULLI, _L); }
              inline double copysign(unsigned long long _ULLI,
                                     int _I)
              { return __copysign((double)_ULLI, (double)_I); }
              inline double copysign(unsigned long long _ULLI,
                                     unsigned int _UI)
              { return __copysign((double)_ULLI, (double)_UI); }
              inline double copysign(unsigned long long _ULLI,
                                     long _LI)
              { return __copysign((double)_ULLI, (double)_LI); }
              inline double copysign(unsigned long long _ULLI,
                                     unsigned long _ULI)
              { return __copysign((double)_ULLI, (double)_ULI); }
              inline double copysign(unsigned long long _ULLI,
                                     long long _LLI)
              { return __copysign((double)_ULLI, (double)_LLI); }
              inline double copysign(unsigned long long _ULLI1,
                                     unsigned long long _ULLI2)
              { return __copysign((double)_ULLI1, (double)_ULLI2); }


           inline float scalbn(float _F, int _I)
           {return scalbnf(_F, _I);}
           inline long double scalbn(long double _L, int _I)
           {return scalbnl(_L, _I);}
           inline double scalbn(int _I1, int _I2)
           {return __scalbn((double)_I1, _I2);}
           inline double scalbn(unsigned int _UI, int _I)
           {return __scalbn((double)_UI, _I);}
           inline double scalbn(long _LI, int _I)
           {return __scalbn((double)_LI, _I);}
           inline double scalbn(unsigned long _ULI, int _I)
           {return __scalbn((double)_ULI, _I);}

              inline double scalbn(long long _LLI, int _I)
              {return __scalbn((double)_LLI, _I);}
              inline double scalbn(unsigned long long _ULLI, int _I)
              {return __scalbn((double)_ULLI, _I);}




         inline float exp2(float _F)
         {return exp2f(_F);}
         inline long double exp2(long double _L)
         {return exp2l(_L);}
         inline double exp2(int _I)
         {return __exp2((double)_I);}
         inline double exp2(unsigned int _UI)
         {return __exp2((double)_UI);}
         inline double exp2(long _LI)
         {return __exp2((double)_LI);}
         inline double exp2(unsigned long _ULI)
         {return __exp2((double)_ULI);}

            inline double exp2(long long _LLI)
            {return __exp2((double)_LLI);}
            inline double exp2(unsigned long long _ULLI)
            {return __exp2((double)_ULLI);}


         inline float fma(float _F1,
                          float _F2,
                          float _F3)
         {return fmaf(_F1, _F2, _F3);}
         inline long double fma(long double _L1,
                                long double _L2,
                                long double _L3)
         {return fmal(_L1, _L2, _L3);}


         inline double fma(float _F1, float _F2, double _D)
         { return __fma((double)_F1, (double)_F2, _D); }
         inline long double fma(float _F1, float _F2, long double _L)
         { return fmal((long double)_F1, (long double)_F2, _L); }
         inline double fma(float _F1, float _F2, int _I)
         { return __fma((double)_F1, (double)_F2, (double)_I); }
         inline double fma(float _F1, float _F2, unsigned int _UI)
         { return __fma((double)_F1, (double)_F2, (double)_UI); }
         inline double fma(float _F1, float _F2, long _LI)
         { return __fma((double)_F1, (double)_F2, (double)_LI); }
         inline double fma(float _F1, float _F2, unsigned long _ULI)
         { return __fma((double)_F1, (double)_F2, (double)_ULI); }

            inline double fma(float _F1, float _F2, long long _LLI)
            { return __fma((double)_F1, (double)_F2, (double)_LLI); }
            inline double fma(float _F1,
                              float _F2,
                              unsigned long long _ULLI)
            { return __fma((double)_F1, (double)_F2, (double)_ULLI); }


         inline double fma(float _F1, double _D, float _F2)
         { return __fma((double)_F1, _D, (double)_F2); }
         inline double fma(float _F, double _D1, double _D2)
         { return __fma((double)_F, _D1, _D2); }
         inline long double fma(float _F, double _D, long double _L)
         { return fmal((long double)_F, (long double)_D, _L); }
         inline double fma(float _F, double _D, int _I)
         { return __fma((double)_F, _D, (double)_I); }
         inline double fma(float _F, double _D, unsigned int _UI)
         { return __fma((double)_F, _D, (double)_UI); }
         inline double fma(float _F, double _D, long _LI)
         { return __fma((double)_F, _D, (double)_LI); }
         inline double fma(float _F, double _D, unsigned long _ULI)
         { return __fma((double)_F, _D, (double)_ULI); }

            inline double fma(float _F, double _D, long long _LLI)
            { return __fma((double)_F, _D, (double)_LLI); }
            inline double fma(float _F,
                              double _D,
                              unsigned long long _ULLI)
            { return __fma((double)_F, _D, (double)_ULLI); }


         inline long double fma(float _F1, long double _L, float _F2)
         { return fmal((long double)_F1, _L, (long double)_F2); }
         inline long double fma(float _F, long double _L, double _D)
         { return fmal((long double)_F, _L, (long double)_D); }
         inline long double fma(float _F, long double _L1, long double _L2)
         { return fmal((long double)_F, _L1, _L2); }
         inline long double fma(float _F, long double _L, int _I)
         { return fmal((long double)_F, _L, (long double)_I); }
         inline long double fma(float _F, long double _L, unsigned int _UI)
         { return fmal((long double)_F, _L, (long double)_UI); }
         inline long double fma(float _F, long double _L, long _LI)
         { return fmal((long double)_F, _L, (long double)_LI); }
         inline long double fma(float _F, long double _L, unsigned long _ULI)
         { return fmal((long double)_F, _L, (long double)_ULI); }

            inline long double fma(float _F, long double _L, long long _LLI)
            { return fmal((long double)_F, _L, (long double)_LLI); }
            inline long double fma(float _F,
                              long double _L,
                              unsigned long long _ULLI)
            { return fmal((long double)_F, _L, (long double)_ULLI); }


         inline double fma(float _F1, int _I, float _F2)
         { return __fma((double)_F1, (double)_I, (double)_F2); }
         inline double fma(float _F, int _I, double _D)
         { return __fma((double)_F, (double)_I, _D); }
         inline long double fma(float _F, int _I, long double _L)
         { return fmal((long double)_F, (long double)_I, _L); }
         inline double fma(float _F, int _I1, int _I2)
         { return __fma((double)_F, (double)_I1, (double)_I2); }
         inline double fma(float _F, int _I, unsigned int _UI)
         { return __fma((double)_F, (double)_I, (double)_UI); }
         inline double fma(float _F, int _I, long _LI)
         { return __fma((double)_F, (double)_I, (double)_LI); }
         inline double fma(float _F, int _I, unsigned long _ULI)
         { return __fma((double)_F, (double)_I, (double)_ULI); }

            inline double fma(float _F, int _I, long long _LLI)
            { return __fma((double)_F, (double)_I, (double)_LLI); }
            inline double fma(float _F, int _I, unsigned long long _ULLI)
            { return __fma((double)_F, (double)_I, (double)_ULLI); }


         inline double fma(float _F1, unsigned int _UI, float _F2)
         { return __fma((double)_F1, (double)_UI, (double)_F2); }
         inline double fma(float _F, unsigned int _UI, double _D)
         { return __fma((double)_F, (double)_UI, _D); }
         inline long double fma(float _F, unsigned int _UI, long double _L)
         { return fmal((long double)_F, (long double)_UI, _L); }
         inline double fma(float _F, unsigned int _UI, int _I)
         { return __fma((double)_F, (double)_UI, (double)_I); }
         inline double fma(float _F, unsigned int _UI1, unsigned int _UI2)
         { return __fma((double)_F, (double)_UI1, (double)_UI2); }
         inline double fma(float _F, unsigned int _UI, long _LI)
         { return __fma((double)_F, (double)_UI, (double)_LI); }
         inline double fma(float _F, unsigned int _UI, unsigned long _ULI)
         { return __fma((double)_F, (double)_UI, (double)_ULI); }

            inline double fma(float _F, unsigned int _UI, long long _LLI)
            { return __fma((double)_F, (double)_UI, (double)_LLI); }
            inline double fma(float _F,
                              unsigned int _UI,
                              unsigned long long _ULLI)
            { return __fma((double)_F, (double)_UI, (double)_ULLI); }


         inline double fma(float _F1, long _LI, float _F2)
         { return __fma((double)_F1, (double)_LI, (double)_F2); }
         inline double fma(float _F, long _LI, double _D)
         { return __fma((double)_F, (double)_LI, _D); }
         inline long double fma(float _F, long _LI, long double _L)
         { return fmal((long double)_F, (long double)_LI, _L); }
         inline double fma(float _F, long _LI, int _I)
         { return __fma((double)_F, (double)_LI, (double)_I); }
         inline double fma(float _F, long _LI, unsigned int _UI)
         { return __fma((double)_F, (double)_LI, (double)_UI); }
         inline double fma(float _F, long _LI1, long _LI2)
         { return __fma((double)_F, (double)_LI1, (double)_LI2); }
         inline double fma(float _F, long _LI, unsigned long _ULI)
         { return __fma((double)_F, (double)_LI, (double)_ULI); }

            inline double fma(float _F, long _LI, long long _LLI)
            { return __fma((double)_F, (double)_LI, (double)_LLI); }
            inline double fma(float _F, long _LI, unsigned long long _ULLI)
            { return __fma((double)_F, (double)_LI, (double)_ULLI); }


         inline double fma(float _F1, unsigned long _ULI, float _F2)
         { return __fma((double)_F1, (double)_ULI, (double)_F2); }
         inline double fma(float _F, unsigned long _ULI, double _D)
         { return __fma((double)_F, (double)_ULI, _D); }
         inline long double fma(float _F, unsigned long _ULI, long double _L)
         { return fmal((long double)_F, (long double)_ULI, _L); }
         inline double fma(float _F, unsigned long _ULI, int _I)
         { return __fma((double)_F, (double)_ULI, (double)_I); }
         inline double fma(float _F, unsigned long _ULI, unsigned int _UI)
         { return __fma((double)_F, (double)_ULI, (double)_UI); }
         inline double fma(float _F, unsigned long _ULI, long _LI)
         { return __fma((double)_F, (double)_ULI, (double)_LI); }
         inline double fma(float _F,
                           unsigned long _ULI1,
                           unsigned long _ULI2)
         { return __fma((double)_F, (double)_ULI1, (double)_ULI2); }

            inline double fma(float _F, unsigned long _ULI, long long _LLI)
            { return __fma((double)_F, (double)_ULI, (double)_LLI); }
            inline double fma(float _F,
                              unsigned long _ULI,
                              unsigned long long _ULLI)
            { return __fma((double)_F, (double)_ULI, (double)_ULLI); }



            inline double fma(float _F1, long long _LLI, float _F2)
            { return __fma((double)_F1, (double)_LLI, (double)_F2); }
            inline double fma(float _F, long long _LLI, double _D)
            { return __fma((double)_F, (double)_LLI, _D); }
            inline long double fma(float _F, long long _LLI, long double _L)
            { return fmal((long double)_F, (long double)_LLI, _L); }
            inline double fma(float _F, long long _LLI, int _I)
            { return __fma((double)_F, (double)_LLI, (double)_I); }
            inline double fma(float _F, long long _LLI, unsigned int _UI)
            { return __fma((double)_F, (double)_LLI, (double)_UI); }
            inline double fma(float _F, long long _LLI, long _LI)
            { return __fma((double)_F, (double)_LLI, (double)_LI); }
            inline double fma(float _F, long long _LLI, unsigned long _ULI)
            { return __fma((double)_F, (double)_LLI, (double)_ULI); }
            inline double fma(float _F, long long _LLI1, long long _LLI2)
            { return __fma((double)_F, (double)_LLI1, (double)_LLI2); }
            inline double fma(float _F,
                              long long _LLI,
                              unsigned long long _ULLI)
            { return __fma((double)_F, (double)_LLI, (double)_ULLI); }

            inline double fma(float _F1,
                              unsigned long long _ULLI,
                              float _F2)
            { return __fma((double)_F1, (double)_ULLI, (double)_F2); }
            inline double fma(float _F,
                              unsigned long long _ULLI,
                              double _D)
            { return __fma((double)_F, (double)_ULLI, _D); }
            inline long double fma(float _F,
                              unsigned long long _ULLI,
                              long double _L)
            { return fmal((long double)_F, (long double)_ULLI, _L); }
            inline double fma(float _F, unsigned long long _ULLI, int _I)
            { return __fma((double)_F, (double)_ULLI, (double)_I); }
            inline double fma(float _F,
                              unsigned long long _ULLI,
                              unsigned int _UI)
            { return __fma((double)_F, (double)_ULLI, (double)_UI); }
            inline double fma(float _F, unsigned long long _ULLI, long _LI)
            { return __fma((double)_F, (double)_ULLI, (double)_LI); }
            inline double fma(float _F,
                              unsigned long long _ULLI,
                              unsigned long _ULI)
            { return __fma((double)_F, (double)_ULLI, (double)_ULI); }
            inline double fma(float _F,
                              unsigned long long _ULLI,
                              long long _LLI)
            { return __fma((double)_F, (double)_ULLI, (double)_LLI); }
            inline double fma(float _F,
                              unsigned long long _ULLI1,
                              unsigned long long _ULLI2)
            { return __fma((double)_F, (double)_ULLI1, (double)_ULLI2); }



         inline double fma(double _D, float _F1, float _F2)
         { return __fma(_D, (double)_F1, (double)_F2); }
         inline double fma(double _D1, float _F, double _D2)
         { return __fma(_D1, (double)_F, _D2); }
         inline long double fma(double _D, float _F, long double _L)
         { return fmal((long double)_D, (long double)_F, _L); }
         inline double fma(double _D, float _F, int _I)
         { return __fma(_D, (double)_F, (double)_I); }
         inline double fma(double _D, float _F, unsigned int _UI)
         { return __fma(_D, (double)_F, (double)_UI); }
         inline double fma(double _D, float _F, long _LI)
         { return __fma(_D, (double)_F, (double)_LI); }
         inline double fma(double _D, float _F, unsigned long _ULI)
         { return __fma(_D, (double)_F, (double)_ULI); }

            inline double fma(double _D, float _F, long long _LLI)
            { return __fma(_D, (double)_F, (double)_LLI); }
            inline double fma(double _D,
                              float _F,
                              unsigned long long _ULLI)
            { return __fma(_D, (double)_F, (double)_ULLI); }


         inline double fma(double _D1, double _D2, float _F)
         { return __fma(_D1, _D2, (double)_F); }
         inline long double fma(double _D1, double _D2, long double _L)
         { return fmal((long double)_D1, (long double)_D2, _L); }
         inline double fma(double _D1, double _D2, int _I)
         { return __fma(_D1, _D2, (double)_I); }
         inline double fma(double _D1, double _D2, unsigned int _UI)
         { return __fma(_D1, _D2, (double)_UI); }
         inline double fma(double _D1, double _D2, long _LI)
         { return __fma(_D1, _D2, (double)_LI); }
         inline double fma(double _D1, double _D2, unsigned long _ULI)
         { return __fma(_D1, _D2, (double)_ULI); }

            inline double fma(double _D1, double _D2, long long _LLI)
            { return __fma(_D1, _D2, (double)_LLI); }
            inline double fma(double _D1,
                              double _D2,
                              unsigned long long _ULLI)
            { return __fma(_D1, _D2, (double)_ULLI); }


         inline long double fma(double _D, long double _L, float _F)
         { return fmal((long double)_D, _L, (long double)_F); }
         inline long double fma(double _D1, long double _L, double _D2)
         { return fmal((long double)_D1, _L, (long double)_D2); }
         inline long double fma(double _D, long double _L1, long double _L2)
         { return fmal((long double)_D, _L1, _L2); }
         inline long double fma(double _D, long double _L, int _I)
         { return fmal((long double)_D, _L, (long double)_I); }
         inline long double fma(double _D, long double _L, unsigned int _UI)
         { return fmal((long double)_D, _L, (long double)_UI); }
         inline long double fma(double _D, long double _L, long _LI)
         { return fmal((long double)_D, _L, (long double)_LI); }
         inline long double fma(double _D, long double _L, unsigned long _ULI)
         { return fmal((long double)_D, _L, (long double)_ULI); }

            inline long double fma(double _D, long double _L, long long _LLI)
            { return fmal((long double)_D, _L, (long double)_LLI); }
            inline long double fma(double _D,
                              long double _L,
                              unsigned long long _ULLI)
            { return fmal((long double)_D, _L, (long double)_ULLI); }


         inline double fma(double _D, int _I, float _F)
         { return __fma(_D, (double)_I, (double)_F); }
         inline double fma(double _D1, int _I, double _D2)
         { return __fma(_D1, (double)_I, _D2); }
         inline long double fma(double _D, int _I, long double _L)
         { return fmal((long double)_D, (long double)_I, _L); }
         inline double fma(double _D, int _I1, int _I2)
         { return __fma(_D, (double)_I1, (double)_I2); }
         inline double fma(double _D, int _I, unsigned int _UI)
         { return __fma(_D, (double)_I, (double)_UI); }
         inline double fma(double _D, int _I, long _LI)
         { return __fma(_D, (double)_I, (double)_LI); }
         inline double fma(double _D, int _I, unsigned long _ULI)
         { return __fma(_D, (double)_I, (double)_ULI); }

            inline double fma(double _D, int _I, long long _LLI)
            { return __fma(_D, (double)_I, (double)_LLI); }
            inline double fma(double _D, int _I, unsigned long long _ULLI)
            { return __fma(_D, (double)_I, (double)_ULLI); }


         inline double fma(double _D, unsigned int _UI, float _F)
         { return __fma(_D, (double)_UI, (double)_F); }
         inline double fma(double _D1, unsigned int _UI, double _D2)
         { return __fma(_D1, (double)_UI, _D2); }
         inline long double fma(double _D, unsigned int _UI, long double _L)
         { return fmal((long double)_D, (long double)_UI, _L); }
         inline double fma(double _D, unsigned int _UI, int _I)
         { return __fma(_D, (double)_UI, (double)_I); }
         inline double fma(double _D, unsigned int _UI1, unsigned int _UI2)
         { return __fma(_D, (double)_UI1, (double)_UI2); }
         inline double fma(double _D, unsigned int _UI, long _LI)
         { return __fma(_D, (double)_UI, (double)_LI); }
         inline double fma(double _D, unsigned int _UI, unsigned long _ULI)
         { return __fma(_D, (double)_UI, (double)_ULI); }

            inline double fma(double _D, unsigned int _UI, long long _LLI)
            { return __fma(_D, (double)_UI, (double)_LLI); }
            inline double fma(double _D,
                              unsigned int _UI,
                              unsigned long long _ULLI)
            { return __fma(_D, (double)_UI, (double)_ULLI); }


         inline double fma(double _D, long _LI, float _F)
         { return __fma(_D, (double)_LI, (double)_F); }
         inline double fma(double _D1, long _LI, double _D2)
         { return __fma(_D1, (double)_LI, _D2); }
         inline long double fma(double _D, long _LI, long double _L)
         { return fmal((long double)_D, (long double)_LI, _L); }
         inline double fma(double _D, long _LI, int _I)
         { return __fma(_D, (double)_LI, (double)_I); }
         inline double fma(double _D, long _LI, unsigned int _UI)
         { return __fma(_D, (double)_LI, (double)_UI); }
         inline double fma(double _D, long _LI1, long _LI2)
         { return __fma(_D, (double)_LI1, (double)_LI2); }
         inline double fma(double _D, long _LI, unsigned long _ULI)
         { return __fma(_D, (double)_LI, (double)_ULI); }

            inline double fma(double _D, long _LI, long long _LLI)
            { return __fma(_D, (double)_LI, (double)_LLI); }
            inline double fma(double _D,
                              long _LI,
                              unsigned long long _ULLI)
            { return __fma(_D, (double)_LI, (double)_ULLI); }


         inline double fma(double _D, unsigned long _ULI, float _F)
         { return __fma(_D, (double)_ULI, (double)_F); }
         inline double fma(double _D1, unsigned long _ULI, double _D2)
         { return __fma(_D1, (double)_ULI, _D2); }
         inline long double fma(double _D, unsigned long _ULI, long double _L)
         { return fmal((long double)_D, (long double)_ULI, _L); }
         inline double fma(double _D, unsigned long _ULI, int _I)
         { return __fma(_D, (double)_ULI, (double)_I); }
         inline double fma(double _D, unsigned long _ULI, unsigned int _UI)
         { return __fma(_D, (double)_ULI, (double)_UI); }
         inline double fma(double _D, unsigned long _ULI, long _LI)
         { return __fma(_D, (double)_ULI, (double)_LI); }
         inline double fma(double _D,
                           unsigned long _ULI1,
                           unsigned long _ULI2)
         { return __fma(_D, (double)_ULI1, (double)_ULI2); }

            inline double fma(double _D,
                              unsigned long _ULI,
                              long long _LLI)
            { return __fma(_D, (double)_ULI, (double)_LLI); }
            inline double fma(double _D,
                              unsigned long _ULI,
                              unsigned long long _ULLI)
            { return __fma(_D, (double)_ULI, (double)_ULLI); }



            inline double fma(double _D, long long _LLI, float _F)
            { return __fma(_D, (double)_LLI, (double)_F); }
            inline double fma(double _D1, long long _LLI, double _D2)
            { return __fma(_D1, (double)_LLI, _D2); }
            inline long double fma(double _D, long long _LLI, long double _L)
            { return fmal((long double)_D, (long double)_LLI, _L); }
            inline double fma(double _D, long long _LLI, int _I)
            { return __fma(_D, (double)_LLI, (double)_I); }
            inline double fma(double _D, long long _LLI, unsigned int _UI)
            { return __fma(_D, (double)_LLI, (double)_UI); }
            inline double fma(double _D, long long _LLI, long _LI)
            { return __fma(_D, (double)_LLI, (double)_LI); }
            inline double fma(double _D,
                              long long _LLI,
                              unsigned long _ULI)
            { return __fma(_D, (double)_LLI, (double)_ULI); }
            inline double fma(double _D, long long _LLI1, long long _LLI2)
            { return __fma(_D, (double)_LLI1, (double)_LLI2); }
            inline double fma(double _D,
                              long long _LLI,
                              unsigned long long _ULLI)
            { return __fma(_D, (double)_LLI, (double)_ULLI); }

            inline double fma(double _D, unsigned long long _ULLI, float _F)
            { return __fma(_D, (double)_ULLI, (double)_F); }
            inline double fma(double _D1,
                              unsigned long long _ULLI,
                              double _D2)
            { return __fma(_D1, (double)_ULLI, _D2); }
            inline long double fma(double _D,
                              unsigned long long _ULLI,
                              long double _L)
            { return fmal((long double)_D, (long double)_ULLI, _L); }
            inline double fma(double _D, unsigned long long _ULLI, int _I)
            { return __fma(_D, (double)_ULLI, (double)_I); }
            inline double fma(double _D,
                              unsigned long long _ULLI,
                              unsigned int _UI)
            { return __fma(_D, (double)_ULLI, (double)_UI); }
            inline double fma(double _D,
                              unsigned long long _ULLI,
                              long _LI)
            { return __fma(_D, (double)_ULLI, (double)_LI); }
            inline double fma(double _D,
                              unsigned long long _ULLI,
                              unsigned long _ULI)
            { return __fma(_D, (double)_ULLI, (double)_ULI); }
            inline double fma(double _D,
                              unsigned long long _ULLI,
                              long long _LLI)
            { return __fma(_D, (double)_ULLI, (double)_LLI); }
            inline double fma(double _D,
                              unsigned long long _ULLI1,
                              unsigned long long _ULLI2)
            { return __fma(_D, (double)_ULLI1, (double)_ULLI2); }



         inline long double fma(long double _L, float _F1, float _F2)
         { return fmal(_L, (long double)_F1, (long double)_F2); }
         inline long double fma(long double _L, float _F, double _D)
         { return fmal(_L, (long double)_F, (long double)_D); }
         inline long double fma(long double _L1, float _F, long double _L2)
         { return fmal(_L1, (long double)_F, _L2); }
         inline long double fma(long double _L, float _F, int _I)
         { return fmal(_L, (long double)_F, (long double)_I); }
         inline long double fma(long double _L, float _F, unsigned int _UI)
         { return fmal(_L, (long double)_F, (long double)_UI); }
         inline long double fma(long double _L, float _F, long _LI)
         { return fmal(_L, (long double)_F, (long double)_LI); }
         inline long double fma(long double _L, float _F, unsigned long _ULI)
         { return fmal(_L, (long double)_F, (long double)_ULI); }

            inline long double fma(long double _L, float _F, long long _LLI)
            { return fmal(_L, (long double)_F, (long double)_LLI); }
            inline long double fma(long double _L,
                              float _F,
                              unsigned long long _ULLI)
            { return fmal(_L, (long double)_F, (long double)_ULLI); }


         inline long double fma(long double _L, double _D, float _F)
         { return fmal(_L, (long double)_D, (long double)_F); }
         inline long double fma(long double _L, double _D1, double _D2)
         { return fmal(_L, (long double)_D1, (long double)_D2); }
         inline long double fma(long double _L1, double _D, long double _L2)
         { return fmal(_L1, (long double)_D, _L2); }
         inline long double fma(long double _L, double _D, int _I)
         { return fmal(_L, (long double)_D, (long double)_I); }
         inline long double fma(long double _L, double _D, unsigned int _UI)
         { return fmal(_L, (long double)_D, (long double)_UI); }
          inline long double fma(long double _L, double _D, long _LI)
         { return fmal(_L, (long double)_D, (long double)_LI); }
         inline long double fma(long double _L, double _D, unsigned long _ULI)
         { return fmal(_L, (long double)_D, (long double)_ULI); }

            inline long double fma(long double _L, double _D, long long _LLI)
            { return fmal(_L, (long double)_D, (long double)_LLI); }
            inline long double fma(long double _L,
                              double _D,
                              unsigned long long _ULLI)
            { return fmal(_L, (long double)_D, (long double)_ULLI); }


         inline long double fma(long double _L1, long double _L2, float _F)
         { return fmal(_L1, _L2, (long double)_F); }
         inline long double fma(long double _L1, long double _L2, double _D)
         { return fmal(_L1, _L2, (long double)_D); }
         inline long double fma(long double _L1, long double _L2, int _I)
         { return fmal(_L1, _L2, (long double)_I); }
         inline long double fma(long double _L1,
                           long double _L2,
                           unsigned int _UI)
         { return fmal(_L1, _L2, (long double)_UI); }
         inline long double fma(long double _L1, long double _L2, long _LI)
         { return fmal(_L1, _L2, (long double)_LI); }
         inline long double fma(long double _L1,
                           long double _L2,
                           unsigned long _ULI)
         { return fmal(_L1, _L2, (long double)_ULI); }

            inline long double fma(long double _L1,
                              long double _L2,
                              long long _LLI)
            { return fmal(_L1, _L2, (long double)_LLI); }
            inline long double fma(long double _L1,
                              long double _L2,
                              unsigned long long _ULLI)
            { return fmal(_L1, _L2, (long double)_ULLI); }


         inline long double fma(long double _L, int _I, float _F)
         { return fmal(_L, (long double)_I, (long double)_F); }
         inline long double fma(long double _L, int _I, double _D)
         { return fmal(_L, (long double)_I, (long double)_D); }
         inline long double fma(long double _L1, int _I, long double _L2)
         { return fmal(_L1, (long double)_I, _L2); }
         inline long double fma(long double _L, int _I1, int _I2)
         { return fmal(_L, (long double)_I1, (long double)_I2); }
         inline long double fma(long double _L, int _I, unsigned int _UI)
         { return fmal(_L, (long double)_I, (long double)_UI); }
         inline long double fma(long double _L, int _I, long _LI)
         { return fmal(_L, (long double)_I, (long double)_LI); }
         inline long double fma(long double _L, int _I, unsigned long _ULI)
         { return fmal(_L, (long double)_I, (long double)_ULI); }

            inline long double fma(long double _L, int _I, long long _LLI)
            { return fmal(_L, (long double)_I, (long double)_LLI); }
            inline long double fma(long double _L,
                              int _I,
                              unsigned long long _ULLI)
            { return fmal(_L, (long double)_I, (long double)_ULLI); }


         inline long double fma(long double _L, unsigned int _UI, float _F)
         { return fmal(_L, (long double)_UI, (long double)_F); }
         inline long double fma(long double _L, unsigned int _UI, double _D)
         { return fmal(_L, (long double)_UI, (long double)_D); }
         inline long double fma(long double _L1,
                           unsigned int _UI,
                           long double _L2)
         { return fmal(_L1, (long double)_UI, _L2); }
         inline long double fma(long double _L, unsigned int _UI1, int _I)
         { return fmal(_L, (long double)_UI1, (long double)_I); }
         inline long double fma(long double _L,
                           unsigned int _UI1,
                           unsigned int _UI2)
         { return fmal(_L, (long double)_UI1, (long double)_UI2); }
         inline long double fma(long double _L, unsigned int _UI, long _LI)
         { return fmal(_L, (long double)_UI, (long double)_LI); }
         inline long double fma(long double _L,
                           unsigned int _UI,
                           unsigned long _ULI)
         { return fmal(_L, (long double)_UI, (long double)_ULI); }

            inline long double fma(long double _L,
                              unsigned int _UI,
                              long long _LLI)
            { return fmal(_L, (long double)_UI, (long double)_LLI); }
            inline long double fma(long double _L,
                              unsigned int _UI,
                              unsigned long long _ULLI)
            { return fmal(_L, (long double)_UI, (long double)_ULLI); }


         inline long double fma(long double _L, long _LI, float _F)
         { return fmal(_L, (long double)_LI, (long double)_F); }
         inline long double fma(long double _L, long _LI, double _D)
         { return fmal(_L, (long double)_LI, (long double)_D); }
         inline long double fma(long double _L1, long _LI, long double _L2)
         { return fmal(_L1, (long double)_LI, _L2); }
         inline long double fma(long double _L, long _LI, int _I)
         { return fmal(_L, (long double)_LI, (long double)_I); }
         inline long double fma(long double _L, long _LI, unsigned int _UI)
         { return fmal(_L, (long double)_LI, (long double)_UI); }
         inline long double fma(long double _L, long _LI1, long _LI2)
         { return fmal(_L, (long double)_LI1, (long double)_LI2); }
         inline long double fma(long double _L, long _LI, unsigned long _ULI)
         { return fmal(_L, (long double)_LI, (long double)_ULI); }

            inline long double fma(long double _L, long _LI, long long _LLI)
            { return fmal(_L, (long double)_LI, (long double)_LLI); }
            inline long double fma(long double _L,
                              long _LI,
                              unsigned long long _ULLI)
            { return fmal(_L, (long double)_LI, (long double)_ULLI); }


         inline long double fma(long double _L, unsigned long _ULI, float _F)
         { return fmal(_L, (long double)_ULI, (long double)_F); }
         inline long double fma(long double _L, unsigned long _ULI, double _D)
         { return fmal(_L, (long double)_ULI, (long double)_D); }
         inline long double fma(long double _L1,
                           unsigned long _ULI,
                           long double _L2)
         { return fmal(_L1, (long double)_ULI, _L2); }
         inline long double fma(long double _L, unsigned long _ULI, int _I)
         { return fmal(_L, (long double)_ULI, (long double)_I); }
         inline long double fma(long double _L,
                           unsigned long _ULI,
                           unsigned int _UI)
         { return fmal(_L, (long double)_ULI, (long double)_UI); }
         inline long double fma(long double _L, unsigned long _ULI, long _LI)
         { return fmal(_L, (long double)_ULI, (long double)_LI); }
         inline long double fma(long double _L,
                           unsigned long _ULI1,
                           unsigned long _ULI2)
         { return fmal(_L, (long double)_ULI1, (long double)_ULI2); }

            inline long double fma(long double _L,
                              unsigned long _ULI,
                              long long _LLI)
            { return fmal(_L, (long double)_ULI, (long double)_LLI); }
            inline long double fma(long double _L,
                              unsigned long _ULI,
                              unsigned long long _ULLI)
            { return fmal(_L, (long double)_ULI, (long double)_ULLI); }



            inline long double fma(long double _L, long long _LLI, float _F)
            { return fmal(_L, (long double)_LLI, (long double)_F); }
            inline long double fma(long double _L, long long _LLI, double _D)
            { return fmal(_L, (long double)_LLI, (long double)_D); }
            inline long double fma(long double _L1,
                              long long _LLI,
                              long double _L2)
            { return fmal(_L1, (long double)_LLI, _L2); }
            inline long double fma(long double _L, long long _LLI, int _I)
            { return fmal(_L, (long double)_LLI, (long double)_I); }
            inline long double fma(long double _L,
                              long long _LLI,
                              unsigned int _UI)
            { return fmal(_L, (long double)_LLI, (long double)_UI); }
            inline long double fma(long double _L, long long _LLI, long _LI)
            { return fmal(_L, (long double)_LLI, (long double)_LI); }
            inline long double fma(long double _L,
                              long long _LLI,
                              unsigned long _ULI)
            { return fmal(_L, (long double)_LLI, (long double)_ULI); }
            inline long double fma(long double _L,
                              long long _LLI1,
                              long long _LLI2)
            { return fmal(_L, (long double)_LLI1, (long double)_LLI2); }
            inline long double fma(long double _L,
                              long long _LLI,
                              unsigned long long _ULLI)
            { return fmal(_L, (long double)_LLI, (long double)_ULLI); }

            inline long double fma(long double _L,
                              unsigned long long _ULLI,
                              float _F)
            { return fmal(_L, (long double)_ULLI, (long double)_F); }
            inline long double fma(long double _L,
                              unsigned long long _ULLI,
                              double _D)
            { return fmal(_L, (long double)_ULLI, (long double)_D); }
            inline long double fma(long double _L1,
                              unsigned long long _ULLI,
                              long double _L2)
            { return fmal(_L1, (long double)_ULLI, _L2); }
            inline long double fma(long double _L,
                              unsigned long long _ULLI,
                              int _I)
            { return fmal(_L, (long double)_ULLI, (long double)_I); }
            inline long double fma(long double _L,
                              unsigned long long _ULLI,
                              unsigned int _UI)
            { return fmal(_L, (long double)_ULLI, (long double)_UI); }
            inline long double fma(long double _L,
                              unsigned long long _ULLI,
                              long _LI)
            { return fmal(_L, (long double)_ULLI, (long double)_LI); }
            inline long double fma(long double _L,
                              unsigned long long _ULLI,
                              unsigned long _ULI)
            { return fmal(_L, (long double)_ULLI, (long double)_ULI); }
            inline long double fma(long double _L,
                              unsigned long long _ULLI,
                              long long _LLI)
            { return fmal(_L, (long double)_ULLI, (long double)_LLI); }
            inline long double fma(long double _L,
                              unsigned long long _ULLI1,
                              unsigned long long _ULLI2)
            { return fmal(_L, (long double)_ULLI1, (long double)_ULLI2); }



         inline double fma(int _I, float _F1, float _F2)
         { return __fma((double)_I, (double)_F1, (double)_F2); }
         inline double fma(int _I, float _F, double _D)
         { return __fma((double)_I, (double)_F, _D); }
         inline long double fma(int _I, float _F, long double _L)
         { return fmal((long double)_I, (long double)_F, _L); }
         inline double fma(int _I1, float _F, int _I2)
         { return __fma((double)_I1, (double)_F, (double)_I2); }
         inline double fma(int _I, float _F, unsigned int _UI)
         { return __fma((double)_I, (double)_F, (double)_UI); }
         inline double fma(int _I, float _F, long _LI)
         { return __fma((double)_I, (double)_F, (double)_LI); }
         inline double fma(int _I, float _F, unsigned long _ULI)
         { return __fma((double)_I, (double)_F, (double)_ULI); }

            inline double fma(int _I, float _F, long long _LLI)
            { return __fma((double)_I, (double)_F, (double)_LLI); }
            inline double fma(int _I, float _F, unsigned long long _ULLI)
            { return __fma((double)_I, (double)_F, (double)_ULLI); }


         inline double fma(int _I, double _D, float _F)
         { return __fma((double)_I, _D, (double)_F); }
         inline double fma(int _I, double _D1, double _D2)
         { return __fma((double)_I, _D1, _D2); }
         inline long double fma(int _I, double _D, long double _L)
         { return fmal((long double)_I, (long double)_D, _L); }
         inline double fma(int _I1, double _D, int _I2)
         { return __fma((double)_I1, _D, (double)_I2); }
         inline double fma(int _I, double _D, unsigned int _UI)
         { return __fma((double)_I, _D, (double)_UI); }
         inline double fma(int _I, double _D, long _LI)
         { return __fma((double)_I, _D, (double)_LI); }
         inline double fma(int _I, double _D, unsigned long _ULI)
         { return __fma((double)_I, _D, (double)_ULI); }

            inline double fma(int _I, double _D, long long _LLI)
            { return __fma((double)_I, _D, (double)_LLI); }
            inline double fma(int _I, double _D, unsigned long long _ULLI)
            { return __fma((double)_I, _D, (double)_ULLI); }


         inline long double fma(int _I, long double _L, float _F)
         { return fmal((long double)_I, _L, (long double)_F); }
         inline long double fma(int _I, long double _L, double _D)
         { return fmal((long double)_I, _L, (long double)_D); }
         inline long double fma(int _I, long double _L1, long double _L2)
         { return fmal((long double)_I, _L1, _L2); }
         inline long double fma(int _I1, long double _L, int _I2)
         { return fmal((long double)_I1, _L, (long double)_I2); }
         inline long double fma(int _I, long double _L, unsigned int _UI)
         { return fmal((long double)_I, _L, (long double)_UI); }
         inline long double fma(int _I, long double _L, long _LI)
         { return fmal((long double)_I, _L, (long double)_LI); }
         inline long double fma(int _I, long double _L, unsigned long _ULI)
         { return fmal((long double)_I, _L, (long double)_ULI); }

            inline long double fma(int _I, long double _L, long long _LLI)
            { return fmal((long double)_I, _L, (long double)_LLI); }
            inline long double fma(int _I,
                              long double _L,
                              unsigned long long _ULLI)
            { return fmal((long double)_I, _L, (long double)_ULLI); }


         inline double fma(int _I1, int _I2, float _F)
         { return __fma((double)_I1, (double)_I2, (double)_F); }
         inline double fma(int _I1, int _I2, double _D)
         { return __fma((double)_I1, (double)_I2, _D); }
         inline long double fma(int _I1, int _I2, long double _L)
         { return fmal((long double)_I1, (long double)_I2, _L); }
         inline double fma(int _I1, int _I2, int _I3)
         { return __fma((double)_I1, (double)_I2, (double)_I3); }
         inline double fma(int _I1, int _I2, unsigned int _UI)
         { return __fma((double)_I1, (double)_I2, (double)_UI); }
         inline double fma(int _I1, int _I2, long _LI)
         { return __fma((double)_I1, (double)_I2, (double)_LI); }
         inline double fma(int _I1, int _I2, unsigned long _ULI)
         { return __fma((double)_I1, (double)_I2, (double)_ULI); }

            inline double fma(int _I1, int _I2, long long _LLI)
            { return __fma((double)_I1, (double)_I2, (double)_LLI); }
            inline double fma(int _I1, int _I2, unsigned long long _ULLI)
            { return __fma((double)_I1, (double)_I2, (double)_ULLI); }


         inline double fma(int _I, unsigned int _UI, float _F)
         { return __fma((double)_I, (double)_UI, (double)_F); }
         inline double fma(int _I, unsigned int _UI, double _D)
         { return __fma((double)_I, (double)_UI, _D); }
         inline long double fma(int _I, unsigned int _UI, long double _L)
         { return fmal((long double)_I, (long double)_UI, _L); }
         inline double fma(int _I1, unsigned int _UI, int _I2)
         { return __fma((double)_I1, (double)_UI, (double)_I2); }
         inline double fma(int _I, unsigned int _UI1, unsigned int _UI2)
         { return __fma((double)_I, (double)_UI1, (double)_UI2); }
         inline double fma(int _I, unsigned int _UI, long _LI)
         { return __fma((double)_I, (double)_UI, (double)_LI); }
         inline double fma(int _I, unsigned int _UI, unsigned long _ULI)
         { return __fma((double)_I, (double)_UI, (double)_ULI); }

            inline double fma(int _I, unsigned int _UI, long long _LLI)
            { return __fma((double)_I, (double)_UI, (double)_LLI); }
            inline double fma(int _I,
                              unsigned int _UI,
                              unsigned long long _ULLI)
            { return __fma((double)_I, (double)_UI, (double)_ULLI); }


         inline double fma(int _I, long _LI, float _F)
         { return __fma((double)_I, (double)_LI, (double)_F); }
         inline double fma(int _I, long _LI, double _D)
         { return __fma((double)_I, (double)_LI, _D); }
         inline long double fma(int _I, long _LI, long double _L)
         { return fmal((long double)_I, (long double)_LI, _L); }
         inline double fma(int _I1, long _LI, int _I2)
         { return __fma((double)_I1, (double)_LI, (double)_I2); }
         inline double fma(int _I, long _LI, unsigned int _UI)
         { return __fma((double)_I, (double)_LI, (double)_UI); }
         inline double fma(int _I, long _LI1, long _LI2)
         { return __fma((double)_I, (double)_LI1, (double)_LI2); }
         inline double fma(int _I, long _LI, unsigned long _ULI)
         { return __fma((double)_I, (double)_LI, (double)_ULI); }

            inline double fma(int _I, long _LI, long long _LLI)
            { return __fma((double)_I, (double)_LI, (double)_LLI); }
            inline double fma(int _I, long _LI, unsigned long long _ULLI)
            { return __fma((double)_I, (double)_LI, (double)_ULLI); }


         inline double fma(int _I, unsigned long _ULI, float _F)
         { return __fma((double)_I, (double)_ULI, (double)_F); }
         inline double fma(int _I, unsigned long _ULI, double _D)
         { return __fma((double)_I, (double)_ULI, _D); }
         inline long double fma(int _I, unsigned long _ULI, long double _L)
         { return fmal((long double)_I, (long double)_ULI, _L); }
         inline double fma(int _I1, unsigned long _ULI, int _I2)
         { return __fma((double)_I1, (double)_ULI, (double)_I2); }
         inline double fma(int _I, unsigned long _ULI, unsigned int _UI)
         { return __fma((double)_I, (double)_ULI, (double)_UI); }
         inline double fma(int _I, unsigned long _ULI, long _LI)
         { return __fma((double)_I, (double)_ULI, (double)_LI); }
         inline double fma(int _I, unsigned long _ULI1, unsigned long _ULI2)
         { return __fma((double)_I, (double)_ULI1, (double)_ULI2); }

            inline double fma(int _I, unsigned long _ULI, long long _LLI)
            { return __fma((double)_I, (double)_ULI, (double)_LLI); }
            inline double fma(int _I,
                              unsigned long _ULI,
                              unsigned long long _ULLI)
            { return __fma((double)_I, (double)_ULI, (double)_ULLI); }



            inline double fma(int _I, long long _LLI, float _F)
            { return __fma((double)_I, (double)_LLI, (double)_F); }
            inline double fma(int _I, long long _LLI, double _D)
            { return __fma((double)_I, (double)_LLI, _D); }
            inline long double fma(int _I, long long _LLI, long double _L)
            { return fmal((long double)_I, (long double)_LLI, _L); }
            inline double fma(int _I1, long long _LLI, int _I2)
            { return __fma((double)_I1, (double)_LLI, (double)_I2); }
            inline double fma(int _I, long long _LLI, unsigned int _UI)
            { return __fma((double)_I, (double)_LLI, (double)_UI); }
            inline double fma(int _I, long long _LLI, long _LI)
            { return __fma((double)_I, (double)_LLI, (double)_LI); }
            inline double fma(int _I, long long _LLI, unsigned long _ULI)
            { return __fma((double)_I, (double)_LLI, (double)_ULI); }
            inline double fma(int _I, long long _LLI1, long long _LLI2)
            { return __fma((double)_I, (double)_LLI1, (double)_LLI2); }
            inline double fma(int _I,
                              long long _LLI,
                              unsigned long long _ULLI)
            { return __fma((double)_I, (double)_LLI, (double)_ULLI); }

            inline double fma(int _I, unsigned long long _ULLI, float _F)
            { return __fma((double)_I, (double)_ULLI, (double)_F); }
            inline double fma(int _I, unsigned long long _ULLI, double _D)
            { return __fma((double)_I, (double)_ULLI, _D); }
            inline long double fma(int _I,
                              unsigned long long _ULLI,
                              long double _L)
            { return fmal((long double)_I, (long double)_ULLI, _L); }
            inline double fma(int _I1, unsigned long long _ULLI, int _I2)
            { return __fma((double)_I1, (double)_ULLI, (double)_I2); }
            inline double fma(int _I,
                              unsigned long long _ULLI,
                              unsigned int _UI)
            { return __fma((double)_I, (double)_ULLI, (double)_UI); }
            inline double fma(int _I, unsigned long long _ULLI, long _LI)
            { return __fma((double)_I, (double)_ULLI, (double)_LI); }
            inline double fma(int _I,
                              unsigned long long _ULLI,
                              unsigned long _ULI)
            { return __fma((double)_I, (double)_ULLI, (double)_ULI); }
            inline double fma(int _I,
                              unsigned long long _ULLI,
                              long long _LLI)
            { return __fma((double)_I, (double)_ULLI, (double)_LLI); }
            inline double fma(int _I,
                              unsigned long long _ULLI1,
                              unsigned long long _ULLI2)
            { return __fma((double)_I, (double)_ULLI1, (double)_ULLI2); }



         inline double fma(unsigned int _UI, float _F1, float _F2)
         { return __fma((double)_UI, (double)_F1, (double)_F2); }
         inline double fma(unsigned int _UI, float _F, double _D)
         { return __fma((double)_UI, (double)_F, _D); }
         inline long double fma(unsigned int _UI, float _F, long double _L)
         { return fmal((long double)_UI, (long double)_F, _L); }
         inline double fma(unsigned int _UI, float _F, int _I)
         { return __fma((double)_UI, (double)_F, (double)_I); }
         inline double fma(unsigned int _UI1, float _F, unsigned int _UI2)
         { return __fma((double)_UI1, (double)_F, (double)_UI2); }
         inline double fma(unsigned int _UI, float _F, long _LI)
         { return __fma((double)_UI, (double)_F, (double)_LI); }
         inline double fma(unsigned int _UI, float _F, unsigned long _ULI)
         { return __fma((double)_UI, (double)_F, (double)_ULI); }

            inline double fma(unsigned int _UI, float _F, long long _LLI)
            { return __fma((double)_UI, (double)_F, (double)_LLI); }
            inline double fma(unsigned int _UI,
                              float _F,
                              unsigned long long _ULLI)
            { return __fma((double)_UI, (double)_F, (double)_ULLI); }


         inline double fma(unsigned int _UI, double _D, float _F)
         { return __fma((double)_UI, _D, (double)_F); }
         inline double fma(unsigned int _UI, double _D1, double _D2)
         { return __fma((double)_UI, _D1, _D2); }
         inline long double fma(unsigned int _UI, double _D, long double _L)
         { return fmal((long double)_UI, (long double)_D, _L); }
         inline double fma(unsigned int _UI, double _D, int _I)
         { return __fma((double)_UI, _D, (double)_I); }
         inline double fma(unsigned int _UI1, double _D, unsigned int _UI2)
         { return __fma((double)_UI1, _D, (double)_UI2); }
         inline double fma(unsigned int _UI, double _D, long _LI)
         { return __fma((double)_UI, _D, (double)_LI); }
         inline double fma(unsigned int _UI, double _D, unsigned long _ULI)
         { return __fma((double)_UI, _D, (double)_ULI); }

            inline double fma(unsigned int _UI, double _D, long long _LLI)
            { return __fma((double)_UI, _D, (double)_LLI); }
            inline double fma(unsigned int _UI,
                              double _D,
                              unsigned long long _ULLI)
            { return __fma((double)_UI, _D, (double)_ULLI); }


         inline long double fma(unsigned int _UI, long double _L, float _F)
         { return fmal((long double)_UI, _L, (long double)_F); }
         inline long double fma(unsigned int _UI, long double _L, double _D)
         { return fmal((long double)_UI, _L, (long double)_D); }
         inline long double fma(unsigned int _UI,
                           long double _L1,
                           long double _L2)
         { return fmal((long double)_UI, _L1, _L2); }
         inline long double fma(unsigned int _UI, long double _L, int _I)
         { return fmal((long double)_UI, _L, (long double)_I); }
         inline long double fma(unsigned int _UI1,
                           long double _L,
                           unsigned int _UI2)
         { return fmal((long double)_UI1, _L, (long double)_UI2); }
         inline long double fma(unsigned int _UI, long double _L, long _LI)
         { return fmal((long double)_UI, _L, (long double)_LI); }
         inline long double fma(unsigned int _UI,
                           long double _L,
                           unsigned long _ULI)
         { return fmal((long double)_UI, _L, (long double)_ULI); }

            inline long double fma(unsigned int _UI,
                              long double _L,
                              long long _LLI)
            { return fmal((long double)_UI, _L, (long double)_LLI); }
            inline long double fma(unsigned int _UI,
                              long double _L,
                              unsigned long long _ULLI)
            { return fmal((long double)_UI, _L, (long double)_ULLI); }


         inline double fma(unsigned int _UI, int _I, float _F)
         { return __fma((double)_UI, (double)_I, (double)_F); }
         inline double fma(unsigned int _UI, int _I, double _D)
         { return __fma((double)_UI, (double)_I, _D); }
         inline long double fma(unsigned int _UI, int _I, long double _L)
         { return fmal((long double)_UI, (long double)_I, _L); }
         inline double fma(unsigned int _UI, int _I1, int _I2)
         { return __fma((double)_UI, (double)_I1, (double)_I2); }
         inline double fma(unsigned int _UI1, int _I, unsigned int _UI2)
         { return __fma((double)_UI1, (double)_I, (double)_UI2); }
         inline double fma(unsigned int _UI, int _I, long _LI)
         { return __fma((double)_UI, (double)_I, (double)_LI); }
         inline double fma(unsigned int _UI, int _I, unsigned long _ULI)
         { return __fma((double)_UI, (double)_I, (double)_ULI); }

            inline double fma(unsigned int _UI, int _I, long long _LLI)
            { return __fma((double)_UI, (double)_I, (double)_LLI); }
            inline double fma(unsigned int _UI,
                              int _I,
                              unsigned long long _ULLI)
            { return __fma((double)_UI, (double)_I, (double)_ULLI); }


         inline double fma(unsigned int _UI1, unsigned int _UI2, float _F)
         { return __fma((double)_UI1, (double)_UI2, (double)_F); }
         inline double fma(unsigned int _UI1, unsigned int _UI2, double _D)
         { return __fma((double)_UI1, (double)_UI2, _D); }
         inline long double fma(unsigned int _UI1,
                           unsigned int _UI2,
                           long double _L)
         { return fmal((long double)_UI1, (long double)_UI2, _L); }
         inline double fma(unsigned int _UI1, unsigned int _UI2, int _I)
         { return __fma((double)_UI1, (double)_UI2, (double)_I); }
         inline double fma(unsigned int _UI1,
                           unsigned int _UI2,
                           unsigned int _UI3)
         { return __fma((double)_UI1, (double)_UI2, (double)_UI3); }
         inline double fma(unsigned int _UI1, unsigned int _UI2, long _LI)
         { return __fma((double)_UI1, (double)_UI2, (double)_LI); }
         inline double fma(unsigned int _UI1,
                           unsigned int _UI2,
                           unsigned long _ULI)
         { return __fma((double)_UI1, (double)_UI2, (double)_ULI); }

            inline double fma(unsigned int _UI1,
                              unsigned int _UI2,
                              long long _LLI)
            { return __fma((double)_UI1, (double)_UI2, (double)_LLI); }
            inline double fma(unsigned int _UI1,
                              unsigned int _UI2,
                              unsigned long long _ULLI)
            { return __fma((double)_UI1, (double)_UI2, (double)_ULLI); }


         inline double fma(unsigned int _UI, long _LI, float _F)
         { return __fma((double)_UI, (double)_LI, (double)_F); }
         inline double fma(unsigned int _UI, long _LI, double _D)
         { return __fma((double)_UI, (double)_LI, _D); }
         inline long double fma(unsigned int _UI, long _LI, long double _L)
         { return fmal((long double)_UI, (long double)_LI, _L); }
         inline double fma(unsigned int _UI, long _LI, int _I)
         { return __fma((double)_UI, (double)_LI, (double)_I); }
         inline double fma(unsigned int _UI1, long _LI, unsigned int _UI2)
         { return __fma((double)_UI1, (double)_LI, (double)_UI2); }
         inline double fma(unsigned int _UI, long _LI1, long _LI2)
         { return __fma((double)_UI, (double)_LI1, (double)_LI2); }
         inline double fma(unsigned int _UI, long _LI, unsigned long _ULI)
         { return __fma((double)_UI, (double)_LI, (double)_ULI); }

            inline double fma(unsigned int _UI, long _LI, long long _LLI)
            { return __fma((double)_UI, (double)_LI, (double)_LLI); }
            inline double fma(unsigned int _UI,
                              long _LI,
                              unsigned long long _ULLI)
            { return __fma((double)_UI, (double)_LI, (double)_ULLI); }


         inline double fma(unsigned int _UI, unsigned long _ULI, float _F)
         { return __fma((double)_UI, (double)_ULI, (double)_F); }
         inline double fma(unsigned int _UI, unsigned long _ULI, double _D)
         { return __fma((double)_UI, (double)_ULI, _D); }
         inline long double fma(unsigned int _UI,
                           unsigned long _ULI,
                           long double _L)
         { return fmal((long double)_UI, (long double)_ULI, _L); }
         inline double fma(unsigned int _UI, unsigned long _ULI, int _I)
         { return __fma((double)_UI, (double)_ULI, (double)_I); }
         inline double fma(unsigned int _UI1,
                           unsigned long _ULI,
                           unsigned int _UI2)
         { return __fma((double)_UI1, (double)_ULI, (double)_UI2); }
         inline double fma(unsigned int _UI, unsigned long _ULI, long _LI)
         { return __fma((double)_UI, (double)_ULI, (double)_LI); }
         inline double fma(unsigned int _UI,
                           unsigned long _ULI1,
                           unsigned long _ULI2)
         { return __fma((double)_UI, (double)_ULI1, (double)_ULI2); }

            inline double fma(unsigned int _UI,
                              unsigned long _ULI,
                              long long _LLI)
            { return __fma((double)_UI, (double)_ULI, (double)_LLI); }
            inline double fma(unsigned int _UI,
                              unsigned long _ULI,
                              unsigned long long _ULLI)
            { return __fma((double)_UI, (double)_ULI, (double)_ULLI); }



            inline double fma(unsigned int _UI, long long _LLI, float _F)
            { return __fma((double)_UI, (double)_LLI, (double)_F); }
            inline double fma(unsigned int _UI, long long _LLI, double _D)
            { return __fma((double)_UI, (double)_LLI, _D); }
            inline long double fma(unsigned int _UI,
                              long long _LLI,
                              long double _L)
            { return fmal((long double)_UI, (long double)_LLI, _L); }
            inline double fma(unsigned int _UI, long long _LLI, int _I)
            { return __fma((double)_UI, (double)_LLI, (double)_I); }
            inline double fma(unsigned int _UI1,
                              long long _LLI,
                              unsigned int _UI2)
            { return __fma((double)_UI1, (double)_LLI, (double)_UI2); }
            inline double fma(unsigned int _UI, long long _LLI, long _LI)
            { return __fma((double)_UI, (double)_LLI, (double)_LI); }
            inline double fma(unsigned int _UI,
                              long long _LLI,
                              unsigned long _ULI)
            { return __fma((double)_UI, (double)_LLI, (double)_ULI); }
            inline double fma(unsigned int _UI,
                              long long _LLI1,
                              long long _LLI2)
            { return __fma((double)_UI, (double)_LLI1, (double)_LLI2); }
            inline double fma(unsigned int _UI,
                              long long _LLI,
                              unsigned long long _ULLI)
            { return __fma((double)_UI, (double)_LLI, (double)_ULLI); }

            inline double fma(unsigned int _UI,
                              unsigned long long _ULLI,
                              float _F)
            { return __fma((double)_UI, (double)_ULLI, (double)_F); }
            inline double fma(unsigned int _UI,
                              unsigned long long _ULLI,
                              double _D)
            { return __fma((double)_UI, (double)_ULLI, _D); }
            inline long double fma(unsigned int _UI,
                              unsigned long long _ULLI,
                              long double _L)
            { return fmal((long double)_UI, (long double)_ULLI, _L); }
            inline double fma(unsigned int _UI,
                              unsigned long long _ULLI,
                              int _I)
            { return __fma((double)_UI, (double)_ULLI, (double)_I); }
            inline double fma(unsigned int _UI1,
                              unsigned long long _ULLI,
                              unsigned int _UI2)
            { return __fma((double)_UI1, (double)_ULLI, (double)_UI2); }
            inline double fma(unsigned int _UI,
                              unsigned long long _ULLI,
                              long _LI)
            { return __fma((double)_UI, (double)_ULLI, (double)_LI); }
            inline double fma(unsigned int _UI,
                              unsigned long long _ULLI,
                              unsigned long _ULI)
            { return __fma((double)_UI, (double)_ULLI, (double)_ULI); }
            inline double fma(unsigned int _UI,
                              unsigned long long _ULLI,
                              long long _LLI)
            { return __fma((double)_UI, (double)_ULLI, (double)_LLI); }
            inline double fma(unsigned int _UI,
                              unsigned long long _ULLI1,
                              unsigned long long _ULLI2)
            { return __fma((double)_UI, (double)_ULLI1, (double)_ULLI2); }



         inline double fma(long _LI, float _F1, float _F2)
         { return __fma((double)_LI, (double)_F1, (double)_F2); }
         inline double fma(long _LI, float _F, double _D)
         { return __fma((double)_LI, (double)_F, _D); }
         inline long double fma(long _LI, float _F, long double _L)
         { return fmal((long double)_LI, (long double)_F, _L); }
         inline double fma(long _LI, float _F, int _I)
         { return __fma((double)_LI, (double)_F, (double)_I); }
         inline double fma(long _LI, float _F, unsigned int _UI)
         { return __fma((double)_LI, (double)_F, (double)_UI); }
         inline double fma(long _LI1, float _F, long _LI2)
         { return __fma((double)_LI1, (double)_F, (double)_LI2); }
         inline double fma(long _LI, float _F, unsigned long _ULI)
         { return __fma((double)_LI, (double)_F, (double)_ULI); }

            inline double fma(long _LI, float _F, long long _LLI)
            { return __fma((double)_LI, (double)_F, (double)_LLI); }
            inline double fma(long _LI, float _F, unsigned long long _ULLI)
            { return __fma((double)_LI, (double)_F, (double)_ULLI); }


         inline double fma(long _LI, double _D, float _F)
         { return __fma((double)_LI, _D, (double)_F); }
         inline double fma(long _LI, double _D1, double _D2)
         { return __fma((double)_LI, _D1, _D2); }
         inline long double fma(long _LI, double _D, long double _L)
         { return fmal((long double)_LI, (long double)_D, _L); }
         inline double fma(long _LI, double _D, int _I)
         { return __fma((double)_LI, _D, (double)_I); }
         inline double fma(long _LI, double _D, unsigned int _UI)
         { return __fma((double)_LI, _D, (double)_UI); }
         inline double fma(long _LI1, double _D, long _LI2)
         { return __fma((double)_LI1, _D, (double)_LI2); }
         inline double fma(long _LI, double _D, unsigned long _ULI)
         { return __fma((double)_LI, _D, (double)_ULI); }

            inline double fma(long _LI, double _D, long long _LLI)
            { return __fma((double)_LI, _D, (double)_LLI); }
            inline double fma(long _LI, double _D, unsigned long long _ULLI)
            { return __fma((double)_LI, _D, (double)_ULLI); }


         inline long double fma(long _LI, long double _L, float _F)
         { return fmal((long double)_LI, _L, (long double)_F); }
         inline long double fma(long _LI, long double _L, double _D)
         { return fmal((long double)_LI, _L, (long double)_D); }
         inline long double fma(long _LI, long double _L1, long double _L2)
         { return fmal((long double)_LI, _L1, _L2); }
         inline long double fma(long _LI, long double _L, int _I)
         { return fmal((long double)_LI, _L, (long double)_I); }
         inline long double fma(long _LI, long double _L, unsigned int _UI)
         { return fmal((long double)_LI, _L, (long double)_UI); }
         inline long double fma(long _LI1, long double _L, long _LI2)
         { return fmal((long double)_LI1, _L, (long double)_LI2); }
         inline long double fma(long _LI, long double _L, unsigned long _ULI)
         { return fmal((long double)_LI, _L, (long double)_ULI); }

            inline long double fma(long _LI, long double _L, long long _LLI)
            { return fmal((long double)_LI, _L, (long double)_LLI); }
            inline long double fma(long _LI,
                              long double _L,
                              unsigned long long _ULLI)
            { return fmal((long double)_LI, _L, (long double)_ULLI); }


         inline double fma(long _LI, int _I, float _F)
         { return __fma((double)_LI, (double)_I, (double)_F); }
         inline double fma(long _LI, int _I, double _D)
         { return __fma((double)_LI, (double)_I, _D); }
         inline long double fma(long _LI, int _I, long double _L)
         { return fmal((long double)_LI, (long double)_I, _L); }
         inline double fma(long _LI, int _I1, int _I2)
         { return __fma((double)_LI, (double)_I1, (double)_I2); }
         inline double fma(long _LI, int _I, unsigned int _UI)
         { return __fma((double)_LI, (double)_I, (double)_UI); }
         inline double fma(long _LI1, int _I, long _LI2)
         { return __fma((double)_LI1, (double)_I, (double)_LI2); }
         inline double fma(long _LI, int _I, unsigned long _ULI)
         { return __fma((double)_LI, (double)_I, (double)_ULI); }

            inline double fma(long _LI, int _I, long long _LLI)
            { return __fma((double)_LI, (double)_I, (double)_LLI); }
            inline double fma(long _LI, int _I, unsigned long long _ULLI)
            { return __fma((double)_LI, (double)_I, (double)_ULLI); }


         inline double fma(long _LI, unsigned int _UI, float _F)
         { return __fma((double)_LI, (double)_UI, (double)_F); }
         inline double fma(long _LI, unsigned int _UI, double _D)
         { return __fma((double)_LI, (double)_UI, _D); }
         inline long double fma(long _LI, unsigned int _UI, long double _L)
         { return fmal((long double)_LI, (long double)_UI, _L); }
         inline double fma(long _LI, unsigned int _UI, int _I)
         { return __fma((double)_LI, (double)_UI, (double)_I); }
         inline double fma(long _LI, unsigned int _UI1, unsigned int _UI2)
         { return __fma((double)_LI, (double)_UI1, (double)_UI2); }
         inline double fma(long _LI1, unsigned int _UI, long _LI2)
         { return __fma((double)_LI1, (double)_UI, (double)_LI2); }
         inline double fma(long _LI, unsigned int _UI, unsigned long _ULI)
         { return __fma((double)_LI, (double)_UI, (double)_ULI); }

            inline double fma(long _LI, unsigned int _UI, long long _LLI)
            { return __fma((double)_LI, (double)_UI, (double)_LLI); }
            inline double fma(long _LI,
                              unsigned int _UI,
                              unsigned long long _ULLI)
            { return __fma((double)_LI, (double)_UI, (double)_ULLI); }


         inline double fma(long _LI1, long _LI2, float _F)
         { return __fma((double)_LI1, (double)_LI2, (double)_F); }
         inline double fma(long _LI1, long _LI2, double _D)
         { return __fma((double)_LI1, (double)_LI2, _D); }
         inline long double fma(long _LI1, long _LI2, long double _L)
         { return fmal((long double)_LI1, (long double)_LI2, _L); }
         inline double fma(long _LI1, long _LI2, int _I)
         { return __fma((double)_LI1, (double)_LI2, (double)_I); }
         inline double fma(long _LI1, long _LI2, unsigned int _UI)
         { return __fma((double)_LI1, (double)_LI2, (double)_UI); }
         inline double fma(long _LI1, long _LI2, long _LI3)
         { return __fma((double)_LI1, (double)_LI2, (double)_LI3); }
         inline double fma(long _LI1, long _LI2, unsigned long _ULI)
         { return __fma((double)_LI1, (double)_LI2, (double)_ULI); }

            inline double fma(long _LI1, long _LI2, long long _LLI)
            { return __fma((double)_LI1, (double)_LI2, (double)_LLI); }
            inline double fma(long _LI1,
                              long _LI2,
                              unsigned long long _ULLI)
            { return __fma((double)_LI1, (double)_LI2, (double)_ULLI); }


         inline double fma(long _LI, unsigned long _ULI, float _F)
         { return __fma((double)_LI, (double)_ULI, (double)_F); }
         inline double fma(long _LI, unsigned long _ULI, double _D)
         { return __fma((double)_LI, (double)_ULI, _D); }
         inline long double fma(long _LI, unsigned long _ULI, long double _L)
         { return fmal((long double)_LI, (long double)_ULI, _L); }
         inline double fma(long _LI, unsigned long _ULI, int _I)
         { return __fma((double)_LI, (double)_ULI, (double)_I); }
         inline double fma(long _LI, unsigned long _ULI, unsigned int _UI)
         { return __fma((double)_LI, (double)_ULI, (double)_UI); }
         inline double fma(long _LI1, unsigned long _ULI, long _LI2)
         { return __fma((double)_LI1, (double)_ULI, (double)_LI2); }
         inline double fma(long _LI,
                           unsigned long _ULI1,
                           unsigned long _ULI2)
         { return __fma((double)_LI, (double)_ULI1, (double)_ULI2); }

            inline double fma(long _LI, unsigned long _ULI, long long _LLI)
            { return __fma((double)_LI, (double)_ULI, (double)_LLI); }
            inline double fma(long _LI,
                              unsigned long _ULI,
                              unsigned long long _ULLI)
            { return __fma((double)_LI, (double)_ULI, (double)_ULLI); }



            inline double fma(long _LI, long long _LLI, float _F)
            { return __fma((double)_LI, (double)_LLI, (double)_F); }
            inline double fma(long _LI, long long _LLI, double _D)
            { return __fma((double)_LI, (double)_LLI, _D); }
            inline long double fma(long _LI, long long _LLI, long double _L)
            { return fmal((long double)_LI, (long double)_LLI, _L); }
            inline double fma(long _LI, long long _LLI, int _I)
            { return __fma((double)_LI, (double)_LLI, (double)_I); }
            inline double fma(long _LI, long long _LLI, unsigned int _UI)
            { return __fma((double)_LI, (double)_LLI, (double)_UI); }
            inline double fma(long _LI1, long long _LLI, long _LI2)
            { return __fma((double)_LI1, (double)_LLI, (double)_LI2); }
            inline double fma(long _LI, long long _LLI, unsigned long _ULI)
            { return __fma((double)_LI, (double)_LLI, (double)_ULI); }
            inline double fma(long _LI, long long _LLI1, long long _LLI2)
            { return __fma((double)_LI, (double)_LLI1, (double)_LLI2); }
            inline double fma(long _LI,
                              long long _LLI,
                              unsigned long long _ULLI)
            { return __fma((double)_LI, (double)_LLI, (double)_ULLI); }

            inline double fma(long _LI, unsigned long long _ULLI, float _F)
            { return __fma((double)_LI, (double)_ULLI, (double)_F); }
            inline double fma(long _LI, unsigned long long _ULLI, double _D)
            { return __fma((double)_LI, (double)_ULLI, _D); }
            inline long double fma(long _LI,
                              unsigned long long _ULLI,
                              long double _L)
            { return fmal((long double)_LI, (long double)_ULLI, _L); }
            inline double fma(long _LI, unsigned long long _ULLI, int _I)
            { return __fma((double)_LI, (double)_ULLI, (double)_I); }
            inline double fma(long _LI,
                              unsigned long long _ULLI,
                              unsigned int _UI)
            { return __fma((double)_LI, (double)_ULLI, (double)_UI); }
            inline double fma(long _LI1,
                              unsigned long long _ULLI,
                              long _LI2)
            { return __fma((double)_LI1, (double)_ULLI, (double)_LI2); }
            inline double fma(long _LI,
                              unsigned long long _ULLI,
                              unsigned long _ULI)
            { return __fma((double)_LI, (double)_ULLI, (double)_ULI); }
            inline double fma(long _LI,
                              unsigned long long _ULLI,
                              long long _LLI)
            { return __fma((double)_LI, (double)_ULLI, (double)_LLI); }
            inline double fma(long _LI,
                              unsigned long long _ULLI1,
                              unsigned long long _ULLI2)
            { return __fma((double)_LI, (double)_ULLI1, (double)_ULLI2); }



         inline double fma(unsigned long _ULI, float _F1, float _F2)
         { return __fma((double)_ULI, (double)_F1, (double)_F2); }
         inline double fma(unsigned long _ULI, float _F, double _D)
         { return __fma((double)_ULI, (double)_F, _D); }
         inline long double fma(unsigned long _ULI, float _F, long double _L)
         { return fmal((long double)_ULI, (long double)_F, _L); }
         inline double fma(unsigned long _ULI, float _F, int _I)
         { return __fma((double)_ULI, (double)_F, (double)_I); }
         inline double fma(unsigned long _ULI, float _F, unsigned int _UI)
         { return __fma((double)_ULI, (double)_F, (double)_UI); }
         inline double fma(unsigned long _ULI, float _F, long _LI)
         { return __fma((double)_ULI, (double)_F, (double)_LI); }
         inline double fma(unsigned long _ULI1,
                           float _F,
                           unsigned long _ULI2)
         { return __fma((double)_ULI1, (double)_F, (double)_ULI2); }

            inline double fma(unsigned long _ULI, float _F, long long _LLI)
            { return __fma((double)_ULI, (double)_F, (double)_LLI); }
            inline double fma(unsigned long _ULI,
                              float _F,
                              unsigned long long _ULLI)
            { return __fma((double)_ULI, (double)_F, (double)_ULLI); }


         inline double fma(unsigned long _ULI, double _D, float _F)
         { return __fma((double)_ULI, _D, (double)_F); }
         inline double fma(unsigned long _ULI, double _D1, double _D2)
         { return __fma((double)_ULI, _D1, _D2); }
         inline long double fma(unsigned long _ULI, double _D, long double _L)
         { return fmal((long double)_ULI, (long double)_D, _L); }
         inline double fma(unsigned long _ULI, double _D, int _I)
         { return __fma((double)_ULI, _D, (double)_I); }
         inline double fma(unsigned long _ULI, double _D, unsigned int _UI)
         { return __fma((double)_ULI, _D, (double)_UI); }
         inline double fma(unsigned long _ULI, double _D, long _LI)
         { return __fma((double)_ULI, _D, (double)_LI); }
         inline double fma(unsigned long _ULI1,
                           double _D,
                           unsigned long _ULI2)
         { return __fma((double)_ULI1, _D, (double)_ULI2); }

            inline double fma(unsigned long _ULI, double _D, long long _LLI)
            { return __fma((double)_ULI, _D, (double)_LLI); }
            inline double fma(unsigned long _ULI,
                              double _D,
                              unsigned long long _ULLI)
            { return __fma((double)_ULI, _D, (double)_ULLI); }


         inline long double fma(unsigned long _ULI, long double _L, float _F)
         { return fmal((long double)_ULI, _L, (long double)_F); }
         inline long double fma(unsigned long _ULI, long double _L, double _D)
         { return fmal((long double)_ULI, _L, (long double)_D); }
         inline long double fma(unsigned long _ULI,
                           long double _L1,
                           long double _L2)
         { return fmal((long double)_ULI, _L1, _L2); }
         inline long double fma(unsigned long _ULI, long double _L, int _I)
         { return fmal((long double)_ULI, _L, (long double)_I); }
         inline long double fma(unsigned long _ULI,
                           long double _L,
                           unsigned int _UI)
         { return fmal((long double)_ULI, _L, (long double)_UI); }
         inline long double fma(unsigned long _ULI, long double _L, long _LI)
         { return fmal((long double)_ULI, _L, (long double)_LI); }
         inline long double fma(unsigned long _ULI1,
                           long double _L,
                           unsigned long _ULI2)
         { return fmal((long double)_ULI1, _L, (long double)_ULI2); }

            inline long double fma(unsigned long _ULI,
                              long double _L,
                              long long _LLI)
            { return fmal((long double)_ULI, _L, (long double)_LLI); }
            inline long double fma(unsigned long _ULI,
                              long double _L,
                              unsigned long long _ULLI)
            { return fmal((long double)_ULI, _L, (long double)_ULLI); }


         inline double fma(unsigned long _ULI, int _I, float _F)
         { return __fma((double)_ULI, (double)_I, (double)_F); }
         inline double fma(unsigned long _ULI, int _I, double _D)
         { return __fma((double)_ULI, (double)_I, _D); }
         inline long double fma(unsigned long _ULI, int _I, long double _L)
         { return fmal((long double)_ULI, (long double)_I, _L); }
         inline double fma(unsigned long _ULI, int _I1, int _I2)
         { return __fma((double)_ULI, (double)_I1, (double)_I2); }
         inline double fma(unsigned long _ULI, int _I, unsigned int _UI)
         { return __fma((double)_ULI, (double)_I, (double)_UI); }
         inline double fma(unsigned long _ULI, int _I, long _LI)
         { return __fma((double)_ULI, (double)_I, (double)_LI); }
         inline double fma(unsigned long _ULI1, int _I, unsigned long _ULI2)
         { return __fma((double)_ULI1, (double)_I, (double)_ULI2); }

            inline double fma(unsigned long _ULI, int _I, long long _LLI)
            { return __fma((double)_ULI, (double)_I, (double)_LLI); }
            inline double fma(unsigned long _ULI,
                              int _I,
                              unsigned long long _ULLI)
            { return __fma((double)_ULI, (double)_I, (double)_ULLI); }


         inline double fma(unsigned long _ULI, unsigned int _UI, float _F)
         { return __fma((double)_ULI, (double)_UI, (double)_F); }
         inline double fma(unsigned long _ULI, unsigned int _UI, double _D)
         { return __fma((double)_ULI, (double)_UI, _D); }
         inline long double fma(unsigned long _ULI,
                           unsigned int _UI,
                           long double _L)
         { return fmal((long double)_ULI, (long double)_UI, _L); }
         inline double fma(unsigned long _ULI, unsigned int _UI, int _I)
         { return __fma((double)_ULI, (double)_UI, (double)_I); }
         inline double fma(unsigned long _ULI,
                           unsigned int _UI1,
                           unsigned int _UI2)
         { return __fma((double)_ULI, (double)_UI1, (double)_UI2); }
         inline double fma(unsigned long _ULI, unsigned int _UI, long _LI)
         { return __fma((double)_ULI, (double)_UI, (double)_LI); }
         inline double fma(unsigned long _ULI1,
                           unsigned int _UI,
                           unsigned long _ULI2)
         { return __fma((double)_ULI1, (double)_UI, (double)_ULI2); }

            inline double fma(unsigned long _ULI,
                              unsigned int _UI,
                              long long _LLI)
            { return __fma((double)_ULI, (double)_UI, (double)_LLI); }
            inline double fma(unsigned long _ULI,
                              unsigned int _UI,
                              unsigned long long _ULLI)
            { return __fma((double)_ULI, (double)_UI, (double)_ULLI); }


         inline double fma(unsigned long _ULI, long _LI, float _F)
         { return __fma((double)_ULI, (double)_LI, (double)_F); }
         inline double fma(unsigned long _ULI, long _LI, double _D)
         { return __fma((double)_ULI, (double)_LI, _D); }
         inline long double fma(unsigned long _ULI, long _LI, long double _L)
         { return fmal((long double)_ULI, (long double)_LI, _L); }
         inline double fma(unsigned long _ULI, long _LI, int _I)
         { return __fma((double)_ULI, (double)_LI, (double)_I); }
         inline double fma(unsigned long _ULI, long _LI, unsigned int _UI)
         { return __fma((double)_ULI, (double)_LI, (double)_UI); }
         inline double fma(unsigned long _ULI, long _LI1, long _LI2)
         { return __fma((double)_ULI, (double)_LI1, (double)_LI2); }
         inline double fma(unsigned long _ULI1,
                           long _LI,
                           unsigned long _ULI2)
         { return __fma((double)_ULI1, (double)_LI, (double)_ULI2); }

            inline double fma(unsigned long _ULI, long _LI, long long _LLI)
            { return __fma((double)_ULI, (double)_LI, (double)_LLI); }
            inline double fma(unsigned long _ULI,
                              long _LI,
                              unsigned long long _ULLI)
            { return __fma((double)_ULI, (double)_LI, (double)_ULLI); }


         inline double fma(unsigned long _ULI1,
                           unsigned long _ULI2,
                           float _F)
         { return __fma((double)_ULI1, (double)_ULI2, (double)_F); }
         inline double fma(unsigned long _ULI1,
                           unsigned long _ULI2,
                           double _D)
         { return __fma((double)_ULI1, (double)_ULI2, _D); }
         inline long double fma(unsigned long _ULI1,
                           unsigned long _ULI2,
                           long double _L)
         { return fmal((long double)_ULI1, (long double)_ULI2, _L); }
         inline double fma(unsigned long _ULI1, unsigned long _ULI2, int _I)
         { return __fma((double)_ULI1, (double)_ULI2, (double)_I); }
         inline double fma(unsigned long _ULI1,
                           unsigned long _ULI2,
                           unsigned int _UI)
         { return __fma((double)_ULI1, (double)_ULI2, (double)_UI); }
         inline double fma(unsigned long _ULI1,
                           unsigned long _ULI2,
                           long _LI)
         { return __fma((double)_ULI1, (double)_ULI2, (double)_LI); }
         inline double fma(unsigned long _ULI1,
                           unsigned long _ULI2,
                           unsigned long _ULI3)
         { return __fma((double)_ULI1, (double)_ULI2, (double)_ULI3); }

            inline double fma(unsigned long _ULI1,
                              unsigned long _ULI2,
                              long long _LLI)
            { return __fma((double)_ULI1, (double)_ULI2, (double)_LLI); }
            inline double fma(unsigned long _ULI1,
                              unsigned long _ULI2,
                              unsigned long long _ULLI)
            { return __fma((double)_ULI1, (double)_ULI2, (double)_ULLI); }



            inline double fma(unsigned long _ULI, long long _LLI, float _F)
            { return __fma((double)_ULI, (double)_LLI, (double)_F); }
            inline double fma(unsigned long _ULI, long long _LLI, double _D)
            { return __fma((double)_ULI, (double)_LLI, _D); }
            inline long double fma(unsigned long _ULI,
                              long long _LLI,
                              long double _L)
            { return fmal((long double)_ULI, (long double)_LLI, _L); }
            inline double fma(unsigned long _ULI, long long _LLI, int _I)
            { return __fma((double)_ULI, (double)_LLI, (double)_I); }
            inline double fma(unsigned long _ULI,
                              long long _LLI,
                              unsigned int _UI)
            { return __fma((double)_ULI, (double)_LLI, (double)_UI); }
            inline double fma(unsigned long _ULI, long long _LLI, long _LI)
            { return __fma((double)_ULI, (double)_LLI, (double)_LI); }
            inline double fma(unsigned long _ULI1,
                              long long _LLI,
                              unsigned long _ULI2)
            { return __fma((double)_ULI1, (double)_LLI, (double)_ULI2); }
            inline double fma(unsigned long _ULI,
                              long long _LLI1,
                              long long _LLI2)
            { return __fma((double)_ULI, (double)_LLI1, (double)_LLI2); }
            inline double fma(unsigned long _ULI,
                              long long _LLI,
                              unsigned long long _ULLI)
            { return __fma((double)_ULI, (double)_LLI, (double)_ULLI); }

            inline double fma(unsigned long _ULI,
                              unsigned long long _ULLI,
                              float _F)
            { return __fma((double)_ULI, (double)_ULLI, (double)_F); }
            inline double fma(unsigned long _ULI,
                              unsigned long long _ULLI,
                              double _D)
            { return __fma((double)_ULI, (double)_ULLI, _D); }
            inline long double fma(unsigned long _ULI,
                              unsigned long long _ULLI,
                              long double _L)
            { return fmal((long double)_ULI, (long double)_ULLI, _L); }
            inline double fma(unsigned long _ULI,
                              unsigned long long _ULLI,
                              int _I)
            { return __fma((double)_ULI, (double)_ULLI, (double)_I); }
            inline double fma(unsigned long _ULI,
                              unsigned long long _ULLI,
                              unsigned int _UI)
            { return __fma((double)_ULI, (double)_ULLI, (double)_UI); }
            inline double fma(unsigned long _ULI,
                              unsigned long long _ULLI,
                              long _LI)
            { return __fma((double)_ULI, (double)_ULLI, (double)_LI); }
            inline double fma(unsigned long _ULI1,
                              unsigned long long _ULLI,
                              unsigned long _ULI2)
            { return __fma((double)_ULI1, (double)_ULLI, (double)_ULI2); }
            inline double fma(unsigned long _ULI,
                              unsigned long long _ULLI,
                              long long _LLI)
            { return __fma((double)_ULI, (double)_ULLI, (double)_LLI); }
            inline double fma(unsigned long _ULI,
                              unsigned long long _ULLI1,
                              unsigned long long _ULLI2)
            { return __fma((double)_ULI, (double)_ULLI1, (double)_ULLI2); }




            inline double fma(long long _LLI, float _F1, float _F2)
            { return __fma((double)_LLI, (double)_F1, (double)_F2); }
            inline double fma(long long _LLI, float _F, double _D)
            { return __fma((double)_LLI, (double)_F, _D); }
            inline long double fma(long long _LLI, float _F, long double _L)
            { return fmal((long double)_LLI, (long double)_F, _L); }
            inline double fma(long long _LLI, float _F, int _I)
            { return __fma((double)_LLI, (double)_F, (double)_I); }
            inline double fma(long long _LLI, float _F, unsigned int _UI)
            { return __fma((double)_LLI, (double)_F, (double)_UI); }
            inline double fma(long long _LLI, float _F, long _LI)
            { return __fma((double)_LLI, (double)_F, (double)_LI); }
            inline double fma(long long _LLI, float _F, unsigned long _ULI)
            { return __fma((double)_LLI, (double)_F, (double)_ULI); }
            inline double fma(long long _LLI1, float _F, long long _LLI2)
            { return __fma((double)_LLI1, (double)_F, (double)_LLI2); }
            inline double fma(long long _LLI,
                              float _F,
                              unsigned long long _ULLI)
            { return __fma((double)_LLI, (double)_F, (double)_ULLI); }

            inline double fma(long long _LLI, double _D, float _F)
            { return __fma((double)_LLI, _D, (double)_F); }
            inline double fma(long long _LLI, double _D1, double _D2)
            { return __fma((double)_LLI, _D1, _D2); }
            inline long double fma(long long _LLI, double _D, long double _L)
            { return fmal((long double)_LLI, (long double)_D, _L); }
            inline double fma(long long _LLI, double _D, int _I)
            { return __fma((double)_LLI, _D, (double)_I); }
            inline double fma(long long _LLI, double _D, unsigned int _UI)
            { return __fma((double)_LLI, _D, (double)_UI); }
            inline double fma(long long _LLI, double _D, long _LI)
            { return __fma((double)_LLI, _D, (double)_LI); }
            inline double fma(long long _LLI, double _D, unsigned long _ULI)
            { return __fma((double)_LLI, _D, (double)_ULI); }
            inline double fma(long long _LLI1, double _D, long long _LLI2)
            { return __fma((double)_LLI1, _D, (double)_LLI2); }
            inline double fma(long long _LLI,
                              double _D,
                              unsigned long long _ULLI)
            { return __fma((double)_LLI, _D, (double)_ULLI); }

            inline long double fma(long long _LLI, long double _L, float _F)
            { return fmal((long double)_LLI, _L, (long double)_F); }
            inline long double fma(long long _LLI, long double _L, double _D)
            { return fmal((long double)_LLI, _L, (long double)_D); }
            inline long double fma(long long _LLI,
                              long double _L1,
                              long double _L2)
            { return fmal((long double)_LLI, _L1, _L2); }
            inline long double fma(long long _LLI, long double _L, int _I)
            { return fmal((long double)_LLI, _L, (long double)_I); }
            inline long double fma(long long _LLI,
                              long double _L,
                              unsigned int _UI)
            { return fmal((long double)_LLI, _L, (long double)_UI); }
            inline long double fma(long long _LLI, long double _L, long _LI)
            { return fmal((long double)_LLI, _L, (long double)_LI); }
            inline long double fma(long long _LLI,
                              long double _L,
                              unsigned long _ULI)
            { return fmal((long double)_LLI, _L, (long double)_ULI); }
            inline long double fma(long long _LLI1,
                              long double _L,
                              long long _LLI2)
            { return fmal((long double)_LLI1, _L, (long double)_LLI2); }
            inline long double fma(long long _LLI,
                              long double _L,
                              unsigned long long _ULLI)
            { return fmal((long double)_LLI, _L, (long double)_ULLI); }

            inline double fma(long long _LLI, int _I, float _F)
            { return __fma((double)_LLI, (double)_I, (double)_F); }
            inline double fma(long long _LLI, int _I, double _D)
            { return __fma((double)_LLI, (double)_I, _D); }
            inline long double fma(long long _LLI, int _I, long double _L)
            { return fmal((long double)_LLI, (long double)_I, _L); }
            inline double fma(long long _LLI, int _I1, int _I2)
            { return __fma((double)_LLI, (double)_I1, (double)_I2); }
            inline double fma(long long _LLI, int _I, unsigned int _UI)
            { return __fma((double)_LLI, (double)_I, (double)_UI); }
            inline double fma(long long _LLI, int _I, long _LI)
            { return __fma((double)_LLI, (double)_I, (double)_LI); }
            inline double fma(long long _LLI, int _I, unsigned long _ULI)
            { return __fma((double)_LLI, (double)_I, (double)_ULI); }
            inline double fma(long long _LLI1, int _I, long long _LLI2)
            { return __fma((double)_LLI1, (double)_I, (double)_LLI2); }
            inline double fma(long long _LLI,
                              int _I,
                              unsigned long long _ULLI)
            { return __fma((double)_LLI, (double)_I, (double)_ULLI); }

            inline double fma(long long _LLI, unsigned int _UI, float _F)
            { return __fma((double)_LLI, (double)_UI, (double)_F); }
            inline double fma(long long _LLI, unsigned int _UI, double _D)
            { return __fma((double)_LLI, (double)_UI, _D); }
            inline long double fma(long long _LLI,
                              unsigned int _UI,
                              long double _L)
            { return fmal((long double)_LLI, (long double)_UI, _L); }
            inline double fma(long long _LLI, unsigned int _UI, int _I)
            { return __fma((double)_LLI, (double)_UI, (double)_I); }
            inline double fma(long long _LLI,
                              unsigned int _UI1,
                              unsigned int _UI2)
            { return __fma((double)_LLI, (double)_UI1, (double)_UI2); }
            inline double fma(long long _LLI, unsigned int _UI, long _LI)
            { return __fma((double)_LLI, (double)_UI, (double)_LI); }
            inline double fma(long long _LLI,
                              unsigned int _UI,
                              unsigned long _ULI)
            { return __fma((double)_LLI, (double)_UI, (double)_ULI); }
            inline double fma(long long _LLI1,
                              unsigned int _UI,
                              long long _LLI2)
            { return __fma((double)_LLI1, (double)_UI, (double)_LLI2); }
            inline double fma(long long _LLI,
                              unsigned int _UI,
                              unsigned long long _ULLI)
            { return __fma((double)_LLI, (double)_UI, (double)_ULLI); }

            inline double fma(long long _LLI, long _LI, float _F)
            { return __fma((double)_LLI, (double)_LI, (double)_F); }
            inline double fma(long long _LLI, long _LI, double _D)
            { return __fma((double)_LLI, (double)_LI, _D); }
            inline long double fma(long long _LLI, long _LI, long double _L)
            { return fmal((long double)_LLI, (long double)_LI, _L); }
            inline double fma(long long _LLI, long _LI, int _I)
            { return __fma((double)_LLI, (double)_LI, (double)_I); }
            inline double fma(long long _LLI, long _LI, unsigned int _UI)
            { return __fma((double)_LLI, (double)_LI, (double)_UI); }
            inline double fma(long long _LLI, long _LI1, long _LI2)
            { return __fma((double)_LLI, (double)_LI1, (double)_LI2); }
            inline double fma(long long _LLI, long _LI, unsigned long _ULI)
            { return __fma((double)_LLI, (double)_LI, (double)_ULI); }
            inline double fma(long long _LLI1, long _LI, long long _LLI2)
            { return __fma((double)_LLI1, (double)_LI, (double)_LLI2); }
            inline double fma(long long _LLI,
                              long _LI,
                              unsigned long long _ULLI)
            { return __fma((double)_LLI, (double)_LI, (double)_ULLI); }

            inline double fma(long long _LLI, unsigned long _ULI, float _F)
            { return __fma((double)_LLI, (double)_ULI, (double)_F); }
            inline double fma(long long _LLI, unsigned long _ULI, double _D)
            { return __fma((double)_LLI, (double)_ULI, _D); }
            inline long double fma(long long _LLI,
                              unsigned long _ULI,
                              long double _L)
            { return fmal((long double)_LLI, (long double)_ULI, _L); }
            inline double fma(long long _LLI, unsigned long _ULI, int _I)
            { return __fma((double)_LLI, (double)_ULI, (double)_I); }
            inline double fma(long long _LLI,
                              unsigned long _ULI,
                              unsigned int _UI)
            { return __fma((double)_LLI, (double)_ULI, (double)_UI); }
            inline double fma(long long _LLI, unsigned long _ULI, long _LI)
            { return __fma((double)_LLI, (double)_ULI, (double)_LI); }
            inline double fma(long long _LLI,
                              unsigned long _ULI1,
                              unsigned long _ULI2)
            { return __fma((double)_LLI, (double)_ULI1, (double)_ULI2); }
            inline double fma(long long _LLI1,
                              unsigned long _ULI,
                              long long _LLI2)
            { return __fma((double)_LLI1, (double)_ULI, (double)_LLI2); }
            inline double fma(long long _LLI,
                              unsigned long _ULI,
                              unsigned long long _ULLI)
            { return __fma((double)_LLI, (double)_ULI, (double)_ULLI); }

            inline double fma(long long _LLI1, long long _LLI2, float _F)
            { return __fma((double)_LLI1, (double)_LLI2, (double)_F); }
            inline double fma(long long _LLI1, long long _LLI2, double _D)
            { return __fma((double)_LLI1, (double)_LLI2, _D); }
            inline long double fma(long long _LLI1,
                              long long _LLI2,
                              long double _L)
            { return fmal((long double)_LLI1, (long double)_LLI2, _L); }
            inline double fma(long long _LLI1, long long _LLI2, int _I)
            { return __fma((double)_LLI1, (double)_LLI2, (double)_I); }
            inline double fma(long long _LLI1,
                              long long _LLI2,
                              unsigned int _UI)
            { return __fma((double)_LLI1, (double)_LLI2, (double)_UI); }
            inline double fma(long long _LLI1, long long _LLI2, long _LI)
            { return __fma((double)_LLI1, (double)_LLI2, (double)_LI); }
            inline double fma(long long _LLI1,
                              long long _LLI2,
                              unsigned long _ULI)
            { return __fma((double)_LLI1, (double)_LLI2, (double)_ULI); }
            inline double fma(long long _LLI1,
                              long long _LLI2,
                              long long _LLI3)
            { return __fma((double)_LLI1, (double)_LLI2, (double)_LLI3); }
            inline double fma(long long _LLI1,
                              long long _LLI2,
                              unsigned long long _ULLI)
            { return __fma((double)_LLI1, (double)_LLI2, (double)_ULLI); }

            inline double fma(long long _LLI,
                              unsigned long long _ULLI,
                              float _F)
            { return __fma((double)_LLI, (double)_ULLI, (double)_F); }
            inline double fma(long long _LLI,
                              unsigned long long _ULLI,
                              double _D)
            { return __fma((double)_LLI, (double)_ULLI, _D); }
            inline long double fma(long long _LLI,
                              unsigned long long _ULLI,
                              long double _L)
            { return fmal((long double)_LLI, (long double)_ULLI, _L); }
            inline double fma(long long _LLI,
                              unsigned long long _ULLI,
                              int _I)
            { return __fma((double)_LLI, (double)_ULLI, (double)_I); }
            inline double fma(long long _LLI,
                              unsigned long long _ULLI,
                              unsigned int _UI)
            { return __fma((double)_LLI, (double)_ULLI, (double)_UI); }
            inline double fma(long long _LLI,
                              unsigned long long _ULLI,
                              long _LI)
            { return __fma((double)_LLI, (double)_ULLI, (double)_LI); }
            inline double fma(long long _LLI,
                              unsigned long long _ULLI,
                              unsigned long _ULI)
            { return __fma((double)_LLI, (double)_ULLI, (double)_ULI); }
            inline double fma(long long _LLI1,
                              unsigned long long _ULLI,
                              long long _LLI2)
            { return __fma((double)_LLI1, (double)_ULLI, (double)_LLI2); }
            inline double fma(long long _LLI,
                              unsigned long long _ULLI1,
                              unsigned long long _ULLI2)
            { return __fma((double)_LLI, (double)_ULLI1, (double)_ULLI2); }


            inline double fma(unsigned long long _ULLI,
                              float _F1,
                              float _F2)
            { return __fma((double)_ULLI, (double)_F1, (double)_F2); }
            inline double fma(unsigned long long _ULLI,
                              float _F,
                              double _D)
            { return __fma((double)_ULLI, (double)_F, _D); }
            inline long double fma(unsigned long long _ULLI,
                              float _F,
                              long double _L)
            { return fmal((long double)_ULLI, (long double)_F, _L); }
            inline double fma(unsigned long long _ULLI, float _F, int _I)
            { return __fma((double)_ULLI, (double)_F, (double)_I); }
            inline double fma(unsigned long long _ULLI,
                              float _F,
                              unsigned int _UI)
            { return __fma((double)_ULLI, (double)_F, (double)_UI); }
            inline double fma(unsigned long long _ULLI, float _F, long _LI)
            { return __fma((double)_ULLI, (double)_F, (double)_LI); }
            inline double fma(unsigned long long _ULLI,
                              float _F,
                              unsigned long _ULI)
            { return __fma((double)_ULLI, (double)_F, (double)_ULI); }
            inline double fma(unsigned long long _ULLI,
                              float _F,
                              long long _LLI)
            { return __fma((double)_ULLI, (double)_F, (double)_LLI); }
            inline double fma(unsigned long long _ULLI1,
                              float _F,
                              unsigned long long _ULLI2)
            { return __fma((double)_ULLI1, (double)_F, (double)_ULLI2); }

            inline double fma(unsigned long long _ULLI,
                              double _D,
                              float _F)
            { return __fma((double)_ULLI, _D, (double)_F); }
            inline double fma(unsigned long long _ULLI,
                              double _D1,
                              double _D2)
            { return __fma((double)_ULLI, _D1, _D2); }
            inline long double fma(unsigned long long _ULLI,
                              double _D,
                              long double _L)
            { return fmal((long double)_ULLI, (long double)_D, _L); }
            inline double fma(unsigned long long _ULLI, double _D, int _I)
            { return __fma((double)_ULLI, _D, (double)_I); }
            inline double fma(unsigned long long _ULLI,
                              double _D,
                              unsigned int _UI)
            { return __fma((double)_ULLI, _D, (double)_UI); }
            inline double fma(unsigned long long _ULLI,
                              double _D,
                              long _LI)
            { return __fma((double)_ULLI, _D, (double)_LI); }
            inline double fma(unsigned long long _ULLI,
                              double _D,
                              unsigned long _ULI)
            { return __fma((double)_ULLI, _D, (double)_ULI); }
            inline double fma(unsigned long long _ULLI,
                              double _D,
                              long long _LLI)
            { return __fma((double)_ULLI, _D, (double)_LLI); }
            inline double fma(unsigned long long _ULLI1,
                              double _D,
                              unsigned long long _ULLI2)
            { return __fma((double)_ULLI1, _D, (double)_ULLI2); }

            inline long double fma(unsigned long long _ULLI,
                              long double _L,
                              float _F)
            { return fmal((long double)_ULLI, _L, (long double)_F); }
            inline long double fma(unsigned long long _ULLI,
                              long double _L,
                              double _D)
            { return fmal((long double)_ULLI, _L, (long double)_D); }
            inline long double fma(unsigned long long _ULLI,
                              long double _L1,
                              long double _L2)
            { return fmal((long double)_ULLI, _L1, _L2); }
            inline long double fma(unsigned long long _ULLI,
                              long double _L,
                              int _I)
            { return fmal((long double)_ULLI, _L, (long double)_I); }
            inline long double fma(unsigned long long _ULLI,
                              long double _L,
                              unsigned int _UI)
            { return fmal((long double)_ULLI, _L, (long double)_UI); }
            inline long double fma(unsigned long long _ULLI,
                              long double _L,
                              long _LI)
            { return fmal((long double)_ULLI, _L, (long double)_LI); }
            inline long double fma(unsigned long long _ULLI,
                              long double _L,
                              unsigned long _ULI)
            { return fmal((long double)_ULLI, _L, (long double)_ULI); }
            inline long double fma(unsigned long long _ULLI,
                              long double _L,
                              long long _LLI)
            { return fmal((long double)_ULLI, _L, (long double)_LLI); }
            inline long double fma(unsigned long long _ULLI1,
                              long double _L,
                              unsigned long long _ULLI2)
            { return fmal((long double)_ULLI1, _L, (long double)_ULLI2); }

            inline double fma(unsigned long long _ULLI, int _I, float _F)
            { return __fma((double)_ULLI, (double)_I, (double)_F); }
            inline double fma(unsigned long long _ULLI, int _I, double _D)
            { return __fma((double)_ULLI, (double)_I, _D); }
            inline long double fma(unsigned long long _ULLI,
                              int _I,
                              long double _L)
            { return fmal((long double)_ULLI, (long double)_I, _L); }
            inline double fma(unsigned long long _ULLI, int _I1, int _I2)
            { return __fma((double)_ULLI, (double)_I1, (double)_I2); }
            inline double fma(unsigned long long _ULLI,
                              int _I,
                              unsigned int _UI)
            { return __fma((double)_ULLI, (double)_I, (double)_UI); }
            inline double fma(unsigned long long _ULLI, int _I, long _LI)
            { return __fma((double)_ULLI, (double)_I, (double)_LI); }
            inline double fma(unsigned long long _ULLI,
                              int _I,
                              unsigned long _ULI)
            { return __fma((double)_ULLI, (double)_I, (double)_ULI); }
            inline double fma(unsigned long long _ULLI,
                              int _I,
                              long long _LLI)
            { return __fma((double)_ULLI, (double)_I, (double)_LLI); }
            inline double fma(unsigned long long _ULLI1,
                              int _I,
                              unsigned long long _ULLI2)
            { return __fma((double)_ULLI1, (double)_I, (double)_ULLI2); }

            inline double fma(unsigned long long _ULLI,
                              unsigned int _UI,
                              float _F)
            { return __fma((double)_ULLI, (double)_UI, (double)_F); }
            inline double fma(unsigned long long _ULLI,
                              unsigned int _UI,
                              double _D)
            { return __fma((double)_ULLI, (double)_UI, _D); }
            inline long double fma(unsigned long long _ULLI,
                              unsigned int _UI,
                              long double _L)
            { return fmal((long double)_ULLI, (long double)_UI, _L); }
            inline double fma(unsigned long long _ULLI,
                              unsigned int _UI,
                              int _I)
            { return __fma((double)_ULLI, (double)_UI, (double)_I); }
            inline double fma(unsigned long long _ULLI,
                              unsigned int _UI1,
                              unsigned int _UI2)
            { return __fma((double)_ULLI, (double)_UI1, (double)_UI2); }
            inline double fma(unsigned long long _ULLI,
                              unsigned int _UI,
                              long _LI)
            { return __fma((double)_ULLI, (double)_UI, (double)_LI); }
            inline double fma(unsigned long long _ULLI,
                              unsigned int _UI,
                              unsigned long _ULI)
            { return __fma((double)_ULLI, (double)_UI, (double)_ULI); }
            inline double fma(unsigned long long _ULLI,
                              unsigned int _UI,
                              long long _LLI)
            { return __fma((double)_ULLI, (double)_UI, (double)_LLI); }
            inline double fma(unsigned long long _ULLI1,
                              unsigned int _UI,
                              unsigned long long _ULLI2)
            { return __fma((double)_ULLI1, (double)_UI, (double)_ULLI2); }

            inline double fma(unsigned long long _ULLI, long _LI, float _F)
            { return __fma((double)_ULLI, (double)_LI, (double)_F); }
            inline double fma(unsigned long long _ULLI, long _LI, double _D)
            { return __fma((double)_ULLI, (double)_LI, _D); }
            inline long double fma(unsigned long long _ULLI,
                              long _LI,
                              long double _L)
            { return fmal((long double)_ULLI, (long double)_LI, _L); }
            inline double fma(unsigned long long _ULLI, long _LI, int _I)
            { return __fma((double)_ULLI, (double)_LI, (double)_I); }
            inline double fma(unsigned long long _ULLI,
                              long _LI,
                              unsigned int _UI)
            { return __fma((double)_ULLI, (double)_LI, (double)_UI); }
            inline double fma(unsigned long long _ULLI,
                              long _LI1,
                              long _LI2)
            { return __fma((double)_ULLI, (double)_LI1, (double)_LI2); }
            inline double fma(unsigned long long _ULLI,
                              long _LI,
                              unsigned long _ULI)
            { return __fma((double)_ULLI, (double)_LI, (double)_ULI); }
            inline double fma(unsigned long long _ULLI,
                              long _LI,
                              long long _LLI)
            { return __fma((double)_ULLI, (double)_LI, (double)_LLI); }
            inline double fma(unsigned long long _ULLI1,
                              long _LI,
                              unsigned long long _ULLI2)
            { return __fma((double)_ULLI1, (double)_LI, (double)_ULLI2); }

            inline double fma(unsigned long long _ULLI,
                              unsigned long _ULI,
                              float _F)
            { return __fma((double)_ULLI, (double)_ULI, (double)_F); }
            inline double fma(unsigned long long _ULLI,
                              unsigned long _ULI,
                              double _D)
            { return __fma((double)_ULLI, (double)_ULI, _D); }
            inline long double fma(unsigned long long _ULLI,
                              unsigned long _ULI,
                              long double _L)
            { return fmal((long double)_ULLI, (long double)_ULI, _L); }
            inline double fma(unsigned long long _ULLI,
                              unsigned long _ULI,
                              int _I)
            { return __fma((double)_ULLI, (double)_ULI, (double)_I); }
            inline double fma(unsigned long long _ULLI,
                              unsigned long _ULI,
                              unsigned int _UI)
            { return __fma((double)_ULLI, (double)_ULI, (double)_UI); }
            inline double fma(unsigned long long _ULLI,
                              unsigned long _ULI,
                              long _LI)
            { return __fma((double)_ULLI, (double)_ULI, (double)_LI); }
            inline double fma(unsigned long long _ULLI,
                              unsigned long _ULI1,
                              unsigned long _ULI2)
            { return __fma((double)_ULLI, (double)_ULI1, (double)_ULI2); }
            inline double fma(unsigned long long _ULLI,
                              unsigned long _ULI,
                              long long _LLI)
            { return __fma((double)_ULLI, (double)_ULI, (double)_LLI); }
            inline double fma(unsigned long long _ULLI1,
                              unsigned long _ULI,
                              unsigned long long _ULLI2)
            { return __fma((double)_ULLI1, (double)_ULI, (double)_ULLI2); }

            inline double fma(unsigned long long _ULLI,
                              long long _LLI,
                              float _F)
            { return __fma((double)_ULLI, (double)_LLI, (double)_F); }
            inline double fma(unsigned long long _ULLI,
                              long long _LLI,
                              double _D)
            { return __fma((double)_ULLI, (double)_LLI, _D); }
            inline long double fma(unsigned long long _ULLI,
                              long long _LLI,
                              long double _L)
            { return fmal((long double)_ULLI, (long double)_LLI, _L); }
            inline double fma(unsigned long long _ULLI,
                              long long _LLI,
                              int _I)
            { return __fma((double)_ULLI, (double)_LLI, (double)_I); }
            inline double fma(unsigned long long _ULLI,
                              long long _LLI,
                              unsigned int _UI)
            { return __fma((double)_ULLI, (double)_LLI, (double)_UI); }
            inline double fma(unsigned long long _ULLI,
                              long long _LLI,
                              long _LI)
            { return __fma((double)_ULLI, (double)_LLI, (double)_LI); }
            inline double fma(unsigned long long _ULLI,
                              long long _LLI,
                              unsigned long _ULI)
            { return __fma((double)_ULLI, (double)_LLI, (double)_ULI); }
            inline double fma(unsigned long long _ULLI,
                              long long _LLI1,
                              long long _LLI2)
            { return __fma((double)_ULLI, (double)_LLI1, (double)_LLI2); }
            inline double fma(unsigned long long _ULLI1,
                              long long _LLI,
                              unsigned long long _ULLI2)
            { return __fma((double)_ULLI1, (double)_LLI, (double)_ULLI2); }

            inline double fma(unsigned long long _ULLI1,
                              unsigned long long _ULLI2,
                              float _F)
            { return __fma((double)_ULLI1, (double)_ULLI2, (double)_F); }
            inline double fma(unsigned long long _ULLI1,
                              unsigned long long _ULLI2,
                              double _D)
            { return __fma((double)_ULLI1, (double)_ULLI2, _D); }
            inline long double fma(unsigned long long _ULLI1,
                              unsigned long long _ULLI2,
                              long double _L)
            { return fmal((long double)_ULLI1, (long double)_ULLI2, _L); }
            inline double fma(unsigned long long _ULLI1,
                              unsigned long long _ULLI2,
                              int _I)
            { return __fma((double)_ULLI1, (double)_ULLI2, (double)_I); }
            inline double fma(unsigned long long _ULLI1,
                              unsigned long long _ULLI2,
                              unsigned int _UI)
            { return __fma((double)_ULLI1, (double)_ULLI2, (double)_UI); }
            inline double fma(unsigned long long _ULLI1,
                              unsigned long long _ULLI2,
                              long _LI)
            { return __fma((double)_ULLI1, (double)_ULLI2, (double)_LI); }
            inline double fma(unsigned long long _ULLI1,
                              unsigned long long _ULLI2,
                              unsigned long _ULI)
            { return __fma((double)_ULLI1, (double)_ULLI2, (double)_ULI); }
            inline double fma(unsigned long long _ULLI1,
                              unsigned long long _ULLI2,
                              long long _LLI)
            { return __fma((double)_ULLI1, (double)_ULLI2, (double)_LLI); }
            inline double fma(unsigned long long _ULLI1,
                              unsigned long long _ULLI2,
                              unsigned long long _ULLI3)
            { return __fma((double)_ULLI1, (double)_ULLI2, (double)_ULLI3);}


         inline float log2(float _F)
         {return log2f(_F);}
         inline long double log2(long double _L)
         {return log2l(_L);}
         inline double log2(int _I)
         {return __log2((double)_I);}
         inline double log2(unsigned int _UI)
         {return __log2((double)_UI);}
         inline double log2(long _LI)
         {return __log2((double)_LI);}
         inline double log2(unsigned long _ULI)
         {return __log2((double)_ULI);}

            inline double log2(long long _LLI)
            {return __log2((double)_LLI);}
            inline double log2(unsigned long long _ULLI)
            {return __log2((double)_ULLI);}


         inline float lgamma(float _F)
         {return lgammaf(_F);}
         inline long double lgamma(long double _L)
         {return lgammal(_L);}
         inline double lgamma(int _I)
         {return __lgamma((double)_I);}
         inline double lgamma(unsigned int _UI)
         {return __lgamma((double)_UI);}
         inline double lgamma(long _LI)
         {return __lgamma((double)_LI);}
         inline double lgamma(unsigned long _ULI)
         {return __lgamma((double)_ULI);}

            inline double lgamma(long long _LLI)
            {return __lgamma((double)_LLI);}
            inline double lgamma(unsigned long long _ULLI)
            {return __lgamma((double)_ULLI);}


         inline float erf(float _F)
         {return erff(_F);}
         inline long double erf(long double _L)
         {return erfl(_L);}
         inline double erf(int _I)
         {return __erf((double)_I);}
         inline double erf(unsigned int _UI)
         {return __erf((double)_UI);}
         inline double erf(long _LI)
         {return __erf((double)_LI);}
         inline double erf(unsigned long _ULI)
         {return __erf((double)_ULI);}

            inline double erf(long long _LLI)
            {return __erf((double)_LLI);}
            inline double erf(unsigned long long _ULLI)
            {return __erf((double)_ULLI);}


         inline float erfc(float _F)
         {return erfcf(_F);}
         inline long double erfc(long double _L)
         {return erfcl(_L);}
         inline double erfc(int _I)
         {return __erfc((double)_I);}
         inline double erfc(unsigned int _UI)
         {return __erfc((double)_UI);}
         inline double erfc(long _LI)
         {return __erfc((double)_LI);}
         inline double erfc(unsigned long _ULI)
         {return __erfc((double)_ULI);}

            inline double erfc(long long _LLI)
            {return __erfc((double)_LLI);}
            inline double erfc(unsigned long long _ULLI)
            {return __erfc((double)_ULLI);}


         inline float hypot(float _F1, float _F2)
         {return hypotf(_F1, _F2);}
         inline long double hypot(long double _L1,
                                  long double _L2)
         {return hypotl(_L1, _L2);}

         inline double hypot(float _F, double _D)
         { return __hypot((double)_F, _D); }
         inline long double hypot(float _F, long double _L)
         { return hypotl((long double)_F, _L); }
         inline double hypot(float _F, int _I)
         { return __hypot((double)_F, (double)_I); }
         inline double hypot(float _F, unsigned int _UI)
         { return __hypot((double)_F, (double)_UI); }
         inline double hypot(float _F, long _LI)
         { return __hypot((double)_F, (double)_LI); }
         inline double hypot(float _F, unsigned long _ULI)
         { return __hypot((double)_F, (double)_ULI); }

            inline double hypot(float _F, long long _LLI)
            { return __hypot((double)_F, (double)_LLI); }
            inline double hypot(float _F,
                                unsigned long long _ULLI)
            { return __hypot((double)_F, (double)_ULLI); }


         inline double hypot(double _D, float _F)
         { return __hypot(_D, (double)_F); }
         inline long double hypot(double _D, long double _L)
         { return hypotl((long double)_D, _L); }
         inline double hypot(double _D, int _I)
         { return __hypot(_D, (double)_I); }
         inline double hypot(double _D, unsigned int _UI)
         { return __hypot(_D, (double)_UI); }
         inline double hypot(double _D, long _LI)
         { return __hypot(_D, (double)_LI); }
         inline double hypot(double _D, unsigned long _ULI)
         { return __hypot(_D, (double)_ULI); }

            inline double hypot(double _D, long long _LLI)
            { return __hypot(_D, (double)_LLI); }
            inline double hypot(double _D,
                                unsigned long long _ULLI)
            { return __hypot(_D, (double)_ULLI); }


         inline long double hypot(long double _L, float _F)
         { return hypotl(_L, (long double)_F); }
         inline long double hypot(long double _L, double _D)
         { return hypotl(_L, (long double)_D); }
         inline long double hypot(long double _L, int _I)
         { return hypotl(_L, (long double)_I); }
         inline long double hypot(long double _L,
                                  unsigned int _UI)
         { return hypotl(_L, (long double)_UI); }
         inline long double hypot(long double _L, long _LI)
         { return hypotl(_L, (long double)_LI); }
         inline long double hypot(long double _L,
                                  unsigned long _ULI)
         { return hypotl(_L, (long double)_ULI); }

            inline long double hypot(long double _L,
                                     long long _LLI)
            { return hypotl(_L, (long double)_LLI); }
            inline long double hypot(long double _L,
                                     unsigned long long _ULLI)
            { return hypotl(_L, (long double)_ULLI); }


         inline double hypot(int _I, float _F)
         { return __hypot((double)_I, (double)_F); }
         inline double hypot(int _I, double _D)
         { return __hypot((double)_I, _D); }
         inline long double hypot(int _I, long double _L)
         { return hypotl((long double)_I, _L); }
         inline double hypot(int _I1, int _I2)
         { return __hypot((double)_I1, (double)_I2); }
         inline double hypot(int _I, unsigned int _UI)
         { return __hypot((double)_I, (double)_UI); }
         inline double hypot(int _I, long _LI)
         { return __hypot((double)_I, (double)_LI); }
         inline double hypot(int _I, unsigned long _ULI)
         { return __hypot((double)_I, (double)_ULI); }

            inline double hypot(int _I, long long _LLI)
            { return __hypot((double)_I, (double)_LLI); }
            inline double hypot(int _I,
                                unsigned long long _ULLI)
            { return __hypot((double)_I, (double)_ULLI); }


         inline double hypot(unsigned int _UI, float _F)
         { return __hypot((double)_UI, (double)_F); }
         inline double hypot(unsigned int _UI, double _D)
         { return __hypot((double)_UI, _D); }
         inline long double hypot(unsigned int _UI,
                                  long double _L)
         { return hypotl((long double)_UI, _L); }
         inline double hypot(unsigned int _UI, int _I)
         { return __hypot((double)_UI, (double)_I); }
         inline double hypot(unsigned int _UI1,
                             unsigned int _UI2)
         { return __hypot((double)_UI1, (double)_UI2); }
         inline double hypot(unsigned int _UI, long _LI)
         { return __hypot((double)_UI, (double)_LI); }
         inline double hypot(unsigned int _UI,
                             unsigned long _ULI)
         { return __hypot((double)_UI, (double)_ULI); }

            inline double hypot(unsigned int _UI,
                                long long _LLI)
            { return __hypot((double)_UI, (double)_LLI); }
            inline double hypot(unsigned int _UI,
                                unsigned long long _ULLI)
            { return __hypot((double)_UI, (double)_ULLI); }


         inline double hypot(long _LI, float _F)
         { return __hypot((double)_LI, (double)_F); }
         inline double hypot(long _LI, double _D)
         { return __hypot((double)_LI, _D); }
         inline long double hypot(long _LI, long double _L)
         { return hypotl((long double)_LI, _L); }
         inline double hypot(long _LI, int _I)
         { return __hypot((double)_LI, (double)_I); }
         inline double hypot(long _LI, unsigned int _UI)
         { return __hypot((double)_LI, (double)_UI); }
         inline double hypot(long _LI1, long _LI2)
         { return __hypot((double)_LI1, (double)_LI2); }
         inline double hypot(long _LI, unsigned long _ULI)
         { return __hypot((double)_LI, (double)_ULI); }

            inline double hypot(long _LI, long long _LLI)
            { return __hypot((double)_LI, (double)_LLI); }
            inline double hypot(long _LI,
                                unsigned long long _ULLI)
            { return __hypot((double)_LI, (double)_ULLI); }


         inline double hypot(unsigned long _ULI, float _F)
         { return __hypot((double)_ULI, (double)_F); }
         inline double hypot(unsigned long _ULI, double _D)
         { return __hypot((double)_ULI, _D); }
         inline long double hypot(unsigned long _ULI,
                                  long double _L)
         { return hypotl((long double)_ULI, _L); }
         inline double hypot(unsigned long _ULI, int _I)
         { return __hypot((double)_ULI, (double)_I); }
         inline double hypot(unsigned long _ULI,
                             unsigned int _UI)
         { return __hypot((double)_ULI, (double)_UI); }
         inline double hypot(unsigned long _ULI, long _LI)
         { return __hypot((double)_ULI, (double)_LI); }
         inline double hypot(unsigned long _ULI1,
                             unsigned long _ULI2)
         { return __hypot((double)_ULI1, (double)_ULI2); }

            inline double hypot(unsigned long _ULI,
                                long long _LLI)
            { return __hypot((double)_ULI, (double)_LLI); }
            inline double hypot(unsigned long _ULI,
                                unsigned long long _ULLI)
            { return __hypot((double)_ULI, (double)_ULLI); }



            inline double hypot(long long _LLI, float _F)
            { return __hypot((double)_LLI, (double)_F); }
            inline double hypot(long long _LLI, double _D)
            { return __hypot((double)_LLI, _D); }
            inline long double hypot(long long _LLI,
                                     long double _L)
            { return hypotl((long double)_LLI, _L); }
            inline double hypot(long long _LLI, int _I)
            { return __hypot((double)_LLI, (double)_I); }
            inline double hypot(long long _LLI,
                                unsigned int _UI)
            { return __hypot((double)_LLI, (double)_UI); }
            inline double hypot(long long _LLI, long _LI)
            { return __hypot((double)_LLI, (double)_LI); }
            inline double hypot(long long _LLI,
                                unsigned long _ULI)
            { return __hypot((double)_LLI, (double)_ULI); }
            inline double hypot(long long _LLI1,
                                long long _LLI2)
            { return __hypot((double)_LLI1, (double)_LLI2);}
            inline double hypot(long long _LLI,
                                unsigned long long _ULLI)
            { return __hypot((double)_LLI, (double)_ULLI); }

            inline double hypot(unsigned long long _ULLI,
                                float _F)
            { return __hypot((double)_ULLI, (double)_F); }
            inline double hypot(unsigned long long _ULLI,
                                double _D)
            { return __hypot((double)_ULLI, _D); }
            inline long double hypot(unsigned long long _ULLI,
                                     long double _L)
            { return hypotl((long double)_ULLI, _L); }
            inline double hypot(unsigned long long _ULLI,
                                int _I)
            { return __hypot((double)_ULLI, (double)_I); }
            inline double hypot(unsigned long long _ULLI,
                                unsigned int _UI)
            { return __hypot((double)_ULLI, (double)_UI); }
            inline double hypot(unsigned long long _ULLI,
                                long _LI)
            { return __hypot((double)_ULLI, (double)_LI); }
            inline double hypot(unsigned long long _ULLI,
                                unsigned long _ULI)
            { return __hypot((double)_ULLI, (double)_ULI); }
            inline double hypot(unsigned long long _ULLI,
                                long long _LLI)
            { return __hypot((double)_ULLI, (double)_LLI); }
            inline double hypot(unsigned long long _ULLI1,
                                unsigned long long _ULLI2)
            { return __hypot((double)_ULLI1, (double)_ULLI2); }





         inline double acos(int _I)
         {return __acos((double)_I);}
         inline double acos(unsigned int _UI)
         {return __acos((double)_UI);}
         inline double acos(long _LI)
         {return __acos((double)_LI);}
         inline double acos(unsigned long _ULI)
         {return __acos((double)_ULI);}

            inline double acos(long long _LLI)
            {return __acos((double)_LLI);}
            inline double acos(unsigned long long _ULLI)
            {return __acos((double)_ULLI);}


         inline double asin(int _I)
         {return __asin((double)_I);}
         inline double asin(unsigned int _UI)
         {return __asin((double)_UI);}
         inline double asin(long _LI)
         {return __asin((double)_LI);}
         inline double asin(unsigned long _ULI)
         {return __asin((double)_ULI);}

            inline double asin(long long _LLI)
            {return __asin((double)_LLI);}
            inline double asin(unsigned long long _ULLI)
            {return __asin((double)_ULLI);}


         inline double atan(int _I)
         {return __atan((double)_I);}
         inline double atan(unsigned int _UI)
         {return __atan((double)_UI);}
         inline double atan(long _LI)
         {return __atan((double)_LI);}
         inline double atan(unsigned long _ULI)
         {return __atan((double)_ULI);}

            inline double atan(long long _LLI)
            {return __atan((double)_LLI);}
            inline double atan(unsigned long long _ULLI)
            {return __atan((double)_ULLI);}



         inline double atan2(float _F, double _D)
         { return __atan2((double)_F, _D); }
         inline long double atan2(float _F, long double _L)
         { return atan2l((long double)_F, _L); }
         inline double atan2(float _F, int _I)
         { return __atan2((double)_F, (double)_I); }
         inline double atan2(float _F, unsigned int _UI)
         { return __atan2((double)_F, (double)_UI); }
         inline double atan2(float _F, long _LI)
         { return __atan2((double)_F, (double)_LI); }
         inline double atan2(float _F, unsigned long _ULI)
         { return __atan2((double)_F, (double)_ULI); }

            inline double atan2(float _F, long long _LLI)
            { return __atan2((double)_F, (double)_LLI); }
            inline double atan2(float _F,
                                unsigned long long _ULLI)
            { return __atan2((double)_F, (double)_ULLI); }


         inline double atan2(double _D, float _F)
         { return __atan2(_D, (double)_F); }
         inline long double atan2(double _D, long double _L)
         { return atan2l((long double)_D, _L); }
         inline double atan2(double _D, int _I)
         { return __atan2(_D, (double)_I); }
         inline double atan2(double _D, unsigned int _UI)
         { return __atan2(_D, (double)_UI); }
         inline double atan2(double _D, long _LI)
         { return __atan2(_D, (double)_LI); }
         inline double atan2(double _D, unsigned long _ULI)
         { return __atan2(_D, (double)_ULI); }

         inline double atan2(double _D, long long _LLI)
            { return __atan2(_D, (double)_LLI); }
            inline double atan2(double _D,
                                unsigned long long _ULLI)
            { return __atan2(_D, (double)_ULLI); }


         inline long double atan2(long double _L, float _F)
         { return atan2l(_L, (long double)_F); }
         inline long double atan2(long double _L, double _D)
         { return atan2l(_L, (long double)_D); }
         inline long double atan2(long double _L, int _I)
         { return atan2l(_L, (long double)_I); }
         inline long double atan2(long double _L,
                                  unsigned int _UI)
         { return atan2l(_L, (long double)_UI); }
         inline long double atan2(long double _L, long _LI)
         { return atan2l(_L, (long double)_LI); }
         inline long double atan2(long double _L,
                                  unsigned long _ULI)
         { return atan2l(_L, (long double)_ULI); }

            inline long double atan2(long double _L,
                                     long long _LLI)
            { return atan2l(_L, (long double)_LLI); }
            inline long double atan2(long double _L,
                                     unsigned long long _ULLI)
            { return atan2l(_L, (long double)_ULLI); }


         inline double atan2(int _I, float _F)
         { return __atan2((double)_I, (double)_F); }
         inline double atan2(int _I, double _D)
         { return __atan2((double)_I, _D); }
         inline long double atan2(int _I, long double _L)
         { return atan2l((long double)_I, _L); }
         inline double atan2(int _I1, int _I2)
         { return __atan2((double)_I1, (double)_I2); }
         inline double atan2(int _I, unsigned int _UI)
         { return __atan2((double)_I, (double)_UI); }
         inline double atan2(int _I, long _LI)
         { return __atan2((double)_I, (double)_LI); }
         inline double atan2(int _I, unsigned long _ULI)
         { return __atan2((double)_I, (double)_ULI); }

            inline double atan2(int _I, long long _LLI)
            { return __atan2((double)_I, (double)_LLI); }
            inline double atan2(int _I,
                                unsigned long long _ULLI)
            { return __atan2((double)_I, (double)_ULLI); }


         inline double atan2(unsigned int _UI, float _F)
         { return __atan2((double)_UI, (double)_F); }
         inline double atan2(unsigned int _UI, double _D)
         { return __atan2((double)_UI, _D); }
         inline long double atan2(unsigned int _UI,
                                  long double _L)
         { return atan2l((long double)_UI, _L); }
         inline double atan2(unsigned int _UI, int _I)
         { return __atan2((double)_UI, (double)_I); }
         inline double atan2(unsigned int _UI1,
                             unsigned int _UI2)
         { return __atan2((double)_UI1, (double)_UI2); }
         inline double atan2(unsigned int _UI, long _LI)
         { return __atan2((double)_UI, (double)_LI); }
         inline double atan2(unsigned int _UI,
                             unsigned long _ULI)
         { return __atan2((double)_UI, (double)_ULI); }

            inline double atan2(unsigned int _UI,
                                long long _LLI)
            { return __atan2((double)_UI, (double)_LLI); }
            inline double atan2(unsigned int _UI,
                                unsigned long long _ULLI)
            { return __atan2((double)_UI, (double)_ULLI); }


         inline double atan2(long _LI, float _F)
         { return __atan2((double)_LI, (double)_F); }
         inline double atan2(long _LI, double _D)
         { return __atan2((double)_LI, _D); }
         inline long double atan2(long _LI, long double _L)
         { return atan2l((long double)_LI, _L); }
         inline double atan2(long _LI, int _I)
         { return __atan2((double)_LI, (double)_I); }
         inline double atan2(long _LI, unsigned int _UI)
         { return __atan2((double)_LI, (double)_UI); }
         inline double atan2(long _LI1, long _LI2)
         { return __atan2((double)_LI1, (double)_LI2); }
         inline double atan2(long _LI, unsigned long _ULI)
         { return __atan2((double)_LI, (double)_ULI); }

            inline double atan2(long _LI, long long _LLI)
            { return __atan2((double)_LI, (double)_LLI); }
            inline double atan2(long _LI,
                                unsigned long long _ULLI)
            { return __atan2((double)_LI, (double)_ULLI); }


         inline double atan2(unsigned long _ULI, float _F)
         { return __atan2((double)_ULI, (double)_F); }
         inline double atan2(unsigned long _ULI, double _D)
         { return __atan2((double)_ULI, _D); }
         inline long double atan2(unsigned long _ULI,
                                  long double _L)
         { return atan2l((long double)_ULI, _L); }
         inline double atan2(unsigned long _ULI, int _I)
         { return __atan2((double)_ULI, (double)_I); }
         inline double atan2(unsigned long _ULI,
                             unsigned int _UI)
         { return __atan2((double)_ULI, (double)_UI); }
         inline double atan2(unsigned long _ULI, long _LI)
         { return __atan2((double)_ULI, (double)_LI); }
         inline double atan2(unsigned long _ULI1,
                             unsigned long _ULI2)
         { return __atan2((double)_ULI1, (double)_ULI2); }

            inline double atan2(unsigned long _ULI,
                                long long _LLI)
            { return __atan2((double)_ULI, (double)_LLI); }
            inline double atan2(unsigned long _ULI,
                                unsigned long long _ULLI)
            { return __atan2((double)_ULI, (double)_ULLI); }



            inline double atan2(long long _LLI, float _F)
            { return __atan2((double)_LLI, (double)_F); }
            inline double atan2(long long _LLI, double _D)
            { return __atan2((double)_LLI, _D); }
            inline long double atan2(long long _LLI,
                                     long double _L)
            { return atan2l((long double)_LLI, _L); }
            inline double atan2(long long _LLI, int _I)
            { return __atan2((double)_LLI, (double)_I); }
            inline double atan2(long long _LLI,
                                unsigned int _UI)
            { return __atan2((double)_LLI, (double)_UI); }
            inline double atan2(long long _LLI, long _LI)
            { return __atan2((double)_LLI, (double)_LI); }
            inline double atan2(long long _LLI,
                                unsigned long _ULI)
            { return __atan2((double)_LLI, (double)_ULI); }
            inline double atan2(long long _LLI1,
                                long long _LLI2)
            { return __atan2((double)_LLI1, (double)_LLI2); }
            inline double atan2(long long _LLI,
                                unsigned long long _ULLI)
            { return __atan2((double)_LLI, (double)_ULLI); }

            inline double atan2(unsigned long long _ULLI,
                                float _F)
            { return __atan2((double)_ULLI, (double)_F); }
            inline double atan2(unsigned long long _ULLI,
                                double _D)
            { return __atan2((double)_ULLI, _D); }
            inline long double atan2(unsigned long long _ULLI,
                                     long double _L)
            { return atan2l((long double)_ULLI, _L); }
            inline double atan2(unsigned long long _ULLI,
                                int _I)
            { return __atan2((double)_ULLI, (double)_I); }
            inline double atan2(unsigned long long _ULLI,
                                unsigned int _UI)
            { return __atan2((double)_ULLI, (double)_UI); }
            inline double atan2(unsigned long long _ULLI,
                                long _LI)
            { return __atan2((double)_ULLI, (double)_LI); }
            inline double atan2(unsigned long long _ULLI,
                                unsigned long _ULI)
            { return __atan2((double)_ULLI, (double)_ULI); }
            inline double atan2(unsigned long long _ULLI,
                                long long _LLI)
            { return __atan2((double)_ULLI, (double)_LLI); }
            inline double atan2(unsigned long long _ULLI1,
                                unsigned long long _ULLI2)
            { return __atan2((double)_ULLI1, (double)_ULLI2); }


         inline double ceil(int _I)
         {return __ceil((double)_I);}
         inline double ceil(unsigned int _UI)
         {return __ceil((double)_UI);}
         inline double ceil(long _LI)
         {return __ceil((double)_LI);}
         inline double ceil(unsigned long _ULI)
         {return __ceil((double)_ULI);}

            inline double ceil(long long _LLI)
            {return __ceil((double)_LLI);}
            inline double ceil(unsigned long long _ULLI)
            {return __ceil((double)_ULLI);}


         inline double cos(int _I)
         {return __cos((double)_I);}
         inline double cos(unsigned int _UI)
         {return __cos((double)_UI);}
         inline double cos(long _LI)
         {return __cos((double)_LI);}
         inline double cos(unsigned long _ULI)
         {return __cos((double)_ULI);}

            inline double cos(long long _LLI)
            {return __cos((double)_LLI);}
            inline double cos(unsigned long long _ULLI)
            {return __cos((double)_ULLI);}


         inline double cosh(int _I)
         {return __cosh((double)_I);}
         inline double cosh(unsigned int _UI)
         {return __cosh((double)_UI);}
         inline double cosh(long _LI)
         {return __cosh((double)_LI);}
         inline double cosh(unsigned long _ULI)
         {return __cosh((double)_ULI);}

            inline double cosh(long long _LLI)
            {return __cosh((double)_LLI);}
            inline double cosh(unsigned long long _ULLI)
            {return __cosh((double)_ULLI);}


         inline double exp(int _I)
         {return __exp((double)_I);}
         inline double exp(unsigned int _UI)
         {return __exp((double)_UI);}
         inline double exp(long _LI)
         {return __exp((double)_LI);}
         inline double exp(unsigned long _ULI)
         {return __exp((double)_ULI);}

            inline double exp(long long _LLI)
            {return __exp((double)_LLI);}
            inline double exp(unsigned long long _ULLI)
            {return __exp((double)_ULLI);}


         inline double fabs(int _I)
         {return __fabs((double)_I);}
         inline double fabs(unsigned int _UI)
         {return __fabs((double)_UI);}
         inline double fabs(long _LI)
         {return __fabs((double)_LI);}
         inline double fabs(unsigned long _ULI)
         {return __fabs((double)_ULI);}

            inline double fabs(long long _LLI)
            {return __fabs((double)_LLI);}
            inline double fabs(unsigned long long _ULLI)
            {return __fabs((double)_ULLI);}


         inline double floor(int _I)
         {return __floor((double)_I);}
         inline double floor(unsigned int _UI)
         {return __floor((double)_UI);}
         inline double floor(long _LI)
         {return __floor((double)_LI);}
         inline double floor(unsigned long _ULI)
         {return __floor((double)_ULI);}

            inline double floor(long long _LLI)
            {return __floor((double)_LLI);}
            inline double floor(unsigned long long _ULLI)
            {return __floor((double)_ULLI);}



         inline double fmod(float _F, double _D)
         { return __fmod((double)_F, _D); }
         inline long double fmod(float _F, long double _L)
         { return fmodl((long double)_F, _L); }
         inline double fmod(float _F, int _I)
         { return __fmod((double)_F, (double)_I); }
         inline double fmod(float _F, unsigned int _UI)
         { return __fmod((double)_F, (double)_UI); }
         inline double fmod(float _F, long _LI)
         { return __fmod((double)_F, (double)_LI); }
         inline double fmod(float _F, unsigned long _ULI)
         { return __fmod((double)_F, (double)_ULI); }

            inline double fmod(float _F, long long _LLI)
            { return __fmod((double)_F, (double)_LLI); }
            inline double fmod(float _F,
                               unsigned long long _ULLI)
            { return __fmod((double)_F, (double)_ULLI); }


         inline double fmod(double _D, float _F)
         { return __fmod(_D, (double)_F); }
         inline long double fmod(double _D, long double _L)
         { return fmodl((long double)_D, _L); }
         inline double fmod(double _D, int _I)
         { return __fmod(_D, (double)_I); }
         inline double fmod(double _D, unsigned int _UI)
         { return __fmod(_D, (double)_UI); }
         inline double fmod(double _D, long _LI)
         { return __fmod(_D, (double)_LI); }
         inline double fmod(double _D, unsigned long _ULI)
         { return __fmod(_D, (double)_ULI); }

         inline double fmod(double _D, long long _LLI)
            { return __fmod(_D, (double)_LLI); }
            inline double fmod(double _D,
                               unsigned long long _ULLI)
            { return __fmod(_D, (double)_ULLI); }


         inline long double fmod(long double _L, float _F)
         { return fmodl(_L, (long double)_F); }
         inline long double fmod(long double _L, double _D)
         { return fmodl(_L, (long double)_D); }
         inline long double fmod(long double _L, int _I)
         { return fmodl(_L, (long double)_I); }
         inline long double fmod(long double _L,
                                 unsigned int _UI)
         { return fmodl(_L, (long double)_UI); }
         inline long double fmod(long double _L, long _LI)
         { return fmodl(_L, (long double)_LI); }
         inline long double fmod(long double _L,
                                 unsigned long _ULI)
         { return fmodl(_L, (long double)_ULI); }

            inline long double fmod(long double _L,
                                    long long _LLI)
            { return fmodl(_L, (long double)_LLI); }
            inline long double fmod(long double _L,
                                    unsigned long long _ULLI)
            { return fmodl(_L, (long double)_ULLI); }


         inline double fmod(int _I, float _F)
         { return __fmod((double)_I, (double)_F); }
         inline double fmod(int _I, double _D)
         { return __fmod((double)_I, _D); }
         inline long double fmod(int _I, long double _L)
         { return fmodl((long double)_I, _L); }
         inline double fmod(int _I1, int _I2)
         { return __fmod((double)_I1, (double)_I2); }
         inline double fmod(int _I, unsigned int _UI)
         { return __fmod((double)_I, (double)_UI); }
         inline double fmod(int _I, long _LI)
         { return __fmod((double)_I, (double)_LI); }
         inline double fmod(int _I, unsigned long _ULI)
         { return __fmod((double)_I, (double)_ULI); }

            inline double fmod(int _I, long long _LLI)
            { return __fmod((double)_I, (double)_LLI); }
            inline double fmod(int _I,
                               unsigned long long _ULLI)
            { return __fmod((double)_I, (double)_ULLI); }


         inline double fmod(unsigned int _UI, float _F)
         { return __fmod((double)_UI, (double)_F); }
         inline double fmod(unsigned int _UI, double _D)
         { return __fmod((double)_UI, _D); }
         inline long double fmod(unsigned int _UI,
                                 long double _L)
         { return fmodl((long double)_UI, _L); }
         inline double fmod(unsigned int _UI, int _I)
         { return __fmod((double)_UI, (double)_I); }
         inline double fmod(unsigned int _UI1,
                            unsigned int _UI2)
         { return __fmod((double)_UI1, (double)_UI2); }
         inline double fmod(unsigned int _UI, long _LI)
         { return __fmod((double)_UI, (double)_LI); }
         inline double fmod(unsigned int _UI,
                            unsigned long _ULI)
         { return __fmod((double)_UI, (double)_ULI); }

            inline double fmod(unsigned int _UI,
                               long long _LLI)
            { return __fmod((double)_UI, (double)_LLI); }
            inline double fmod(unsigned int _UI,
                               unsigned long long _ULLI)
            { return __fmod((double)_UI, (double)_ULLI); }


         inline double fmod(long _LI, float _F)
         { return __fmod((double)_LI, (double)_F); }
         inline double fmod(long _LI, double _D)
         { return __fmod((double)_LI, _D); }
         inline long double fmod(long _LI, long double _L)
         { return fmodl((long double)_LI, _L); }
         inline double fmod(long _LI, int _I)
         { return __fmod((double)_LI, (double)_I); }
         inline double fmod(long _LI, unsigned int _UI)
         { return __fmod((double)_LI, (double)_UI); }
         inline double fmod(long _LI1, long _LI2)
         { return __fmod((double)_LI1, (double)_LI2); }
         inline double fmod(long _LI, unsigned long _ULI)
         { return __fmod((double)_LI, (double)_ULI); }

            inline double fmod(long _LI, long long _LLI)
            { return __fmod((double)_LI, (double)_LLI); }
            inline double fmod(long _LI,
                               unsigned long long _ULLI)
            { return __fmod((double)_LI, (double)_ULLI); }


         inline double fmod(unsigned long _ULI, float _F)
         { return __fmod((double)_ULI, (double)_F); }
         inline double fmod(unsigned long _ULI, double _D)
         { return __fmod((double)_ULI, _D); }
         inline long double fmod(unsigned long _ULI,
                                 long double _L)
         { return fmodl((long double)_ULI, _L); }
         inline double fmod(unsigned long _ULI, int _I)
         { return __fmod((double)_ULI, (double)_I); }
         inline double fmod(unsigned long _ULI,
                            unsigned int _UI)
         { return __fmod((double)_ULI, (double)_UI); }
         inline double fmod(unsigned long _ULI, long _LI)
         { return __fmod((double)_ULI, (double)_LI); }
         inline double fmod(unsigned long _ULI1,
                            unsigned long _ULI2)
         { return __fmod((double)_ULI1, (double)_ULI2); }

            inline double fmod(unsigned long _ULI,
                               long long _LLI)
            { return __fmod((double)_ULI, (double)_LLI); }
            inline double fmod(unsigned long _ULI,
                               unsigned long long _ULLI)
            { return __fmod((double)_ULI, (double)_ULLI); }



            inline double fmod(long long _LLI, float _F)
            { return __fmod((double)_LLI, (double)_F); }
            inline double fmod(long long _LLI, double _D)
            { return __fmod((double)_LLI, _D); }
            inline long double fmod(long long _LLI,
                                    long double _L)
            { return fmodl((long double)_LLI, _L); }
            inline double fmod(long long _LLI, int _I)
            { return __fmod((double)_LLI, (double)_I); }
            inline double fmod(long long _LLI,
                               unsigned int _UI)
            { return __fmod((double)_LLI, (double)_UI); }
            inline double fmod(long long _LLI, long _LI)
            { return __fmod((double)_LLI, (double)_LI); }
            inline double fmod(long long _LLI,
                               unsigned long _ULI)
            { return __fmod((double)_LLI, (double)_ULI); }
            inline double fmod(long long _LLI1,
                               long long _LLI2)
            { return __fmod((double)_LLI1, (double)_LLI2); }
            inline double fmod(long long _LLI,
                               unsigned long long _ULLI)
            { return __fmod((double)_LLI, (double)_ULLI); }

            inline double fmod(unsigned long long _ULLI,
                               float _F)
            { return __fmod((double)_ULLI, (double)_F); }
            inline double fmod(unsigned long long _ULLI,
                               double _D)
            { return __fmod((double)_ULLI, _D); }
            inline long double fmod(unsigned long long _ULLI,
                                    long double _L)
            { return fmodl((long double)_ULLI, _L); }
            inline double fmod(unsigned long long _ULLI,
                               int _I)
            { return __fmod((double)_ULLI, (double)_I); }
            inline double fmod(unsigned long long _ULLI,
                               unsigned int _UI)
            { return __fmod((double)_ULLI, (double)_UI); }
            inline double fmod(unsigned long long _ULLI,
                               long _LI)
            { return __fmod((double)_ULLI, (double)_LI); }
            inline double fmod(unsigned long long _ULLI,
                               unsigned long _ULI)
            { return __fmod((double)_ULLI, (double)_ULI); }
            inline double fmod(unsigned long long _ULLI,
                               long long _LLI)
            { return __fmod((double)_ULLI, (double)_LLI); }
            inline double fmod(unsigned long long _ULLI1,
                               unsigned long long _ULLI2)
            { return __fmod((double)_ULLI1, (double)_ULLI2); }


         inline double frexp(int _I, int *_Iptr)
         {return __frexp((double)_I, _Iptr);}
         inline double frexp(unsigned int _UI, int *_Iptr)
         {return __frexp((double)_UI, _Iptr);}
         inline double frexp(long _LI, int *_Iptr)
         {return __frexp((double)_LI, _Iptr);}
         inline double frexp(unsigned long _ULI, int *_Iptr)
         {return __frexp((double)_ULI, _Iptr);}

            inline double frexp(long long _LLI, int *_Iptr)
            {return __frexp((double)_LLI, _Iptr);}
            inline double frexp(unsigned long long _ULLI, int *_Iptr)
            {return __frexp((double)_ULLI, _Iptr);}


         inline double ldexp(int _I1, int _I2)
         {return __ldexp((double)_I1, _I2);}
         inline double ldexp(unsigned int _UI, int _I)
         {return __ldexp((double)_UI, _I);}
         inline double ldexp(long _LI, int _I)
         {return __ldexp((double)_LI, _I);}
         inline double ldexp(unsigned long _ULI, int _I)
         {return __ldexp((double)_ULI, _I);}

            inline double ldexp(long long _LLI, int _I)
            {return __ldexp((double)_LLI, _I);}
            inline double ldexp(unsigned long long _ULLI, int _I)
            {return __ldexp((double)_ULLI, _I);}


         inline double log(int _I)
         {return __log((double)_I);}
         inline double log(unsigned int _UI)
         {return __log((double)_UI);}
         inline double log(long _LI)
         {return __log((double)_LI);}
         inline double log(unsigned long _ULI)
         {return __log((double)_ULI);}

            inline double log(long long _LLI)
            {return __log((double)_LLI);}
            inline double log(unsigned long long _ULLI)
            {return __log((double)_ULLI);}


         inline double log10(int _I)
         {return __log10((double)_I);}
         inline double log10(unsigned int _UI)
         {return __log10((double)_UI);}
         inline double log10(long _LI)
         {return __log10((double)_LI);}
         inline double log10(unsigned long _ULI)
         {return __log10((double)_ULI);}

            inline double log10(long long _LLI)
            {return __log10((double)_LLI);}
            inline double log10(unsigned long long _ULLI)
            {return __log10((double)_ULLI);}



         inline double pow(float _F, double _D)
         { return __pow((double)_F, _D); }
         inline long double pow(float _F, long double _L)
         { return powl((long double)_F, _L); }
         inline double pow(float _F, unsigned int _UI)
         { return __pow((double)_F, (double)_UI); }
         inline double pow(float _F, long _LI)
         { return __pow((double)_F, (double)_LI); }
         inline double pow(float _F, unsigned long _ULI)
         { return __pow((double)_F, (double)_ULI); }

            inline double pow(float _F, long long _LLI)
            { return __pow((double)_F, (double)_LLI); }
            inline double pow(float _F,
                              unsigned long long _ULLI)
            { return __pow((double)_F, (double)_ULLI); }


         inline double pow(double _D, float _F)
         { return __pow(_D, (double)_F); }
         inline long double pow(double _D, long double _L)
         { return powl((long double)_D, _L); }
         inline double pow(double _D, unsigned int _UI)
         { return __pow(_D, (double)_UI); }
         inline double pow(double _D, long _LI)
         { return __pow(_D, (double)_LI); }
         inline double pow(double _D, unsigned long _ULI)
         { return __pow(_D, (double)_ULI); }

         inline double pow(double _D, long long _LLI)
            { return __pow(_D, (double)_LLI); }
            inline double pow(double _D,
                              unsigned long long _ULLI)
            { return __pow(_D, (double)_ULLI); }


         inline long double pow(long double _L, float _F)
         { return powl(_L, (long double)_F); }
         inline long double pow(long double _L, double _D)
         { return powl(_L, (long double)_D); }
         inline long double pow(long double _L,
                                unsigned int _UI)
         { return powl(_L, (long double)_UI); }
         inline long double pow(long double _L, long _LI)
         { return powl(_L, (long double)_LI); }
         inline long double pow(long double _L,
                                 unsigned long _ULI)
         { return powl(_L, (long double)_ULI); }

            inline long double pow(long double _L,
                                   long long _LLI)
            { return powl(_L, (long double)_LLI); }
            inline long double pow(long double _L,
                                   unsigned long long _ULLI)
            { return powl(_L, (long double)_ULLI); }


         inline double pow(int _I, float _F)
         { return __pow((double)_I, (double)_F); }
         inline double pow(int _I, double _D)
         { return __pow((double)_I, _D); }
         inline long double pow(int _I, long double _L)
         { return powl((long double)_I, _L); }
         inline double pow(int _I1, int _I2)
         { return __pow((double)_I1, (double)_I2); }
         inline double pow(int _I, unsigned int _UI)
         { return __pow((double)_I, (double)_UI); }
         inline double pow(int _I, long _LI)
         { return __pow((double)_I, (double)_LI); }
         inline double pow(int _I, unsigned long _ULI)
         { return __pow((double)_I, (double)_ULI); }

            inline double pow(int _I, long long _LLI)
            { return __pow((double)_I, (double)_LLI); }
            inline double pow(int _I,
                              unsigned long long _ULLI)
            { return __pow((double)_I, (double)_ULLI); }


         inline double pow(unsigned int _UI, float _F)
         { return __pow((double)_UI, (double)_F); }
         inline double pow(unsigned int _UI, double _D)
         { return __pow((double)_UI, _D); }
         inline long double pow(unsigned int _UI,
                                long double _L)
         { return powl((long double)_UI, _L); }
         inline double pow(unsigned int _UI, int _I)
         { return __pow((double)_UI, (double)_I); }
         inline double pow(unsigned int _UI1,
                           unsigned int _UI2)
         { return __pow((double)_UI1, (double)_UI2); }
         inline double pow(unsigned int _UI, long _LI)
         { return __pow((double)_UI, (double)_LI); }
         inline double pow(unsigned int _UI,
                           unsigned long _ULI)
         { return __pow((double)_UI, (double)_ULI); }

            inline double pow(unsigned int _UI,
                              long long _LLI)
            { return __pow((double)_UI, (double)_LLI); }
            inline double pow(unsigned int _UI,
                              unsigned long long _ULLI)
            { return __pow((double)_UI, (double)_ULLI); }


         inline double pow(long _LI, float _F)
         { return __pow((double)_LI, (double)_F); }
         inline double pow(long _LI, double _D)
         { return __pow((double)_LI, _D); }
         inline long double pow(long _LI, long double _L)
         { return powl((long double)_LI, _L); }
         inline double pow(long _LI, int _I)
         { return __pow((double)_LI, (double)_I); }
         inline double pow(long _LI, unsigned int _UI)
         { return __pow((double)_LI, (double)_UI); }
         inline double pow(long _LI1, long _LI2)
         { return __pow((double)_LI1, (double)_LI2); }
         inline double pow(long _LI, unsigned long _ULI)
         { return __pow((double)_LI, (double)_ULI); }

            inline double pow(long _LI, long long _LLI)
            { return __pow((double)_LI, (double)_LLI); }
            inline double pow(long _LI,
                              unsigned long long _ULLI)
            { return __pow((double)_LI, (double)_ULLI); }


         inline double pow(unsigned long _ULI, float _F)
         { return __pow((double)_ULI, (double)_F); }
         inline double pow(unsigned long _ULI, double _D)
         { return __pow((double)_ULI, _D); }
         inline long double pow(unsigned long _ULI,
                                long double _L)
         { return powl((long double)_ULI, _L); }
         inline double pow(unsigned long _ULI, int _I)
         { return __pow((double)_ULI, (double)_I); }
         inline double pow(unsigned long _ULI,
                           unsigned int _UI)
         { return __pow((double)_ULI, (double)_UI); }
         inline double pow(unsigned long _ULI, long _LI)
         { return __pow((double)_ULI, (double)_LI); }
         inline double pow(unsigned long _ULI1,
                           unsigned long _ULI2)
         { return __pow((double)_ULI1, (double)_ULI2); }

            inline double pow(unsigned long _ULI,
                              long long _LLI)
            { return __pow((double)_ULI, (double)_LLI); }
            inline double pow(unsigned long _ULI,
                              unsigned long long _ULLI)
            { return __pow((double)_ULI, (double)_ULLI); }



            inline double pow(long long _LLI, float _F)
            { return __pow((double)_LLI, (double)_F); }
            inline double pow(long long _LLI, double _D)
            { return __pow((double)_LLI, _D); }
            inline long double pow(long long _LLI,
                                   long double _L)
            { return powl((long double)_LLI, _L); }
            inline double pow(long long _LLI, int _I)
            { return __pow((double)_LLI, (double)_I); }
            inline double pow(long long _LLI,
                              unsigned int _UI)
            { return __pow((double)_LLI, (double)_UI); }
            inline double pow(long long _LLI, long _LI)
            { return __pow((double)_LLI, (double)_LI); }
            inline double pow(long long _LLI,
                              unsigned long _ULI)
            { return __pow((double)_LLI, (double)_ULI); }
            inline double pow(long long _LLI1,
                              long long _LLI2)
            { return __pow((double)_LLI1, (double)_LLI2); }
            inline double pow(long long _LLI,
                              unsigned long long _ULLI)
            { return __pow((double)_LLI, (double)_ULLI); }

            inline double pow(unsigned long long _ULLI,
                              float _F)
            { return __pow((double)_ULLI, (double)_F); }
            inline double pow(unsigned long long _ULLI,
                              double _D)
            { return __pow((double)_ULLI, _D); }
            inline long double pow(unsigned long long _ULLI,
                                   long double _L)
            { return powl((long double)_ULLI, _L); }
            inline double pow(unsigned long long _ULLI,
                              int _I)
            { return __pow((double)_ULLI, (double)_I); }
            inline double pow(unsigned long long _ULLI,
                              unsigned int _UI)
            { return __pow((double)_ULLI, (double)_UI); }
            inline double pow(unsigned long long _ULLI,
                              long _LI)
            { return __pow((double)_ULLI, (double)_LI); }
            inline double pow(unsigned long long _ULLI,
                              unsigned long _ULI)
            { return __pow((double)_ULLI, (double)_ULI); }
            inline double pow(unsigned long long _ULLI,
                              long long _LLI)
            { return __pow((double)_ULLI, (double)_LLI); }
            inline double pow(unsigned long long _ULLI1,
                              unsigned long long _ULLI2)
            { return __pow((double)_ULLI1, (double)_ULLI2); }


         inline double sin(int _I)
         {return __sin((double)_I);}
         inline double sin(unsigned int _UI)
         {return __sin((double)_UI);}
         inline double sin(long _LI)
         {return __sin((double)_LI);}
         inline double sin(unsigned long _ULI)
         {return __sin((double)_ULI);}

            inline double sin(long long _LLI)
            {return __sin((double)_LLI);}
            inline double sin(unsigned long long _ULLI)
            {return __sin((double)_ULLI);}


         inline double sinh(int _I)
         {return __sinh((double)_I);}
         inline double sinh(unsigned int _UI)
         {return __sinh((double)_UI);}
         inline double sinh(long _LI)
         {return __sinh((double)_LI);}
         inline double sinh(unsigned long _ULI)
         {return __sinh((double)_ULI);}

            inline double sinh(long long _LLI)
            {return __sinh((double)_LLI);}
            inline double sinh(unsigned long long _ULLI)
            {return __sinh((double)_ULLI);}


         inline double sqrt(int _I)
         {return __sqrt((double)_I);}
         inline double sqrt(unsigned int _UI)
         {return __sqrt((double)_UI);}
         inline double sqrt(long _LI)
         {return __sqrt((double)_LI);}
         inline double sqrt(unsigned long _ULI)
         {return __sqrt((double)_ULI);}

            inline double sqrt(long long _LLI)
            {return __sqrt((double)_LLI);}
            inline double sqrt(unsigned long long _ULLI)
            {return __sqrt((double)_ULLI);}


         inline double tan(int _I)
         {return __tan((double)_I);}
         inline double tan(unsigned int _UI)
         {return __tan((double)_UI);}
         inline double tan(long _LI)
         {return __tan((double)_LI);}
         inline double tan(unsigned long _ULI)
         {return __tan((double)_ULI);}

            inline double tan(long long _LLI)
            {return __tan((double)_LLI);}
            inline double tan(unsigned long long _ULLI)
            {return __tan((double)_ULLI);}


         inline double tanh(int _I)
         {return __tanh((double)_I);}
         inline double tanh(unsigned int _UI)
         {return __tanh((double)_UI);}
         inline double tanh(long _LI)
         {return __tanh((double)_LI);}
         inline double tanh(unsigned long _ULI)
         {return __tanh((double)_ULI);}

            inline double tanh(long long _LLI)
            {return __tanh((double)_LLI);}
            inline double tanh(unsigned long long _ULLI)
            {return __tanh((double)_ULLI);}


         inline double remquo(double _D1,
                              double _D2,
                              int *_Iptr)
         {return __remquo(_D1, _D2, _Iptr);}
         inline float remquo(float _F1, float _F2, int *_Iptr)
         {return remquof(_F1, _F2, _Iptr);}
         inline long double remquo(long double _L1,
                                   long double _L2,
                                   int *_Iptr)
         {return remquol(_L1, _L2, _Iptr);}

         inline double remquo(float _F, double _D, int *_Iptr)
         { return __remquo((double)_F, _D, _Iptr); }
         inline long double remquo(float _F,
                                   long double _L,
                                   int *_Iptr)
         { return remquol((long double)_F, _L, _Iptr); }
         inline double remquo(float _F, int _I, int *_Iptr)
         { return __remquo((double)_F, (double)_I, _Iptr); }
         inline double remquo(float _F,
                              unsigned int _UI,
                              int *_Iptr)
         { return __remquo((double)_F, (double)_UI, _Iptr); }
         inline double remquo(float _F, long _LI, int *_Iptr)
         { return __remquo((double)_F, (double)_LI, _Iptr); }
         inline double remquo(float _F,
                              unsigned long _ULI,
                              int *_Iptr)
         { return __remquo((double)_F, (double)_ULI, _Iptr); }

            inline double remquo(float _F,
                                 long long _LLI,
                                 int *_Iptr)
            { return __remquo((double)_F,
                              (double)_LLI, _Iptr); }
            inline double remquo(float _F,
                                 unsigned long long _ULLI,
                                 int *_Iptr)
            { return __remquo((double)_F,
                              (double)_ULLI, _Iptr); }


         inline double remquo(double _D, float _F, int *_Iptr)
         { return __remquo(_D, (double)_F, _Iptr); }
         inline long double remquo(double _D,
                                   long double _L,
                                   int *_Iptr)
         { return remquol((long double)_D, _L, _Iptr); }
         inline double remquo(double _D, int _I, int *_Iptr)
         { return __remquo(_D, (double)_I, _Iptr); }
         inline double remquo(double _D,
                              unsigned int _UI,
                              int *_Iptr)
         { return __remquo(_D, (double)_UI, _Iptr); }
         inline double remquo(double _D,
                              long _LI,
                              int *_Iptr)
         { return __remquo(_D, (double)_LI, _Iptr); }
         inline double remquo(double _D,
                              unsigned long _ULI,
                              int *_Iptr)
         { return __remquo(_D, (double)_ULI, _Iptr); }

            inline double remquo(double _D,
                                 long long _LLI,
                                 int *_Iptr)
            { return __remquo(_D, (double)_LLI, _Iptr); }
            inline double remquo(double _D,
                                 unsigned long long _ULLI,
                                 int *_Iptr)
            { return __remquo(_D, (double)_ULLI, _Iptr); }


         inline long double remquo(long double _L,
                                   float _F,
                                   int *_Iptr)
         { return remquol(_L, (long double)_F, _Iptr); }
         inline long double remquo(long double _L,
                                   double _D,
                                   int *_Iptr)
         { return remquol(_L, (long double)_D, _Iptr); }
         inline long double remquo(long double _L,
                                   int _I,
                                   int *_Iptr)
         { return remquol(_L, (long double)_I, _Iptr); }
         inline long double remquo(long double _L,
                                   unsigned int _UI,
                                   int *_Iptr)
         { return remquol(_L, (long double)_UI, _Iptr); }
         inline long double remquo(long double _L,
                                   long _LI,
                                   int *_Iptr)
         { return remquol(_L, (long double)_LI, _Iptr); }
         inline long double remquo(long double _L,
                                   unsigned long _ULI,
                                   int *_Iptr)
         { return remquol(_L, (long double)_ULI, _Iptr); }

            inline long double remquo(long double _L,
                                      long long _LLI,
                                      int *_Iptr)
            { return remquol(_L, (long double)_LLI, _Iptr); }
            inline long double remquo(long double _L,
                                      unsigned long long _ULLI,
                                      int *_Iptr)
            { return remquol(_L, (long double)_ULLI, _Iptr); }


         inline double remquo(int _I, float _F, int *_Iptr)
         { return __remquo((double)_I, (double)_F, _Iptr); }
         inline double remquo(int _I, double _D, int *_Iptr)
         { return __remquo((double)_I, _D, _Iptr); }
         inline long double remquo(int _I,
                                   long double _L,
                                   int *_Iptr)
         { return remquol((long double)_I, _L, _Iptr); }
         inline double remquo(int _I1, int _I2, int *_Iptr)
         { return __remquo((double)_I1, (double)_I2, _Iptr); }
         inline double remquo(int _I,
                              unsigned int _UI,
                              int *_Iptr)
         { return __remquo((double)_I, (double)_UI, _Iptr); }
         inline double remquo(int _I, long _LI, int *_Iptr)
         { return __remquo((double)_I, (double)_LI, _Iptr); }
         inline double remquo(int _I,
                              unsigned long _ULI,
                              int *_Iptr)
         { return __remquo((double)_I, (double)_ULI, _Iptr); }

            inline double remquo(int _I,
                                 long long _LLI,
                                 int *_Iptr)
            { return __remquo((double)_I,
                              (double)_LLI, _Iptr); }
            inline double remquo(int _I,
                                 unsigned long long _ULLI,
                                 int *_Iptr)
            { return __remquo((double)_I,
                              (double)_ULLI, _Iptr); }


         inline double remquo(unsigned int _UI,
                              float _F,
                              int *_Iptr)
         { return __remquo((double)_UI, (double)_F, _Iptr); }
         inline double remquo(unsigned int _UI,
                              double _D,
                              int *_Iptr)
         { return __remquo((double)_UI, _D, _Iptr); }
         inline long double remquo(unsigned int _UI,
                                   long double _L,
                                   int *_Iptr)
         { return remquol((long double)_UI, _L, _Iptr); }
         inline double remquo(unsigned int _UI,
                              int _I,
                              int *_Iptr)
         { return __remquo((double)_UI, (double)_I, _Iptr); }
         inline double remquo(unsigned int _UI1,
                              unsigned int _UI2,
                              int *_Iptr)
         { return __remquo((double)_UI1,
                           (double)_UI2, _Iptr); }
         inline double remquo(unsigned int _UI,
                              long _LI,
                              int *_Iptr)
         { return __remquo((double)_UI, (double)_LI, _Iptr); }
         inline double remquo(unsigned int _UI,
                              unsigned long _ULI,
                              int *_Iptr)
         { return __remquo((double)_UI,
                           (double)_ULI, _Iptr); }

            inline double remquo(unsigned int _UI,
                                 long long _LLI,
                                 int *_Iptr)
            { return __remquo((double)_UI,
                              (double)_LLI, _Iptr); }
            inline double remquo(unsigned int _UI,
                                 unsigned long long _ULLI,
                                 int *_Iptr)
            { return __remquo((double)_UI,
                              (double)_ULLI, _Iptr); }


         inline double remquo(long _LI, float _F, int *_Iptr)
         { return __remquo((double)_LI, (double)_F, _Iptr); }
         inline double remquo(long _LI, double _D, int *_Iptr)
         { return __remquo((double)_LI, _D, _Iptr); }
         inline long double remquo(long _LI,
                                   long double _L,
                                   int *_Iptr)
         { return remquol((long double)_LI, _L, _Iptr); }
         inline double remquo(long _LI, int _I, int *_Iptr)
         { return __remquo((double)_LI, (double)_I, _Iptr); }
         inline double remquo(long _LI,
                              unsigned int _UI,
                              int *_Iptr)
         { return __remquo((double)_LI, (double)_UI, _Iptr); }
         inline double remquo(long _LI1,
                              long _LI2,
                              int *_Iptr)
         { return __remquo((double)_LI1,
                           (double)_LI2, _Iptr); }
         inline double remquo(long _LI,
                              unsigned long _ULI,
                              int *_Iptr)
         { return __remquo((double)_LI,
                           (double)_ULI, _Iptr); }

            inline double remquo(long _LI,
                                 long long _LLI,
                                 int *_Iptr)
            { return __remquo((double)_LI,
                              (double)_LLI, _Iptr); }
            inline double remquo(long _LI,
                                 unsigned long long _ULLI,
                                 int *_Iptr)
            { return __remquo((double)_LI,
                              (double)_ULLI, _Iptr); }


         inline double remquo(unsigned long _ULI,
                              float _F,
                              int *_Iptr)
         { return __remquo((double)_ULI, (double)_F, _Iptr); }
         inline double remquo(unsigned long _ULI,
                              double _D,
                              int *_Iptr)
         { return __remquo((double)_ULI, _D, _Iptr); }
         inline long double remquo(unsigned long _ULI,
                                   long double _L,
                                   int *_Iptr)
         { return remquol((long double)_ULI, _L, _Iptr); }
         inline double remquo(unsigned long _ULI,
                              int _I,
                              int *_Iptr)
         { return __remquo((double)_ULI, (double)_I, _Iptr); }
         inline double remquo(unsigned long _ULI,
                              unsigned int _UI,
                              int *_Iptr)
         { return __remquo((double)_ULI, (double)_UI, _Iptr);}
         inline double remquo(unsigned long _ULI,
                              long _LI,
                              int *_Iptr)
         { return __remquo((double)_ULI, (double)_LI, _Iptr);}
         inline double remquo(unsigned long _ULI1,
                              unsigned long _ULI2,
                              int *_Iptr)
         { return __remquo((double)_ULI1,
                           (double)_ULI2, _Iptr); }

            inline double remquo(unsigned long _ULI,
                                 long long _LLI,
                                 int *_Iptr)
            { return __remquo((double)_ULI,
                              (double)_LLI, _Iptr); }
            inline double remquo(unsigned long _ULI,
                                 unsigned long long _ULLI,
                                 int *_Iptr)
            { return __remquo((double)_ULI,
                              (double)_ULLI, _Iptr); }



            inline double remquo(long long _LLI,
                                 float _F,
                                 int *_Iptr)
            { return __remquo((double)_LLI,
                              (double)_F, _Iptr); }
            inline double remquo(long long _LLI,
                                 double _D,
                                 int *_Iptr)
            { return __remquo((double)_LLI, _D, _Iptr); }
            inline long double remquo(long long _LLI,
                                      long double _L,
                                      int *_Iptr)
            { return remquol((long double)_LLI, _L, _Iptr); }
            inline double remquo(long long _LLI,
                                 int _I,
                                 int *_Iptr)
            { return __remquo((double)_LLI,
                              (double)_I, _Iptr); }
            inline double remquo(long long _LLI,
                                 unsigned int _UI,
                                 int *_Iptr)
            { return __remquo((double)_LLI,
                              (double)_UI, _Iptr); }
            inline double remquo(long long _LLI,
                                 long _LI,
                                 int *_Iptr)
            { return __remquo((double)_LLI,
                              (double)_LI, _Iptr); }
            inline double remquo(long long _LLI,
                                 unsigned long _ULI,
                                 int *_Iptr)
            { return __remquo((double)_LLI,
                              (double)_ULI, _Iptr); }
            inline double remquo(long long _LLI1,
                                 long long _LLI2,
                                 int *_Iptr)
            { return __remquo((double)_LLI1,
                              (double)_LLI2, _Iptr); }
            inline double remquo(long long _LLI,
                                 unsigned long long _ULLI,
                                 int *_Iptr)
            { return __remquo((double)_LLI,
                              (double)_ULLI, _Iptr); }

            inline double remquo(unsigned long long _ULLI,
                                 float _F,
                                 int *_Iptr)
            { return __remquo((double)_ULLI,
                              (double)_F, _Iptr); }
            inline double remquo(unsigned long long _ULLI,
                                 double _D,
                                 int *_Iptr)
            { return __remquo((double)_ULLI, _D, _Iptr); }
            inline long double remquo(unsigned long long _ULLI,
                                      long double _L,
                                      int *_Iptr)
            { return remquol((long double)_ULLI, _L, _Iptr); }
            inline double remquo(unsigned long long _ULLI,
                                 int _I,
                                 int *_Iptr)
            { return __remquo((double)_ULLI,
                              (double)_I, _Iptr); }
            inline double remquo(unsigned long long _ULLI,
                                 unsigned int _UI,
                                 int *_Iptr)
            { return __remquo((double)_ULLI,
                              (double)_UI, _Iptr); }
            inline double remquo(unsigned long long _ULLI,
                                 long _LI,
                                 int *_Iptr)
            { return __remquo((double)_ULLI,
                              (double)_LI, _Iptr); }
            inline double remquo(unsigned long long _ULLI,
                                 unsigned long _ULI,
                                 int *_Iptr)
            { return __remquo((double)_ULLI,
                              (double)_ULI, _Iptr); }
            inline double remquo(unsigned long long _ULLI,
                                 long long _LLI,
                                 int *_Iptr)
            { return __remquo((double)_ULLI,
                              (double)_LLI, _Iptr); }
            inline double remquo(unsigned long long _ULLI1,
                                 unsigned long long _ULLI2,
                                 int *_Iptr)
            { return __remquo((double)_ULLI1,
                              (double)_ULLI2, _Iptr); }


      }






     }

#pragma checkout(resume)





extern "C++" {
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    acos(_A1 __lcpp_x) noexcept {
  return acos((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    asin(_A1 __lcpp_x) noexcept {
  return asin((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    atan(_A1 __lcpp_x) noexcept {
  return atan((double)__lcpp_x);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    atan2(_A1 __lcpp_y, _A2 __lcpp_x) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    ceil(_A1 __lcpp_x) noexcept {
  return ceil((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    cos(_A1 __lcpp_x) noexcept {
  return cos((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    cosh(_A1 __lcpp_x) noexcept {
  return cosh((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    exp(_A1 __lcpp_x) noexcept {
  return exp((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    fabs(_A1 __lcpp_x) noexcept {
  return fabs((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    floor(_A1 __lcpp_x) noexcept {
  return floor((double)__lcpp_x);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    fmod(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    frexp(_A1 __lcpp_x, int *__lcpp_e) noexcept {
  return frexp((double)__lcpp_x, __lcpp_e);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    ldexp(_A1 __lcpp_x, int __lcpp_e) noexcept {
  return ldexp((double)__lcpp_x, __lcpp_e);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    log(_A1 __lcpp_x) noexcept {
  return log((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    log10(_A1 __lcpp_x) noexcept {
  return log10((double)__lcpp_x);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    pow(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    sin(_A1 __lcpp_x) noexcept {
  return sin((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    sinh(_A1 __lcpp_x) noexcept {
  return sinh((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    sqrt(_A1 __lcpp_x) noexcept {
  return sqrt((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    tan(_A1 __lcpp_x) noexcept {
  return tan((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    tanh(_A1 __lcpp_x) noexcept {
  return tanh((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    acosh(_A1 __lcpp_x) noexcept {
  return acosh((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    asinh(_A1 __lcpp_x) noexcept {
  return asinh((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    atanh(_A1 __lcpp_x) noexcept {
  return atanh((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    cbrt(_A1 __lcpp_x) noexcept {
  return cbrt((double)__lcpp_x);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    copysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    erf(_A1 __lcpp_x) noexcept {
  return erf((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    erfc(_A1 __lcpp_x) noexcept {
  return erfc((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    exp2(_A1 __lcpp_x) noexcept {
  return exp2((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    expm1(_A1 __lcpp_x) noexcept {
  return expm1((double)__lcpp_x);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    fdim(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
template <class _A1, class _A2, class _A3>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value &&
                                       std::is_arithmetic<_A3>::value,
                                   std::__promote<_A1, _A2, _A3>>::type
    fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept {
  typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value &&
                   std::is_same<_A3, __result_type>::value)),
                "");
  return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y,
             (__result_type)__lcpp_z);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    fmax(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    fmin(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    hypot(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, int>::type
    ilogb(_A1 __lcpp_x) noexcept {
  return ilogb((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    lgamma(_A1 __lcpp_x) noexcept {
  return lgamma((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, long long>::type
    llrint(_A1 __lcpp_x) noexcept {
  return llrint((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, long long>::type
    llround(_A1 __lcpp_x) noexcept {
  return llround((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    log1p(_A1 __lcpp_x) noexcept {
  return log1p((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    log2(_A1 __lcpp_x) noexcept {
  return log2((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    logb(_A1 __lcpp_x) noexcept {
  return logb((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, long>::type
    lrint(_A1 __lcpp_x) noexcept {
  return lrint((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, long>::type
    lround(_A1 __lcpp_x) noexcept {
  return lround((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    nearbyint(_A1 __lcpp_x) noexcept {
  return nearbyint((double)__lcpp_x);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    nextafter(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    nexttoward(_A1 __lcpp_x, long double __lcpp_y) noexcept {
  return nexttoward((double)__lcpp_x, __lcpp_y);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    remainder(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}
template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::__lazy_enable_if<std::is_arithmetic<_A1>::value &&
                                       std::is_arithmetic<_A2>::value,
                                   std::__promote<_A1, _A2>>::type
    remquo(_A1 __lcpp_x, _A2 __lcpp_y, int *__lcpp_z) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::is_same<_A1, __result_type>::value &&
                   std::is_same<_A2, __result_type>::value)),
                "");
  return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    rint(_A1 __lcpp_x) noexcept {
  return rint((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    round(_A1 __lcpp_x) noexcept {
  return round((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    scalbln(_A1 __lcpp_x, long __lcpp_y) noexcept {
  return scalbln((double)__lcpp_x, __lcpp_y);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    scalbn(_A1 __lcpp_x, int __lcpp_y) noexcept {
  return scalbn((double)__lcpp_x, __lcpp_y);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    tgamma(_A1 __lcpp_x) noexcept {
  return tgamma((double)__lcpp_x);
}
template <class _A1>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_integral<_A1>::value, double>::type
    trunc(_A1 __lcpp_x) noexcept {
  return trunc((double)__lcpp_x);
}



}


template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_arithmetic<_A1>::value &&
                                std::is_arithmetic<_A2>::value,
                            bool>::type
    isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return isgreater((type)__lcpp_x, (type)__lcpp_y);
}



template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_arithmetic<_A1>::value &&
                                std::is_arithmetic<_A2>::value,
                            bool>::type
    isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}



template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_arithmetic<_A1>::value &&
                                std::is_arithmetic<_A2>::value,
                            bool>::type
    isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return isless((type)__lcpp_x, (type)__lcpp_y);
}




template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_arithmetic<_A1>::value &&
                                std::is_arithmetic<_A2>::value,
                            bool>::type
    islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return islessequal((type)__lcpp_x, (type)__lcpp_y);
}





template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_arithmetic<_A1>::value &&
                                std::is_arithmetic<_A2>::value,
                            bool>::type
    islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return islessgreater((type)__lcpp_x, (type)__lcpp_y);
}





template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename std::enable_if<std::is_arithmetic<_A1>::value &&
                                std::is_arithmetic<_A2>::value,
                            bool>::type
    isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return isunordered((type)__lcpp_x, (type)__lcpp_y);
}


namespace std { inline namespace __1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;


using ::abs;
using ::isnan;
using ::isinf;


using ::acos;
using ::acosf;
using ::asin;
using ::asinf;
using ::atan;
using ::atanf;
using ::atan2;
using ::atan2f;
using ::ceil;
using ::ceilf;
using ::cos;
using ::cosf;
using ::cosh;
using ::coshf;

using ::exp;
using ::expf;

using ::fabs;
using ::fabsf;
using ::floor;
using ::floorf;

using ::fmod;
using ::fmodf;

using ::frexp;
using ::frexpf;
using ::ldexp;
using ::ldexpf;

using ::log;
using ::logf;

using ::log10;
using ::log10f;
using ::modf;
using ::modff;

using ::pow;
using ::powf;

using ::sin;
using ::sinf;
using ::sinh;
using ::sinhf;

using ::sqrt;
using ::sqrtf;
using ::tan;
using ::tanf;

using ::tanh;
using ::tanhf;


using ::acosh;
using ::acoshf;
using ::asinh;
using ::asinhf;
using ::atanh;
using ::atanhf;
using ::cbrt;
using ::cbrtf;


using ::copysign;
using ::copysignf;


using ::erf;
using ::erff;
using ::erfc;
using ::erfcf;
using ::exp2;
using ::exp2f;
using ::expm1;
using ::expm1f;
using ::fdim;
using ::fdimf;
using ::fmaf;
using ::fma;
using ::fmax;
using ::fmaxf;
using ::fmin;
using ::fminf;
using ::hypot;
using ::hypotf;
using ::ilogb;
using ::ilogbf;
using ::lgamma;
using ::lgammaf;
using ::llrint;
using ::llrintf;
using ::llround;
using ::llroundf;
using ::log1p;
using ::log1pf;
using ::log2;
using ::log2f;
using ::logb;
using ::logbf;
using ::lrint;
using ::lrintf;
using ::lround;
using ::lroundf;



using ::nan;
using ::nanf;



using ::nearbyint;
using ::nearbyintf;
using ::nextafter;
using ::nextafterf;
using ::nexttoward;
using ::nexttowardf;
using ::remainder;
using ::remainderf;
using ::remquo;
using ::remquof;
using ::rint;
using ::rintf;
using ::round;
using ::roundf;
using ::scalbln;
using ::scalblnf;
using ::scalbn;
using ::scalbnf;
using ::tgamma;
using ::tgammaf;
using ::trunc;
using ::truncf;


using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;


using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;


using ::copysignl;


using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;
template <class _A1>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_floating_point<_A1>::value, bool>::type
    __libcpp_isnan(_A1 __lcpp_x) noexcept {



  return isnan(__lcpp_x);

}

template <class _A1>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<!is_floating_point<_A1>::value, bool>::type
    __libcpp_isnan(_A1 __lcpp_x) noexcept {
  return isnan(__lcpp_x);
}

template <class _A1>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_floating_point<_A1>::value, bool>::type
    __libcpp_isinf(_A1 __lcpp_x) noexcept {



  return isinf(__lcpp_x);

}

template <class _A1>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<!is_floating_point<_A1>::value, bool>::type
    __libcpp_isinf(_A1 __lcpp_x) noexcept {
  return isinf(__lcpp_x);
}

template <class _A1>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<is_floating_point<_A1>::value, bool>::type
    __libcpp_isfinite(_A1 __lcpp_x) noexcept {



  return isfinite(__lcpp_x);

}

template <class _A1>
__attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<!is_floating_point<_A1>::value, bool>::type
    __libcpp_isfinite(_A1 __lcpp_x) noexcept {
  return isfinite(__lcpp_x);
}

} }
















namespace v8 {
namespace base {

typedef AtomicWord OnceType;





enum {
  ONCE_STATE_UNINITIALIZED = 0,
  ONCE_STATE_EXECUTING_FUNCTION = 1,
  ONCE_STATE_DONE = 2
};

typedef void (*NoArgFunction)();
typedef void (*PointerArgFunction)(void* arg);

template <typename T>
struct OneArgFunction {
  typedef void (*type)(T);
};

void CallOnceImpl(OnceType* once, PointerArgFunction init_func, void* arg);

inline void CallOnce(OnceType* once, NoArgFunction init_func) {
  if (Acquire_Load(once) != ONCE_STATE_DONE) {
    CallOnceImpl(once, reinterpret_cast<PointerArgFunction>(init_func), 0);
  }
}


template <typename Arg>
inline void CallOnce(OnceType* once,
    typename OneArgFunction<Arg*>::type init_func, Arg* arg) {
  if (Acquire_Load(once) != ONCE_STATE_DONE) {
    CallOnceImpl(once, reinterpret_cast<PointerArgFunction>(init_func),
        static_cast<void*>(arg));
  }
}

}
}

namespace v8 {
namespace base {
template <typename T>
struct LeakyInstanceTrait {
  static void Destroy(T* ) {}
};





template <typename T>
struct StaticallyAllocatedInstanceTrait {

  struct alignas(T) StorageType {
    char x[sizeof(T)];
  };

  static_assert(__alignof(StorageType) >= __alignof(T), "V8_ALIGNOF(StorageType) >= V8_ALIGNOF(T)");

  static T* MutableInstance(StorageType* storage) {
    return reinterpret_cast<T*>(storage);
  }

  template <typename ConstructTrait>
  static void InitStorageUsingTrait(StorageType* storage) {
    ConstructTrait::Construct(MutableInstance(storage));
  }
};


template <typename T>
struct DynamicallyAllocatedInstanceTrait {
  typedef T* StorageType;

  static T* MutableInstance(StorageType* storage) {
    return *storage;
  }

  template <typename CreateTrait>
  static void InitStorageUsingTrait(StorageType* storage) {
    *storage = CreateTrait::Create();
  }
};


template <typename T>
struct DefaultConstructTrait {

  static void Construct(T* allocated_ptr) {
    new(allocated_ptr) T();
  }
};


template <typename T>
struct DefaultCreateTrait {
  static T* Create() {
    return new T();
  }
};


struct ThreadSafeInitOnceTrait {
  template <typename Function, typename Storage>
  static void Init(OnceType* once, Function function, Storage storage) {
    CallOnce(once, function, storage);
  }
};



struct SingleThreadInitOnceTrait {
  template <typename Function, typename Storage>
  static void Init(OnceType* once, Function function, Storage storage) {
    if (*once == ONCE_STATE_UNINITIALIZED) {
      function(storage);
      *once = ONCE_STATE_DONE;
    }
  }
};



template <typename T, typename AllocationTrait, typename CreateTrait,
          typename InitOnceTrait, typename DestroyTrait >
struct LazyInstanceImpl {
 public:
  typedef typename AllocationTrait::StorageType StorageType;

 private:
  static void InitInstance(StorageType* storage) {
    AllocationTrait::template InitStorageUsingTrait<CreateTrait>(storage);
  }

  void Init() const {
    InitOnceTrait::Init(
        &once_,


        reinterpret_cast<void(*)(void*)>(&InitInstance),
        reinterpret_cast<void*>(&storage_));
  }

 public:
  T* Pointer() {
    Init();
    return AllocationTrait::MutableInstance(&storage_);
  }

  const T& Get() const {
    Init();
    return *AllocationTrait::MutableInstance(&storage_);
  }

  mutable OnceType once_;



  mutable StorageType storage_;
};


template <typename T,
          typename CreateTrait = DefaultConstructTrait<T>,
          typename InitOnceTrait = ThreadSafeInitOnceTrait,
          typename DestroyTrait = LeakyInstanceTrait<T> >
struct LazyStaticInstance {
  typedef LazyInstanceImpl<T, StaticallyAllocatedInstanceTrait<T>,
      CreateTrait, InitOnceTrait, DestroyTrait> type;
};


template <typename T,
          typename CreateTrait = DefaultConstructTrait<T>,
          typename InitOnceTrait = ThreadSafeInitOnceTrait,
          typename DestroyTrait = LeakyInstanceTrait<T> >
struct LazyInstance {

  typedef typename LazyStaticInstance<T, CreateTrait, InitOnceTrait,
      DestroyTrait>::type type;
};


template <typename T,
          typename CreateTrait = DefaultCreateTrait<T>,
          typename InitOnceTrait = ThreadSafeInitOnceTrait,
          typename DestroyTrait = LeakyInstanceTrait<T> >
struct LazyDynamicInstance {
  typedef LazyInstanceImpl<T, DynamicallyAllocatedInstanceTrait<T>,
      CreateTrait, InitOnceTrait, DestroyTrait> type;
};

}
}
namespace v8 {
namespace base {
class Mutex final {
 public:
  Mutex();
  ~Mutex();





  void Lock();



  void Unlock();



  bool TryLock() __attribute__((warn_unused_result));



  typedef pthread_mutex_t NativeHandle;




  NativeHandle& native_handle() {
    return native_handle_;
  }
  const NativeHandle& native_handle() const {
    return native_handle_;
  }

 private:
  NativeHandle native_handle_;

  int level_;


  inline void AssertHeldAndUnmark() {

    do { if (std::string* _msg = ::v8::base::CheckEQImpl( (1), (level_), "1" " " "==" " " "level_")) { V8_Fatal(".././src/base/platform/mutex.h", 77, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    level_--;

  }

  inline void AssertUnheldAndMark() {

    do { if (std::string* _msg = ::v8::base::CheckEQImpl( (0), (level_), "0" " " "==" " " "level_")) { V8_Fatal(".././src/base/platform/mutex.h", 84, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    level_++;

  }

  friend class ConditionVariable;

  Mutex(const Mutex&) = delete; void operator=(const Mutex&) = delete;
};
typedef LazyStaticInstance<Mutex, DefaultConstructTrait<Mutex>,
                           ThreadSafeInitOnceTrait>::type LazyMutex;
class RecursiveMutex final {
 public:
  RecursiveMutex();
  ~RecursiveMutex();







  void Lock();






  void Unlock();



  bool TryLock() __attribute__((warn_unused_result));


  typedef Mutex::NativeHandle NativeHandle;

  NativeHandle& native_handle() {
    return native_handle_;
  }
  const NativeHandle& native_handle() const {
    return native_handle_;
  }

 private:
  NativeHandle native_handle_;

  int level_;


  RecursiveMutex(const RecursiveMutex&) = delete; void operator=(const RecursiveMutex&) = delete;
};
typedef LazyStaticInstance<RecursiveMutex,
                           DefaultConstructTrait<RecursiveMutex>,
                           ThreadSafeInitOnceTrait>::type LazyRecursiveMutex;
template <typename Mutex>
class LockGuard final {
 public:
  explicit LockGuard(Mutex* mutex) : mutex_(mutex) { mutex_->Lock(); }
  ~LockGuard() { mutex_->Unlock(); }

 private:
  Mutex* mutex_;

  LockGuard(const LockGuard&) = delete; void operator=(const LockGuard&) = delete;
};

}
}


#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {


#pragma filetag("IBM-1047")


#pragma nomargins nosequence
#pragma checkout(suspend)
 extern "C" {
         struct ipc_perm {
            uid_t uid;
            gid_t gid;
            uid_t cuid;
            gid_t cgid;
            mode_t mode;
         };
         key_t ftok(const char *, int);
  }


#pragma checkout(resume)
         struct semid_ds {
            struct ipc_perm sem_perm;

            unsigned short int sem_nsems;

            short int __filler;

            char sem_otime_31[4];
            char sem_ctime_31[4];

            time_t sem_otime;
            time_t sem_ctime;

         };

         struct sembuf {
            unsigned short int sem_num;
            short int sem_op;
            short int sem_flg;
         };

         struct sema {
            unsigned short int semval;
            pid_t sempid;

            unsigned short int semncnt;



            unsigned short int semzcnt;


         };
              int semctl(int, int, int, ...);
              int semget(key_t, int, int);
              int semop(int, struct sembuf *, size_t);
     int __semop_timed(int, struct sembuf *, size_t,
                       struct timespec *);







  }


#pragma checkout(resume)
typedef union {
  char __size[16];
  int64_t __align;
} sem_t;

int sem_init(int *semid, int pshared, unsigned int value);

int sem_destroy(int *semid);

int sem_wait(int *semid);

int sem_trywait(int *semid);

int sem_post(int *semid);

int sem_timedwait(int *semid, struct timespec *timeout);





namespace v8 {
namespace base {


class TimeDelta;
class Semaphore final {
 public:
  explicit Semaphore(int count);
  ~Semaphore();


  void Signal();



  void Wait();





  bool WaitFor(const TimeDelta& rel_time) __attribute__((warn_unused_result));





  typedef int NativeHandle;







  NativeHandle& native_handle() {
    return native_handle_;
  }
  const NativeHandle& native_handle() const {
    return native_handle_;
  }

 private:
  NativeHandle native_handle_;

  Semaphore(const Semaphore&) = delete; void operator=(const Semaphore&) = delete;
};
template <int N>
struct CreateSemaphoreTrait {
  static Semaphore* Create() {
    return new Semaphore(N);
  }
};

template <int N>
struct LazySemaphore {
  typedef typename LazyDynamicInstance<Semaphore, CreateSemaphoreTrait<N>,
                                       ThreadSafeInitOnceTrait>::type type;
};



}
}





namespace v8 {
namespace base {
class TimezoneCache;
class OS {
 public:




  static void Initialize(int64_t random_seed,
                         bool hard_abort,
                         const char* const gc_fake_mmap);





  static int GetUserTime(uint32_t* secs, uint32_t* usecs);



  static double TimeCurrentMillis();

  static TimezoneCache* CreateTimezoneCache();
  static void DisposeTimezoneCache(TimezoneCache* cache);
  static void ClearTimezoneCache(TimezoneCache* cache);



  static const char* LocalTimezone(double time, TimezoneCache* cache);



  static double LocalTimeOffset(TimezoneCache* cache);


  static double DaylightSavingsOffset(double time, TimezoneCache* cache);


  static int GetLastError();

  static FILE* FOpen(const char* path, const char* mode);
  static FILE* FOpenASCII(const char* path_a, const char* mode_a);
  static bool Remove(const char* path);

  static char DirectorySeparator();
  static bool isDirectorySeparator(const char ch);


  static FILE* OpenTemporaryFile();


  static const char* const LogFileOpenMode;




  static void Print(const char* format, ...);
  static void VPrint(const char* format, va_list args);


  static void FPrint(FILE* out, const char* format, ...);
  static void VFPrint(FILE* out, const char* format, va_list args);




  static void PrintError(const char* format, ...);
  static void VPrintError(const char* format, va_list args);




  static void* Allocate(const size_t requested,
                        size_t* allocated,
                        bool is_executable);
  static void Free(void* address, const size_t size);



  static intptr_t CommitPageSize();


  static void ProtectCode(void* address, const size_t size);


  static void Guard(void* address, const size_t size);


  static void* GetRandomMmapAddr();


  static size_t AllocateAlignment();


  static void Sleep(TimeDelta interval);


  __attribute__((noreturn)) static void Abort();


  static void DebugBreak();


  static const int kStackWalkError = -1;
  static const int kStackWalkMaxNameLen = 256;
  static const int kStackWalkMaxTextLen = 256;
  struct StackFrame {
    void* address;
    char text[kStackWalkMaxTextLen];
  };

  class MemoryMappedFile {
   public:
    virtual ~MemoryMappedFile() {}
    virtual void* memory() const = 0;
    virtual size_t size() const = 0;

    static MemoryMappedFile* open(const char* name);
    static MemoryMappedFile* create(const char* name, size_t size,
                                    void* initial);
  };



  static int SNPrintF(char* str, int length, const char* format, ...);
  static int VSNPrintF(char* str,
                       int length,
                       const char* format,
                       va_list args);
  static int SNPrintFASCII(char* str, int length, const char* format, ...);
  static int VSNPrintFASCII(char* str,
                       int length,
                       const char* format,
                       va_list args);
  static char* StrChr(char* str, int c);
  static void StrNCpy(char* dest, int length, const char* src, size_t n);



  struct SharedLibraryAddress {
    SharedLibraryAddress(
        const std::string& library_path, uintptr_t start, uintptr_t end)
        : library_path(library_path), start(start), end(end) {}

    std::string library_path;
    uintptr_t start;
    uintptr_t end;
  };

  static std::vector<SharedLibraryAddress> GetSharedLibraryAddresses();





  static void SignalCodeMovingGC();



  static bool ArmUsingHardFloat();



  static int ActivationFrameAlignment();

  static int GetCurrentProcessId();


  static pthread_t GetCurrentThreadID();



  static void ConvertToASCII(char * str);




 private:
  static const int msPerSecond = 1000;


  static const char* GetGCFakeMMapFile();


  OS() = delete; OS(const OS&) = delete; void operator=(const OS&) = delete;
};






class VirtualMemory {
 public:

  VirtualMemory();


  explicit VirtualMemory(size_t size);




  VirtualMemory(size_t size, size_t alignment);



  VirtualMemory(void* address, size_t size) : address_(address), size_(size) {}



  ~VirtualMemory();


  bool IsReserved();


  void Reset();





  void* address() {
    do { if ((!(IsReserved()))) { V8_Fatal(".././src/base/platform/platform.h", 326, "Check failed: %s.", "IsReserved()"); } } while (0);
    return address_;
  }





  size_t size() { return size_; }


  bool Commit(void* address, size_t size, bool is_executable);


  bool Uncommit(void* address, size_t size);


  bool Guard(void* address);

  void Release() {
    do { if ((!(IsReserved()))) { V8_Fatal(".././src/base/platform/platform.h", 346, "Check failed: %s.", "IsReserved()"); } } while (0);


    void* address = address_;
    size_t size = size_;
    do { if ((!(InVM(address, size)))) { V8_Fatal(".././src/base/platform/platform.h", 351, "Check failed: %s.", "InVM(address, size)"); } } while (0);
    Reset();
    bool result = ReleaseRegion(address, size);
    USE(result);
    do { if ((!(result))) { V8_Fatal(".././src/base/platform/platform.h", 355, "Check failed: %s.", "result"); } } while (0);
  }



  void TakeControl(VirtualMemory* from) {
    do { if ((!(!IsReserved()))) { V8_Fatal(".././src/base/platform/platform.h", 361, "Check failed: %s.", "!IsReserved()"); } } while (0);
    address_ = from->address_;
    size_ = from->size_;
    from->Reset();
  }

  static void* ReserveRegion(size_t size);

  static bool CommitRegion(void* base, size_t size, bool is_executable);

  static bool UncommitRegion(void* base, size_t size);



  static bool ReleaseRegion(void* base, size_t size);




  static bool HasLazyCommits();

 private:
  bool InVM(void* address, size_t size) {
    return (reinterpret_cast<uintptr_t>(address_) <=
            reinterpret_cast<uintptr_t>(address)) &&
           ((reinterpret_cast<uintptr_t>(address_) + size_) >=
            (reinterpret_cast<uintptr_t>(address) + size));
  }

  void* address_;
  size_t size_;
};
class Thread {
 public:


  typedef pthread_key_t LocalStorageKey;



  class Options {
   public:
    Options() : name_("v8:<unknown>"), stack_size_(0) {}
    explicit Options(const char* name, int stack_size = 0)
        : name_(name), stack_size_(stack_size) {}

    const char* name() const { return name_; }
    int stack_size() const { return stack_size_; }

   private:
    const char* name_;
    int stack_size_;
  };


  explicit Thread(const Options& options);
  virtual ~Thread();


  void Start();


  void StartSynchronously() {
    start_semaphore_ = new Semaphore(0);
    Start();
    start_semaphore_->Wait();
    delete start_semaphore_;
    start_semaphore_ = 0;
  }


  void Join();

  inline const char* name() const {
    return name_;
  }


  virtual void Run() = 0;


  static LocalStorageKey CreateThreadLocalKey();
  static void DeleteThreadLocalKey(LocalStorageKey key);
  static void* GetThreadLocal(LocalStorageKey key);
  static int GetThreadLocalInt(LocalStorageKey key) {
    return static_cast<int>(reinterpret_cast<intptr_t>(GetThreadLocal(key)));
  }
  static void SetThreadLocal(LocalStorageKey key, void* value);
  static void SetThreadLocalInt(LocalStorageKey key, int value) {
    SetThreadLocal(key, reinterpret_cast<void*>(static_cast<intptr_t>(value)));
  }
  static bool HasThreadLocal(LocalStorageKey key) {
    return GetThreadLocal(key) != 0;
  }
  static inline void* GetExistingThreadLocal(LocalStorageKey key) {
    return GetThreadLocal(key);
  }




  static const int kMaxThreadNameLength = 16;

  class PlatformData;
  PlatformData* data() { return data_; }

  void NotifyStartedAndRun() {
    if (start_semaphore_) start_semaphore_->Signal();
    Run();
  }

 private:
  void set_name(const char* name);

  PlatformData* data_;

  char name_[kMaxThreadNameLength];
  int stack_size_;
  Semaphore* start_semaphore_;

  Thread(const Thread&) = delete; void operator=(const Thread&) = delete;
};

}
}


namespace v8 {
namespace internal {

template<typename T> class Vector;
template <typename T, class AllocationPolicy>
class List {
 public:
  explicit List(AllocationPolicy allocator = AllocationPolicy()) {
    Initialize(0, allocator);
  }
  inline explicit List(int capacity, AllocationPolicy allocator = AllocationPolicy()) {

    Initialize(capacity, allocator);
  }
  inline ~List() { DeleteData(data_); }



  void Free() {
    DeleteData(data_);
    Initialize(0);
  }

  inline void* operator new(size_t size, AllocationPolicy allocator = AllocationPolicy()) {

    return allocator.New(static_cast<int>(size));
  }
  inline void operator delete(void* p) {
    AllocationPolicy::Delete(p);
  }


  inline void operator delete(void* p, AllocationPolicy allocator) {
    V8_Fatal(".././src/list.h", 60, "unreachable code");
  }




  inline T& operator[](int i) const {
    do { if ((!(0 <= i))) { V8_Fatal(".././src/list.h", 67, "Check failed: %s.", "0 <= i"); } } while (0);
    do { if ((!(!v8::internal::FLAG_enable_slow_asserts || (static_cast<unsigned>(i) < static_cast<unsigned>(length_))))) { V8_Fatal(".././src/list.h", 68, "Check failed: %s.", "!v8::internal::FLAG_enable_slow_asserts || (static_cast<unsigned>(i) < static_cast<unsigned>(length_))"); } } while (0);
    return data_[i];
  }
  inline T& at(int i) const { return operator[](i); }
  inline T& last() const { return at(length_ - 1); }
  inline T& first() const { return at(0); }

  typedef T* iterator;
  inline iterator begin() const { return &data_[0]; }
  inline iterator end() const { return &data_[length_]; }

  inline bool is_empty() const { return length_ == 0; }
  inline int length() const { return length_; }
  inline int capacity() const { return capacity_; }

  Vector<T> ToVector() const { return Vector<T>(data_, length_); }

  Vector<const T> ToConstVector() const {
    return Vector<const T>(data_, length_);
  }



  void Add(const T& element, AllocationPolicy allocator = AllocationPolicy());


  void AddAll(const List<T, AllocationPolicy>& other,
              AllocationPolicy allocator = AllocationPolicy());


  void AddAll(const Vector<T>& other,
              AllocationPolicy allocator = AllocationPolicy());


  void InsertAt(int index, const T& element,
                AllocationPolicy allocator = AllocationPolicy());


  void Set(int index, const T& element);




  Vector<T> AddBlock(T value, int count,
                     AllocationPolicy allocator = AllocationPolicy());





  T Remove(int i);



  bool RemoveElement(const T& elm);



  inline T RemoveLast() { return Remove(length_ - 1); }


  inline void Allocate(int length, AllocationPolicy allocator = AllocationPolicy());




  inline void Clear();


  inline void Rewind(int pos);


  inline void RewindBy(int count) { Rewind(length_ - count); }


  inline void Swap(List<T, AllocationPolicy>* list);


  inline void Trim(AllocationPolicy allocator = AllocationPolicy());

  bool Contains(const T& elm) const;
  int CountOccurrences(const T& elm, int start, int end) const;


  void Iterate(void (*callback)(T* x));
  template<class Visitor>
  void Iterate(Visitor* visitor);


  template <typename CompareFunction>
  void Sort(CompareFunction cmp, size_t start, size_t length);
  template <typename CompareFunction>
  void Sort(CompareFunction cmp);
  void Sort();
  template <typename CompareFunction>
  void StableSort(CompareFunction cmp, size_t start, size_t length);
  template <typename CompareFunction>
  void StableSort(CompareFunction cmp);
  void StableSort();

  inline void Initialize(int capacity, AllocationPolicy allocator = AllocationPolicy()) {

    do { if ((!(capacity >= 0))) { V8_Fatal(".././src/list.h", 170, "Check failed: %s.", "capacity >= 0"); } } while (0);
    data_ = (capacity > 0) ? NewData(capacity, allocator) : 0;
    capacity_ = capacity;
    length_ = 0;
  }

 private:
  T* data_;
  int capacity_;
  int length_;

  inline T* NewData(int n, AllocationPolicy allocator) {
    return static_cast<T*>(allocator.New(n * sizeof(T)));
  }
  inline void DeleteData(T* data) {
    AllocationPolicy::Delete(data);
  }



  void ResizeAdd(const T& element, AllocationPolicy allocator);



  void ResizeAddInternal(const T& element, AllocationPolicy allocator);


  void Resize(int new_capacity, AllocationPolicy allocator);

  List(const List&) = delete; void operator=(const List&) = delete;
};


template<typename T, class P>
size_t GetMemoryUsedByList(const List<T, P>& list) {
  return list.length() * sizeof(T) + sizeof(list);
}


class Map;
class FieldType;
class Code;
template<typename T> class Handle;
typedef List<Map*> MapList;
typedef List<Code*> CodeList;
typedef List<Handle<Map> > MapHandleList;
typedef List<Handle<FieldType> > TypeHandleList;
typedef List<Handle<Code> > CodeHandleList;






template <typename T, class P>
int SortedListBSearch(const List<T>& list, P cmp);
template <typename T>
int SortedListBSearch(const List<T>& list, T elem);


}
}
namespace v8 {
namespace internal {


template <typename T>
class Vector {
 public:
  Vector() : start_(0), length_(0) {}
  Vector(T* data, int length) : start_(data), length_(length) {
    do { if ((!(length == 0 || (length > 0 && data != 0)))) { V8_Fatal(".././src/vector.h", 24, "Check failed: %s.", "length == 0 || (length > 0 && data != 0)"); } } while (0);
  }

  static Vector<T> New(int length) {
    return Vector<T>(NewArray<T>(length), length);
  }



  Vector<T> SubVector(int from, int to) {
    do { if ((!(0 <= from))) { V8_Fatal(".././src/vector.h", 34, "Check failed: %s.", "0 <= from"); } } while (0);
    do { if ((!(!v8::internal::FLAG_enable_slow_asserts || (from < to)))) { V8_Fatal(".././src/vector.h", 35, "Check failed: %s.", "!v8::internal::FLAG_enable_slow_asserts || (from < to)"); } } while (0);
    do { if ((!(!v8::internal::FLAG_enable_slow_asserts || (static_cast<unsigned>(to) <= static_cast<unsigned>(length_))))) { V8_Fatal(".././src/vector.h", 36, "Check failed: %s.", "!v8::internal::FLAG_enable_slow_asserts || (static_cast<unsigned>(to) <= static_cast<unsigned>(length_))"); } } while (0);
    return Vector<T>(start() + from, to - from);
  }


  int length() const { return length_; }


  bool is_empty() const { return length_ == 0; }


  T* start() const { return start_; }


  T& operator[](int index) const {
    do { if ((!(0 <= index && index < length_))) { V8_Fatal(".././src/vector.h", 51, "Check failed: %s.", "0 <= index && index < length_"); } } while (0);
    return start_[index];
  }

  const T& at(int index) const { return operator[](index); }

  T& first() { return start_[0]; }

  T& last() { return start_[length_ - 1]; }

  typedef T* iterator;
  inline iterator begin() const { return &start_[0]; }
  inline iterator end() const { return &start_[length_]; }


  Vector<T> Clone() const {
    T* result = NewArray<T>(length_);
    for (int i = 0; i < length_; i++) result[i] = start_[i];
    return Vector<T>(result, length_);
  }

  template <typename CompareFunction>
  void Sort(CompareFunction cmp, size_t s, size_t l) {
    std::sort(start() + s, start() + s + l, RawComparer<CompareFunction>(cmp));
  }

  template <typename CompareFunction>
  void Sort(CompareFunction cmp) {
    std::sort(start(), start() + length(), RawComparer<CompareFunction>(cmp));
  }

  void Sort() {
    std::sort(start(), start() + length());
  }

  template <typename CompareFunction>
  void StableSort(CompareFunction cmp, size_t s, size_t l) {
    std::stable_sort(start() + s, start() + s + l,
                     RawComparer<CompareFunction>(cmp));
  }

  template <typename CompareFunction>
  void StableSort(CompareFunction cmp) {
    std::stable_sort(start(), start() + length(),
                     RawComparer<CompareFunction>(cmp));
  }

  void StableSort() { std::stable_sort(start(), start() + length()); }

  void Truncate(int length) {
    do { if ((!(length <= length_))) { V8_Fatal(".././src/vector.h", 101, "Check failed: %s.", "length <= length_"); } } while (0);
    length_ = length;
  }



  void Dispose() {
    DeleteArray(start_);
    start_ = 0;
    length_ = 0;
  }

  inline Vector<T> operator+(int offset) {
    do { if ((!(offset < length_))) { V8_Fatal(".././src/vector.h", 114, "Check failed: %s.", "offset < length_"); } } while (0);
    return Vector<T>(start_ + offset, length_ - offset);
  }


  static Vector<T> empty() { return Vector<T>(0, 0); }

  template<typename S>
  static Vector<T> cast(Vector<S> input) {
    return Vector<T>(reinterpret_cast<T*>(input.start()),
                     input.length() * sizeof(S) / sizeof(T));
  }

  bool operator==(const Vector<T>& other) const {
    if (length_ != other.length_) return false;
    if (start_ == other.start_) return true;
    for (int i = 0; i < length_; ++i) {
      if (start_[i] != other.start_[i]) {
        return false;
      }
    }
    return true;
  }

 protected:
  void set_start(T* start) { start_ = start; }

 private:
  T* start_;
  int length_;

  template <typename CookedComparer>
  class RawComparer {
   public:
    explicit RawComparer(CookedComparer cmp) : cmp_(cmp) {}
    bool operator()(const T& a, const T& b) {
      return cmp_(&a, &b) < 0;
    }

   private:
    CookedComparer cmp_;
  };
};


template <typename T>
class ScopedVector : public Vector<T> {
 public:
  explicit ScopedVector(int length) : Vector<T>(NewArray<T>(length), length) { }
  ~ScopedVector() {
    DeleteArray(this->start());
  }

 private:
  ScopedVector() = delete; ScopedVector(const ScopedVector&) = delete; void operator=(const ScopedVector&) = delete;
};


inline int StrLength(const char* string) {
  size_t length = strlen(string);
  do { if ((!(length == static_cast<size_t>(static_cast<int>(length))))) { V8_Fatal(".././src/vector.h", 174, "Check failed: %s.", "length == static_cast<size_t>(static_cast<int>(length))"); } } while (0);
  return static_cast<int>(length);
}






inline Vector<const char> CStrVector(const char* data) {
  return Vector<const char>(data, StrLength(data));
}

inline Vector<const uint8_t> OneByteVector(const char* data, int length) {
  return Vector<const uint8_t>(reinterpret_cast<const uint8_t*>(data), length);
}

inline Vector<const uint8_t> OneByteVector(const char* data) {
  return OneByteVector(data, StrLength(data));
}

inline Vector<char> MutableCStrVector(char* data) {
  return Vector<char>(data, StrLength(data));
}

inline Vector<char> MutableCStrVector(char* data, int max) {
  int length = StrLength(data);
  return Vector<char>(data, (length < max) ? length : max);
}


}
}

namespace v8 {
namespace internal {






inline int HexValue(uc32 c) {
  c -= '\x30';
  if (static_cast<unsigned>(c) <= 9) return c;
  c = (c | 0x20) - ('\x61' - '\x30');
  if (static_cast<unsigned>(c) <= 5) return c + 10;
  return -1;
}


inline int BoolToInt(bool b) { return b ? 1 : 0; }



inline bool CStringEquals(const char* s1, const char* s2) {
  return (s1 == s2) || (s1 != 0 && s2 != 0 && strcmp(s1, s2) == 0);
}



inline int WhichPowerOf2(uint32_t x) {
  do { if ((!(base::bits::IsPowerOfTwo32(x)))) { V8_Fatal(".././src/utils.h", 51, "Check failed: %s.", "base::bits::IsPowerOfTwo32(x)"); } } while (0);
  int bits = 0;

  uint32_t original_x = x;

  if (x >= 0x10000) {
    bits += 16;
    x >>= 16;
  }
  if (x >= 0x100) {
    bits += 8;
    x >>= 8;
  }
  if (x >= 0x10) {
    bits += 4;
    x >>= 4;
  }
  switch (x) {
    default: V8_Fatal(".././src/utils.h", 69, "unreachable code");
    case 8: bits++;
    case 4: bits++;
    case 2: bits++;
    case 1: break;
  }
  do { if (std::string* _msg = ::v8::base::CheckEQImpl( (static_cast<uint32_t>(1) << bits), (original_x), "static_cast<uint32_t>(1) << bits" " " "==" " " "original_x")) { V8_Fatal(".././src/utils.h", 75, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
  return bits;
}



inline int WhichPowerOf2_64(uint64_t x) {
  do { if ((!(base::bits::IsPowerOfTwo64(x)))) { V8_Fatal(".././src/utils.h", 82, "Check failed: %s.", "base::bits::IsPowerOfTwo64(x)"); } } while (0);
  int bits = 0;

  uint64_t original_x = x;

  if (x >= 0x100000000L) {
    bits += 32;
    x >>= 32;
  }
  if (x >= 0x10000) {
    bits += 16;
    x >>= 16;
  }
  if (x >= 0x100) {
    bits += 8;
    x >>= 8;
  }
  if (x >= 0x10) {
    bits += 4;
    x >>= 4;
  }
  switch (x) {
    default: V8_Fatal(".././src/utils.h", 104, "unreachable code");
    case 8: bits++;
    case 4: bits++;
    case 2: bits++;
    case 1: break;
  }
  do { if (std::string* _msg = ::v8::base::CheckEQImpl( (static_cast<uint64_t>(1) << bits), (original_x), "static_cast<uint64_t>(1) << bits" " " "==" " " "original_x")) { V8_Fatal(".././src/utils.h", 110, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
  return bits;
}


inline int MostSignificantBit(uint32_t x) {
  static const int msb4[] = {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4};
  int nibble = 0;
  if (x & 0xffff0000) {
    nibble += 16;
    x >>= 16;
  }
  if (x & 0xff00) {
    nibble += 8;
    x >>= 8;
  }
  if (x & 0xf0) {
    nibble += 4;
    x >>= 4;
  }
  return nibble + msb4[x];
}





inline int ArithmeticShiftRight(int x, int s) {
  return x >> s;
}


template <typename T>
int Compare(const T& a, const T& b) {
  if (a == b)
    return 0;
  else if (a < b)
    return -1;
  else
    return 1;
}


template <typename T>
int PointerValueCompare(const T* a, const T* b) {
  return Compare<T>(*a, *b);
}





template<typename T> class Handle;
template <typename T>
int HandleObjectPointerCompare(const Handle<T>* a, const Handle<T>* b) {
  return Compare<T*>(*(*a), *(*b));
}


template <typename T, typename U>
inline bool IsAligned(T value, U alignment) {
  return (value & (alignment - 1)) == 0;
}



inline bool IsAddressAligned(Address addr,
                             intptr_t alignment,
                             int offset = 0) {
  intptr_t offs = OffsetFrom(addr + offset);
  return IsAligned(offs, alignment);
}



template <typename T>
T Max(T a, T b) {
  return a < b ? b : a;
}



template <typename T>
T Min(T a, T b) {
  return a < b ? a : b;
}



template <typename T>
T Abs(T a) {
  return a < 0 ? -a : a;
}



inline double Floor(double x) {



  return std::floor(x);
}



inline int32_t WhichPowerOf2Abs(int32_t x) {
  return (x == kMinInt) ? 31 : WhichPowerOf2(Abs(x));
}




template<typename T>
struct make_unsigned {
  typedef T type;
};



template<> struct make_unsigned<int32_t> {
  typedef uint32_t type;
};


template<> struct make_unsigned<int64_t> {
  typedef uint64_t type;
};






template<class T, int shift, int size, class U>
class BitFieldBase {
 public:



  static const U kOne = static_cast<U>(1U);
  static const U kMask = ((kOne << shift) << size) - (kOne << shift);
  static const U kShift = shift;
  static const U kSize = size;
  static const U kNext = kShift + kSize;


  static const T kMax = static_cast<T>((kOne << size) - 1);


  static bool is_valid(T value) {
    return (static_cast<U>(value) & ~static_cast<U>(kMax)) == 0;
  }


  static U encode(T value) {
    do { if ((!(is_valid(value)))) { V8_Fatal(".././src/utils.h", 265, "Check failed: %s.", "is_valid(value)"); } } while (0);
    return static_cast<U>(value) << shift;
  }


  static U update(U previous, T value) {
    return (previous & ~kMask) | encode(value);
  }


  static T decode(U value) {
    return static_cast<T>((value & kMask) >> shift);
  }
};


template <class T, int shift, int size>
class BitField8 : public BitFieldBase<T, shift, size, uint8_t> {};


template <class T, int shift, int size>
class BitField16 : public BitFieldBase<T, shift, size, uint16_t> {};


template<class T, int shift, int size>
class BitField : public BitFieldBase<T, shift, size, uint32_t> { };


template<class T, int shift, int size>
class BitField64 : public BitFieldBase<T, shift, size, uint64_t> { };
template <class T, int kBitsPerItem, int kBitsPerWord, class U>
class BitSetComputer {
 public:
  static const int kItemsPerWord = kBitsPerWord / kBitsPerItem;
  static const int kMask = (1 << kBitsPerItem) - 1;


  static int word_count(int items) {
    if (items == 0) return 0;
    return (items - 1) / kItemsPerWord + 1;
  }


  static int index(int base_index, int item) {
    return base_index + item / kItemsPerWord;
  }


  static T decode(U data, int item) {
    return static_cast<T>((data >> shift(item)) & kMask);
  }


  static U encode(U previous, int item, T value) {
    int shift_value = shift(item);
    int set_bits = (static_cast<int>(value) << shift_value);
    return (previous & ~(kMask << shift_value)) | set_bits;
  }

  static int shift(int item) { return (item % kItemsPerWord) * kBitsPerItem; }
};





static const uint32_t kZeroHashSeed = 0;



inline uint32_t ComputeIntegerHash(uint32_t key, uint32_t seed) {
  uint32_t hash = key;
  hash = hash ^ seed;
  hash = ~hash + (hash << 15);
  hash = hash ^ (hash >> 12);
  hash = hash + (hash << 2);
  hash = hash ^ (hash >> 4);
  hash = hash * 2057;
  hash = hash ^ (hash >> 16);
  return hash & 0x3fffffff;
}


inline uint32_t ComputeLongHash(uint64_t key) {
  uint64_t hash = key;
  hash = ~hash + (hash << 18);
  hash = hash ^ (hash >> 31);
  hash = hash * 21;
  hash = hash ^ (hash >> 11);
  hash = hash + (hash << 6);
  hash = hash ^ (hash >> 22);
  return static_cast<uint32_t>(hash);
}


inline uint32_t ComputePointerHash(void* ptr) {
  return ComputeIntegerHash(
      static_cast<uint32_t>(reinterpret_cast<intptr_t>(ptr)),
      v8::internal::kZeroHashSeed);
}






void init_memcopy_functions(Isolate* isolate);
inline void MemCopy(void* dest, const void* src, size_t size) {
  memcpy(dest, src, size);
}
inline void MemMove(void* dest, const void* src, size_t size) {
  memmove(dest, src, size);
}
const int kMinComplexMemCopy = 16 * kPointerSize;
template <typename T>
class StaticResource {
 public:
  StaticResource() : is_reserved_(false) {}

 private:
  template <typename S> friend class Access;
  T instance_;
  bool is_reserved_;
};



template <typename T>
class Access {
 public:
  explicit Access(StaticResource<T>* resource)
    : resource_(resource)
    , instance_(&resource->instance_) {
    do { if ((!(!resource->is_reserved_))) { V8_Fatal(".././src/utils.h", 479, "Check failed: %s.", "!resource->is_reserved_"); } } while (0);
    resource->is_reserved_ = true;
  }

  ~Access() {
    resource_->is_reserved_ = false;
    resource_ = 0;
    instance_ = 0;
  }

  T* value() { return instance_; }
  T* operator -> () { return instance_; }

 private:
  StaticResource<T>* resource_;
  T* instance_;
};



template<typename T>
class SetOncePointer {
 public:
  SetOncePointer() : pointer_(0) { }

  bool is_set() const { return pointer_ != 0; }

  T* get() const {
    do { if ((!(pointer_ != 0))) { V8_Fatal(".././src/utils.h", 507, "Check failed: %s.", "pointer_ != 0"); } } while (0);
    return pointer_;
  }

  void set(T* value) {
    do { if ((!(pointer_ == 0 && value != 0))) { V8_Fatal(".././src/utils.h", 512, "Check failed: %s.", "pointer_ == 0 && value != 0"); } } while (0);
    pointer_ = value;
  }

 private:
  T* pointer_;
};


template <typename T, int kSize>
class EmbeddedVector : public Vector<T> {
 public:
  EmbeddedVector() : Vector<T>(buffer_, kSize) { }

  explicit EmbeddedVector(T initial_value) : Vector<T>(buffer_, kSize) {
    for (int i = 0; i < kSize; ++i) {
      buffer_[i] = initial_value;
    }
  }


  EmbeddedVector(const EmbeddedVector& rhs)
      : Vector<T>(rhs) {
    MemCopy(buffer_, rhs.buffer_, sizeof(T) * kSize);
    this->set_start(buffer_);
  }

  EmbeddedVector& operator=(const EmbeddedVector& rhs) {
    if (this == &rhs) return *this;
    Vector<T>::operator=(rhs);
    MemCopy(buffer_, rhs.buffer_, sizeof(T) * kSize);
    this->set_start(buffer_);
    return *this;
  }

 private:
  T buffer_[kSize];
};


template <typename lchar, typename rchar>
inline int CompareCharsUnsigned(const lchar* lhs, const rchar* rhs,
                                size_t chars) {
  const lchar* limit = lhs + chars;
  if (sizeof(*lhs) == sizeof(char) && sizeof(*rhs) == sizeof(char)) {


    return memcmp(lhs, rhs, chars);
  }
  while (lhs < limit) {
    int r = static_cast<int>(*lhs) - static_cast<int>(*rhs);
    if (r != 0) return r;
    ++lhs;
    ++rhs;
  }
  return 0;
}

template <typename lchar, typename rchar>
inline int CompareChars(const lchar* lhs, const rchar* rhs, size_t chars) {
  do { if ((!(sizeof(lchar) <= 2))) { V8_Fatal(".././src/utils.h", 572, "Check failed: %s.", "sizeof(lchar) <= 2"); } } while (0);
  do { if ((!(sizeof(rchar) <= 2))) { V8_Fatal(".././src/utils.h", 573, "Check failed: %s.", "sizeof(rchar) <= 2"); } } while (0);
  if (sizeof(lchar) == 1) {
    if (sizeof(rchar) == 1) {
      return CompareCharsUnsigned(reinterpret_cast<const uint8_t*>(lhs),
                                  reinterpret_cast<const uint8_t*>(rhs),
                                  chars);
    } else {
      return CompareCharsUnsigned(reinterpret_cast<const uint8_t*>(lhs),
                                  reinterpret_cast<const uint16_t*>(rhs),
                                  chars);
    }
  } else {
    if (sizeof(rchar) == 1) {
      return CompareCharsUnsigned(reinterpret_cast<const uint16_t*>(lhs),
                                  reinterpret_cast<const uint8_t*>(rhs),
                                  chars);
    } else {
      return CompareCharsUnsigned(reinterpret_cast<const uint16_t*>(lhs),
                                  reinterpret_cast<const uint16_t*>(rhs),
                                  chars);
    }
  }
}



inline int TenToThe(int exponent) {
  do { if ((!(exponent <= 9))) { V8_Fatal(".././src/utils.h", 600, "Check failed: %s.", "exponent <= 9"); } } while (0);
  do { if ((!(exponent >= 1))) { V8_Fatal(".././src/utils.h", 601, "Check failed: %s.", "exponent >= 1"); } } while (0);
  int answer = 10;
  for (int i = 1; i < exponent; i++) answer *= 10;
  return answer;
}


template<typename ElementType, int NumElements>
class EmbeddedContainer {
 public:
  EmbeddedContainer() : elems_() { }

  int length() const { return NumElements; }
  const ElementType& operator[](int i) const {
    do { if ((!(i < length()))) { V8_Fatal(".././src/utils.h", 615, "Check failed: %s.", "i < length()"); } } while (0);
    return elems_[i];
  }
  ElementType& operator[](int i) {
    do { if ((!(i < length()))) { V8_Fatal(".././src/utils.h", 619, "Check failed: %s.", "i < length()"); } } while (0);
    return elems_[i];
  }

 private:
  ElementType elems_[NumElements];
};


template<typename ElementType>
class EmbeddedContainer<ElementType, 0> {
 public:
  int length() const { return 0; }
  const ElementType& operator[](int i) const {
    V8_Fatal(".././src/utils.h", 633, "unreachable code");
    static ElementType t = 0;
    return t;
  }
  ElementType& operator[](int i) {
    V8_Fatal(".././src/utils.h", 638, "unreachable code");
    static ElementType t = 0;
    return t;
  }
};






class SimpleStringBuilder {
 public:



  explicit SimpleStringBuilder(int size);

  SimpleStringBuilder(char* buffer, int size)
      : buffer_(buffer, size), position_(0) { }

  ~SimpleStringBuilder() { if (!is_finalized()) Finalize(); }

  int size() const { return buffer_.length(); }


  int position() const {
    do { if ((!(!is_finalized()))) { V8_Fatal(".././src/utils.h", 665, "Check failed: %s.", "!is_finalized()"); } } while (0);
    return position_;
  }


  void Reset() { position_ = 0; }




  void AddCharacter(char c) {
    do { if ((!(c != '\0'))) { V8_Fatal(".././src/utils.h", 676, "Check failed: %s.", "c != '\\0'"); } } while (0);
    do { if ((!(!is_finalized() && position_ < buffer_.length()))) { V8_Fatal(".././src/utils.h", 677, "Check failed: %s.", "!is_finalized() && position_ < buffer_.length()"); } } while (0);
    buffer_[position_++] = c;
  }



  void AddString(const char* s);



  void AddSubstring(const char* s, int n);



  void AddPadding(char c, int count);


  void AddDecimalInteger(int value);


  char* Finalize();

 protected:
  Vector<char> buffer_;
  int position_;

  bool is_finalized() const { return position_ < 0; }

 private:
  SimpleStringBuilder() = delete; SimpleStringBuilder(const SimpleStringBuilder&) = delete; void operator=(const SimpleStringBuilder&) = delete;
};




template <class E, class T = int>
class EnumSet {
 public:
  explicit EnumSet(T bits = 0) : bits_(bits) {}
  bool IsEmpty() const { return bits_ == 0; }
  bool Contains(E element) const { return (bits_ & Mask(element)) != 0; }
  bool ContainsAnyOf(const EnumSet& set) const {
    return (bits_ & set.bits_) != 0;
  }
  void Add(E element) { bits_ |= Mask(element); }
  void Add(const EnumSet& set) { bits_ |= set.bits_; }
  void Remove(E element) { bits_ &= ~Mask(element); }
  void Remove(const EnumSet& set) { bits_ &= ~set.bits_; }
  void RemoveAll() { bits_ = 0; }
  void Intersect(const EnumSet& set) { bits_ &= set.bits_; }
  T ToIntegral() const { return bits_; }
  bool operator==(const EnumSet& set) { return bits_ == set.bits_; }
  bool operator!=(const EnumSet& set) { return bits_ != set.bits_; }
  EnumSet<E, T> operator|(const EnumSet& set) const {
    return EnumSet<E, T>(bits_ | set.bits_);
  }

 private:
  T Mask(E element) const {


    do { if ((!(static_cast<int>(element) < static_cast<int>(sizeof(T) * 8)))) { V8_Fatal(".././src/utils.h", 738, "Check failed: %s.", "static_cast<int>(element) < static_cast<int>(sizeof(T) * 8)"); } } while (0);
    return static_cast<T>(1) << element;
  }

  T bits_;
};


inline uint32_t unsigned_bitextract_32(int msb, int lsb, uint32_t x) {
  return (x >> lsb) & ((1 << (1 + msb - lsb)) - 1);
}

inline uint64_t unsigned_bitextract_64(int msb, int lsb, uint64_t x) {
  return (x >> lsb) & ((static_cast<uint64_t>(1) << (1 + msb - lsb)) - 1);
}

inline int32_t signed_bitextract_32(int msb, int lsb, int32_t x) {
  return (x << (31 - msb)) >> (lsb + 31 - msb);
}

inline int signed_bitextract_64(int msb, int lsb, int x) {

  return (x << (63 - msb)) >> (lsb + 63 - msb);
}


inline bool is_intn(int64_t x, unsigned n) {
  do { if ((!((0 < n) && (n < 64)))) { V8_Fatal(".././src/utils.h", 765, "Check failed: %s.", "(0 < n) && (n < 64)"); } } while (0);
  int64_t limit = static_cast<int64_t>(1) << (n - 1);
  return (-limit <= x) && (x < limit);
}

inline bool is_uintn(int64_t x, unsigned n) {
  do { if ((!((0 < n) && (n < (sizeof(x) * kBitsPerByte))))) { V8_Fatal(".././src/utils.h", 771, "Check failed: %s.", "(0 < n) && (n < (sizeof(x) * kBitsPerByte))"); } } while (0);
  return !(x >> n);
}

template <class T>
inline T truncate_to_intn(T x, unsigned n) {
  do { if ((!((0 < n) && (n < (sizeof(x) * kBitsPerByte))))) { V8_Fatal(".././src/utils.h", 777, "Check failed: %s.", "(0 < n) && (n < (sizeof(x) * kBitsPerByte))"); } } while (0);
  return (x & ((static_cast<T>(1) << n) - 1));
}
inline bool is_int1(int64_t x) { return is_intn(x, 1); } inline bool is_int2(int64_t x) { return is_intn(x, 2); } inline bool is_int3(int64_t x) { return is_intn(x, 3); } inline bool is_int4(int64_t x) { return is_intn(x, 4); } inline bool is_int5(int64_t x) { return is_intn(x, 5); } inline bool is_int6(int64_t x) { return is_intn(x, 6); } inline bool is_int7(int64_t x) { return is_intn(x, 7); } inline bool is_int8(int64_t x) { return is_intn(x, 8); } inline bool is_int9(int64_t x) { return is_intn(x, 9); } inline bool is_int10(int64_t x) { return is_intn(x, 10); } inline bool is_int11(int64_t x) { return is_intn(x, 11); } inline bool is_int12(int64_t x) { return is_intn(x, 12); } inline bool is_int13(int64_t x) { return is_intn(x, 13); } inline bool is_int14(int64_t x) { return is_intn(x, 14); } inline bool is_int15(int64_t x) { return is_intn(x, 15); } inline bool is_int16(int64_t x) { return is_intn(x, 16); } inline bool is_int17(int64_t x) { return is_intn(x, 17); } inline bool is_int18(int64_t x) { return is_intn(x, 18); } inline bool is_int19(int64_t x) { return is_intn(x, 19); } inline bool is_int20(int64_t x) { return is_intn(x, 20); } inline bool is_int21(int64_t x) { return is_intn(x, 21); } inline bool is_int22(int64_t x) { return is_intn(x, 22); } inline bool is_int23(int64_t x) { return is_intn(x, 23); } inline bool is_int24(int64_t x) { return is_intn(x, 24); } inline bool is_int25(int64_t x) { return is_intn(x, 25); } inline bool is_int26(int64_t x) { return is_intn(x, 26); } inline bool is_int27(int64_t x) { return is_intn(x, 27); } inline bool is_int28(int64_t x) { return is_intn(x, 28); } inline bool is_int29(int64_t x) { return is_intn(x, 29); } inline bool is_int30(int64_t x) { return is_intn(x, 30); } inline bool is_int31(int64_t x) { return is_intn(x, 31); } inline bool is_int32(int64_t x) { return is_intn(x, 32); } inline bool is_int33(int64_t x) { return is_intn(x, 33); } inline bool is_int34(int64_t x) { return is_intn(x, 34); } inline bool is_int35(int64_t x) { return is_intn(x, 35); } inline bool is_int36(int64_t x) { return is_intn(x, 36); } inline bool is_int37(int64_t x) { return is_intn(x, 37); } inline bool is_int38(int64_t x) { return is_intn(x, 38); } inline bool is_int39(int64_t x) { return is_intn(x, 39); } inline bool is_int40(int64_t x) { return is_intn(x, 40); } inline bool is_int41(int64_t x) { return is_intn(x, 41); } inline bool is_int42(int64_t x) { return is_intn(x, 42); } inline bool is_int43(int64_t x) { return is_intn(x, 43); } inline bool is_int44(int64_t x) { return is_intn(x, 44); } inline bool is_int45(int64_t x) { return is_intn(x, 45); } inline bool is_int46(int64_t x) { return is_intn(x, 46); } inline bool is_int47(int64_t x) { return is_intn(x, 47); } inline bool is_int48(int64_t x) { return is_intn(x, 48); } inline bool is_int49(int64_t x) { return is_intn(x, 49); } inline bool is_int50(int64_t x) { return is_intn(x, 50); } inline bool is_int51(int64_t x) { return is_intn(x, 51); } inline bool is_int52(int64_t x) { return is_intn(x, 52); } inline bool is_int53(int64_t x) { return is_intn(x, 53); } inline bool is_int54(int64_t x) { return is_intn(x, 54); } inline bool is_int55(int64_t x) { return is_intn(x, 55); } inline bool is_int56(int64_t x) { return is_intn(x, 56); } inline bool is_int57(int64_t x) { return is_intn(x, 57); } inline bool is_int58(int64_t x) { return is_intn(x, 58); } inline bool is_int59(int64_t x) { return is_intn(x, 59); } inline bool is_int60(int64_t x) { return is_intn(x, 60); } inline bool is_int61(int64_t x) { return is_intn(x, 61); } inline bool is_int62(int64_t x) { return is_intn(x, 62); } inline bool is_int63(int64_t x) { return is_intn(x, 63); }
template <class T> inline bool is_uint1(T x) { return is_uintn(x, 1); } template <class T> inline bool is_uint2(T x) { return is_uintn(x, 2); } template <class T> inline bool is_uint3(T x) { return is_uintn(x, 3); } template <class T> inline bool is_uint4(T x) { return is_uintn(x, 4); } template <class T> inline bool is_uint5(T x) { return is_uintn(x, 5); } template <class T> inline bool is_uint6(T x) { return is_uintn(x, 6); } template <class T> inline bool is_uint7(T x) { return is_uintn(x, 7); } template <class T> inline bool is_uint8(T x) { return is_uintn(x, 8); } template <class T> inline bool is_uint9(T x) { return is_uintn(x, 9); } template <class T> inline bool is_uint10(T x) { return is_uintn(x, 10); } template <class T> inline bool is_uint11(T x) { return is_uintn(x, 11); } template <class T> inline bool is_uint12(T x) { return is_uintn(x, 12); } template <class T> inline bool is_uint13(T x) { return is_uintn(x, 13); } template <class T> inline bool is_uint14(T x) { return is_uintn(x, 14); } template <class T> inline bool is_uint15(T x) { return is_uintn(x, 15); } template <class T> inline bool is_uint16(T x) { return is_uintn(x, 16); } template <class T> inline bool is_uint17(T x) { return is_uintn(x, 17); } template <class T> inline bool is_uint18(T x) { return is_uintn(x, 18); } template <class T> inline bool is_uint19(T x) { return is_uintn(x, 19); } template <class T> inline bool is_uint20(T x) { return is_uintn(x, 20); } template <class T> inline bool is_uint21(T x) { return is_uintn(x, 21); } template <class T> inline bool is_uint22(T x) { return is_uintn(x, 22); } template <class T> inline bool is_uint23(T x) { return is_uintn(x, 23); } template <class T> inline bool is_uint24(T x) { return is_uintn(x, 24); } template <class T> inline bool is_uint25(T x) { return is_uintn(x, 25); } template <class T> inline bool is_uint26(T x) { return is_uintn(x, 26); } template <class T> inline bool is_uint27(T x) { return is_uintn(x, 27); } template <class T> inline bool is_uint28(T x) { return is_uintn(x, 28); } template <class T> inline bool is_uint29(T x) { return is_uintn(x, 29); } template <class T> inline bool is_uint30(T x) { return is_uintn(x, 30); } template <class T> inline bool is_uint31(T x) { return is_uintn(x, 31); } template <class T> inline bool is_uint32(T x) { return is_uintn(x, 32); } template <class T> inline bool is_uint33(T x) { return is_uintn(x, 33); } template <class T> inline bool is_uint34(T x) { return is_uintn(x, 34); } template <class T> inline bool is_uint35(T x) { return is_uintn(x, 35); } template <class T> inline bool is_uint36(T x) { return is_uintn(x, 36); } template <class T> inline bool is_uint37(T x) { return is_uintn(x, 37); } template <class T> inline bool is_uint38(T x) { return is_uintn(x, 38); } template <class T> inline bool is_uint39(T x) { return is_uintn(x, 39); } template <class T> inline bool is_uint40(T x) { return is_uintn(x, 40); } template <class T> inline bool is_uint41(T x) { return is_uintn(x, 41); } template <class T> inline bool is_uint42(T x) { return is_uintn(x, 42); } template <class T> inline bool is_uint43(T x) { return is_uintn(x, 43); } template <class T> inline bool is_uint44(T x) { return is_uintn(x, 44); } template <class T> inline bool is_uint45(T x) { return is_uintn(x, 45); } template <class T> inline bool is_uint46(T x) { return is_uintn(x, 46); } template <class T> inline bool is_uint47(T x) { return is_uintn(x, 47); } template <class T> inline bool is_uint48(T x) { return is_uintn(x, 48); } template <class T> inline bool is_uint49(T x) { return is_uintn(x, 49); } template <class T> inline bool is_uint50(T x) { return is_uintn(x, 50); } template <class T> inline bool is_uint51(T x) { return is_uintn(x, 51); } template <class T> inline bool is_uint52(T x) { return is_uintn(x, 52); } template <class T> inline bool is_uint53(T x) { return is_uintn(x, 53); } template <class T> inline bool is_uint54(T x) { return is_uintn(x, 54); } template <class T> inline bool is_uint55(T x) { return is_uintn(x, 55); } template <class T> inline bool is_uint56(T x) { return is_uintn(x, 56); } template <class T> inline bool is_uint57(T x) { return is_uintn(x, 57); } template <class T> inline bool is_uint58(T x) { return is_uintn(x, 58); } template <class T> inline bool is_uint59(T x) { return is_uintn(x, 59); } template <class T> inline bool is_uint60(T x) { return is_uintn(x, 60); } template <class T> inline bool is_uint61(T x) { return is_uintn(x, 61); } template <class T> inline bool is_uint62(T x) { return is_uintn(x, 62); } template <class T> inline bool is_uint63(T x) { return is_uintn(x, 63); }
template <class T> inline T truncate_to_int1(T x) { return truncate_to_intn(x, 1); } template <class T> inline T truncate_to_int2(T x) { return truncate_to_intn(x, 2); } template <class T> inline T truncate_to_int3(T x) { return truncate_to_intn(x, 3); } template <class T> inline T truncate_to_int4(T x) { return truncate_to_intn(x, 4); } template <class T> inline T truncate_to_int5(T x) { return truncate_to_intn(x, 5); } template <class T> inline T truncate_to_int6(T x) { return truncate_to_intn(x, 6); } template <class T> inline T truncate_to_int7(T x) { return truncate_to_intn(x, 7); } template <class T> inline T truncate_to_int8(T x) { return truncate_to_intn(x, 8); } template <class T> inline T truncate_to_int9(T x) { return truncate_to_intn(x, 9); } template <class T> inline T truncate_to_int10(T x) { return truncate_to_intn(x, 10); } template <class T> inline T truncate_to_int11(T x) { return truncate_to_intn(x, 11); } template <class T> inline T truncate_to_int12(T x) { return truncate_to_intn(x, 12); } template <class T> inline T truncate_to_int13(T x) { return truncate_to_intn(x, 13); } template <class T> inline T truncate_to_int14(T x) { return truncate_to_intn(x, 14); } template <class T> inline T truncate_to_int15(T x) { return truncate_to_intn(x, 15); } template <class T> inline T truncate_to_int16(T x) { return truncate_to_intn(x, 16); } template <class T> inline T truncate_to_int17(T x) { return truncate_to_intn(x, 17); } template <class T> inline T truncate_to_int18(T x) { return truncate_to_intn(x, 18); } template <class T> inline T truncate_to_int19(T x) { return truncate_to_intn(x, 19); } template <class T> inline T truncate_to_int20(T x) { return truncate_to_intn(x, 20); } template <class T> inline T truncate_to_int21(T x) { return truncate_to_intn(x, 21); } template <class T> inline T truncate_to_int22(T x) { return truncate_to_intn(x, 22); } template <class T> inline T truncate_to_int23(T x) { return truncate_to_intn(x, 23); } template <class T> inline T truncate_to_int24(T x) { return truncate_to_intn(x, 24); } template <class T> inline T truncate_to_int25(T x) { return truncate_to_intn(x, 25); } template <class T> inline T truncate_to_int26(T x) { return truncate_to_intn(x, 26); } template <class T> inline T truncate_to_int27(T x) { return truncate_to_intn(x, 27); } template <class T> inline T truncate_to_int28(T x) { return truncate_to_intn(x, 28); } template <class T> inline T truncate_to_int29(T x) { return truncate_to_intn(x, 29); } template <class T> inline T truncate_to_int30(T x) { return truncate_to_intn(x, 30); } template <class T> inline T truncate_to_int31(T x) { return truncate_to_intn(x, 31); } template <class T> inline T truncate_to_int32(T x) { return truncate_to_intn(x, 32); } template <class T> inline T truncate_to_int33(T x) { return truncate_to_intn(x, 33); } template <class T> inline T truncate_to_int34(T x) { return truncate_to_intn(x, 34); } template <class T> inline T truncate_to_int35(T x) { return truncate_to_intn(x, 35); } template <class T> inline T truncate_to_int36(T x) { return truncate_to_intn(x, 36); } template <class T> inline T truncate_to_int37(T x) { return truncate_to_intn(x, 37); } template <class T> inline T truncate_to_int38(T x) { return truncate_to_intn(x, 38); } template <class T> inline T truncate_to_int39(T x) { return truncate_to_intn(x, 39); } template <class T> inline T truncate_to_int40(T x) { return truncate_to_intn(x, 40); } template <class T> inline T truncate_to_int41(T x) { return truncate_to_intn(x, 41); } template <class T> inline T truncate_to_int42(T x) { return truncate_to_intn(x, 42); } template <class T> inline T truncate_to_int43(T x) { return truncate_to_intn(x, 43); } template <class T> inline T truncate_to_int44(T x) { return truncate_to_intn(x, 44); } template <class T> inline T truncate_to_int45(T x) { return truncate_to_intn(x, 45); } template <class T> inline T truncate_to_int46(T x) { return truncate_to_intn(x, 46); } template <class T> inline T truncate_to_int47(T x) { return truncate_to_intn(x, 47); } template <class T> inline T truncate_to_int48(T x) { return truncate_to_intn(x, 48); } template <class T> inline T truncate_to_int49(T x) { return truncate_to_intn(x, 49); } template <class T> inline T truncate_to_int50(T x) { return truncate_to_intn(x, 50); } template <class T> inline T truncate_to_int51(T x) { return truncate_to_intn(x, 51); } template <class T> inline T truncate_to_int52(T x) { return truncate_to_intn(x, 52); } template <class T> inline T truncate_to_int53(T x) { return truncate_to_intn(x, 53); } template <class T> inline T truncate_to_int54(T x) { return truncate_to_intn(x, 54); } template <class T> inline T truncate_to_int55(T x) { return truncate_to_intn(x, 55); } template <class T> inline T truncate_to_int56(T x) { return truncate_to_intn(x, 56); } template <class T> inline T truncate_to_int57(T x) { return truncate_to_intn(x, 57); } template <class T> inline T truncate_to_int58(T x) { return truncate_to_intn(x, 58); } template <class T> inline T truncate_to_int59(T x) { return truncate_to_intn(x, 59); } template <class T> inline T truncate_to_int60(T x) { return truncate_to_intn(x, 60); } template <class T> inline T truncate_to_int61(T x) { return truncate_to_intn(x, 61); } template <class T> inline T truncate_to_int62(T x) { return truncate_to_intn(x, 62); } template <class T> inline T truncate_to_int63(T x) { return truncate_to_intn(x, 63); }




class TypeFeedbackId {
 public:
  explicit TypeFeedbackId(int id) : id_(id) { }
  int ToInt() const { return id_; }

  static TypeFeedbackId None() { return TypeFeedbackId(kNoneId); }
  bool IsNone() const { return id_ == kNoneId; }

 private:
  static const int kNoneId = -1;

  int id_;
};

inline bool operator<(TypeFeedbackId lhs, TypeFeedbackId rhs) {
  return lhs.ToInt() < rhs.ToInt();
}
inline bool operator>(TypeFeedbackId lhs, TypeFeedbackId rhs) {
  return lhs.ToInt() > rhs.ToInt();
}


class FeedbackVectorSlot {
 public:
  FeedbackVectorSlot() : id_(kInvalidSlot) {}
  explicit FeedbackVectorSlot(int id) : id_(id) {}

  int ToInt() const { return id_; }

  static FeedbackVectorSlot Invalid() { return FeedbackVectorSlot(); }
  bool IsInvalid() const { return id_ == kInvalidSlot; }

  bool operator==(FeedbackVectorSlot that) const {
    return this->id_ == that.id_;
  }
  bool operator!=(FeedbackVectorSlot that) const { return !(*this == that); }

  friend size_t hash_value(FeedbackVectorSlot slot) { return slot.ToInt(); }
  friend std::ostream& operator<<(std::ostream& os, FeedbackVectorSlot);

 private:
  static const int kInvalidSlot = -1;

  int id_;
};


class BailoutId {
 public:
  explicit BailoutId(int id) : id_(id) { }
  int ToInt() const { return id_; }

  static BailoutId None() { return BailoutId(kNoneId); }
  static BailoutId ScriptContext() { return BailoutId(kScriptContextId); }
  static BailoutId FunctionContext() { return BailoutId(kFunctionContextId); }
  static BailoutId FunctionEntry() { return BailoutId(kFunctionEntryId); }
  static BailoutId Declarations() { return BailoutId(kDeclarationsId); }
  static BailoutId FirstUsable() { return BailoutId(kFirstUsableId); }
  static BailoutId StubEntry() { return BailoutId(kStubEntryId); }

  bool IsNone() const { return id_ == kNoneId; }
  bool operator==(const BailoutId& other) const { return id_ == other.id_; }
  bool operator!=(const BailoutId& other) const { return id_ != other.id_; }
  friend size_t hash_value(BailoutId);
  friend std::ostream& operator<<(std::ostream&, BailoutId);

 private:
  static const int kNoneId = -1;


  static const int kScriptContextId = 1;
  static const int kFunctionContextId = 2;
  static const int kFunctionEntryId = 3;




  static const int kDeclarationsId = 4;


  static const int kFirstUsableId = 5;


  static const int kStubEntryId = 6;

  int id_;
};

class TokenDispenserForFinally {
 public:
  int GetBreakContinueToken() { return next_token_++; }
  static const int kFallThroughToken = 0;
  static const int kThrowToken = 1;
  static const int kReturnToken = 2;

  static const int kFirstBreakContinueToken = 3;
  static const int kInvalidToken = -1;

 private:
  int next_token_ = kFirstBreakContinueToken;
};
void __attribute__ ((format (printf, 1, 2))) PrintF(const char* format, ...);
void __attribute__ ((format (printf, 2, 3))) PrintF(FILE* out, const char* format, ...);


void __attribute__ ((format (printf, 1, 2))) PrintPID(const char* format, ...);


void PrintIsolate(void* isolate, const char* format, ...);



int __attribute__ ((format (printf, 2, 3))) SNPrintF(Vector<char> str, const char* format, ...);
int VSNPrintF(Vector<char> str, const char* format, va_list args);

void StrNCpy(Vector<char> dest, const char* src, size_t n);


void Flush(FILE* out);

inline void Flush() {
  Flush(( *((__FILEP * const) (*(_Gtab(3))) ) ));
}




char* ReadLine(const char* prompt);





byte* ReadBytes(const char* filename, int* size, bool verbose = true);




int AppendChars(const char* filename,
                const char* str,
                int size,
                bool verbose = true);




int WriteChars(const char* filename,
               const char* str,
               int size,
               bool verbose = true);




int WriteBytes(const char* filename,
               const byte* bytes,
               int size,
               bool verbose = true);






int WriteAsCFile(const char* filename, const char* varname,
                 const char* str, int size, bool verbose = true);






template <typename T>
inline void CopyWords(T* dst, const T* src, size_t num_words) {
  static_assert(sizeof(T) == kPointerSize, "sizeof(T) == kPointerSize");





  do { if ((!(num_words > 0))) { V8_Fatal(".././src/utils.h", 1013, "Check failed: %s.", "num_words > 0"); } } while (0);



  static const size_t kBlockCopyLimit = 16;

  if (num_words < kBlockCopyLimit) {
    do {
      num_words--;
      *dst++ = *src++;
    } while (num_words > 0);
  } else {
    MemCopy(dst, src, num_words * kPointerSize);
  }
}



template <typename T>
inline void MoveWords(T* dst, const T* src, size_t num_words) {
  static_assert(sizeof(T) == kPointerSize, "sizeof(T) == kPointerSize");
  do { if ((!(num_words > 0))) { V8_Fatal(".././src/utils.h", 1034, "Check failed: %s.", "num_words > 0"); } } while (0);



  static const size_t kBlockCopyLimit = 16;

  if (num_words < kBlockCopyLimit &&
      ((dst < src) || (dst >= (src + num_words * kPointerSize)))) {
    T* end = dst + num_words;
    do {
      num_words--;
      *dst++ = *src++;
    } while (num_words > 0);
  } else {
    MemMove(dst, src, num_words * kPointerSize);
  }
}



template <typename T>
inline void CopyBytes(T* dst, const T* src, size_t num_bytes) {
  static_assert(sizeof(T) == 1, "sizeof(T) == 1");
  do { if ((!(Min(dst, const_cast<T*>(src)) + num_bytes <= Max(dst, const_cast<T*>(src))))) { V8_Fatal(".././src/utils.h", 1058, "Check failed: %s.", "Min(dst, const_cast<T*>(src)) + num_bytes <= Max(dst, const_cast<T*>(src))"); } } while (0);

  if (num_bytes == 0) return;



  static const int kBlockCopyLimit = kMinComplexMemCopy;

  if (num_bytes < static_cast<size_t>(kBlockCopyLimit)) {
    do {
      num_bytes--;
      *dst++ = *src++;
    } while (num_bytes > 0);
  } else {
    MemCopy(dst, src, num_bytes);
  }
}


template <typename T, typename U>
inline void MemsetPointer(T** dest, U* value, int counter) {

  T* a = 0;
  U* b = 0;
  a = b;
  USE(a);
  for (int i = 0; i < counter; i++) {
    dest[i] = value;
  }



}





Vector<const char> ReadFile(const char* filename,
                            bool* exists,
                            bool verbose = true);
Vector<const char> ReadFile(FILE* file,
                            bool* exists,
                            bool verbose = true);


template <typename sourcechar, typename sinkchar>
inline static void CopyCharsUnsigned(sinkchar* dest, const sourcechar* src, size_t chars);
inline void CopyCharsUnsigned(uint8_t* dest, const uint8_t* src, size_t chars);
inline void CopyCharsUnsigned(uint16_t* dest, const uint16_t* src, size_t chars);




template <typename sourcechar, typename sinkchar>
inline void CopyChars(sinkchar* dest, const sourcechar* src, size_t chars);

template <typename sourcechar, typename sinkchar>
void CopyChars(sinkchar* dest, const sourcechar* src, size_t chars) {
  do { if ((!(sizeof(sourcechar) <= 2))) { V8_Fatal(".././src/utils.h", 1159, "Check failed: %s.", "sizeof(sourcechar) <= 2"); } } while (0);
  do { if ((!(sizeof(sinkchar) <= 2))) { V8_Fatal(".././src/utils.h", 1160, "Check failed: %s.", "sizeof(sinkchar) <= 2"); } } while (0);
  if (sizeof(sinkchar) == 1) {
    if (sizeof(sourcechar) == 1) {
      CopyCharsUnsigned(reinterpret_cast<uint8_t*>(dest),
                        reinterpret_cast<const uint8_t*>(src),
                        chars);
    } else {
      CopyCharsUnsigned(reinterpret_cast<uint8_t*>(dest),
                        reinterpret_cast<const uint16_t*>(src),
                        chars);
    }
  } else {
    if (sizeof(sourcechar) == 1) {
      CopyCharsUnsigned(reinterpret_cast<uint16_t*>(dest),
                        reinterpret_cast<const uint8_t*>(src),
                        chars);
    } else {
      CopyCharsUnsigned(reinterpret_cast<uint16_t*>(dest),
                        reinterpret_cast<const uint16_t*>(src),
                        chars);
    }
  }
}

template <typename sourcechar, typename sinkchar>
void CopyCharsUnsigned(sinkchar* dest, const sourcechar* src, size_t chars) {
  sinkchar* limit = dest + chars;
  if ((sizeof(*dest) == sizeof(*src)) &&
      (chars >= static_cast<int>(kMinComplexMemCopy / sizeof(*dest)))) {
    MemCopy(dest, src, chars * sizeof(*dest));
  } else {
    while (dest < limit) *dest++ = static_cast<sinkchar>(*src++);
  }
}
void CopyCharsUnsigned(uint8_t* dest, const uint8_t* src, size_t chars) {
  switch (static_cast<unsigned>(chars)) {
    case 0:
      break;
    case 1:
      *dest = *src;
      break;
      case 2: memcpy(dest, src, 2); break;
      case 3: memcpy(dest, src, 3); break;
      case 4: memcpy(dest, src, 4); break;
      case 5: memcpy(dest, src, 5); break;
      case 6: memcpy(dest, src, 6); break;
      case 7: memcpy(dest, src, 7); break;
      case 8: memcpy(dest, src, 8); break;
      case 9: memcpy(dest, src, 9); break;
      case 10: memcpy(dest, src, 10); break;
      case 11: memcpy(dest, src, 11); break;
      case 12: memcpy(dest, src, 12); break;
      case 13: memcpy(dest, src, 13); break;
      case 14: memcpy(dest, src, 14); break;
      case 15: memcpy(dest, src, 15); break;
      case 16: memcpy(dest, src, 16); break;
      case 17: memcpy(dest, src, 17); break;
      case 18: memcpy(dest, src, 18); break;
      case 19: memcpy(dest, src, 19); break;
      case 20: memcpy(dest, src, 20); break;
      case 21: memcpy(dest, src, 21); break;
      case 22: memcpy(dest, src, 22); break;
      case 23: memcpy(dest, src, 23); break;
      case 24: memcpy(dest, src, 24); break;
      case 25: memcpy(dest, src, 25); break;
      case 26: memcpy(dest, src, 26); break;
      case 27: memcpy(dest, src, 27); break;
      case 28: memcpy(dest, src, 28); break;
      case 29: memcpy(dest, src, 29); break;
      case 30: memcpy(dest, src, 30); break;
      case 31: memcpy(dest, src, 31); break;
      case 32: memcpy(dest, src, 32); break;
      case 33: memcpy(dest, src, 33); break;
      case 34: memcpy(dest, src, 34); break;
      case 35: memcpy(dest, src, 35); break;
      case 36: memcpy(dest, src, 36); break;
      case 37: memcpy(dest, src, 37); break;
      case 38: memcpy(dest, src, 38); break;
      case 39: memcpy(dest, src, 39); break;
      case 40: memcpy(dest, src, 40); break;
      case 41: memcpy(dest, src, 41); break;
      case 42: memcpy(dest, src, 42); break;
      case 43: memcpy(dest, src, 43); break;
      case 44: memcpy(dest, src, 44); break;
      case 45: memcpy(dest, src, 45); break;
      case 46: memcpy(dest, src, 46); break;
      case 47: memcpy(dest, src, 47); break;
      case 48: memcpy(dest, src, 48); break;
      case 49: memcpy(dest, src, 49); break;
      case 50: memcpy(dest, src, 50); break;
      case 51: memcpy(dest, src, 51); break;
      case 52: memcpy(dest, src, 52); break;
      case 53: memcpy(dest, src, 53); break;
      case 54: memcpy(dest, src, 54); break;
      case 55: memcpy(dest, src, 55); break;
      case 56: memcpy(dest, src, 56); break;
      case 57: memcpy(dest, src, 57); break;
      case 58: memcpy(dest, src, 58); break;
      case 59: memcpy(dest, src, 59); break;
      case 60: memcpy(dest, src, 60); break;
      case 61: memcpy(dest, src, 61); break;
      case 62: memcpy(dest, src, 62); break;
      case 63: memcpy(dest, src, 63); break;
      case 64: memcpy(dest, src, 64); break;
    default:
      memcpy(dest, src, chars);
      break;
  }
}






void CopyCharsUnsigned(uint16_t* dest, const uint16_t* src, size_t chars) {
  switch (static_cast<unsigned>(chars)) {
    case 0:
      break;
    case 1:
      *dest = *src;
      break;
      case 2: memcpy(dest, src, 2 * 2); break;
      case 3: memcpy(dest, src, 3 * 2); break;
      case 4: memcpy(dest, src, 4 * 2); break;
      case 5: memcpy(dest, src, 5 * 2); break;
      case 6: memcpy(dest, src, 6 * 2); break;
      case 7: memcpy(dest, src, 7 * 2); break;
      case 8: memcpy(dest, src, 8 * 2); break;
      case 9: memcpy(dest, src, 9 * 2); break;
      case 10: memcpy(dest, src, 10 * 2); break;
      case 11: memcpy(dest, src, 11 * 2); break;
      case 12: memcpy(dest, src, 12 * 2); break;
      case 13: memcpy(dest, src, 13 * 2); break;
      case 14: memcpy(dest, src, 14 * 2); break;
      case 15: memcpy(dest, src, 15 * 2); break;
      case 16: memcpy(dest, src, 16 * 2); break;
      case 17: memcpy(dest, src, 17 * 2); break;
      case 18: memcpy(dest, src, 18 * 2); break;
      case 19: memcpy(dest, src, 19 * 2); break;
      case 20: memcpy(dest, src, 20 * 2); break;
      case 21: memcpy(dest, src, 21 * 2); break;
      case 22: memcpy(dest, src, 22 * 2); break;
      case 23: memcpy(dest, src, 23 * 2); break;
      case 24: memcpy(dest, src, 24 * 2); break;
      case 25: memcpy(dest, src, 25 * 2); break;
      case 26: memcpy(dest, src, 26 * 2); break;
      case 27: memcpy(dest, src, 27 * 2); break;
      case 28: memcpy(dest, src, 28 * 2); break;
      case 29: memcpy(dest, src, 29 * 2); break;
      case 30: memcpy(dest, src, 30 * 2); break;
      case 31: memcpy(dest, src, 31 * 2); break;
      case 32: memcpy(dest, src, 32 * 2); break;
    default:
      memcpy(dest, src, chars * 2);
      break;
  }
}




class StringBuilder : public SimpleStringBuilder {
 public:
  explicit StringBuilder(int size) : SimpleStringBuilder(size) { }
  StringBuilder(char* buffer, int size) : SimpleStringBuilder(buffer, size) { }


  void AddFormatted(const char* format, ...);


  void AddFormattedList(const char* format, va_list list);
 private:
  StringBuilder() = delete; StringBuilder(const StringBuilder&) = delete; void operator=(const StringBuilder&) = delete;
};


bool DoubleToBoolean(double d);

template <typename Stream>
bool StringToArrayIndex(Stream* stream, uint32_t* index) {
  uint16_t ch = stream->GetNext();



  if (ch == '\x30') {
    *index = 0;
    return !stream->HasMore();
  }


  int d = ch - '\x30';
  if (d < 0 || d > 9) return false;
  uint32_t result = d;
  while (stream->HasMore()) {
    d = stream->GetNext() - '\x30';
    if (d < 0 || d > 9) return false;

    if (result > 429496729U - ((d + 3) >> 3)) return false;
    result = (result * 10) + d;
  }

  *index = result;
  return true;
}




inline uintptr_t GetCurrentStackPosition() {


  uintptr_t limit = reinterpret_cast<uintptr_t>(&limit);
  return limit;
}

template <typename V>
static inline V ReadUnalignedValue(const void* p) {

  return *reinterpret_cast<const V*>(p);





}

template <typename V>
static inline void WriteUnalignedValue(void* p, V value) {

  *(reinterpret_cast<V*>(p)) = value;



}

static inline double ReadDoubleValue(const void* p) {
  return ReadUnalignedValue<double>(p);
}

static inline void WriteDoubleValue(void* p, double value) {
  WriteUnalignedValue(p, value);
}

static inline uint16_t ReadUnalignedUInt16(const void* p) {
  return ReadUnalignedValue<uint16_t>(p);
}

static inline void WriteUnalignedUInt16(void* p, uint16_t value) {
  WriteUnalignedValue(p, value);
}

static inline uint32_t ReadUnalignedUInt32(const void* p) {
  return ReadUnalignedValue<uint32_t>(p);
}

static inline void WriteUnalignedUInt32(void* p, uint32_t value) {
  WriteUnalignedValue(p, value);
}

}
}

namespace v8 {
namespace internal {

template<class AllocationPolicy>
class TemplateHashMapImpl {
 public:
  typedef bool (*MatchFun) (void* key1, void* key2);




  static const uint32_t kDefaultHashMapCapacity = 8;



  TemplateHashMapImpl(MatchFun match,
                      uint32_t capacity = kDefaultHashMapCapacity,
                      AllocationPolicy allocator = AllocationPolicy());

  ~TemplateHashMapImpl();




  struct Entry {
    void* key;
    void* value;
    uint32_t hash;
    int order;
  };



  Entry* Lookup(void* key, uint32_t hash) const;




  Entry* LookupOrInsert(void* key, uint32_t hash,
                        AllocationPolicy allocator = AllocationPolicy());




  void* Remove(void* key, uint32_t hash);


  void Clear();


  uint32_t occupancy() const { return occupancy_; }




  uint32_t capacity() const { return capacity_; }
  Entry* Start() const;
  Entry* Next(Entry* p) const;


  static bool PointersMatch(void* key1, void* key2) {
    return key1 == key2;
  }

 private:
  MatchFun match_;
  Entry* map_;
  uint32_t capacity_;
  uint32_t occupancy_;

  Entry* map_end() const { return map_ + capacity_; }
  Entry* Probe(void* key, uint32_t hash) const;
  void Initialize(uint32_t capacity, AllocationPolicy allocator);
  void Resize(AllocationPolicy allocator);
};

typedef TemplateHashMapImpl<FreeStoreAllocationPolicy> HashMap;

template<class AllocationPolicy>
TemplateHashMapImpl<AllocationPolicy>::TemplateHashMapImpl(
    MatchFun match, uint32_t initial_capacity, AllocationPolicy allocator) {
  match_ = match;
  Initialize(initial_capacity, allocator);
}


template<class AllocationPolicy>
TemplateHashMapImpl<AllocationPolicy>::~TemplateHashMapImpl() {
  AllocationPolicy::Delete(map_);
}


template <class AllocationPolicy>
typename TemplateHashMapImpl<AllocationPolicy>::Entry*
TemplateHashMapImpl<AllocationPolicy>::Lookup(void* key, uint32_t hash) const {
  Entry* p = Probe(key, hash);
  return p->key != 0 ? p : 0;
}


template <class AllocationPolicy>
typename TemplateHashMapImpl<AllocationPolicy>::Entry*
TemplateHashMapImpl<AllocationPolicy>::LookupOrInsert(
    void* key, uint32_t hash, AllocationPolicy allocator) {

  Entry* p = Probe(key, hash);
  if (p->key != 0) {
    return p;
  }


  p->key = key;
  p->value = 0;
  p->hash = hash;
  p->order = occupancy_;
  occupancy_++;


  if (occupancy_ + occupancy_ / 4 >= capacity_) {
    Resize(allocator);
    p = Probe(key, hash);
  }

  return p;
}


template<class AllocationPolicy>
void* TemplateHashMapImpl<AllocationPolicy>::Remove(void* key, uint32_t hash) {

  Entry* p = Probe(key, hash);
  if (p->key == 0) {

    return 0;
  }

  void* value = p->value;
  do { if ((!(occupancy_ < capacity_))) { V8_Fatal(".././src/hashmap.h", 173, "Check failed: %s.", "occupancy_ < capacity_"); } } while (0);


  Entry* q = p;
  while (true) {

    q = q + 1;
    if (q == map_end()) {
      q = map_;
    }




    if (q->key == 0) {
      break;
    }


    Entry* r = map_ + (q->hash & (capacity_ - 1));




    if ((q > p && (r <= p || r > q)) ||
        (q < p && (r <= p && r > q))) {
      *p = *q;
      p = q;
    }
  }


  p->key = 0;
  occupancy_--;
  return value;
}


template<class AllocationPolicy>
void TemplateHashMapImpl<AllocationPolicy>::Clear() {

  const Entry* end = map_end();
  for (Entry* p = map_; p < end; p++) {
    p->key = 0;
  }
  occupancy_ = 0;
}


template<class AllocationPolicy>
typename TemplateHashMapImpl<AllocationPolicy>::Entry*
    TemplateHashMapImpl<AllocationPolicy>::Start() const {
  return Next(map_ - 1);
}


template<class AllocationPolicy>
typename TemplateHashMapImpl<AllocationPolicy>::Entry*
    TemplateHashMapImpl<AllocationPolicy>::Next(Entry* p) const {
  const Entry* end = map_end();
  do { if ((!(map_ - 1 <= p && p < end))) { V8_Fatal(".././src/hashmap.h", 233, "Check failed: %s.", "map_ - 1 <= p && p < end"); } } while (0);
  for (p++; p < end; p++) {
    if (p->key != 0) {
      return p;
    }
  }
  return 0;
}


template <class AllocationPolicy>
typename TemplateHashMapImpl<AllocationPolicy>::Entry*
TemplateHashMapImpl<AllocationPolicy>::Probe(void* key, uint32_t hash) const {
  do { if ((!(key != 0))) { V8_Fatal(".././src/hashmap.h", 246, "Check failed: %s.", "key != 0"); } } while (0);

  do { if ((!(base::bits::IsPowerOfTwo32(capacity_)))) { V8_Fatal(".././src/hashmap.h", 248, "Check failed: %s.", "base::bits::IsPowerOfTwo32(capacity_)"); } } while (0);
  Entry* p = map_ + (hash & (capacity_ - 1));
  const Entry* end = map_end();
  do { if ((!(map_ <= p && p < end))) { V8_Fatal(".././src/hashmap.h", 251, "Check failed: %s.", "map_ <= p && p < end"); } } while (0);

  do { if ((!(occupancy_ < capacity_))) { V8_Fatal(".././src/hashmap.h", 253, "Check failed: %s.", "occupancy_ < capacity_"); } } while (0);
  while (p->key != 0 && (hash != p->hash || !match_(key, p->key))) {
    p++;
    if (p >= end) {
      p = map_;
    }
  }

  return p;
}


template<class AllocationPolicy>
void TemplateHashMapImpl<AllocationPolicy>::Initialize(
    uint32_t capacity, AllocationPolicy allocator) {
  do { if ((!(base::bits::IsPowerOfTwo32(capacity)))) { V8_Fatal(".././src/hashmap.h", 268, "Check failed: %s.", "base::bits::IsPowerOfTwo32(capacity)"); } } while (0);
  map_ = reinterpret_cast<Entry*>(allocator.New(capacity * sizeof(Entry)));
  if (map_ == 0) {
    v8::internal::FatalProcessOutOfMemory(u8"HashMap::Initialize");
    return;
  }
  capacity_ = capacity;
  Clear();
}


template<class AllocationPolicy>
void TemplateHashMapImpl<AllocationPolicy>::Resize(AllocationPolicy allocator) {
  Entry* map = map_;
  uint32_t n = occupancy_;


  Initialize(capacity_ * 2, allocator);


  for (Entry* p = map; n > 0; p++) {
    if (p->key != 0) {
      Entry* entry = LookupOrInsert(p->key, p->hash, allocator);
      entry->value = p->value;
      entry->order = p->order;
      n--;
    }
  }


  AllocationPolicy::Delete(map);
}



template<class Key, class Value, class AllocationPolicy>
class TemplateHashMap: private TemplateHashMapImpl<AllocationPolicy> {
 public:
  static_assert(sizeof(Key*) == sizeof(void*), "sizeof(Key*) == sizeof(void*)");
  static_assert(sizeof(Value*) == sizeof(void*), "sizeof(Value*) == sizeof(void*)");
  struct value_type {
    Key* first;
    Value* second;
  };

  class Iterator {
   public:
    Iterator& operator++() {
      entry_ = map_->Next(entry_);
      return *this;
    }

    value_type* operator->() { return reinterpret_cast<value_type*>(entry_); }
    bool operator!=(const Iterator& other) { return entry_ != other.entry_; }

   private:
    Iterator(const TemplateHashMapImpl<AllocationPolicy>* map,
             typename TemplateHashMapImpl<AllocationPolicy>::Entry* entry) :
        map_(map), entry_(entry) { }

    const TemplateHashMapImpl<AllocationPolicy>* map_;
    typename TemplateHashMapImpl<AllocationPolicy>::Entry* entry_;

    friend class TemplateHashMap;
  };

  TemplateHashMap(
      typename TemplateHashMapImpl<AllocationPolicy>::MatchFun match,
      AllocationPolicy allocator = AllocationPolicy())
        : TemplateHashMapImpl<AllocationPolicy>(
            match,
            TemplateHashMapImpl<AllocationPolicy>::kDefaultHashMapCapacity,
            allocator) { }

  Iterator begin() const { return Iterator(this, this->Start()); }
  Iterator end() const { return Iterator(this, 0); }
  Iterator find(Key* key, bool insert = false,
                AllocationPolicy allocator = AllocationPolicy()) {
    if (insert) {
      return Iterator(this, this->LookupOrInsert(key, key->Hash(), allocator));
    }
    return Iterator(this, this->Lookup(key, key->Hash()));
  }
};

}
}

namespace v8 {
namespace internal {
template <typename Config, class AllocationPolicy>
class SplayTree {
 public:
  typedef typename Config::Key Key;
  typedef typename Config::Value Value;

  class Locator;

  explicit SplayTree(AllocationPolicy allocator = AllocationPolicy())
      : root_(0), allocator_(allocator) {}
  ~SplayTree();

  inline void* operator new(size_t size, AllocationPolicy allocator = AllocationPolicy()) {

    return allocator.New(static_cast<int>(size));
  }
  inline void operator delete(void* p) {
    AllocationPolicy::Delete(p);
  }

  inline void operator delete(void* p, AllocationPolicy policy) {
    V8_Fatal(".././src/splay-tree.h", 51, "unreachable code");
  }

  AllocationPolicy allocator() { return allocator_; }


  bool Contains(const Key& key);




  bool Insert(const Key& key, Locator* locator);




  bool Find(const Key& key, Locator* locator);



  bool FindGreatestLessThan(const Key& key, Locator* locator);


  bool FindGreatest(Locator* locator);



  bool FindLeastGreaterThan(const Key& key, Locator* locator);


  bool FindLeast(Locator* locator);


  bool Move(const Key& old_key, const Key& new_key);


  bool Remove(const Key& key);


  void Clear() { ResetRoot(); }

  bool is_empty() { return root_ == 0; }





  void Splay(const Key& key);

  class Node {
   public:
    Node(const Key& key, const Value& value)
        : key_(key),
          value_(value),
          left_(0),
          right_(0) { }

    inline void* operator new(size_t size, AllocationPolicy allocator) {
      return allocator.New(static_cast<int>(size));
    }
    inline void operator delete(void* p) {
      return AllocationPolicy::Delete(p);
    }


    inline void operator delete(void* p, AllocationPolicy allocator) {
      V8_Fatal(".././src/splay-tree.h", 117, "unreachable code");
    }

    Key key() { return key_; }
    Value value() { return value_; }
    Node* left() { return left_; }
    Node* right() { return right_; }

   private:
    friend class SplayTree;
    friend class Locator;
    Key key_;
    Value value_;
    Node* left_;
    Node* right_;
  };



  class Locator : public Embedded {
   public:
    explicit Locator(Node* node) : node_(node) { }
    Locator() : node_(0) { }
    const Key& key() { return node_->key_; }
    Value& value() { return node_->value_; }
    void set_value(const Value& value) { node_->value_ = value; }
    inline void bind(Node* node) { node_ = node; }

   private:
    Node* node_;
  };

  template <class Callback>
  void ForEach(Callback* callback);

 protected:

  void ResetRoot() { root_ = 0; }

 private:


  bool FindInternal(const Key& key);


  void InsertInternal(int cmp, Node* node);


  void RemoveRootNode(const Key& key);

  template<class Callback>
  class NodeToPairAdaptor : public Embedded {
   public:
    explicit NodeToPairAdaptor(Callback* callback)
        : callback_(callback) { }
    void Call(Node* node) {
      callback_->Call(node->key(), node->value());
    }

   private:
    Callback* callback_;

    NodeToPairAdaptor(const NodeToPairAdaptor&) = delete; void operator=(const NodeToPairAdaptor&) = delete;
  };

  class NodeDeleter : public Embedded {
   public:
    NodeDeleter() { }
    void Call(Node* node) { AllocationPolicy::Delete(node); }

   private:
    NodeDeleter(const NodeDeleter&) = delete; void operator=(const NodeDeleter&) = delete;
  };

  template <class Callback>
  void ForEachNode(Callback* callback);

  Node* root_;
  AllocationPolicy allocator_;

  SplayTree(const SplayTree&) = delete; void operator=(const SplayTree&) = delete;
};


}
}

namespace v8 {
namespace internal {


class Segment;
class Zone final {
 public:
  explicit Zone(base::AccountingAllocator* allocator);
  ~Zone();



  void* New(size_t size);

  template <typename T>
  T* NewArray(size_t length) {
    do { if (std::string* _msg = ::v8::base::CheckLTImpl( (length), (std::numeric_limits<size_t>::max() / sizeof(T)), "length" " " "<" " " "std::numeric_limits<size_t>::max() / sizeof(T)")) { V8_Fatal(".././src/zone.h", 47, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    return static_cast<T*>(New(length * sizeof(T)));
  }



  void DeleteAll();



  void DeleteKeptSegment();



  bool excess_allocation() const {
    return segment_bytes_allocated_ > kExcessLimit;
  }

  size_t allocation_size() const { return allocation_size_; }

  base::AccountingAllocator* allocator() const { return allocator_; }

 private:







  static const size_t kAlignment = kPointerSize;



  static const size_t kMinimumSegmentSize = 8 * KB;


  static const size_t kMaximumSegmentSize = 1 * MB;


  static const size_t kMaximumKeptSegmentSize = 64 * KB;


  static const size_t kExcessLimit = 256 * MB;


  size_t allocation_size_;




  size_t segment_bytes_allocated_;





  Address NewExpand(size_t size);



  inline Segment* NewSegment(size_t size);


  inline void DeleteSegment(Segment* segment, size_t size);




  Address position_;
  Address limit_;

  base::AccountingAllocator* allocator_;

  Segment* segment_head_;
};




class ZoneObject {
 public:

  void* operator new(size_t size, Zone* zone) { return zone->New(size); }
  void operator delete(void*, size_t) { V8_Fatal(".././src/zone.h", 140, "unreachable code"); }
  void operator delete(void* pointer, Zone* zone) { V8_Fatal(".././src/zone.h", 141, "unreachable code"); }
};




class ZoneScope final {
 public:
  explicit ZoneScope(Zone* zone) : zone_(zone) { }
  ~ZoneScope() { zone_->DeleteAll(); }

  Zone* zone() const { return zone_; }

 private:
  Zone* zone_;
};




class ZoneAllocationPolicy final {
 public:
  explicit ZoneAllocationPolicy(Zone* zone) : zone_(zone) { }
  void* New(size_t size) { return zone()->New(size); }
  static void Delete(void* pointer) {}
  Zone* zone() const { return zone_; }

 private:
  Zone* zone_;
};






template <typename T>
class ZoneList final : public List<T, ZoneAllocationPolicy> {
 public:


  ZoneList(int capacity, Zone* zone)
      : List<T, ZoneAllocationPolicy>(capacity, ZoneAllocationPolicy(zone)) { }

  void* operator new(size_t size, Zone* zone) { return zone->New(size); }


  ZoneList(const ZoneList<T>& other, Zone* zone)
      : List<T, ZoneAllocationPolicy>(other.length(),
                                      ZoneAllocationPolicy(zone)) {
    AddAll(other, zone);
  }



  void Add(const T& element, Zone* zone) {
    List<T, ZoneAllocationPolicy>::Add(element, ZoneAllocationPolicy(zone));
  }
  void AddAll(const List<T, ZoneAllocationPolicy>& other, Zone* zone) {
    List<T, ZoneAllocationPolicy>::AddAll(other, ZoneAllocationPolicy(zone));
  }
  void AddAll(const Vector<T>& other, Zone* zone) {
    List<T, ZoneAllocationPolicy>::AddAll(other, ZoneAllocationPolicy(zone));
  }
  void InsertAt(int index, const T& element, Zone* zone) {
    List<T, ZoneAllocationPolicy>::InsertAt(index, element,
                                            ZoneAllocationPolicy(zone));
  }
  Vector<T> AddBlock(T value, int count, Zone* zone) {
    return List<T, ZoneAllocationPolicy>::AddBlock(value, count,
                                                   ZoneAllocationPolicy(zone));
  }
  void Allocate(int length, Zone* zone) {
    List<T, ZoneAllocationPolicy>::Allocate(length, ZoneAllocationPolicy(zone));
  }
  void Initialize(int capacity, Zone* zone) {
    List<T, ZoneAllocationPolicy>::Initialize(capacity,
                                              ZoneAllocationPolicy(zone));
  }

  void operator delete(void* pointer) { V8_Fatal(".././src/zone.h", 221, "unreachable code"); }
  void operator delete(void* pointer, Zone* zone) { V8_Fatal(".././src/zone.h", 222, "unreachable code"); }
};





template <typename Config>
class ZoneSplayTree final : public SplayTree<Config, ZoneAllocationPolicy> {
 public:
  explicit ZoneSplayTree(Zone* zone)
      : SplayTree<Config, ZoneAllocationPolicy>(ZoneAllocationPolicy(zone)) {}
  ~ZoneSplayTree() {



    SplayTree<Config, ZoneAllocationPolicy>::ResetRoot();
  }

  void* operator new(size_t size, Zone* zone) { return zone->New(size); }

  void operator delete(void* pointer) { V8_Fatal(".././src/zone.h", 243, "unreachable code"); }
  void operator delete(void* pointer, Zone* zone) { V8_Fatal(".././src/zone.h", 244, "unreachable code"); }
};


typedef TemplateHashMapImpl<ZoneAllocationPolicy> ZoneHashMap;

}
}

namespace v8 {
namespace internal {


class DeferredHandles;
class HandleScopeImplementer;
class Isolate;
class Object;




class HandleBase {
 public:
  inline explicit HandleBase(Object** location) : location_(location) {}
  inline explicit HandleBase(Object* object, Isolate* isolate);


  inline bool is_identical_to(const HandleBase that) const {

    do { if ((!(!v8::internal::FLAG_enable_slow_asserts || ((this->location_ == nullptr || this->IsDereferenceAllowed(NO_DEFERRED_CHECK)) && (that.location_ == nullptr || that.IsDereferenceAllowed(NO_DEFERRED_CHECK)))))) { V8_Fatal(".././src/handles.h", 38, "Check failed: %s.", "!v8::internal::FLAG_enable_slow_asserts || ((this->location_ == nullptr || this->IsDereferenceAllowed(NO_DEFERRED_CHECK)) && (that.location_ == nullptr || that.IsDereferenceAllowed(NO_DEFERRED_CHECK)))"); } } while (0);



    if (this->location_ == that.location_) return true;
    if (this->location_ == 0 || that.location_ == 0) return false;
    return *this->location_ == *that.location_;
  }

  inline bool is_null() const { return location_ == nullptr; }

 protected:

  inline Object* operator*() const {
    do { if ((!(!v8::internal::FLAG_enable_slow_asserts || (IsDereferenceAllowed(INCLUDE_DEFERRED_CHECK))))) { V8_Fatal(".././src/handles.h", 49, "Check failed: %s.", "!v8::internal::FLAG_enable_slow_asserts || (IsDereferenceAllowed(INCLUDE_DEFERRED_CHECK))"); } } while (0);
    return *location_;
  }


  inline Object** location() const {
    do { if ((!(!v8::internal::FLAG_enable_slow_asserts || (location_ == nullptr || IsDereferenceAllowed(INCLUDE_DEFERRED_CHECK))))) { V8_Fatal(".././src/handles.h", 56, "Check failed: %s.", "!v8::internal::FLAG_enable_slow_asserts || (location_ == nullptr || IsDereferenceAllowed(INCLUDE_DEFERRED_CHECK))"); } } while (0);

    return location_;
  }

  enum DereferenceCheckMode { INCLUDE_DEFERRED_CHECK, NO_DEFERRED_CHECK };

  bool IsDereferenceAllowed(DereferenceCheckMode mode) const;





  Object** location_;
};
template <typename T>
class Handle final : public HandleBase {
 public:
  inline explicit Handle(T** location = nullptr)
      : HandleBase(reinterpret_cast<Object**>(location)) {
    Object* a = nullptr;
    T* b = nullptr;
    a = b;
    USE(a);
  }
  inline explicit Handle(T* object) : Handle(object, object->GetIsolate()) {}
  inline Handle(T* object, Isolate* isolate) : HandleBase(object, isolate) {}


  inline static Handle<T> New(T* object, Isolate* isolate);



  template <typename S>
  inline Handle(Handle<S> handle)
      : HandleBase(handle) {
    T* a = nullptr;
    S* b = nullptr;
    a = b;
    USE(a);
  }

  inline T* operator->() const { return operator*(); }


  inline T* operator*() const {
    return reinterpret_cast<T*>(HandleBase::operator*());
  }


  inline T** location() const {
    return reinterpret_cast<T**>(HandleBase::location());
  }

  template <typename S>
  static const Handle<T> cast(Handle<S> that) {
    T::cast(*reinterpret_cast<T**>(that.location_));
    return Handle<T>(reinterpret_cast<T**>(that.location_));
  }



  static const Handle<T> null() { return Handle<T>(); }


  struct equal_to : public std::binary_function<Handle<T>, Handle<T>, bool> {
    inline bool operator()(Handle<T> lhs, Handle<T> rhs) const {
      return lhs.location() == rhs.location();
    }
  };


  struct hash : public std::unary_function<Handle<T>, size_t> {
    inline size_t operator()(Handle<T> const& handle) const {
      return base::hash<void*>()(handle.location());
    }
  };

 private:

  template <typename>
  friend class Handle;

  template <typename>
  friend class MaybeHandle;
};

template <typename T>
inline std::ostream& operator<<(std::ostream& os, Handle<T> handle);

template <typename T>
inline Handle<T> handle(T* object, Isolate* isolate) {
  return Handle<T>(object, isolate);
}

template <typename T>
inline Handle<T> handle(T* object) {
  return Handle<T>(object);
}
template <typename T>
class MaybeHandle final {
 public:
  inline MaybeHandle() {}
  inline ~MaybeHandle() {}



  template <typename S>
  inline MaybeHandle(Handle<S> handle)
      : location_(reinterpret_cast<T**>(handle.location_)) {
    T* a = nullptr;
    S* b = nullptr;
    a = b;
    USE(a);
  }



  template <typename S>
  inline MaybeHandle(MaybeHandle<S> maybe_handle)
      : location_(reinterpret_cast<T**>(maybe_handle.location_)) {
    T* a = nullptr;
    S* b = nullptr;
    a = b;
    USE(a);
  }

  inline void Assert() const { do { if ((!((location_) != nullptr))) { V8_Fatal(".././src/handles.h", 205, "Check failed: %s.", "(location_) != nullptr"); } } while (0); }
  inline void Check() const { do { if ((!((location_) != nullptr))) { V8_Fatal(".././src/handles.h", 206, "Check failed: %s.", "(location_) != nullptr"); } } while (0); }

  inline Handle<T> ToHandleChecked() const {
    Check();
    return Handle<T>(location_);
  }


  template <typename S>
  inline bool ToHandle(Handle<S>* out) const {
    if (location_ == nullptr) {
      *out = Handle<T>::null();
      return false;
    } else {
      *out = Handle<T>(location_);
      return true;
    }
  }

  bool is_null() const { return location_ == nullptr; }

 protected:
  T** location_ = nullptr;



  template <typename>
  friend class MaybeHandle;
};
class HandleScope {
 public:
  explicit inline HandleScope(Isolate* isolate);

  inline ~HandleScope();


  static int NumberOfHandles(Isolate* isolate);


  inline static Object** GetHandle(Isolate* isolate, Object* value);


  inline static Object** CreateHandle(Isolate* isolate, Object* value);


  static void DeleteExtensions(Isolate* isolate);

  static Address current_next_address(Isolate* isolate);
  static Address current_limit_address(Isolate* isolate);
  static Address current_level_address(Isolate* isolate);





  template <typename T>
  Handle<T> CloseAndEscape(Handle<T> handle_value);

  Isolate* isolate() { return isolate_; }




  static const int kCheckHandleThreshold = 30 * 1024;

 private:

  HandleScope(const HandleScope&);
  void operator=(const HandleScope&);
  void* operator new(size_t size);
  void operator delete(void* size_t) {};

  Isolate* isolate_;
  Object** prev_next_;
  Object** prev_limit_;


  static inline void CloseScope(Isolate* isolate,
                                Object** prev_next,
                                Object** prev_limit);


  static Object** Extend(Isolate* isolate);



  static void ZapRange(Object** start, Object** end);


  friend class v8::HandleScope;
  friend class DeferredHandles;
  friend class DeferredHandleScope;
  friend class HandleScopeImplementer;
  friend class Isolate;
};



template <typename V>
class IdentityMap;
class RootIndexMap;







class CanonicalHandleScope final {
 public:
  explicit CanonicalHandleScope(Isolate* isolate);
  ~CanonicalHandleScope();

 private:
  Object** Lookup(Object* object);

  Isolate* isolate_;
  Zone zone_;
  RootIndexMap* root_index_map_;
  IdentityMap<Object**>* identity_map_;

  int canonical_level_;

  CanonicalHandleScope* prev_canonical_scope_;

  friend class HandleScope;
};


class DeferredHandleScope final {
 public:
  explicit DeferredHandleScope(Isolate* isolate);



  DeferredHandles* Detach();
  ~DeferredHandleScope();

 private:
  Object** prev_limit_;
  Object** prev_next_;
  HandleScopeImplementer* impl_;


  bool handles_detached_;
  int prev_level_;


  friend class HandleScopeImplementer;
};




class SealHandleScope final {
 public:




  explicit inline SealHandleScope(Isolate* isolate);
  inline ~SealHandleScope();
 private:
  Isolate* isolate_;
  Object** prev_limit_;
  int prev_sealed_level_;

};


struct HandleScopeData final {
  Object** next;
  Object** limit;
  int level;
  int sealed_level;
  CanonicalHandleScope* canonical_scope;

  void Initialize() {
    next = limit = 0;
    sealed_level = level = 0;
    canonical_scope = 0;
  }
};

}
}

namespace v8 {
namespace internal {

namespace compiler {


class CodeStubAssembler;

}


enum class BuiltinExtraArguments : uint8_t {
  kNone = 0u,
  kTarget = 1u << 0,
  kNewTarget = 1u << 1,
  kTargetAndNewTarget = kTarget | kNewTarget
};

inline bool operator&(BuiltinExtraArguments lhs, BuiltinExtraArguments rhs) {
  return static_cast<uint8_t>(lhs) & static_cast<uint8_t>(rhs);
}
class BuiltinFunctionTable;
class ObjectVisitor;


class Builtins {
 public:
  ~Builtins();



  void SetUp(Isolate* isolate, bool create_heap_objects);
  void TearDown();


  void IterateBuiltins(ObjectVisitor* v);


  const char* Lookup(byte* pc);

  enum Name {




    kIllegal, kEmptyFunction, kArrayConcat, kArrayIsArray, kArrayPop, kArrayPush, kArrayShift, kArraySlice, kArraySplice, kArrayUnshift, kArrayBufferConstructor, kArrayBufferConstructor_ConstructStub, kArrayBufferIsView, kBooleanConstructor, kBooleanConstructor_ConstructStub, kBooleanPrototypeToString, kBooleanPrototypeValueOf, kDataViewConstructor, kDataViewConstructor_ConstructStub, kDateConstructor, kDateConstructor_ConstructStub, kDateNow, kDateParse, kDateUTC, kDatePrototypeSetDate, kDatePrototypeSetFullYear, kDatePrototypeSetHours, kDatePrototypeSetMilliseconds, kDatePrototypeSetMinutes, kDatePrototypeSetMonth, kDatePrototypeSetSeconds, kDatePrototypeSetTime, kDatePrototypeSetUTCDate, kDatePrototypeSetUTCFullYear, kDatePrototypeSetUTCHours, kDatePrototypeSetUTCMilliseconds, kDatePrototypeSetUTCMinutes, kDatePrototypeSetUTCMonth, kDatePrototypeSetUTCSeconds, kDatePrototypeToDateString, kDatePrototypeToISOString, kDatePrototypeToPrimitive, kDatePrototypeToUTCString, kDatePrototypeToString, kDatePrototypeToTimeString, kDatePrototypeValueOf, kDatePrototypeGetYear, kDatePrototypeSetYear, kFunctionConstructor, kFunctionPrototypeBind, kFunctionPrototypeToString, kGeneratorFunctionConstructor, kGlobalEval, kMathAcos, kMathAsin, kMathAtan, kMathFround, kMathImul, kObjectAssign, kObjectCreate, kObjectFreeze, kObjectGetOwnPropertyDescriptor, kObjectGetOwnPropertyNames, kObjectGetOwnPropertySymbols, kObjectIs, kObjectIsExtensible, kObjectIsFrozen, kObjectIsSealed, kObjectKeys, kObjectValues, kObjectEntries, kObjectGetOwnPropertyDescriptors, kObjectPreventExtensions, kObjectSeal, kObjectProtoToString, kProxyConstructor, kProxyConstructor_ConstructStub, kReflectDefineProperty, kReflectDeleteProperty, kReflectGet, kReflectGetOwnPropertyDescriptor, kReflectGetPrototypeOf, kReflectHas, kReflectIsExtensible, kReflectOwnKeys, kReflectPreventExtensions, kReflectSet, kReflectSetPrototypeOf, kSymbolConstructor, kSymbolConstructor_ConstructStub, kHandleApiCall, kHandleApiCallConstruct, kHandleApiCallAsFunction, kHandleApiCallAsConstructor, kRestrictedFunctionPropertiesThrower, kRestrictedStrictArgumentsPropertiesThrower, kArgumentsAdaptorTrampoline, kConstructedNonConstructable, kCallFunction_ReceiverIsNullOrUndefined, kCallFunction_ReceiverIsNotNullOrUndefined, kCallFunction_ReceiverIsAny, kTailCallFunction_ReceiverIsNullOrUndefined, kTailCallFunction_ReceiverIsNotNullOrUndefined, kTailCallFunction_ReceiverIsAny, kCallBoundFunction, kTailCallBoundFunction, kCall_ReceiverIsNullOrUndefined, kCall_ReceiverIsNotNullOrUndefined, kCall_ReceiverIsAny, kTailCall_ReceiverIsNullOrUndefined, kTailCall_ReceiverIsNotNullOrUndefined, kTailCall_ReceiverIsAny, kConstructFunction, kConstructBoundFunction, kConstructProxy, kConstruct, kApply, kHandleFastApiCall, kInOptimizationQueue, kJSConstructStubGeneric, kJSBuiltinsConstructStub, kJSBuiltinsConstructStubForDerived, kJSConstructStubApi, kJSEntryTrampoline, kJSConstructEntryTrampoline, kCompileLazy, kCompileOptimized, kCompileOptimizedConcurrent, kNotifyDeoptimized, kNotifySoftDeoptimized, kNotifyLazyDeoptimized, kNotifyStubFailure, kNotifyStubFailureSaveDoubles, kInterpreterEntryTrampoline, kInterpreterExitTrampoline, kInterpreterPushArgsAndCall, kInterpreterPushArgsAndTailCall, kInterpreterPushArgsAndConstruct, kInterpreterNotifyDeoptimized, kInterpreterNotifySoftDeoptimized, kInterpreterNotifyLazyDeoptimized, kInterpreterEnterBytecodeDispatch, kLoadIC_Miss, kKeyedLoadIC_Miss, kStoreIC_Miss, kKeyedStoreIC_Miss, kLoadIC_Getter_ForDeopt, kKeyedLoadIC_Megamorphic, kStoreIC_Setter_ForDeopt, kKeyedStoreIC_Initialize, kKeyedStoreIC_PreMonomorphic, kKeyedStoreIC_Megamorphic, kKeyedStoreIC_Initialize_Strict, kKeyedStoreIC_PreMonomorphic_Strict, kKeyedStoreIC_Megamorphic_Strict, kDatePrototypeGetDate, kDatePrototypeGetDay, kDatePrototypeGetFullYear, kDatePrototypeGetHours, kDatePrototypeGetMilliseconds, kDatePrototypeGetMinutes, kDatePrototypeGetMonth, kDatePrototypeGetSeconds, kDatePrototypeGetTime, kDatePrototypeGetTimezoneOffset, kDatePrototypeGetUTCDate, kDatePrototypeGetUTCDay, kDatePrototypeGetUTCFullYear, kDatePrototypeGetUTCHours, kDatePrototypeGetUTCMilliseconds, kDatePrototypeGetUTCMinutes, kDatePrototypeGetUTCMonth, kDatePrototypeGetUTCSeconds, kFunctionHasInstance, kFunctionPrototypeApply, kFunctionPrototypeCall, kReflectApply, kReflectConstruct, kInternalArrayCode, kArrayCode, kMathMax, kMathMin, kNumberConstructor, kNumberConstructor_ConstructStub, kStringConstructor, kStringConstructor_ConstructStub, kOnStackReplacement, kInterruptCheck, kStackCheck, kMarkCodeAsToBeExecutedOnce, kMarkCodeAsExecutedOnce, kMarkCodeAsExecutedTwice, kMakeQuadragenarianCodeYoungAgainOddMarking, kMakeQuadragenarianCodeYoungAgainEvenMarking, kMakeQuinquagenarianCodeYoungAgainOddMarking, kMakeQuinquagenarianCodeYoungAgainEvenMarking, kMakeSexagenarianCodeYoungAgainOddMarking, kMakeSexagenarianCodeYoungAgainEvenMarking, kMakeSeptuagenarianCodeYoungAgainOddMarking, kMakeSeptuagenarianCodeYoungAgainEvenMarking, kMakeOctogenarianCodeYoungAgainOddMarking, kMakeOctogenarianCodeYoungAgainEvenMarking,
        kMathCeil, kMathClz32, kMathFloor, kMathRound, kMathSqrt, kMathTrunc, kObjectHasOwnProperty, kLoadIC_Slow, kKeyedLoadIC_Slow, kStoreIC_Slow, kKeyedStoreIC_Slow, kLoadIC_Normal, kStoreIC_Normal,
            kReturn_DebugBreak, kSlot_DebugBreak, kFrameDropper_LiveEdit,




                builtin_count
  };

  enum CFunctionId {

    c_Illegal, c_EmptyFunction, c_ArrayConcat, c_ArrayIsArray, c_ArrayPop, c_ArrayPush, c_ArrayShift, c_ArraySlice, c_ArraySplice, c_ArrayUnshift, c_ArrayBufferConstructor, c_ArrayBufferConstructor_ConstructStub, c_ArrayBufferIsView, c_BooleanConstructor, c_BooleanConstructor_ConstructStub, c_BooleanPrototypeToString, c_BooleanPrototypeValueOf, c_DataViewConstructor, c_DataViewConstructor_ConstructStub, c_DateConstructor, c_DateConstructor_ConstructStub, c_DateNow, c_DateParse, c_DateUTC, c_DatePrototypeSetDate, c_DatePrototypeSetFullYear, c_DatePrototypeSetHours, c_DatePrototypeSetMilliseconds, c_DatePrototypeSetMinutes, c_DatePrototypeSetMonth, c_DatePrototypeSetSeconds, c_DatePrototypeSetTime, c_DatePrototypeSetUTCDate, c_DatePrototypeSetUTCFullYear, c_DatePrototypeSetUTCHours, c_DatePrototypeSetUTCMilliseconds, c_DatePrototypeSetUTCMinutes, c_DatePrototypeSetUTCMonth, c_DatePrototypeSetUTCSeconds, c_DatePrototypeToDateString, c_DatePrototypeToISOString, c_DatePrototypeToPrimitive, c_DatePrototypeToUTCString, c_DatePrototypeToString, c_DatePrototypeToTimeString, c_DatePrototypeValueOf, c_DatePrototypeGetYear, c_DatePrototypeSetYear, c_FunctionConstructor, c_FunctionPrototypeBind, c_FunctionPrototypeToString, c_GeneratorFunctionConstructor, c_GlobalEval, c_MathAcos, c_MathAsin, c_MathAtan, c_MathFround, c_MathImul, c_ObjectAssign, c_ObjectCreate, c_ObjectFreeze, c_ObjectGetOwnPropertyDescriptor, c_ObjectGetOwnPropertyNames, c_ObjectGetOwnPropertySymbols, c_ObjectIs, c_ObjectIsExtensible, c_ObjectIsFrozen, c_ObjectIsSealed, c_ObjectKeys, c_ObjectValues, c_ObjectEntries, c_ObjectGetOwnPropertyDescriptors, c_ObjectPreventExtensions, c_ObjectSeal, c_ObjectProtoToString, c_ProxyConstructor, c_ProxyConstructor_ConstructStub, c_ReflectDefineProperty, c_ReflectDeleteProperty, c_ReflectGet, c_ReflectGetOwnPropertyDescriptor, c_ReflectGetPrototypeOf, c_ReflectHas, c_ReflectIsExtensible, c_ReflectOwnKeys, c_ReflectPreventExtensions, c_ReflectSet, c_ReflectSetPrototypeOf, c_SymbolConstructor, c_SymbolConstructor_ConstructStub, c_HandleApiCall, c_HandleApiCallConstruct, c_HandleApiCallAsFunction, c_HandleApiCallAsConstructor, c_RestrictedFunctionPropertiesThrower, c_RestrictedStrictArgumentsPropertiesThrower,

    cfunction_count
  };






  Handle<Code> Illegal(); Handle<Code> EmptyFunction(); Handle<Code> ArrayConcat(); Handle<Code> ArrayIsArray(); Handle<Code> ArrayPop(); Handle<Code> ArrayPush(); Handle<Code> ArrayShift(); Handle<Code> ArraySlice(); Handle<Code> ArraySplice(); Handle<Code> ArrayUnshift(); Handle<Code> ArrayBufferConstructor(); Handle<Code> ArrayBufferConstructor_ConstructStub(); Handle<Code> ArrayBufferIsView(); Handle<Code> BooleanConstructor(); Handle<Code> BooleanConstructor_ConstructStub(); Handle<Code> BooleanPrototypeToString(); Handle<Code> BooleanPrototypeValueOf(); Handle<Code> DataViewConstructor(); Handle<Code> DataViewConstructor_ConstructStub(); Handle<Code> DateConstructor(); Handle<Code> DateConstructor_ConstructStub(); Handle<Code> DateNow(); Handle<Code> DateParse(); Handle<Code> DateUTC(); Handle<Code> DatePrototypeSetDate(); Handle<Code> DatePrototypeSetFullYear(); Handle<Code> DatePrototypeSetHours(); Handle<Code> DatePrototypeSetMilliseconds(); Handle<Code> DatePrototypeSetMinutes(); Handle<Code> DatePrototypeSetMonth(); Handle<Code> DatePrototypeSetSeconds(); Handle<Code> DatePrototypeSetTime(); Handle<Code> DatePrototypeSetUTCDate(); Handle<Code> DatePrototypeSetUTCFullYear(); Handle<Code> DatePrototypeSetUTCHours(); Handle<Code> DatePrototypeSetUTCMilliseconds(); Handle<Code> DatePrototypeSetUTCMinutes(); Handle<Code> DatePrototypeSetUTCMonth(); Handle<Code> DatePrototypeSetUTCSeconds(); Handle<Code> DatePrototypeToDateString(); Handle<Code> DatePrototypeToISOString(); Handle<Code> DatePrototypeToPrimitive(); Handle<Code> DatePrototypeToUTCString(); Handle<Code> DatePrototypeToString(); Handle<Code> DatePrototypeToTimeString(); Handle<Code> DatePrototypeValueOf(); Handle<Code> DatePrototypeGetYear(); Handle<Code> DatePrototypeSetYear(); Handle<Code> FunctionConstructor(); Handle<Code> FunctionPrototypeBind(); Handle<Code> FunctionPrototypeToString(); Handle<Code> GeneratorFunctionConstructor(); Handle<Code> GlobalEval(); Handle<Code> MathAcos(); Handle<Code> MathAsin(); Handle<Code> MathAtan(); Handle<Code> MathFround(); Handle<Code> MathImul(); Handle<Code> ObjectAssign(); Handle<Code> ObjectCreate(); Handle<Code> ObjectFreeze(); Handle<Code> ObjectGetOwnPropertyDescriptor(); Handle<Code> ObjectGetOwnPropertyNames(); Handle<Code> ObjectGetOwnPropertySymbols(); Handle<Code> ObjectIs(); Handle<Code> ObjectIsExtensible(); Handle<Code> ObjectIsFrozen(); Handle<Code> ObjectIsSealed(); Handle<Code> ObjectKeys(); Handle<Code> ObjectValues(); Handle<Code> ObjectEntries(); Handle<Code> ObjectGetOwnPropertyDescriptors(); Handle<Code> ObjectPreventExtensions(); Handle<Code> ObjectSeal(); Handle<Code> ObjectProtoToString(); Handle<Code> ProxyConstructor(); Handle<Code> ProxyConstructor_ConstructStub(); Handle<Code> ReflectDefineProperty(); Handle<Code> ReflectDeleteProperty(); Handle<Code> ReflectGet(); Handle<Code> ReflectGetOwnPropertyDescriptor(); Handle<Code> ReflectGetPrototypeOf(); Handle<Code> ReflectHas(); Handle<Code> ReflectIsExtensible(); Handle<Code> ReflectOwnKeys(); Handle<Code> ReflectPreventExtensions(); Handle<Code> ReflectSet(); Handle<Code> ReflectSetPrototypeOf(); Handle<Code> SymbolConstructor(); Handle<Code> SymbolConstructor_ConstructStub(); Handle<Code> HandleApiCall(); Handle<Code> HandleApiCallConstruct(); Handle<Code> HandleApiCallAsFunction(); Handle<Code> HandleApiCallAsConstructor(); Handle<Code> RestrictedFunctionPropertiesThrower(); Handle<Code> RestrictedStrictArgumentsPropertiesThrower();
  Handle<Code> ArgumentsAdaptorTrampoline(); Handle<Code> ConstructedNonConstructable(); Handle<Code> CallFunction_ReceiverIsNullOrUndefined(); Handle<Code> CallFunction_ReceiverIsNotNullOrUndefined(); Handle<Code> CallFunction_ReceiverIsAny(); Handle<Code> TailCallFunction_ReceiverIsNullOrUndefined(); Handle<Code> TailCallFunction_ReceiverIsNotNullOrUndefined(); Handle<Code> TailCallFunction_ReceiverIsAny(); Handle<Code> CallBoundFunction(); Handle<Code> TailCallBoundFunction(); Handle<Code> Call_ReceiverIsNullOrUndefined(); Handle<Code> Call_ReceiverIsNotNullOrUndefined(); Handle<Code> Call_ReceiverIsAny(); Handle<Code> TailCall_ReceiverIsNullOrUndefined(); Handle<Code> TailCall_ReceiverIsNotNullOrUndefined(); Handle<Code> TailCall_ReceiverIsAny(); Handle<Code> ConstructFunction(); Handle<Code> ConstructBoundFunction(); Handle<Code> ConstructProxy(); Handle<Code> Construct(); Handle<Code> Apply(); Handle<Code> HandleFastApiCall(); Handle<Code> InOptimizationQueue(); Handle<Code> JSConstructStubGeneric(); Handle<Code> JSBuiltinsConstructStub(); Handle<Code> JSBuiltinsConstructStubForDerived(); Handle<Code> JSConstructStubApi(); Handle<Code> JSEntryTrampoline(); Handle<Code> JSConstructEntryTrampoline(); Handle<Code> CompileLazy(); Handle<Code> CompileOptimized(); Handle<Code> CompileOptimizedConcurrent(); Handle<Code> NotifyDeoptimized(); Handle<Code> NotifySoftDeoptimized(); Handle<Code> NotifyLazyDeoptimized(); Handle<Code> NotifyStubFailure(); Handle<Code> NotifyStubFailureSaveDoubles(); Handle<Code> InterpreterEntryTrampoline(); Handle<Code> InterpreterExitTrampoline(); Handle<Code> InterpreterPushArgsAndCall(); Handle<Code> InterpreterPushArgsAndTailCall(); Handle<Code> InterpreterPushArgsAndConstruct(); Handle<Code> InterpreterNotifyDeoptimized(); Handle<Code> InterpreterNotifySoftDeoptimized(); Handle<Code> InterpreterNotifyLazyDeoptimized(); Handle<Code> InterpreterEnterBytecodeDispatch(); Handle<Code> LoadIC_Miss(); Handle<Code> KeyedLoadIC_Miss(); Handle<Code> StoreIC_Miss(); Handle<Code> KeyedStoreIC_Miss(); Handle<Code> LoadIC_Getter_ForDeopt(); Handle<Code> KeyedLoadIC_Megamorphic(); Handle<Code> StoreIC_Setter_ForDeopt(); Handle<Code> KeyedStoreIC_Initialize(); Handle<Code> KeyedStoreIC_PreMonomorphic(); Handle<Code> KeyedStoreIC_Megamorphic(); Handle<Code> KeyedStoreIC_Initialize_Strict(); Handle<Code> KeyedStoreIC_PreMonomorphic_Strict(); Handle<Code> KeyedStoreIC_Megamorphic_Strict(); Handle<Code> DatePrototypeGetDate(); Handle<Code> DatePrototypeGetDay(); Handle<Code> DatePrototypeGetFullYear(); Handle<Code> DatePrototypeGetHours(); Handle<Code> DatePrototypeGetMilliseconds(); Handle<Code> DatePrototypeGetMinutes(); Handle<Code> DatePrototypeGetMonth(); Handle<Code> DatePrototypeGetSeconds(); Handle<Code> DatePrototypeGetTime(); Handle<Code> DatePrototypeGetTimezoneOffset(); Handle<Code> DatePrototypeGetUTCDate(); Handle<Code> DatePrototypeGetUTCDay(); Handle<Code> DatePrototypeGetUTCFullYear(); Handle<Code> DatePrototypeGetUTCHours(); Handle<Code> DatePrototypeGetUTCMilliseconds(); Handle<Code> DatePrototypeGetUTCMinutes(); Handle<Code> DatePrototypeGetUTCMonth(); Handle<Code> DatePrototypeGetUTCSeconds(); Handle<Code> FunctionHasInstance(); Handle<Code> FunctionPrototypeApply(); Handle<Code> FunctionPrototypeCall(); Handle<Code> ReflectApply(); Handle<Code> ReflectConstruct(); Handle<Code> InternalArrayCode(); Handle<Code> ArrayCode(); Handle<Code> MathMax(); Handle<Code> MathMin(); Handle<Code> NumberConstructor(); Handle<Code> NumberConstructor_ConstructStub(); Handle<Code> StringConstructor(); Handle<Code> StringConstructor_ConstructStub(); Handle<Code> OnStackReplacement(); Handle<Code> InterruptCheck(); Handle<Code> StackCheck(); Handle<Code> MarkCodeAsToBeExecutedOnce(); Handle<Code> MarkCodeAsExecutedOnce(); Handle<Code> MarkCodeAsExecutedTwice(); Handle<Code> MakeQuadragenarianCodeYoungAgainOddMarking(); Handle<Code> MakeQuadragenarianCodeYoungAgainEvenMarking(); Handle<Code> MakeQuinquagenarianCodeYoungAgainOddMarking(); Handle<Code> MakeQuinquagenarianCodeYoungAgainEvenMarking(); Handle<Code> MakeSexagenarianCodeYoungAgainOddMarking(); Handle<Code> MakeSexagenarianCodeYoungAgainEvenMarking(); Handle<Code> MakeSeptuagenarianCodeYoungAgainOddMarking(); Handle<Code> MakeSeptuagenarianCodeYoungAgainEvenMarking(); Handle<Code> MakeOctogenarianCodeYoungAgainOddMarking(); Handle<Code> MakeOctogenarianCodeYoungAgainEvenMarking();
  Handle<Code> MathCeil(); Handle<Code> MathClz32(); Handle<Code> MathFloor(); Handle<Code> MathRound(); Handle<Code> MathSqrt(); Handle<Code> MathTrunc(); Handle<Code> ObjectHasOwnProperty();
  Handle<Code> LoadIC_Slow(); Handle<Code> KeyedLoadIC_Slow(); Handle<Code> StoreIC_Slow(); Handle<Code> KeyedStoreIC_Slow(); Handle<Code> LoadIC_Normal(); Handle<Code> StoreIC_Normal();
  Handle<Code> Return_DebugBreak(); Handle<Code> Slot_DebugBreak(); Handle<Code> FrameDropper_LiveEdit();






  Handle<Code> CallFunction(
      ConvertReceiverMode = ConvertReceiverMode::kAny,
      TailCallMode tail_call_mode = TailCallMode::kDisallow);
  Handle<Code> Call(ConvertReceiverMode = ConvertReceiverMode::kAny,
                    TailCallMode tail_call_mode = TailCallMode::kDisallow);
  Handle<Code> CallBoundFunction(TailCallMode tail_call_mode);
  Handle<Code> InterpreterPushArgsAndCall(TailCallMode tail_call_mode);

  Code* builtin(Name name) {


    return reinterpret_cast<Code*>(builtins_[name]);
  }

  Address builtin_address(Name name) {
    return reinterpret_cast<Address>(&builtins_[name]);
  }

  static Address c_function_address(CFunctionId id) {
    return c_functions_[id];
  }

  const char* name(int index) {
    do { if ((!(index >= 0))) { V8_Fatal(".././src/builtins.h", 414, "Check failed: %s.", "index >= 0"); } } while (0);
    do { if ((!(index < builtin_count))) { V8_Fatal(".././src/builtins.h", 415, "Check failed: %s.", "index < builtin_count"); } } while (0);
    return names_[index];
  }

  bool is_initialized() const { return initialized_; }

  __attribute__((warn_unused_result)) static MaybeHandle<Object> InvokeApiFunction(
      Handle<HeapObject> function, Handle<Object> receiver, int argc,
      Handle<Object> args[]);

 private:
  Builtins();


  static Address const c_functions_[cfunction_count];




  Object* builtins_[builtin_count];
  const char* names_[builtin_count];

  static void Generate_Adaptor(MacroAssembler* masm,
                               CFunctionId id,
                               BuiltinExtraArguments extra_args);
  static void Generate_ConstructedNonConstructable(MacroAssembler* masm);
  static void Generate_CompileLazy(MacroAssembler* masm);
  static void Generate_InOptimizationQueue(MacroAssembler* masm);
  static void Generate_CompileOptimized(MacroAssembler* masm);
  static void Generate_CompileOptimizedConcurrent(MacroAssembler* masm);
  static void Generate_JSConstructStubGeneric(MacroAssembler* masm);
  static void Generate_JSBuiltinsConstructStub(MacroAssembler* masm);
  static void Generate_JSBuiltinsConstructStubForDerived(MacroAssembler* masm);
  static void Generate_JSConstructStubApi(MacroAssembler* masm);
  static void Generate_JSEntryTrampoline(MacroAssembler* masm);
  static void Generate_JSConstructEntryTrampoline(MacroAssembler* masm);
  static void Generate_NotifyDeoptimized(MacroAssembler* masm);
  static void Generate_NotifySoftDeoptimized(MacroAssembler* masm);
  static void Generate_NotifyLazyDeoptimized(MacroAssembler* masm);
  static void Generate_NotifyStubFailure(MacroAssembler* masm);
  static void Generate_NotifyStubFailureSaveDoubles(MacroAssembler* masm);
  static void Generate_ArgumentsAdaptorTrampoline(MacroAssembler* masm);

  static void Generate_Apply(MacroAssembler* masm);


  static void Generate_CallFunction(MacroAssembler* masm,
                                    ConvertReceiverMode mode,
                                    TailCallMode tail_call_mode);
  static void Generate_CallFunction_ReceiverIsNullOrUndefined(
      MacroAssembler* masm) {
    Generate_CallFunction(masm, ConvertReceiverMode::kNullOrUndefined,
                          TailCallMode::kDisallow);
  }
  static void Generate_CallFunction_ReceiverIsNotNullOrUndefined(
      MacroAssembler* masm) {
    Generate_CallFunction(masm, ConvertReceiverMode::kNotNullOrUndefined,
                          TailCallMode::kDisallow);
  }
  static void Generate_CallFunction_ReceiverIsAny(MacroAssembler* masm) {
    Generate_CallFunction(masm, ConvertReceiverMode::kAny,
                          TailCallMode::kDisallow);
  }
  static void Generate_TailCallFunction_ReceiverIsNullOrUndefined(
      MacroAssembler* masm) {
    Generate_CallFunction(masm, ConvertReceiverMode::kNullOrUndefined,
                          TailCallMode::kAllow);
  }
  static void Generate_TailCallFunction_ReceiverIsNotNullOrUndefined(
      MacroAssembler* masm) {
    Generate_CallFunction(masm, ConvertReceiverMode::kNotNullOrUndefined,
                          TailCallMode::kAllow);
  }
  static void Generate_TailCallFunction_ReceiverIsAny(MacroAssembler* masm) {
    Generate_CallFunction(masm, ConvertReceiverMode::kAny,
                          TailCallMode::kAllow);
  }

  static void Generate_CallBoundFunctionImpl(MacroAssembler* masm,
                                             TailCallMode tail_call_mode);
  static void Generate_CallBoundFunction(MacroAssembler* masm) {
    Generate_CallBoundFunctionImpl(masm, TailCallMode::kDisallow);
  }
  static void Generate_TailCallBoundFunction(MacroAssembler* masm) {
    Generate_CallBoundFunctionImpl(masm, TailCallMode::kAllow);
  }

  static void Generate_Call(MacroAssembler* masm, ConvertReceiverMode mode,
                            TailCallMode tail_call_mode);
  static void Generate_Call_ReceiverIsNullOrUndefined(MacroAssembler* masm) {
    Generate_Call(masm, ConvertReceiverMode::kNullOrUndefined,
                  TailCallMode::kDisallow);
  }
  static void Generate_Call_ReceiverIsNotNullOrUndefined(MacroAssembler* masm) {
    Generate_Call(masm, ConvertReceiverMode::kNotNullOrUndefined,
                  TailCallMode::kDisallow);
  }
  static void Generate_Call_ReceiverIsAny(MacroAssembler* masm) {
    Generate_Call(masm, ConvertReceiverMode::kAny, TailCallMode::kDisallow);
  }
  static void Generate_TailCall_ReceiverIsNullOrUndefined(
      MacroAssembler* masm) {
    Generate_Call(masm, ConvertReceiverMode::kNullOrUndefined,
                  TailCallMode::kAllow);
  }
  static void Generate_TailCall_ReceiverIsNotNullOrUndefined(
      MacroAssembler* masm) {
    Generate_Call(masm, ConvertReceiverMode::kNotNullOrUndefined,
                  TailCallMode::kAllow);
  }
  static void Generate_TailCall_ReceiverIsAny(MacroAssembler* masm) {
    Generate_Call(masm, ConvertReceiverMode::kAny, TailCallMode::kAllow);
  }


  static void Generate_ConstructFunction(MacroAssembler* masm);

  static void Generate_ConstructBoundFunction(MacroAssembler* masm);

  static void Generate_ConstructProxy(MacroAssembler* masm);

  static void Generate_Construct(MacroAssembler* masm);

  static void Generate_HandleFastApiCall(MacroAssembler* masm);

  static void Generate_DatePrototype_GetField(MacroAssembler* masm,
                                              int field_index);

  static void Generate_DatePrototypeGetDate(MacroAssembler* masm);

  static void Generate_DatePrototypeGetDay(MacroAssembler* masm);

  static void Generate_DatePrototypeGetFullYear(MacroAssembler* masm);

  static void Generate_DatePrototypeGetHours(MacroAssembler* masm);

  static void Generate_DatePrototypeGetMilliseconds(MacroAssembler* masm);

  static void Generate_DatePrototypeGetMinutes(MacroAssembler* masm);

  static void Generate_DatePrototypeGetMonth(MacroAssembler* masm);

  static void Generate_DatePrototypeGetSeconds(MacroAssembler* masm);

  static void Generate_DatePrototypeGetTime(MacroAssembler* masm);

  static void Generate_DatePrototypeGetTimezoneOffset(MacroAssembler* masm);

  static void Generate_DatePrototypeGetUTCDate(MacroAssembler* masm);

  static void Generate_DatePrototypeGetUTCDay(MacroAssembler* masm);

  static void Generate_DatePrototypeGetUTCFullYear(MacroAssembler* masm);

  static void Generate_DatePrototypeGetUTCHours(MacroAssembler* masm);

  static void Generate_DatePrototypeGetUTCMilliseconds(MacroAssembler* masm);

  static void Generate_DatePrototypeGetUTCMinutes(MacroAssembler* masm);

  static void Generate_DatePrototypeGetUTCMonth(MacroAssembler* masm);

  static void Generate_DatePrototypeGetUTCSeconds(MacroAssembler* masm);

  static void Generate_FunctionHasInstance(MacroAssembler* masm);
  static void Generate_FunctionPrototypeApply(MacroAssembler* masm);
  static void Generate_FunctionPrototypeCall(MacroAssembler* masm);

  static void Generate_ReflectApply(MacroAssembler* masm);
  static void Generate_ReflectConstruct(MacroAssembler* masm);

  static void Generate_InternalArrayCode(MacroAssembler* masm);
  static void Generate_ArrayCode(MacroAssembler* masm);


  static void Generate_MathCeil(compiler::CodeStubAssembler* assembler);

  static void Generate_MathClz32(compiler::CodeStubAssembler* assembler);

  static void Generate_MathFloor(compiler::CodeStubAssembler* assembler);
  enum class MathMaxMinKind { kMax, kMin };
  static void Generate_MathMaxMin(MacroAssembler* masm, MathMaxMinKind kind);

  static void Generate_MathMax(MacroAssembler* masm) {
    Generate_MathMaxMin(masm, MathMaxMinKind::kMax);
  }

  static void Generate_MathMin(MacroAssembler* masm) {
    Generate_MathMaxMin(masm, MathMaxMinKind::kMin);
  }

  static void Generate_MathRound(compiler::CodeStubAssembler* assembler);

  static void Generate_MathSqrt(compiler::CodeStubAssembler* assembler);

  static void Generate_MathTrunc(compiler::CodeStubAssembler* assembler);


  static void Generate_NumberConstructor(MacroAssembler* masm);

  static void Generate_NumberConstructor_ConstructStub(MacroAssembler* masm);


  static void Generate_ObjectHasOwnProperty(
      compiler::CodeStubAssembler* assembler);

  static void Generate_StringConstructor(MacroAssembler* masm);
  static void Generate_StringConstructor_ConstructStub(MacroAssembler* masm);
  static void Generate_OnStackReplacement(MacroAssembler* masm);
  static void Generate_InterruptCheck(MacroAssembler* masm);
  static void Generate_StackCheck(MacroAssembler* masm);

  static void Generate_InterpreterEntryTrampoline(MacroAssembler* masm);
  static void Generate_InterpreterExitTrampoline(MacroAssembler* masm);
  static void Generate_InterpreterPushArgsAndCall(MacroAssembler* masm) {
    return Generate_InterpreterPushArgsAndCallImpl(masm,
                                                   TailCallMode::kDisallow);
  }
  static void Generate_InterpreterPushArgsAndTailCall(MacroAssembler* masm) {
    return Generate_InterpreterPushArgsAndCallImpl(masm, TailCallMode::kAllow);
  }
  static void Generate_InterpreterPushArgsAndCallImpl(
      MacroAssembler* masm, TailCallMode tail_call_mode);
  static void Generate_InterpreterPushArgsAndConstruct(MacroAssembler* masm);
  static void Generate_InterpreterNotifyDeoptimized(MacroAssembler* masm);
  static void Generate_InterpreterNotifySoftDeoptimized(MacroAssembler* masm);
  static void Generate_InterpreterNotifyLazyDeoptimized(MacroAssembler* masm);
  static void Generate_InterpreterEnterBytecodeDispatch(MacroAssembler* masm);






  static void Generate_MakeQuadragenarianCodeYoungAgainEvenMarking( MacroAssembler* masm); static void Generate_MakeQuadragenarianCodeYoungAgainOddMarking( MacroAssembler* masm); static void Generate_MakeQuinquagenarianCodeYoungAgainEvenMarking( MacroAssembler* masm); static void Generate_MakeQuinquagenarianCodeYoungAgainOddMarking( MacroAssembler* masm); static void Generate_MakeSexagenarianCodeYoungAgainEvenMarking( MacroAssembler* masm); static void Generate_MakeSexagenarianCodeYoungAgainOddMarking( MacroAssembler* masm); static void Generate_MakeSeptuagenarianCodeYoungAgainEvenMarking( MacroAssembler* masm); static void Generate_MakeSeptuagenarianCodeYoungAgainOddMarking( MacroAssembler* masm); static void Generate_MakeOctogenarianCodeYoungAgainEvenMarking( MacroAssembler* masm); static void Generate_MakeOctogenarianCodeYoungAgainOddMarking( MacroAssembler* masm);


  static void Generate_MarkCodeAsToBeExecutedOnce(MacroAssembler* masm);
  static void Generate_MarkCodeAsExecutedOnce(MacroAssembler* masm);
  static void Generate_MarkCodeAsExecutedTwice(MacroAssembler* masm);

  static void InitBuiltinFunctionTable();

  bool initialized_;

  friend class BuiltinFunctionTable;
  friend class Isolate;

  Builtins(const Builtins&) = delete; void operator=(const Builtins&) = delete;
};

}
}








namespace std { inline namespace __1 {

template <class _Tp, class _Allocator> class __deque_base;
template <class _Tp, class _Allocator = allocator<_Tp>>
class __attribute__((__visibility__("default"))) deque;

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
class __attribute__((__visibility__("default"))) __deque_iterator;

template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2,
          _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f, _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type * =
         0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                     _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2,
          _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy_backward(
    _RAIter __f, _RAIter __l,
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
    typename enable_if<__is_random_access_iterator<_RAIter>::value>::type * =
        0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2,
          _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f, _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type * =
         0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                     _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2,
          _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(
    _RAIter __f, _RAIter __l,
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
    typename enable_if<__is_random_access_iterator<_RAIter>::value>::type * =
        0);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r);

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

template <class _ValueType, class _DiffType> struct __deque_block_size {
  static const _DiffType value =
      sizeof(_ValueType) < 256 ? 4096 / sizeof(_ValueType) : 16;
};

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BS =






                               __deque_block_size<_ValueType, _DiffType>::value

          >
class __attribute__((__visibility__("default"))) __deque_iterator {
  typedef _MapPointer __map_iterator;

public:
  typedef _Pointer pointer;
  typedef _DiffType difference_type;

private:
  __map_iterator __m_iter_;
  pointer __ptr_;

  static const difference_type __block_size;

public:
  typedef _ValueType value_type;
  typedef random_access_iterator_tag iterator_category;
  typedef _Reference reference;

  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator() noexcept




  {
  }

  template <class _Pp, class _Rp, class _MP>
  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator(
      const __deque_iterator<value_type, _Pp, _Rp, _MP, difference_type, _BS>
          &__it,
      typename enable_if<is_convertible<_Pp, pointer>::value>::type * =
          0) noexcept : __m_iter_(__it.__m_iter_),
                         __ptr_(__it.__ptr_) {}

  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator*() const { return *__ptr_; }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer operator->() const { return __ptr_; }

  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator &operator++() {
    if (++__ptr_ - *__m_iter_ == __block_size) {
      ++__m_iter_;
      __ptr_ = *__m_iter_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator operator++(int) {
    __deque_iterator __tmp = *this;
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator &operator--() {
    if (__ptr_ == *__m_iter_) {
      --__m_iter_;
      __ptr_ = *__m_iter_ + __block_size;
    }
    --__ptr_;
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator operator--(int) {
    __deque_iterator __tmp = *this;
    --(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator &operator+=(difference_type __n) {
    if (__n != 0) {
      __n += __ptr_ - *__m_iter_;
      if (__n > 0) {
        __m_iter_ += __n / __block_size;
        __ptr_ = *__m_iter_ + __n % __block_size;
      } else
      {
        difference_type __z = __block_size - 1 - __n;
        __m_iter_ -= __z / __block_size;
        __ptr_ = *__m_iter_ + (__block_size - 1 - __z % __block_size);
      }
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator &operator-=(difference_type __n) {
    return *this += -__n;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator
  operator+(difference_type __n) const {
    __deque_iterator __t(*this);
    __t += __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator
  operator-(difference_type __n) const {
    __deque_iterator __t(*this);
    __t -= __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  friend __deque_iterator operator+(difference_type __n,
                                    const __deque_iterator &__it) {
    return __it + __n;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  friend difference_type operator-(const __deque_iterator &__x,
                                   const __deque_iterator &__y) {
    if (__x != __y)
      return (__x.__m_iter_ - __y.__m_iter_) * __block_size +
             (__x.__ptr_ - *__x.__m_iter_) - (__y.__ptr_ - *__y.__m_iter_);
    return 0;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator[](difference_type __n) const {
    return *(*this + __n);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool
  operator==(const __deque_iterator &__x, const __deque_iterator &__y) {
    return __x.__ptr_ == __y.__ptr_;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool
  operator!=(const __deque_iterator &__x, const __deque_iterator &__y) {
    return !(__x == __y);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool operator<(const __deque_iterator &__x,
                                                  const __deque_iterator &__y) {
    return __x.__m_iter_ < __y.__m_iter_ ||
           (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool operator>(const __deque_iterator &__x,
                                                  const __deque_iterator &__y) {
    return __y < __x;
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool
  operator<=(const __deque_iterator &__x, const __deque_iterator &__y) {
    return !(__y < __x);
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) friend bool
  operator>=(const __deque_iterator &__x, const __deque_iterator &__y) {
    return !(__x < __y);
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__)) __deque_iterator(__map_iterator __m,
                                             pointer __p) noexcept
      : __m_iter_(__m),
        __ptr_(__p) {}

  template <class _Tp, class _Ap> friend class __deque_base;
  template <class _Tp, class _Ap> friend class __attribute__((__visibility__("default"))) deque;
  template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp>
  friend class __attribute__((__visibility__("default"))) __deque_iterator;

  template <class _RAIter, class _V2, class _P2, class _R2, class _M2,
            class _D2, _D2 _B2>
  friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
  copy(_RAIter __f, _RAIter __l,
       __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
       typename enable_if<__is_random_access_iterator<_RAIter>::value>::type *);

  template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
            class _OutputIterator>
  friend _OutputIterator
  copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
       __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);

  template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
            class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
  friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
  copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
       __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
       __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

  template <class _RAIter, class _V2, class _P2, class _R2, class _M2,
            class _D2, _D2 _B2>
  friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy_backward(
      _RAIter __f, _RAIter __l,
      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
      typename enable_if<__is_random_access_iterator<_RAIter>::value>::type *);

  template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
            class _OutputIterator>
  friend _OutputIterator
  copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                _OutputIterator __r);

  template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
            class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
  friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
  copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

  template <class _RAIter, class _V2, class _P2, class _R2, class _M2,
            class _D2, _D2 _B2>
  friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
  move(_RAIter __f, _RAIter __l,
       __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
       typename enable_if<__is_random_access_iterator<_RAIter>::value>::type *);

  template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
            class _OutputIterator>
  friend _OutputIterator
  move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
       __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l, _OutputIterator __r);

  template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
            class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
  friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
  move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
       __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
       __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);

  template <class _RAIter, class _V2, class _P2, class _R2, class _M2,
            class _D2, _D2 _B2>
  friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(
      _RAIter __f, _RAIter __l,
      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
      typename enable_if<__is_random_access_iterator<_RAIter>::value>::type *);

  template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
            class _OutputIterator>
  friend _OutputIterator
  move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                _OutputIterator __r);

  template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
            class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
  friend __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
  move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);
};

template <class _ValueType, class _Pointer, class _Reference, class _MapPointer,
          class _DiffType, _DiffType _BlockSize>
const _DiffType __deque_iterator<_ValueType, _Pointer, _Reference, _MapPointer,
                                 _DiffType, _BlockSize>::__block_size =
    __deque_block_size<_ValueType, _DiffType>::value;



template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2,
          _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(_RAIter __f, _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type *) {
  typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2,
                                    _B2>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
  const difference_type __block_size =
      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
  while (__f != __l) {
    pointer __rb = __r.__ptr_;
    pointer __re = *__r.__m_iter_ + __block_size;
    difference_type __bs = __re - __rb;
    difference_type __n = __l - __f;
    _RAIter __m = __l;
    if (__n > __bs) {
      __n = __bs;
      __m = __f + __n;
    }
    std::__1::copy(__f, __m, __rb);
    __f = __m;
    __r += __n;
  }
  return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                     _OutputIterator __r) {
  typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1,
                                    _B1>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
  const difference_type __block_size =
      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
  difference_type __n = __l - __f;
  while (__n > 0) {
    pointer __fb = __f.__ptr_;
    pointer __fe = *__f.__m_iter_ + __block_size;
    difference_type __bs = __fe - __fb;
    if (__bs > __n) {
      __bs = __n;
      __fe = __fb + __bs;
    }
    __r = std::__1::copy(__fb, __fe, __r);
    __n -= __bs;
    __f += __bs;
  }
  return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r) {
  typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1,
                                    _B1>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
  const difference_type __block_size =
      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
  difference_type __n = __l - __f;
  while (__n > 0) {
    pointer __fb = __f.__ptr_;
    pointer __fe = *__f.__m_iter_ + __block_size;
    difference_type __bs = __fe - __fb;
    if (__bs > __n) {
      __bs = __n;
      __fe = __fb + __bs;
    }
    __r = std::__1::copy(__fb, __fe, __r);
    __n -= __bs;
    __f += __bs;
  }
  return __r;
}



template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2,
          _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> copy_backward(
    _RAIter __f, _RAIter __l,
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
    typename enable_if<__is_random_access_iterator<_RAIter>::value>::type *) {
  typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2,
                                    _B2>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
  while (__f != __l) {
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
    pointer __rb = *__rp.__m_iter_;
    pointer __re = __rp.__ptr_ + 1;
    difference_type __bs = __re - __rb;
    difference_type __n = __l - __f;
    _RAIter __m = __f;
    if (__n > __bs) {
      __n = __bs;
      __m = __l - __n;
    }
    std::__1::copy_backward(__m, __l, __re);
    __l = __m;
    __r -= __n;
  }
  return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r) {
  typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1,
                                    _B1>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
  difference_type __n = __l - __f;
  while (__n > 0) {
    --__l;
    pointer __lb = *__l.__m_iter_;
    pointer __le = __l.__ptr_ + 1;
    difference_type __bs = __le - __lb;
    if (__bs > __n) {
      __bs = __n;
      __lb = __le - __bs;
    }
    __r = std::__1::copy_backward(__lb, __le, __r);
    __n -= __bs;
    __l -= __bs - 1;
  }
  return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r) {
  typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1,
                                    _B1>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
  difference_type __n = __l - __f;
  while (__n > 0) {
    --__l;
    pointer __lb = *__l.__m_iter_;
    pointer __le = __l.__ptr_ + 1;
    difference_type __bs = __le - __lb;
    if (__bs > __n) {
      __bs = __n;
      __lb = __le - __bs;
    }
    __r = std::__1::copy_backward(__lb, __le, __r);
    __n -= __bs;
    __l -= __bs - 1;
  }
  return __r;
}



template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2,
          _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(_RAIter __f, _RAIter __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type *) {
  typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2,
                                    _B2>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
  const difference_type __block_size =
      __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::__block_size;
  while (__f != __l) {
    pointer __rb = __r.__ptr_;
    pointer __re = *__r.__m_iter_ + __block_size;
    difference_type __bs = __re - __rb;
    difference_type __n = __l - __f;
    _RAIter __m = __l;
    if (__n > __bs) {
      __n = __bs;
      __m = __f + __n;
    }
    std::__1::move(__f, __m, __rb);
    __f = __m;
    __r += __n;
  }
  return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
                     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
                     _OutputIterator __r) {
  typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1,
                                    _B1>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
  const difference_type __block_size =
      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
  difference_type __n = __l - __f;
  while (__n > 0) {
    pointer __fb = __f.__ptr_;
    pointer __fe = *__f.__m_iter_ + __block_size;
    difference_type __bs = __fe - __fb;
    if (__bs > __n) {
      __bs = __n;
      __fe = __fb + __bs;
    }
    __r = std::__1::move(__fb, __fe, __r);
    __n -= __bs;
    __f += __bs;
  }
  return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r) {
  typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1,
                                    _B1>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
  const difference_type __block_size =
      __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::__block_size;
  difference_type __n = __l - __f;
  while (__n > 0) {
    pointer __fb = __f.__ptr_;
    pointer __fe = *__f.__m_iter_ + __block_size;
    difference_type __bs = __fe - __fb;
    if (__bs > __n) {
      __bs = __n;
      __fe = __fb + __bs;
    }
    __r = std::__1::move(__fb, __fe, __r);
    __n -= __bs;
    __f += __bs;
  }
  return __r;
}



template <class _RAIter, class _V2, class _P2, class _R2, class _M2, class _D2,
          _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> move_backward(
    _RAIter __f, _RAIter __l,
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,
    typename enable_if<__is_random_access_iterator<_RAIter>::value>::type *) {
  typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2,
                                    _B2>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;
  while (__f != __l) {
    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = std::__1::prev(__r);
    pointer __rb = *__rp.__m_iter_;
    pointer __re = __rp.__ptr_ + 1;
    difference_type __bs = __re - __rb;
    difference_type __n = __l - __f;
    _RAIter __m = __f;
    if (__n > __bs) {
      __n = __bs;
      __m = __l - __n;
    }
    std::__1::move_backward(__m, __l, __re);
    __l = __m;
    __r -= __n;
  }
  return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _OutputIterator>
_OutputIterator
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              _OutputIterator __r) {
  typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1,
                                    _B1>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
  difference_type __n = __l - __f;
  while (__n > 0) {
    --__l;
    pointer __lb = *__l.__m_iter_;
    pointer __le = __l.__ptr_ + 1;
    difference_type __bs = __le - __lb;
    if (__bs > __n) {
      __bs = __n;
      __lb = __le - __bs;
    }
    __r = std::__1::move_backward(__lb, __le, __r);
    __n -= __bs;
    __l -= __bs - 1;
  }
  return __r;
}

template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,
          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>
__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>
move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,
              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,
              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r) {
  typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1,
                                    _B1>::difference_type difference_type;
  typedef
      typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;
  difference_type __n = __l - __f;
  while (__n > 0) {
    --__l;
    pointer __lb = *__l.__m_iter_;
    pointer __le = __l.__ptr_ + 1;
    difference_type __bs = __le - __lb;
    if (__bs > __n) {
      __bs = __n;
      __lb = __le - __bs;
    }
    __r = std::__1::move_backward(__lb, __le, __r);
    __n -= __bs;
    __l -= __bs - 1;
  }
  return __r;
}

template <bool> class __deque_base_common {
protected:
  [[noreturn]] void __throw_length_error() const;
  [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void __deque_base_common<__b>::__throw_length_error() const {
  std::__1::__throw_length_error("deque");
}

template <bool __b>
void __deque_base_common<__b>::__throw_out_of_range() const {
  std::__1::__throw_out_of_range("deque");
}

template <class _Tp, class _Allocator>
class __deque_base : protected __deque_base_common<true> {
  __deque_base(const __deque_base &__c);
  __deque_base &operator=(const __deque_base &__c);

protected:
  typedef _Tp value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;

  static const difference_type __block_size;

  typedef typename __rebind_alloc_helper<__alloc_traits, pointer>::type
      __pointer_allocator;
  typedef allocator_traits<__pointer_allocator> __map_traits;
  typedef typename __map_traits::pointer __map_pointer;
  typedef typename __rebind_alloc_helper<__alloc_traits, const_pointer>::type
      __const_pointer_allocator;
  typedef typename allocator_traits<__const_pointer_allocator>::const_pointer
      __map_const_pointer;
  typedef __split_buffer<pointer, __pointer_allocator> __map;

  typedef __deque_iterator<value_type, pointer, reference, __map_pointer,
                           difference_type>
      iterator;
  typedef __deque_iterator<value_type, const_pointer, const_reference,
                           __map_const_pointer, difference_type>
      const_iterator;

  __map __map_;
  size_type __start_;
  __compressed_pair<size_type, allocator_type> __size_;

  iterator begin() noexcept;
  const_iterator begin() const noexcept;
  iterator end() noexcept;
  const_iterator end() const noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__)) size_type &size() { return __size_.first(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const size_type &size() const noexcept { return __size_.first(); }
  __attribute__((__visibility__("hidden"), __always_inline__)) allocator_type &__alloc() {
    return __size_.second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const allocator_type &__alloc() const noexcept { return __size_.second(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __deque_base()
      noexcept(is_nothrow_default_constructible<allocator_type>::value);
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __deque_base(const allocator_type &__a);

public:
  ~__deque_base();



  __deque_base(__deque_base &&__c)
      noexcept(is_nothrow_move_constructible<allocator_type>::value);
  __deque_base(__deque_base &&__c, const allocator_type &__a);


  void swap(__deque_base &__c)



      noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value);


protected:
  void clear() noexcept;

  bool __invariants() const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign(__deque_base &__c)
      noexcept(__alloc_traits::propagate_on_container_move_assignment::value &&is_nothrow_move_assignable<allocator_type>::value) {

    __map_ = std::__1::move(__c.__map_);
    __start_ = __c.__start_;
    size() = __c.size();
    __move_assign_alloc(__c);
    __c.__start_ = __c.size() = 0;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__deque_base &__c) noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value) {


    __move_assign_alloc(
        __c,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_move_assignment::value>());
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__deque_base &__c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::__1::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__deque_base &, false_type) noexcept {}
};

template <class _Tp, class _Allocator>
const typename __deque_base<_Tp, _Allocator>::difference_type
    __deque_base<_Tp, _Allocator>::__block_size =
        __deque_block_size<value_type, difference_type>::value;

template <class _Tp, class _Allocator>
bool __deque_base<_Tp, _Allocator>::__invariants() const {
  if (!__map_.__invariants())
    return false;
  if (__map_.size() >= size_type(-1) / __block_size)
    return false;
  for (typename __map::const_iterator __i = __map_.begin(), __e = __map_.end();
       __i != __e; ++__i)
    if (*__i == nullptr)
      return false;
  if (__map_.size() != 0) {
    if (size() >= __map_.size() * __block_size)
      return false;
    if (__start_ >= __map_.size() * __block_size - size())
      return false;
  } else {
    if (size() != 0)
      return false;
    if (__start_ != 0)
      return false;
  }
  return true;
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::begin() noexcept {
  __map_pointer __mp = __map_.begin() + __start_ / __block_size;
  return iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::begin() const noexcept {
  __map_const_pointer __mp = static_cast<__map_const_pointer>(
      __map_.begin() + __start_ / __block_size);
  return const_iterator(__mp,
                        __map_.empty() ? 0 : *__mp + __start_ % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::iterator
__deque_base<_Tp, _Allocator>::end() noexcept {
  size_type __p = size() + __start_;
  __map_pointer __mp = __map_.begin() + __p / __block_size;
  return iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}

template <class _Tp, class _Allocator>
typename __deque_base<_Tp, _Allocator>::const_iterator
__deque_base<_Tp, _Allocator>::end() const noexcept {
  size_type __p = size() + __start_;
  __map_const_pointer __mp =
      static_cast<__map_const_pointer>(__map_.begin() + __p / __block_size);
  return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);
}

template <class _Tp, class _Allocator>
inline __deque_base<_Tp, _Allocator>::__deque_base()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __start_(0), __size_(0) {}

template <class _Tp, class _Allocator>
inline __deque_base<_Tp, _Allocator>::__deque_base(const allocator_type &__a)
    : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {}

template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::~__deque_base() {
  clear();
  typename __map::iterator __i = __map_.begin();
  typename __map::iterator __e = __map_.end();
  for (; __i != __e; ++__i)
    __alloc_traits::deallocate(__alloc(), *__i, __block_size);
}



template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::__deque_base(__deque_base &&__c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __map_(std::__1::move(__c.__map_)), __start_(std::__1::move(__c.__start_)),
      __size_(std::__1::move(__c.__size_)) {
  __c.__start_ = 0;
  __c.size() = 0;
}

template <class _Tp, class _Allocator>
__deque_base<_Tp, _Allocator>::__deque_base(__deque_base &&__c,
                                            const allocator_type &__a)
    : __map_(std::__1::move(__c.__map_), __pointer_allocator(__a)),
      __start_(std::__1::move(__c.__start_)),
      __size_(std::__1::move(__c.size()), __a) {
  if (__a == __c.__alloc()) {
    __c.__start_ = 0;
    __c.size() = 0;
  } else {
    __map_.clear();
    __start_ = 0;
    size() = 0;
  }
}



template <class _Tp, class _Allocator>
void __deque_base<_Tp, _Allocator>::swap(__deque_base &__c)



    noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value)


{
  __map_.swap(__c.__map_);
  std::__1::swap(__start_, __c.__start_);
  std::__1::swap(size(), __c.size());
  __swap_allocator(__alloc(), __c.__alloc());
}

template <class _Tp, class _Allocator>
void __deque_base<_Tp, _Allocator>::clear() noexcept {
  allocator_type &__a = __alloc();
  for (iterator __i = begin(), __e = end(); __i != __e; ++__i)
    __alloc_traits::destroy(__a, std::__1::addressof(*__i));
  size() = 0;
  while (__map_.size() > 2) {
    __alloc_traits::deallocate(__a, __map_.front(), __block_size);
    __map_.pop_front();
  }
  switch (__map_.size()) {
  case 1:
    __start_ = __block_size / 2;
    break;
  case 2:
    __start_ = __block_size;
    break;
  }
}

template <class _Tp, class _Allocator >
class __attribute__((__visibility__("default"))) deque : private __deque_base<_Tp, _Allocator> {
public:


  typedef _Tp value_type;
  typedef _Allocator allocator_type;

  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

  typedef __deque_base<value_type, allocator_type> __base;

  typedef typename __base::__alloc_traits __alloc_traits;
  typedef typename __base::reference reference;
  typedef typename __base::const_reference const_reference;
  typedef typename __base::iterator iterator;
  typedef typename __base::const_iterator const_iterator;
  typedef typename __base::size_type size_type;
  typedef typename __base::difference_type difference_type;

  typedef typename __base::pointer pointer;
  typedef typename __base::const_pointer const_pointer;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


  __attribute__((__visibility__("hidden"), __always_inline__))
  deque() noexcept(is_nothrow_default_constructible<allocator_type>::value) {}
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit deque(const allocator_type &__a)
      : __base(__a) {}
  explicit deque(size_type __n);



  deque(size_type __n, const value_type &__v);
  deque(size_type __n, const value_type &__v, const allocator_type &__a);
  template <class _InputIter>
  deque(_InputIter __f, _InputIter __l,
        typename enable_if<__is_input_iterator<_InputIter>::value>::type * = 0);
  template <class _InputIter>
  deque(_InputIter __f, _InputIter __l, const allocator_type &__a,
        typename enable_if<__is_input_iterator<_InputIter>::value>::type * = 0);
  deque(const deque &__c);
  deque(const deque &__c, const allocator_type &__a);

  deque(initializer_list<value_type> __il);
  deque(initializer_list<value_type> __il, const allocator_type &__a);


  deque &operator=(const deque &__c);

  __attribute__((__visibility__("hidden"), __always_inline__))
  deque &operator=(initializer_list<value_type> __il) {
    assign(__il);
    return *this;
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  deque(deque &&__c) noexcept(is_nothrow_move_constructible<__base>::value);
  __attribute__((__visibility__("hidden"), __always_inline__))
  deque(deque &&__c, const allocator_type &__a);
  __attribute__((__visibility__("hidden"), __always_inline__))
  deque &operator=(deque &&__c)
      noexcept(__alloc_traits::propagate_on_container_move_assignment::value &&is_nothrow_move_assignable<allocator_type>::value);



  template <class _InputIter>
  void assign(_InputIter __f, _InputIter __l,
              typename enable_if<
                  __is_input_iterator<_InputIter>::value &&
                  !__is_random_access_iterator<_InputIter>::value>::type * = 0);
  template <class _RAIter>
  void assign(
      _RAIter __f, _RAIter __l,
      typename enable_if<__is_random_access_iterator<_RAIter>::value>::type * =
          0);
  void assign(size_type __n, const value_type &__v);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void assign(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type get_allocator() const noexcept;



  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator begin() noexcept { return __base::begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator begin() const noexcept { return __base::begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator end() noexcept { return __base::end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator end() const noexcept { return __base::end(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rbegin() noexcept {
    return reverse_iterator(__base::end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(__base::end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rend() noexcept {
    return reverse_iterator(__base::begin());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(__base::begin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cbegin() const noexcept { return __base::begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cend() const noexcept { return __base::end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(__base::end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(__base::begin());
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type size() const noexcept { return __base::size(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type max_size() const noexcept {
    return __alloc_traits::max_size(__base::__alloc());
  }
  void resize(size_type __n);
  void resize(size_type __n, const value_type &__v);
  void shrink_to_fit() noexcept;
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool empty() const noexcept { return __base::size() == 0; }


  __attribute__((__visibility__("hidden"), __always_inline__))
  reference operator[](size_type __i);
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reference operator[](size_type __i) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  reference at(size_type __i);
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reference at(size_type __i) const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  reference front();
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reference front() const;
  __attribute__((__visibility__("hidden"), __always_inline__))
  reference back();
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reference back() const;


  void push_front(const value_type &__v);
  void push_back(const value_type &__v);


  template <class... _Args> reference emplace_front(_Args &&... __args);
  template <class... _Args> reference emplace_back(_Args &&... __args);
  template <class... _Args>
  iterator emplace(const_iterator __p, _Args &&... __args);

  void push_front(value_type &&__v);
  void push_back(value_type &&__v);
  iterator insert(const_iterator __p, value_type &&__v);

  iterator insert(const_iterator __p, const value_type &__v);
  iterator insert(const_iterator __p, size_type __n, const value_type &__v);
  template <class _InputIter>
  iterator
  insert(const_iterator __p, _InputIter __f, _InputIter __l,
         typename enable_if<__is_input_iterator<_InputIter>::value &&
                            !__is_forward_iterator<_InputIter>::value>::type * =
             0);
  template <class _ForwardIterator>
  iterator insert(
      const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,
      typename enable_if<
          __is_forward_iterator<_ForwardIterator>::value &&
          !__is_bidirectional_iterator<_ForwardIterator>::value>::type * = 0);
  template <class _BiIter>
  iterator insert(
      const_iterator __p, _BiIter __f, _BiIter __l,
      typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type * =
          0);

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __p, initializer_list<value_type> __il) {
    return insert(__p, __il.begin(), __il.end());
  }

  void pop_front();
  void pop_back();
  iterator erase(const_iterator __p);
  iterator erase(const_iterator __f, const_iterator __l);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(deque &__c)



      noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value);


  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool __invariants() const { return __base::__invariants(); }

private:
  typedef typename __base::__map_const_pointer __map_const_pointer;

  __attribute__((__visibility__("hidden"), __always_inline__))
  static size_type __recommend_blocks(size_type __n) {
    return __n / __base::__block_size + (__n % __base::__block_size != 0);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type __capacity() const {
    return __base::__map_.size() == 0
               ? 0
               : __base::__map_.size() * __base::__block_size - 1;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type __front_spare() const { return __base::__start_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type __back_spare() const {
    return __capacity() - (__base::__start_ + __base::size());
  }

  template <class _InpIter>
  void __append(
      _InpIter __f, _InpIter __l,
      typename enable_if<__is_input_iterator<_InpIter>::value &&
                         !__is_forward_iterator<_InpIter>::value>::type * = 0);
  template <class _ForIter>
  void __append(
      _ForIter __f, _ForIter __l,
      typename enable_if<__is_forward_iterator<_ForIter>::value>::type * = 0);
  void __append(size_type __n);
  void __append(size_type __n, const value_type &__v);
  void __erase_to_end(const_iterator __f);
  void __add_front_capacity();
  void __add_front_capacity(size_type __n);
  void __add_back_capacity();
  void __add_back_capacity(size_type __n);
  iterator __move_and_check(iterator __f, iterator __l, iterator __r,
                            const_pointer &__vt);
  iterator __move_backward_and_check(iterator __f, iterator __l, iterator __r,
                                     const_pointer &__vt);
  void __move_construct_and_check(iterator __f, iterator __l, iterator __r,
                                  const_pointer &__vt);
  void __move_construct_backward_and_check(iterator __f, iterator __l,
                                           iterator __r, const_pointer &__vt);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const deque &__c) {
    __copy_assign_alloc(
        __c,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const deque &__c, true_type) {
    if (__base::__alloc() != __c.__alloc()) {
      clear();
      shrink_to_fit();
    }
    __base::__alloc() = __c.__alloc();
    __base::__map_.__alloc() = __c.__map_.__alloc();
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const deque &, false_type) {}

  void __move_assign(deque &__c, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value);
  void __move_assign(deque &__c, false_type);
};

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n) {
  if (__n > 0)
    __append(__n);
}
template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type &__v) {
  if (__n > 0)
    __append(__n, __v);
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(size_type __n, const value_type &__v,
                              const allocator_type &__a)
    : __base(__a) {
  if (__n > 0)
    __append(__n, __v);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(
    _InputIter __f, _InputIter __l,
    typename enable_if<__is_input_iterator<_InputIter>::value>::type *) {
  __append(__f, __l);
}

template <class _Tp, class _Allocator>
template <class _InputIter>
deque<_Tp, _Allocator>::deque(
    _InputIter __f, _InputIter __l, const allocator_type &__a,
    typename enable_if<__is_input_iterator<_InputIter>::value>::type *)
    : __base(__a) {
  __append(__f, __l);
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque &__c)
    : __base(__alloc_traits::select_on_container_copy_construction(
          __c.__alloc())) {
  __append(__c.begin(), __c.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(const deque &__c, const allocator_type &__a)
    : __base(__a) {
  __append(__c.begin(), __c.end());
}



template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(initializer_list<value_type> __il) {
  __append(__il.begin(), __il.end());
}

template <class _Tp, class _Allocator>
deque<_Tp, _Allocator>::deque(initializer_list<value_type> __il,
                              const allocator_type &__a)
    : __base(__a) {
  __append(__il.begin(), __il.end());
}



template <class _Tp, class _Allocator>
deque<_Tp, _Allocator> &deque<_Tp, _Allocator>::operator=(const deque &__c) {
  if (this != &__c) {
    __copy_assign_alloc(__c);
    assign(__c.begin(), __c.end());
  }
  return *this;
}



template <class _Tp, class _Allocator>
inline deque<_Tp, _Allocator>::deque(deque &&__c)
    noexcept(is_nothrow_move_constructible<__base>::value)
    : __base(std::__1::move(__c)) {}

template <class _Tp, class _Allocator>
inline deque<_Tp, _Allocator>::deque(deque &&__c, const allocator_type &__a)
    : __base(std::__1::move(__c), __a) {
  if (__a != __c.__alloc()) {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__c.begin()), _Ip(__c.end()));
  }
}

template <class _Tp, class _Allocator>
inline deque<_Tp, _Allocator> &deque<_Tp, _Allocator>::operator=(deque &&__c)
    noexcept(__alloc_traits::propagate_on_container_move_assignment::value &&is_nothrow_move_assignable<allocator_type>::value) {

  __move_assign(
      __c,
      integral_constant<
          bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__move_assign(deque &__c, false_type) {
  if (__base::__alloc() != __c.__alloc()) {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__c.begin()), _Ip(__c.end()));
  } else
    __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__move_assign(deque &__c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value) {
  clear();
  shrink_to_fit();
  __base::__move_assign(__c);
}



template <class _Tp, class _Allocator>
template <class _InputIter>
void deque<_Tp, _Allocator>::assign(
    _InputIter __f, _InputIter __l,
    typename enable_if<__is_input_iterator<_InputIter>::value &&
                       !__is_random_access_iterator<_InputIter>::value>::type
        *) {
  iterator __i = __base::begin();
  iterator __e = __base::end();
  for (; __f != __l && __i != __e; ++__f, (void)++__i)
    *__i = *__f;
  if (__f != __l)
    __append(__f, __l);
  else
    __erase_to_end(__i);
}

template <class _Tp, class _Allocator>
template <class _RAIter>
void deque<_Tp, _Allocator>::assign(
    _RAIter __f, _RAIter __l,
    typename enable_if<__is_random_access_iterator<_RAIter>::value>::type *) {
  if (static_cast<size_type>(__l - __f) > __base::size()) {
    _RAIter __m = __f + __base::size();
    std::__1::copy(__f, __m, __base::begin());
    __append(__m, __l);
  } else
    __erase_to_end(std::__1::copy(__f, __l, __base::begin()));
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::assign(size_type __n, const value_type &__v) {
  if (__n > __base::size()) {
    std::__1::fill_n(__base::begin(), __base::size(), __v);
    __n -= __base::size();
    __append(__n, __v);
  } else
    __erase_to_end(std::__1::fill_n(__base::begin(), __n, __v));
}

template <class _Tp, class _Allocator>
inline _Allocator deque<_Tp, _Allocator>::get_allocator() const noexcept {
  return __base::__alloc();
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::resize(size_type __n) {
  if (__n > __base::size())
    __append(__n - __base::size());
  else if (__n < __base::size())
    __erase_to_end(__base::begin() + __n);
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::resize(size_type __n, const value_type &__v) {
  if (__n > __base::size())
    __append(__n - __base::size(), __v);
  else if (__n < __base::size())
    __erase_to_end(__base::begin() + __n);
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::shrink_to_fit() noexcept {
  allocator_type &__a = __base::__alloc();
  if (empty()) {
    while (__base::__map_.size() > 0) {
      __alloc_traits::deallocate(__a, __base::__map_.back(),
                                 __base::__block_size);
      __base::__map_.pop_back();
    }
    __base::__start_ = 0;
  } else {
    if (__front_spare() >= __base::__block_size) {
      __alloc_traits::deallocate(__a, __base::__map_.front(),
                                 __base::__block_size);
      __base::__map_.pop_front();
      __base::__start_ -= __base::__block_size;
    }
    if (__back_spare() >= __base::__block_size) {
      __alloc_traits::deallocate(__a, __base::__map_.back(),
                                 __base::__block_size);
      __base::__map_.pop_back();
    }
  }
  __base::__map_.shrink_to_fit();
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::reference deque<_Tp, _Allocator>::
operator[](size_type __i) {
  size_type __p = __base::__start_ + __i;
  return *(*(__base::__map_.begin() + __p / __base::__block_size) +
           __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::const_reference deque<_Tp, _Allocator>::
operator[](size_type __i) const {
  size_type __p = __base::__start_ + __i;
  return *(*(__base::__map_.begin() + __p / __base::__block_size) +
           __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::at(size_type __i) {
  if (__i >= __base::size())
    __base::__throw_out_of_range();
  size_type __p = __base::__start_ + __i;
  return *(*(__base::__map_.begin() + __p / __base::__block_size) +
           __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::at(size_type __i) const {
  if (__i >= __base::size())
    __base::__throw_out_of_range();
  size_type __p = __base::__start_ + __i;
  return *(*(__base::__map_.begin() + __p / __base::__block_size) +
           __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::front() {
  return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size) +
           __base::__start_ % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::front() const {
  return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size) +
           __base::__start_ % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::back() {
  size_type __p = __base::size() + __base::__start_ - 1;
  return *(*(__base::__map_.begin() + __p / __base::__block_size) +
           __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
inline typename deque<_Tp, _Allocator>::const_reference
deque<_Tp, _Allocator>::back() const {
  size_type __p = __base::size() + __base::__start_ - 1;
  return *(*(__base::__map_.begin() + __p / __base::__block_size) +
           __p % __base::__block_size);
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::push_back(const value_type &__v) {
  allocator_type &__a = __base::__alloc();
  if (__back_spare() == 0)
    __add_back_capacity();

  __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
  ++__base::size();
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::push_back(value_type &&__v) {
  allocator_type &__a = __base::__alloc();
  if (__back_spare() == 0)
    __add_back_capacity();

  __alloc_traits::construct(__a, std::__1::addressof(*__base::end()),
                            std::__1::move(__v));
  ++__base::size();
}



template <class _Tp, class _Allocator>
template <class... _Args>
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::emplace_back(_Args &&... __args) {
  allocator_type &__a = __base::__alloc();
  if (__back_spare() == 0)
    __add_back_capacity();

  __alloc_traits::construct(__a, std::__1::addressof(*__base::end()),
                            std::__1::forward<_Args>(__args)...);
  ++__base::size();
  return *--__base::end();
}




template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::push_front(const value_type &__v) {
  allocator_type &__a = __base::__alloc();
  if (__front_spare() == 0)
    __add_front_capacity();

  __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
  --__base::__start_;
  ++__base::size();
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::push_front(value_type &&__v) {
  allocator_type &__a = __base::__alloc();
  if (__front_spare() == 0)
    __add_front_capacity();

  __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()),
                            std::__1::move(__v));
  --__base::__start_;
  ++__base::size();
}



template <class _Tp, class _Allocator>
template <class... _Args>
typename deque<_Tp, _Allocator>::reference
deque<_Tp, _Allocator>::emplace_front(_Args &&... __args) {
  allocator_type &__a = __base::__alloc();
  if (__front_spare() == 0)
    __add_front_capacity();

  __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()),
                            std::__1::forward<_Args>(__args)...);
  --__base::__start_;
  ++__base::size();
  return *__base::begin();
}




template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, const value_type &__v) {
  size_type __pos = __p - __base::begin();
  size_type __to_end = __base::size() - __pos;
  allocator_type &__a = __base::__alloc();
  if (__pos < __to_end) {
    if (__front_spare() == 0)
      __add_front_capacity();

    if (__pos == 0) {
      __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()), __v);
      --__base::__start_;
      ++__base::size();
    } else {
      const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
      iterator __b = __base::begin();
      iterator __bm1 = std::__1::prev(__b);
      if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))
        __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);
      __alloc_traits::construct(__a, std::__1::addressof(*__bm1),
                                std::__1::move(*__b));
      --__base::__start_;
      ++__base::size();
      if (__pos > 1)
        __b = __move_and_check(std::__1::next(__b), __b + __pos, __b, __vt);
      *__b = *__vt;
    }
  } else {
    if (__back_spare() == 0)
      __add_back_capacity();

    size_type __de = __base::size() - __pos;
    if (__de == 0) {
      __alloc_traits::construct(__a, std::__1::addressof(*__base::end()), __v);
      ++__base::size();
    } else {
      const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
      iterator __e = __base::end();
      iterator __em1 = std::__1::prev(__e);
      if (__vt == pointer_traits<const_pointer>::pointer_to(*__em1))
        __vt = pointer_traits<const_pointer>::pointer_to(*__e);
      __alloc_traits::construct(__a, std::__1::addressof(*__e),
                                std::__1::move(*__em1));
      ++__base::size();
      if (__de > 1)
        __e = __move_backward_and_check(__e - __de, __em1, __e, __vt);
      *--__e = *__vt;
    }
  }
  return __base::begin() + __pos;
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, value_type &&__v) {
  size_type __pos = __p - __base::begin();
  size_type __to_end = __base::size() - __pos;
  allocator_type &__a = __base::__alloc();
  if (__pos < __to_end) {
    if (__front_spare() == 0)
      __add_front_capacity();

    if (__pos == 0) {
      __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()),
                                std::__1::move(__v));
      --__base::__start_;
      ++__base::size();
    } else {
      iterator __b = __base::begin();
      iterator __bm1 = std::__1::prev(__b);
      __alloc_traits::construct(__a, std::__1::addressof(*__bm1),
                                std::__1::move(*__b));
      --__base::__start_;
      ++__base::size();
      if (__pos > 1)
        __b = std::__1::move(std::__1::next(__b), __b + __pos, __b);
      *__b = std::__1::move(__v);
    }
  } else {
    if (__back_spare() == 0)
      __add_back_capacity();

    size_type __de = __base::size() - __pos;
    if (__de == 0) {
      __alloc_traits::construct(__a, std::__1::addressof(*__base::end()),
                                std::__1::move(__v));
      ++__base::size();
    } else {
      iterator __e = __base::end();
      iterator __em1 = std::__1::prev(__e);
      __alloc_traits::construct(__a, std::__1::addressof(*__e),
                                std::__1::move(*__em1));
      ++__base::size();
      if (__de > 1)
        __e = std::__1::move_backward(__e - __de, __em1, __e);
      *--__e = std::__1::move(__v);
    }
  }
  return __base::begin() + __pos;
}



template <class _Tp, class _Allocator>
template <class... _Args>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::emplace(const_iterator __p, _Args &&... __args) {
  size_type __pos = __p - __base::begin();
  size_type __to_end = __base::size() - __pos;
  allocator_type &__a = __base::__alloc();
  if (__pos < __to_end) {
    if (__front_spare() == 0)
      __add_front_capacity();

    if (__pos == 0) {
      __alloc_traits::construct(__a, std::__1::addressof(*--__base::begin()),
                                std::__1::forward<_Args>(__args)...);
      --__base::__start_;
      ++__base::size();
    } else {
      __temp_value<value_type, _Allocator> __tmp(
          this->__alloc(), std::__1::forward<_Args>(__args)...);
      iterator __b = __base::begin();
      iterator __bm1 = std::__1::prev(__b);
      __alloc_traits::construct(__a, std::__1::addressof(*__bm1),
                                std::__1::move(*__b));
      --__base::__start_;
      ++__base::size();
      if (__pos > 1)
        __b = std::__1::move(std::__1::next(__b), __b + __pos, __b);
      *__b = std::__1::move(__tmp.get());
    }
  } else {
    if (__back_spare() == 0)
      __add_back_capacity();

    size_type __de = __base::size() - __pos;
    if (__de == 0) {
      __alloc_traits::construct(__a, std::__1::addressof(*__base::end()),
                                std::__1::forward<_Args>(__args)...);
      ++__base::size();
    } else {
      __temp_value<value_type, _Allocator> __tmp(
          this->__alloc(), std::__1::forward<_Args>(__args)...);
      iterator __e = __base::end();
      iterator __em1 = std::__1::prev(__e);
      __alloc_traits::construct(__a, std::__1::addressof(*__e),
                                std::__1::move(*__em1));
      ++__base::size();
      if (__de > 1)
        __e = std::__1::move_backward(__e - __de, __em1, __e);
      *--__e = std::__1::move(__tmp.get());
    }
  }
  return __base::begin() + __pos;
}




template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::insert(const_iterator __p, size_type __n,
                               const value_type &__v) {
  size_type __pos = __p - __base::begin();
  size_type __to_end = __base::size() - __pos;
  allocator_type &__a = __base::__alloc();
  if (__pos < __to_end) {
    if (__n > __front_spare())
      __add_front_capacity(__n - __front_spare());

    iterator __old_begin = __base::begin();
    iterator __i = __old_begin;
    if (__n > __pos) {
      for (size_type __m = __n - __pos; __m;
           --__m, --__base::__start_, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*--__i), __v);
      __n = __pos;
    }
    if (__n > 0) {
      const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
      iterator __obn = __old_begin + __n;
      __move_construct_backward_and_check(__old_begin, __obn, __i, __vt);
      if (__n < __pos)
        __old_begin =
            __move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);
      std::__1::fill_n(__old_begin, __n, *__vt);
    }
  } else {
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
      __add_back_capacity(__n - __back_capacity);

    iterator __old_end = __base::end();
    iterator __i = __old_end;
    size_type __de = __base::size() - __pos;
    if (__n > __de) {
      for (size_type __m = __n - __de; __m; --__m, ++__i, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*__i), __v);
      __n = __de;
    }
    if (__n > 0) {
      const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);
      iterator __oen = __old_end - __n;
      __move_construct_and_check(__oen, __old_end, __i, __vt);
      if (__n < __de)
        __old_end =
            __move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);
      std::__1::fill_n(__old_end - __n, __n, *__vt);
    }
  }
  return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(
    const_iterator __p, _InputIter __f, _InputIter __l,
    typename enable_if<__is_input_iterator<_InputIter>::value &&
                       !__is_forward_iterator<_InputIter>::value>::type *) {
  __split_buffer<value_type, allocator_type &> __buf(__base::__alloc());
  __buf.__construct_at_end(__f, __l);
  typedef typename __split_buffer<value_type, allocator_type &>::iterator __bi;
  return insert(__p, move_iterator<__bi>(__buf.begin()),
                move_iterator<__bi>(__buf.end()));
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(
    const_iterator __p, _ForwardIterator __f, _ForwardIterator __l,
    typename enable_if<
        __is_forward_iterator<_ForwardIterator>::value &&
        !__is_bidirectional_iterator<_ForwardIterator>::value>::type *) {
  size_type __n = std::__1::distance(__f, __l);
  __split_buffer<value_type, allocator_type &> __buf(__n, 0, __base::__alloc());
  __buf.__construct_at_end(__f, __l);
  typedef typename __split_buffer<value_type, allocator_type &>::iterator __fwd;
  return insert(__p, move_iterator<__fwd>(__buf.begin()),
                move_iterator<__fwd>(__buf.end()));
}

template <class _Tp, class _Allocator>
template <class _BiIter>
typename deque<_Tp, _Allocator>::iterator deque<_Tp, _Allocator>::insert(
    const_iterator __p, _BiIter __f, _BiIter __l,
    typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type *) {
  size_type __n = std::__1::distance(__f, __l);
  size_type __pos = __p - __base::begin();
  size_type __to_end = __base::size() - __pos;
  allocator_type &__a = __base::__alloc();
  if (__pos < __to_end) {
    if (__n > __front_spare())
      __add_front_capacity(__n - __front_spare());

    iterator __old_begin = __base::begin();
    iterator __i = __old_begin;
    _BiIter __m = __f;
    if (__n > __pos) {
      __m = __pos < __n / 2 ? std::__1::prev(__l, __pos)
                            : std::__1::next(__f, __n - __pos);
      for (_BiIter __j = __m; __j != __f; --__base::__start_, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*--__i), *--__j);
      __n = __pos;
    }
    if (__n > 0) {
      iterator __obn = __old_begin + __n;
      for (iterator __j = __obn; __j != __old_begin;) {
        __alloc_traits::construct(__a, std::__1::addressof(*--__i),
                                  std::__1::move(*--__j));
        --__base::__start_;
        ++__base::size();
      }
      if (__n < __pos)
        __old_begin = std::__1::move(__obn, __old_begin + __pos, __old_begin);
      std::__1::copy(__m, __l, __old_begin);
    }
  } else {
    size_type __back_capacity = __back_spare();
    if (__n > __back_capacity)
      __add_back_capacity(__n - __back_capacity);

    iterator __old_end = __base::end();
    iterator __i = __old_end;
    _BiIter __m = __l;
    size_type __de = __base::size() - __pos;
    if (__n > __de) {
      __m = __de < __n / 2 ? std::__1::next(__f, __de)
                           : std::__1::prev(__l, __n - __de);
      for (_BiIter __j = __m; __j != __l; ++__i, (void)++__j, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*__i), *__j);
      __n = __de;
    }
    if (__n > 0) {
      iterator __oen = __old_end - __n;
      for (iterator __j = __oen; __j != __old_end;
           ++__i, ++__j, ++__base::size())
        __alloc_traits::construct(__a, std::__1::addressof(*__i),
                                  std::__1::move(*__j));
      if (__n < __de)
        __old_end = std::__1::move_backward(__old_end - __de, __oen, __old_end);
      std::__1::copy_backward(__f, __m, __old_end);
    }
  }
  return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
template <class _InpIter>
void deque<_Tp, _Allocator>::__append(
    _InpIter __f, _InpIter __l,
    typename enable_if<__is_input_iterator<_InpIter>::value &&
                       !__is_forward_iterator<_InpIter>::value>::type *) {
  for (; __f != __l; ++__f)
    push_back(*__f);
}

template <class _Tp, class _Allocator>
template <class _ForIter>
void deque<_Tp, _Allocator>::__append(
    _ForIter __f, _ForIter __l,
    typename enable_if<__is_forward_iterator<_ForIter>::value>::type *) {
  size_type __n = std::__1::distance(__f, __l);
  allocator_type &__a = __base::__alloc();
  size_type __back_capacity = __back_spare();
  if (__n > __back_capacity)
    __add_back_capacity(__n - __back_capacity);

  for (iterator __i = __base::end(); __f != __l;
       ++__i, (void)++__f, ++__base::size())
    __alloc_traits::construct(__a, std::__1::addressof(*__i), *__f);
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__append(size_type __n) {
  allocator_type &__a = __base::__alloc();
  size_type __back_capacity = __back_spare();
  if (__n > __back_capacity)
    __add_back_capacity(__n - __back_capacity);

  for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())
    __alloc_traits::construct(__a, std::__1::addressof(*__i));
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__append(size_type __n, const value_type &__v) {
  allocator_type &__a = __base::__alloc();
  size_type __back_capacity = __back_spare();
  if (__n > __back_capacity)
    __add_back_capacity(__n - __back_capacity);

  for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())
    __alloc_traits::construct(__a, std::__1::addressof(*__i), __v);
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_front_capacity() {
  allocator_type &__a = __base::__alloc();
  if (__back_spare() >= __base::__block_size) {
    __base::__start_ += __base::__block_size;
    pointer __pt = __base::__map_.back();
    __base::__map_.pop_back();
    __base::__map_.push_front(__pt);
  }


  else if (__base::__map_.size() <
           __base::__map_.capacity()) {



    if (__base::__map_.__front_spare() > 0)
      __base::__map_.push_front(
          __alloc_traits::allocate(__a, __base::__block_size));
    else {
      __base::__map_.push_back(
          __alloc_traits::allocate(__a, __base::__block_size));

      pointer __pt = __base::__map_.back();
      __base::__map_.pop_back();
      __base::__map_.push_front(__pt);
    }
    __base::__start_ = __base::__map_.size() == 1
                           ? __base::__block_size / 2
                           : __base::__start_ + __base::__block_size;
  }

  else {
    __split_buffer<pointer, typename __base::__pointer_allocator &> __buf(
        max<size_type>(2 * __base::__map_.capacity(), 1), 0,
        __base::__map_.__alloc());

    typedef __allocator_destructor<_Allocator> _Dp;
    unique_ptr<pointer, _Dp> __hold(
        __alloc_traits::allocate(__a, __base::__block_size),
        _Dp(__a, __base::__block_size));
    __buf.push_back(__hold.get());
    __hold.release();

    for (typename __base::__map_pointer __i = __base::__map_.begin();
         __i != __base::__map_.end(); ++__i)
      __buf.push_back(*__i);
    std::__1::swap(__base::__map_.__first_, __buf.__first_);
    std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
    std::__1::swap(__base::__map_.__end_, __buf.__end_);
    std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
    __base::__start_ = __base::__map_.size() == 1
                           ? __base::__block_size / 2
                           : __base::__start_ + __base::__block_size;
  }
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_front_capacity(size_type __n) {
  allocator_type &__a = __base::__alloc();
  size_type __nb = __recommend_blocks(__n + __base::__map_.empty());

  size_type __back_capacity = __back_spare() / __base::__block_size;
  __back_capacity =
      std::__1::min(__back_capacity, __nb);
  __nb -= __back_capacity;

  if (__nb == 0) {
    __base::__start_ += __base::__block_size * __back_capacity;
    for (; __back_capacity > 0; --__back_capacity) {
      pointer __pt = __base::__map_.back();
      __base::__map_.pop_back();
      __base::__map_.push_front(__pt);
    }
  }


  else if (__nb <= __base::__map_.capacity() -
                       __base::__map_.size()) {




    for (; __nb > 0; --__nb, __base::__start_ += __base::__block_size -
                                                 (__base::__map_.size() == 1)) {
      if (__base::__map_.__front_spare() == 0)
        break;
      __base::__map_.push_front(
          __alloc_traits::allocate(__a, __base::__block_size));
    }
    for (; __nb > 0; --__nb, ++__back_capacity)
      __base::__map_.push_back(
          __alloc_traits::allocate(__a, __base::__block_size));

    __base::__start_ += __back_capacity * __base::__block_size;
    for (; __back_capacity > 0; --__back_capacity) {
      pointer __pt = __base::__map_.back();
      __base::__map_.pop_back();
      __base::__map_.push_front(__pt);
    }
  }

  else {
    size_type __ds = (__nb + __back_capacity) * __base::__block_size -
                     __base::__map_.empty();
    __split_buffer<pointer, typename __base::__pointer_allocator &> __buf(
        max<size_type>(2 * __base::__map_.capacity(),
                       __nb + __base::__map_.size()),
        0, __base::__map_.__alloc());

    try {

      for (; __nb > 0; --__nb)
        __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));

    } catch (...) {
      for (typename __base::__map_pointer __i = __buf.begin();
           __i != __buf.end(); ++__i)
        __alloc_traits::deallocate(__a, *__i, __base::__block_size);
      throw;
    }

    for (; __back_capacity > 0; --__back_capacity) {
      __buf.push_back(__base::__map_.back());
      __base::__map_.pop_back();
    }
    for (typename __base::__map_pointer __i = __base::__map_.begin();
         __i != __base::__map_.end(); ++__i)
      __buf.push_back(*__i);
    std::__1::swap(__base::__map_.__first_, __buf.__first_);
    std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
    std::__1::swap(__base::__map_.__end_, __buf.__end_);
    std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
    __base::__start_ += __ds;
  }
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_back_capacity() {
  allocator_type &__a = __base::__alloc();
  if (__front_spare() >= __base::__block_size) {
    __base::__start_ -= __base::__block_size;
    pointer __pt = __base::__map_.front();
    __base::__map_.pop_front();
    __base::__map_.push_back(__pt);
  }


  else if (__base::__map_.size() <
           __base::__map_.capacity()) {



    if (__base::__map_.__back_spare() != 0)
      __base::__map_.push_back(
          __alloc_traits::allocate(__a, __base::__block_size));
    else {
      __base::__map_.push_front(
          __alloc_traits::allocate(__a, __base::__block_size));

      pointer __pt = __base::__map_.front();
      __base::__map_.pop_front();
      __base::__map_.push_back(__pt);
    }
  }

  else {
    __split_buffer<pointer, typename __base::__pointer_allocator &> __buf(
        max<size_type>(2 * __base::__map_.capacity(), 1), __base::__map_.size(),
        __base::__map_.__alloc());

    typedef __allocator_destructor<_Allocator> _Dp;
    unique_ptr<pointer, _Dp> __hold(
        __alloc_traits::allocate(__a, __base::__block_size),
        _Dp(__a, __base::__block_size));
    __buf.push_back(__hold.get());
    __hold.release();

    for (typename __base::__map_pointer __i = __base::__map_.end();
         __i != __base::__map_.begin();)
      __buf.push_front(*--__i);
    std::__1::swap(__base::__map_.__first_, __buf.__first_);
    std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
    std::__1::swap(__base::__map_.__end_, __buf.__end_);
    std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
  }
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__add_back_capacity(size_type __n) {
  allocator_type &__a = __base::__alloc();
  size_type __nb = __recommend_blocks(__n + __base::__map_.empty());

  size_type __front_capacity = __front_spare() / __base::__block_size;
  __front_capacity =
      std::__1::min(__front_capacity, __nb);
  __nb -= __front_capacity;

  if (__nb == 0) {
    __base::__start_ -= __base::__block_size * __front_capacity;
    for (; __front_capacity > 0; --__front_capacity) {
      pointer __pt = __base::__map_.front();
      __base::__map_.pop_front();
      __base::__map_.push_back(__pt);
    }
  }


  else if (__nb <= __base::__map_.capacity() -
                       __base::__map_.size()) {




    for (; __nb > 0; --__nb) {
      if (__base::__map_.__back_spare() == 0)
        break;
      __base::__map_.push_back(
          __alloc_traits::allocate(__a, __base::__block_size));
    }
    for (; __nb > 0; --__nb, ++__front_capacity,
                     __base::__start_ +=
                     __base::__block_size - (__base::__map_.size() == 1))
      __base::__map_.push_front(
          __alloc_traits::allocate(__a, __base::__block_size));

    __base::__start_ -= __base::__block_size * __front_capacity;
    for (; __front_capacity > 0; --__front_capacity) {
      pointer __pt = __base::__map_.front();
      __base::__map_.pop_front();
      __base::__map_.push_back(__pt);
    }
  }

  else {
    size_type __ds = __front_capacity * __base::__block_size;
    __split_buffer<pointer, typename __base::__pointer_allocator &> __buf(
        max<size_type>(2 * __base::__map_.capacity(),
                       __nb + __base::__map_.size()),
        __base::__map_.size() - __front_capacity, __base::__map_.__alloc());

    try {

      for (; __nb > 0; --__nb)
        __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));

    } catch (...) {
      for (typename __base::__map_pointer __i = __buf.begin();
           __i != __buf.end(); ++__i)
        __alloc_traits::deallocate(__a, *__i, __base::__block_size);
      throw;
    }

    for (; __front_capacity > 0; --__front_capacity) {
      __buf.push_back(__base::__map_.front());
      __base::__map_.pop_front();
    }
    for (typename __base::__map_pointer __i = __base::__map_.end();
         __i != __base::__map_.begin();)
      __buf.push_front(*--__i);
    std::__1::swap(__base::__map_.__first_, __buf.__first_);
    std::__1::swap(__base::__map_.__begin_, __buf.__begin_);
    std::__1::swap(__base::__map_.__end_, __buf.__end_);
    std::__1::swap(__base::__map_.__end_cap(), __buf.__end_cap());
    __base::__start_ -= __ds;
  }
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::pop_front() {
  allocator_type &__a = __base::__alloc();
  __alloc_traits::destroy(
      __a, __to_raw_pointer(*(__base::__map_.begin() +
                              __base::__start_ / __base::__block_size) +
                            __base::__start_ % __base::__block_size));
  --__base::size();
  if (++__base::__start_ >= 2 * __base::__block_size) {
    __alloc_traits::deallocate(__a, __base::__map_.front(),
                               __base::__block_size);
    __base::__map_.pop_front();
    __base::__start_ -= __base::__block_size;
  }
}

template <class _Tp, class _Allocator> void deque<_Tp, _Allocator>::pop_back() {
  allocator_type &__a = __base::__alloc();
  size_type __p = __base::size() + __base::__start_ - 1;
  __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +
                                                  __p / __base::__block_size) +
                                                __p % __base::__block_size));
  --__base::size();
  if (__back_spare() >= 2 * __base::__block_size) {
    __alloc_traits::deallocate(__a, __base::__map_.back(),
                               __base::__block_size);
    __base::__map_.pop_back();
  }
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_and_check(iterator __f, iterator __l,
                                         iterator __r, const_pointer &__vt) {



  difference_type __n = __l - __f;
  while (__n > 0) {
    pointer __fb = __f.__ptr_;
    pointer __fe = *__f.__m_iter_ + __base::__block_size;
    difference_type __bs = __fe - __fb;
    if (__bs > __n) {
      __bs = __n;
      __fe = __fb + __bs;
    }
    if (__fb <= __vt && __vt < __fe)
      __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_),
                             __vt) -= __f - __r)
                 .__ptr_;
    __r = std::__1::move(__fb, __fe, __r);
    __n -= __bs;
    __f += __bs;
  }
  return __r;
}



template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::__move_backward_and_check(iterator __f, iterator __l,
                                                  iterator __r,
                                                  const_pointer &__vt) {



  difference_type __n = __l - __f;
  while (__n > 0) {
    --__l;
    pointer __lb = *__l.__m_iter_;
    pointer __le = __l.__ptr_ + 1;
    difference_type __bs = __le - __lb;
    if (__bs > __n) {
      __bs = __n;
      __lb = __le - __bs;
    }
    if (__lb <= __vt && __vt < __le)
      __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_),
                             __vt) +=
              __r - __l -
              1).__ptr_;
    __r = std::__1::move_backward(__lb, __le, __r);
    __n -= __bs;
    __l -= __bs - 1;
  }
  return __r;
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__move_construct_and_check(iterator __f,
                                                        iterator __l,
                                                        iterator __r,
                                                        const_pointer &__vt) {
  allocator_type &__a = __base::__alloc();




  difference_type __n = __l - __f;
  while (__n > 0) {
    pointer __fb = __f.__ptr_;
    pointer __fe = *__f.__m_iter_ + __base::__block_size;
    difference_type __bs = __fe - __fb;
    if (__bs > __n) {
      __bs = __n;
      __fe = __fb + __bs;
    }
    if (__fb <= __vt && __vt < __fe)
      __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_),
                             __vt) += __r - __f)
                 .__ptr_;
    for (; __fb != __fe; ++__fb, ++__r, ++__base::size())
      __alloc_traits::construct(__a, std::__1::addressof(*__r),
                                std::__1::move(*__fb));
    __n -= __bs;
    __f += __bs;
  }
}



template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__move_construct_backward_and_check(
    iterator __f, iterator __l, iterator __r, const_pointer &__vt) {
  allocator_type &__a = __base::__alloc();
  difference_type __n = __l - __f;
  while (__n > 0) {
    --__l;
    pointer __lb = *__l.__m_iter_;
    pointer __le = __l.__ptr_ + 1;
    difference_type __bs = __le - __lb;
    if (__bs > __n) {
      __bs = __n;
      __lb = __le - __bs;
    }
    if (__lb <= __vt && __vt < __le)
      __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_),
                             __vt) -=
              __l - __r +
              1).__ptr_;
    while (__le != __lb) {
      __alloc_traits::construct(__a, std::__1::addressof(*--__r),
                                std::__1::move(*--__le));
      --__base::__start_;
      ++__base::size();
    }
    __n -= __bs;
    __l -= __bs - 1;
  }
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f) {
  iterator __b = __base::begin();
  difference_type __pos = __f - __b;
  iterator __p = __b + __pos;
  allocator_type &__a = __base::__alloc();
  if (__pos <= (__base::size() - 1) / 2) {
    std::__1::move_backward(__b, __p, std::__1::next(__p));
    __alloc_traits::destroy(__a, std::__1::addressof(*__b));
    --__base::size();
    ++__base::__start_;
    if (__front_spare() >= 2 * __base::__block_size) {
      __alloc_traits::deallocate(__a, __base::__map_.front(),
                                 __base::__block_size);
      __base::__map_.pop_front();
      __base::__start_ -= __base::__block_size;
    }
  } else {
    iterator __i = std::__1::move(std::__1::next(__p), __base::end(), __p);
    __alloc_traits::destroy(__a, std::__1::addressof(*__i));
    --__base::size();
    if (__back_spare() >= 2 * __base::__block_size) {
      __alloc_traits::deallocate(__a, __base::__map_.back(),
                                 __base::__block_size);
      __base::__map_.pop_back();
    }
  }
  return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
typename deque<_Tp, _Allocator>::iterator
deque<_Tp, _Allocator>::erase(const_iterator __f, const_iterator __l) {
  difference_type __n = __l - __f;
  iterator __b = __base::begin();
  difference_type __pos = __f - __b;
  iterator __p = __b + __pos;
  if (__n > 0) {
    allocator_type &__a = __base::__alloc();
    if (__pos <= (__base::size() - __n) / 2) {
      iterator __i = std::__1::move_backward(__b, __p, __p + __n);
      for (; __b != __i; ++__b)
        __alloc_traits::destroy(__a, std::__1::addressof(*__b));
      __base::size() -= __n;
      __base::__start_ += __n;
      while (__front_spare() >= 2 * __base::__block_size) {
        __alloc_traits::deallocate(__a, __base::__map_.front(),
                                   __base::__block_size);
        __base::__map_.pop_front();
        __base::__start_ -= __base::__block_size;
      }
    } else {
      iterator __i = std::__1::move(__p + __n, __base::end(), __p);
      for (iterator __e = __base::end(); __i != __e; ++__i)
        __alloc_traits::destroy(__a, std::__1::addressof(*__i));
      __base::size() -= __n;
      while (__back_spare() >= 2 * __base::__block_size) {
        __alloc_traits::deallocate(__a, __base::__map_.back(),
                                   __base::__block_size);
        __base::__map_.pop_back();
      }
    }
  }
  return __base::begin() + __pos;
}

template <class _Tp, class _Allocator>
void deque<_Tp, _Allocator>::__erase_to_end(const_iterator __f) {
  iterator __e = __base::end();
  difference_type __n = __e - __f;
  if (__n > 0) {
    allocator_type &__a = __base::__alloc();
    iterator __b = __base::begin();
    difference_type __pos = __f - __b;
    for (iterator __p = __b + __pos; __p != __e; ++__p)
      __alloc_traits::destroy(__a, std::__1::addressof(*__p));
    __base::size() -= __n;
    while (__back_spare() >= 2 * __base::__block_size) {
      __alloc_traits::deallocate(__a, __base::__map_.back(),
                                 __base::__block_size);
      __base::__map_.pop_back();
    }
  }
}

template <class _Tp, class _Allocator>
inline void deque<_Tp, _Allocator>::swap(deque &__c)



    noexcept(!__alloc_traits::propagate_on_container_swap::value || __is_nothrow_swappable<allocator_type>::value)


{
  __base::swap(__c);
}

template <class _Tp, class _Allocator>
inline void deque<_Tp, _Allocator>::clear() noexcept {
  __base::clear();
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const deque<_Tp, _Allocator> &__x,
           const deque<_Tp, _Allocator> &__y) {
  const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();
  return __sz == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const deque<_Tp, _Allocator> &__x,
           const deque<_Tp, _Allocator> &__y) {
  return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const deque<_Tp, _Allocator> &__x,
          const deque<_Tp, _Allocator> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                        __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const deque<_Tp, _Allocator> &__x,
          const deque<_Tp, _Allocator> &__y) {
  return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const deque<_Tp, _Allocator> &__x,
           const deque<_Tp, _Allocator> &__y) {
  return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const deque<_Tp, _Allocator> &__x,
           const deque<_Tp, _Allocator> &__y) {
  return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(deque<_Tp, _Allocator> &__x,
                                           deque<_Tp, _Allocator> &__y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

} }


namespace std { inline namespace __1 {

template <class _Tp, class _Container = deque<_Tp>>
class __attribute__((__visibility__("default"))) queue;

template <class _Tp, class _Container>
__attribute__((__visibility__("hidden"), __always_inline__)) bool operator==(const queue<_Tp, _Container> &__x,
                                          const queue<_Tp, _Container> &__y);

template <class _Tp, class _Container>
__attribute__((__visibility__("hidden"), __always_inline__)) bool operator<(const queue<_Tp, _Container> &__x,
                                         const queue<_Tp, _Container> &__y);

template <class _Tp, class _Container >
class __attribute__((__visibility__("default"))) queue {
public:
  typedef _Container container_type;
  typedef typename container_type::value_type value_type;
  typedef typename container_type::reference reference;
  typedef typename container_type::const_reference const_reference;
  typedef typename container_type::size_type size_type;
  static_assert((is_same<_Tp, value_type>::value), "");

protected:
  container_type c;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  queue() noexcept(is_nothrow_default_constructible<container_type>::value)
      : c() {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  queue(const queue &__q) : c(__q.c) {}


  __attribute__((__visibility__("hidden"), __always_inline__))
  queue(queue &&__q)
      noexcept(is_nothrow_move_constructible<container_type>::value)
      : c(std::__1::move(__q.c)) {}


  __attribute__((__visibility__("hidden"), __always_inline__))
  queue &operator=(const queue &__q) {
    c = __q.c;
    return *this;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  queue &operator=(queue &&__q)
      noexcept(is_nothrow_move_assignable<container_type>::value) {
    c = std::__1::move(__q.c);
    return *this;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit queue(const container_type &__c) : c(__c) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit queue(container_type &&__c) : c(std::__1::move(__c)) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit queue(
      const _Alloc &__a,
      typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
          * = 0)
      : c(__a) {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__))
  queue(const queue &__q, const _Alloc &__a,
        typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
            * = 0)
      : c(__q.c, __a) {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__))
  queue(const container_type &__c, const _Alloc &__a,
        typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
            * = 0)
      : c(__c, __a) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__))
  queue(container_type &&__c, const _Alloc &__a,
        typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
            * = 0)
      : c(std::__1::move(__c), __a) {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__))
  queue(queue &&__q, const _Alloc &__a,
        typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
            * = 0)
      : c(std::__1::move(__q.c), __a) {}



  __attribute__((__visibility__("hidden"), __always_inline__))
  bool empty() const { return c.empty(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type size() const { return c.size(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  reference front() { return c.front(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reference front() const { return c.front(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  reference back() { return c.back(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reference back() const { return c.back(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void push(const value_type &__v) { c.push_back(__v); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void push(value_type &&__v) { c.push_back(std::__1::move(__v)); }

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) reference emplace(_Args &&... __args) {
    return c.emplace_back(std::__1::forward<_Args>(__args)...);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  void pop() { c.pop_front(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(queue &__q)
      noexcept(__is_nothrow_swappable<container_type>::value) {
    using std::__1::swap;
    swap(c, __q.c);
  }

  template <class _T1, class _C1>
  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool operator==(const queue<_T1, _C1> &__x,
                                                   const queue<_T1, _C1> &__y);

  template <class _T1, class _C1>
  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool operator<(const queue<_T1, _C1> &__x,
                                                  const queue<_T1, _C1> &__y);
};

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const queue<_Tp, _Container> &__x,
           const queue<_Tp, _Container> &__y) {
  return __x.c == __y.c;
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const queue<_Tp, _Container> &__x,
          const queue<_Tp, _Container> &__y) {
  return __x.c < __y.c;
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const queue<_Tp, _Container> &__x,
           const queue<_Tp, _Container> &__y) {
  return !(__x == __y);
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const queue<_Tp, _Container> &__x,
          const queue<_Tp, _Container> &__y) {
  return __y < __x;
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const queue<_Tp, _Container> &__x,
           const queue<_Tp, _Container> &__y) {
  return !(__x < __y);
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const queue<_Tp, _Container> &__x,
           const queue<_Tp, _Container> &__y) {
  return !(__y < __x);
}

template <class _Tp, class _Container>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_swappable<_Container>::value, void>::type
    swap(queue<_Tp, _Container> &__x, queue<_Tp, _Container> &__y)
        noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

template <class _Tp, class _Container, class _Alloc>
struct __attribute__((__visibility__("default"))) uses_allocator<queue<_Tp, _Container>, _Alloc>
    : public uses_allocator<_Container, _Alloc> {};

template <class _Tp, class _Container = vector<_Tp>,
          class _Compare = less<typename _Container::value_type>>
class __attribute__((__visibility__("default"))) priority_queue {
public:
  typedef _Container container_type;
  typedef _Compare value_compare;
  typedef typename container_type::value_type value_type;
  typedef typename container_type::reference reference;
  typedef typename container_type::const_reference const_reference;
  typedef typename container_type::size_type size_type;
  static_assert((is_same<_Tp, value_type>::value), "");

protected:
  container_type c;
  value_compare comp;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  priority_queue()
      noexcept(is_nothrow_default_constructible<container_type>::value &&is_nothrow_default_constructible<value_compare>::value)

      : c(), comp() {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  priority_queue(const priority_queue &__q) : c(__q.c), comp(__q.comp) {}


  __attribute__((__visibility__("hidden"), __always_inline__))
  priority_queue(priority_queue &&__q)
      noexcept(is_nothrow_move_constructible<container_type>::value &&is_nothrow_move_constructible<value_compare>::value)

      : c(std::__1::move(__q.c)), comp(std::__1::move(__q.comp)) {}


  __attribute__((__visibility__("hidden"), __always_inline__))
  priority_queue &operator=(const priority_queue &__q) {
    c = __q.c;
    comp = __q.comp;
    return *this;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  priority_queue &operator=(priority_queue &&__q)
      noexcept(is_nothrow_move_assignable<container_type>::value &&is_nothrow_move_assignable<value_compare>::value) {

    c = std::__1::move(__q.c);
    comp = std::__1::move(__q.comp);
    return *this;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit priority_queue(const value_compare &__comp) : c(), comp(__comp) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  priority_queue(const value_compare &__comp, const container_type &__c);

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit priority_queue(const value_compare &__comp, container_type &&__c);

  template <class _InputIter>
  __attribute__((__visibility__("hidden"), __always_inline__))
  priority_queue(_InputIter __f, _InputIter __l,
                 const value_compare &__comp = value_compare());
  template <class _InputIter>
  __attribute__((__visibility__("hidden"), __always_inline__)) priority_queue(_InputIter __f, _InputIter __l,
                                           const value_compare &__comp,
                                           const container_type &__c);

  template <class _InputIter>
  __attribute__((__visibility__("hidden"), __always_inline__)) priority_queue(_InputIter __f, _InputIter __l,
                                           const value_compare &__comp,
                                           container_type &&__c);

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) explicit priority_queue(
      const _Alloc &__a,
      typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
          * = 0);
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) priority_queue(
      const value_compare &__comp, const _Alloc &__a,
      typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
          * = 0);
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) priority_queue(
      const value_compare &__comp, const container_type &__c, const _Alloc &__a,
      typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
          * = 0);
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) priority_queue(
      const priority_queue &__q, const _Alloc &__a,
      typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
          * = 0);

  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) priority_queue(
      const value_compare &__comp, container_type &&__c, const _Alloc &__a,
      typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
          * = 0);
  template <class _Alloc>
  __attribute__((__visibility__("hidden"), __always_inline__)) priority_queue(
      priority_queue &&__q, const _Alloc &__a,
      typename enable_if<uses_allocator<container_type, _Alloc>::value>::type
          * = 0);


  __attribute__((__visibility__("hidden"), __always_inline__))
  bool empty() const { return c.empty(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type size() const { return c.size(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reference top() const { return c.front(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void push(const value_type &__v);

  __attribute__((__visibility__("hidden"), __always_inline__))
  void push(value_type &&__v);

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) void emplace(_Args &&... __args);


  __attribute__((__visibility__("hidden"), __always_inline__))
  void pop();

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(priority_queue &__q)
      noexcept(__is_nothrow_swappable<container_type>::value &&__is_nothrow_swappable<value_compare>::value);

};

template <class _Tp, class _Container, class _Compare>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const _Compare &__comp, const container_type &__c)
    : c(__c), comp(__comp) {
  std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const value_compare &__comp, container_type &&__c)
    : c(std::__1::move(__c)), comp(__comp) {
  std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
template <class _InputIter>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    _InputIter __f, _InputIter __l, const value_compare &__comp)
    : c(__f, __l), comp(__comp) {
  std::__1::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _InputIter>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    _InputIter __f, _InputIter __l, const value_compare &__comp,
    const container_type &__c)
    : c(__c), comp(__comp) {
  c.insert(c.end(), __f, __l);
  std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
template <class _InputIter>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    _InputIter __f, _InputIter __l, const value_compare &__comp,
    container_type &&__c)
    : c(std::__1::move(__c)), comp(__comp) {
  c.insert(c.end(), __f, __l);
  std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const _Alloc &__a,
    typename enable_if<uses_allocator<container_type, _Alloc>::value>::type *)
    : c(__a) {}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const value_compare &__comp, const _Alloc &__a,
    typename enable_if<uses_allocator<container_type, _Alloc>::value>::type *)
    : c(__a), comp(__comp) {}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const value_compare &__comp, const container_type &__c, const _Alloc &__a,
    typename enable_if<uses_allocator<container_type, _Alloc>::value>::type *)
    : c(__c, __a), comp(__comp) {
  std::__1::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const priority_queue &__q, const _Alloc &__a,
    typename enable_if<uses_allocator<container_type, _Alloc>::value>::type *)
    : c(__q.c, __a), comp(__q.comp) {
  std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    const value_compare &__comp, container_type &&__c, const _Alloc &__a,
    typename enable_if<uses_allocator<container_type, _Alloc>::value>::type *)
    : c(std::__1::move(__c), __a), comp(__comp) {
  std::__1::make_heap(c.begin(), c.end(), comp);
}

template <class _Tp, class _Container, class _Compare>
template <class _Alloc>
inline priority_queue<_Tp, _Container, _Compare>::priority_queue(
    priority_queue &&__q, const _Alloc &__a,
    typename enable_if<uses_allocator<container_type, _Alloc>::value>::type *)
    : c(std::__1::move(__q.c), __a), comp(std::__1::move(__q.comp)) {
  std::__1::make_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
inline void
priority_queue<_Tp, _Container, _Compare>::push(const value_type &__v) {
  c.push_back(__v);
  std::__1::push_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
inline void priority_queue<_Tp, _Container, _Compare>::push(value_type &&__v) {
  c.push_back(std::__1::move(__v));
  std::__1::push_heap(c.begin(), c.end(), comp);
}



template <class _Tp, class _Container, class _Compare>
template <class... _Args>
inline void
priority_queue<_Tp, _Container, _Compare>::emplace(_Args &&... __args) {
  c.emplace_back(std::__1::forward<_Args>(__args)...);
  std::__1::push_heap(c.begin(), c.end(), comp);
}




template <class _Tp, class _Container, class _Compare>
inline void priority_queue<_Tp, _Container, _Compare>::pop() {
  std::__1::pop_heap(c.begin(), c.end(), comp);
  c.pop_back();
}

template <class _Tp, class _Container, class _Compare>
inline void priority_queue<_Tp, _Container, _Compare>::swap(priority_queue &__q)
    noexcept(__is_nothrow_swappable<container_type>::value &&__is_nothrow_swappable<value_compare>::value) {

  using std::__1::swap;
  swap(c, __q.c);
  swap(comp, __q.comp);
}

template <class _Tp, class _Container, class _Compare>
inline __attribute__((__visibility__("hidden"), __always_inline__))
    typename enable_if<__is_swappable<_Container>::value &&
                           __is_swappable<_Compare>::value,
                       void>::type
    swap(priority_queue<_Tp, _Container, _Compare> &__x,
         priority_queue<_Tp, _Container, _Compare> &__y)
        noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

template <class _Tp, class _Container, class _Compare, class _Alloc>
struct __attribute__((__visibility__("default")))
    uses_allocator<priority_queue<_Tp, _Container, _Compare>, _Alloc>
    : public uses_allocator<_Container, _Alloc> {};

} }


namespace std { inline namespace __1 {

template <class _Tp, class _Compare, class _Allocator> class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__((__visibility__("default"))) __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
class __attribute__((__visibility__("default"))) __tree_const_iterator;

template <class _Pointer> class __tree_end_node;
template <class _VoidPtr> class __tree_node_base;
template <class _Tp, class _VoidPtr> class __tree_node;


template <class _Key, class _Value> union __value_type;




template <class _Allocator> class __map_node_destructor;
template <class _TreeIterator> class __attribute__((__visibility__("default"))) __map_iterator;
template <class _TreeIterator> class __attribute__((__visibility__("default"))) __map_const_iterator;
template <class _NodePtr>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
__tree_is_left_child(_NodePtr __x) noexcept {
  return __x == __x->__parent_->__left_;
}




template <class _NodePtr> unsigned __tree_sub_invariant(_NodePtr __x) {
  if (__x == nullptr)
    return 1;


  if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)
    return 0;

  if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)
    return 0;

  if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)
    return 0;

  if (!__x->__is_black_) {
    if (__x->__left_ && !__x->__left_->__is_black_)
      return 0;
    if (__x->__right_ && !__x->__right_->__is_black_)
      return 0;
  }
  unsigned __h = __tree_sub_invariant(__x->__left_);
  if (__h == 0)
    return 0;
  if (__h != __tree_sub_invariant(__x->__right_))
    return 0;
  return __h + __x->__is_black_;
}





template <class _NodePtr> bool __tree_invariant(_NodePtr __root) {
  if (__root == nullptr)
    return true;

  if (__root->__parent_ == nullptr)
    return false;
  if (!__tree_is_left_child(__root))
    return false;

  if (!__root->__is_black_)
    return false;

  return __tree_sub_invariant(__root) != 0;
}



template <class _NodePtr>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _NodePtr __tree_min(_NodePtr __x) noexcept {
  while (__x->__left_ != nullptr)
    __x = __x->__left_;
  return __x;
}



template <class _NodePtr>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _NodePtr __tree_max(_NodePtr __x) noexcept {
  while (__x->__right_ != nullptr)
    __x = __x->__right_;
  return __x;
}



template <class _NodePtr> _NodePtr __tree_next(_NodePtr __x) noexcept {
  if (__x->__right_ != nullptr)
    return __tree_min(__x->__right_);
  while (!__tree_is_left_child(__x))
    __x = __x->__parent_unsafe();
  return __x->__parent_unsafe();
}

template <class _EndNodePtr, class _NodePtr>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _EndNodePtr
__tree_next_iter(_NodePtr __x) noexcept {
  if (__x->__right_ != nullptr)
    return static_cast<_EndNodePtr>(__tree_min(__x->__right_));
  while (!__tree_is_left_child(__x))
    __x = __x->__parent_unsafe();
  return static_cast<_EndNodePtr>(__x->__parent_);
}




template <class _NodePtr, class _EndNodePtr>
inline __attribute__((__visibility__("hidden"), __always_inline__)) _NodePtr
__tree_prev_iter(_EndNodePtr __x) noexcept {
  if (__x->__left_ != nullptr)
    return __tree_max(__x->__left_);
  _NodePtr __xx = static_cast<_NodePtr>(__x);
  while (__tree_is_left_child(__xx))
    __xx = __xx->__parent_unsafe();
  return __xx->__parent_unsafe();
}



template <class _NodePtr> _NodePtr __tree_leaf(_NodePtr __x) noexcept {
  while (true) {
    if (__x->__left_ != nullptr) {
      __x = __x->__left_;
      continue;
    }
    if (__x->__right_ != nullptr) {
      __x = __x->__right_;
      continue;
    }
    break;
  }
  return __x;
}




template <class _NodePtr> void __tree_left_rotate(_NodePtr __x) noexcept {
  _NodePtr __y = __x->__right_;
  __x->__right_ = __y->__left_;
  if (__x->__right_ != nullptr)
    __x->__right_->__set_parent(__x);
  __y->__parent_ = __x->__parent_;
  if (__tree_is_left_child(__x))
    __x->__parent_->__left_ = __y;
  else
    __x->__parent_unsafe()->__right_ = __y;
  __y->__left_ = __x;
  __x->__set_parent(__y);
}




template <class _NodePtr> void __tree_right_rotate(_NodePtr __x) noexcept {
  _NodePtr __y = __x->__left_;
  __x->__left_ = __y->__right_;
  if (__x->__left_ != nullptr)
    __x->__left_->__set_parent(__x);
  __y->__parent_ = __x->__parent_;
  if (__tree_is_left_child(__x))
    __x->__parent_->__left_ = __y;
  else
    __x->__parent_unsafe()->__right_ = __y;
  __y->__right_ = __x;
  __x->__set_parent(__y);
}
template <class _NodePtr>
void __tree_balance_after_insert(_NodePtr __root, _NodePtr __x) noexcept {
  __x->__is_black_ = __x == __root;
  while (__x != __root && !__x->__parent_unsafe()->__is_black_) {

    if (__tree_is_left_child(__x->__parent_unsafe())) {
      _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
      if (__y != nullptr && !__y->__is_black_) {
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = __x == __root;
        __y->__is_black_ = true;
      } else {
        if (!__tree_is_left_child(__x)) {
          __x = __x->__parent_unsafe();
          __tree_left_rotate(__x);
        }
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = false;
        __tree_right_rotate(__x);
        break;
      }
    } else {
      _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
      if (__y != nullptr && !__y->__is_black_) {
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = __x == __root;
        __y->__is_black_ = true;
      } else {
        if (__tree_is_left_child(__x)) {
          __x = __x->__parent_unsafe();
          __tree_right_rotate(__x);
        }
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = false;
        __tree_left_rotate(__x);
        break;
      }
    }
  }
}
template <class _NodePtr>
void __tree_remove(_NodePtr __root, _NodePtr __z) noexcept {





  _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr)
                     ? __z
                     : __tree_next(__z);

  _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;

  _NodePtr __w = nullptr;

  if (__x != nullptr)
    __x->__parent_ = __y->__parent_;
  if (__tree_is_left_child(__y)) {
    __y->__parent_->__left_ = __x;
    if (__y != __root)
      __w = __y->__parent_unsafe()->__right_;
    else
      __root = __x;
  } else {
    __y->__parent_unsafe()->__right_ = __x;

    __w = __y->__parent_->__left_;
  }
  bool __removed_black = __y->__is_black_;


  if (__y != __z) {

    __y->__parent_ = __z->__parent_;
    if (__tree_is_left_child(__z))
      __y->__parent_->__left_ = __y;
    else
      __y->__parent_unsafe()->__right_ = __y;
    __y->__left_ = __z->__left_;
    __y->__left_->__set_parent(__y);
    __y->__right_ = __z->__right_;
    if (__y->__right_ != nullptr)
      __y->__right_->__set_parent(__y);
    __y->__is_black_ = __z->__is_black_;
    if (__root == __z)
      __root = __y;
  }


  if (__removed_black && __root != nullptr) {
    if (__x != nullptr)
      __x->__is_black_ = true;
    else {





      while (true) {
        if (!__tree_is_left_child(__w))
        {
          if (!__w->__is_black_) {
            __w->__is_black_ = true;
            __w->__parent_unsafe()->__is_black_ = false;
            __tree_left_rotate(__w->__parent_unsafe());


            if (__root == __w->__left_)
              __root = __w;

            __w = __w->__left_->__right_;
          }

          if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
              (__w->__right_ == nullptr || __w->__right_->__is_black_)) {
            __w->__is_black_ = false;
            __x = __w->__parent_unsafe();

            if (__x == __root || !__x->__is_black_) {
              __x->__is_black_ = true;
              break;
            }

            __w = __tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_
                                            : __x->__parent_->__left_;

          } else
          {
            if (__w->__right_ == nullptr || __w->__right_->__is_black_) {

              __w->__left_->__is_black_ = true;
              __w->__is_black_ = false;
              __tree_right_rotate(__w);


              __w = __w->__parent_unsafe();
            }

            __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
            __w->__parent_unsafe()->__is_black_ = true;
            __w->__right_->__is_black_ = true;
            __tree_left_rotate(__w->__parent_unsafe());
            break;
          }
        } else {
          if (!__w->__is_black_) {
            __w->__is_black_ = true;
            __w->__parent_unsafe()->__is_black_ = false;
            __tree_right_rotate(__w->__parent_unsafe());


            if (__root == __w->__right_)
              __root = __w;

            __w = __w->__right_->__left_;
          }

          if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
              (__w->__right_ == nullptr || __w->__right_->__is_black_)) {
            __w->__is_black_ = false;
            __x = __w->__parent_unsafe();

            if (!__x->__is_black_ || __x == __root) {
              __x->__is_black_ = true;
              break;
            }

            __w = __tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_
                                            : __x->__parent_->__left_;

          } else
          {
            if (__w->__left_ == nullptr || __w->__left_->__is_black_) {

              __w->__right_->__is_black_ = true;
              __w->__is_black_ = false;
              __tree_left_rotate(__w);


              __w = __w->__parent_unsafe();
            }

            __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
            __w->__parent_unsafe()->__is_black_ = true;
            __w->__left_->__is_black_ = true;
            __tree_right_rotate(__w->__parent_unsafe());
            break;
          }
        }
      }
    }
  }
}




template <class _Tp> struct __is_tree_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {};

template <class... _Args> struct __is_tree_value_type : false_type {};

template <class _One>
struct __is_tree_value_type<_One>
    : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};


template <class _Tp> struct __tree_key_value_types {
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__((__visibility__("hidden"), __always_inline__))
  static key_type const &__get_key(_Tp const &__v) { return __v; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  static __container_value_type const &
  __get_value(__node_value_type const &__v) {
    return __v;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  static __container_value_type *__get_ptr(__node_value_type &__n) {
    return std::__1::addressof(__n);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  static __container_value_type &&__move(__node_value_type &__v) {
    return std::__1::move(__v);
  }

};

template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp>> {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef pair<_Key, _Tp> __nc_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__((__visibility__("hidden"), __always_inline__))
  static key_type const &__get_key(__node_value_type const &__t) {
    return __t.__cc.first;
  }

  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) static
      typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
                         key_type const &>::type
      __get_key(_Up &__t) {
    return __t.first;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  static __container_value_type const &
  __get_value(__node_value_type const &__t) {
    return __t.__cc;
  }

  template <class _Up>
  __attribute__((__visibility__("hidden"), __always_inline__)) static
      typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
                         __container_value_type const &>::type
      __get_value(_Up &__t) {
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  static __container_value_type *__get_ptr(__node_value_type &__n) {
    return std::__1::addressof(__n.__cc);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  static __nc_value_type &&__move(__node_value_type &__v) {
    return std::__1::move(__v.__nc);
  }

};

template <class _VoidPtr> struct __tree_node_base_types {
  typedef _VoidPtr __void_pointer;

  typedef __tree_node_base<__void_pointer> __node_base_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type
      __node_base_pointer;

  typedef __tree_end_node<__node_base_pointer> __end_node_type;
  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type
      __end_node_pointer;



  typedef typename conditional<is_pointer<__end_node_pointer>::value,
                               __end_node_pointer,
                               __node_base_pointer>::type __parent_pointer;


private:
  static_assert(
      (is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
      "_VoidPtr does not point to unqualified void type");
};

template <class _Tp, class _AllocPtr,
          class _KVTypes = __tree_key_value_types<_Tp>,
          bool = _KVTypes::__is_map>
struct __tree_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef
      typename __rebind_pointer<_AllocPtr, _Mv>::type __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
      __const_map_value_type_pointer;
};

template <class _NodePtr,
          class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr>>
    : public __tree_node_base_types<_VoidPtr>,
      __tree_key_value_types<_Tp>,
      __tree_map_pointer_types<_Tp, _VoidPtr> {
  typedef __tree_node_base_types<_VoidPtr> __base;
  typedef __tree_key_value_types<_Tp> __key_base;
  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;

public:
  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
      __const_node_value_type_pointer;



  typedef typename conditional<is_pointer<__node_pointer>::value,
                               typename __base::__end_node_pointer,
                               __node_pointer>::type __iter_pointer;

private:
  static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
  static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                         _NodePtr>::value),
                "_VoidPtr does not rebind to _NodePtr.");
};

template <class _ValueTp, class _VoidPtr> struct __make_tree_node_types {
  typedef
      typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr>>::type
          _NodePtr;
  typedef __tree_node_types<_NodePtr> type;
};



template <class _Pointer> class __tree_end_node {
public:
  typedef _Pointer pointer;
  pointer __left_;

  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_end_node() noexcept : __left_() {}
};

template <class _VoidPtr>
class __tree_node_base
    : public __tree_node_base_types<_VoidPtr>::__end_node_type {
  typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;

public:
  typedef typename _NodeBaseTypes::__node_base_pointer pointer;
  typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;

  pointer __right_;
  __parent_pointer __parent_;
  bool __is_black_;

  __attribute__((__visibility__("hidden"), __always_inline__))
  pointer __parent_unsafe() const { return static_cast<pointer>(__parent_); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __set_parent(pointer __p) {
    __parent_ = static_cast<__parent_pointer>(__p);
  }

private:
  ~__tree_node_base() = delete;
  __tree_node_base(__tree_node_base const &) = delete;
  __tree_node_base &operator=(__tree_node_base const &) = delete;
};

template <class _Tp, class _VoidPtr>
class __tree_node : public __tree_node_base<_VoidPtr> {
public:
  typedef _Tp __node_value_type;

  __node_value_type __value_;

private:
  ~__tree_node() = delete;
  __tree_node(__tree_node const &) = delete;
  __tree_node &operator=(__tree_node const &) = delete;
};

template <class _Allocator> class __tree_node_destructor {
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;

private:
  typedef __tree_node_types<pointer> _NodeTypes;
  allocator_type &__na_;

  __tree_node_destructor &operator=(const __tree_node_destructor &);

public:
  bool __value_constructed;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __tree_node_destructor(allocator_type &__na,
                                  bool __val = false) noexcept
      : __na_(__na),
        __value_constructed(__val) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator()(pointer __p) noexcept {
    if (__value_constructed)
      __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
    if (__p)
      __alloc_traits::deallocate(__na_, __p, 1);
  }

  template <class> friend class __map_node_destructor;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__((__visibility__("default"))) __tree_iterator {
  typedef __tree_node_types<_NodePtr> _NodeTypes;
  typedef _NodePtr __node_pointer;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
  typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
  typedef typename _NodeTypes::__iter_pointer __iter_pointer;
  typedef pointer_traits<__node_pointer> __pointer_traits;

  __iter_pointer __ptr_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef _DiffType difference_type;
  typedef value_type &reference;
  typedef typename _NodeTypes::__node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"), __always_inline__)) __tree_iterator() noexcept



  {
  }

  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator*() const {
    return __get_np()->__value_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__get_np()->__value_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_iterator &operator++() {
    __ptr_ = static_cast<__iter_pointer>(__tree_next_iter<__end_node_pointer>(
        static_cast<__node_base_pointer>(__ptr_)));
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_iterator operator++(int) {
    __tree_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_iterator &operator--() {
    __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(
        static_cast<__end_node_pointer>(__ptr_)));
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_iterator operator--(int) {
    __tree_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool operator==(const __tree_iterator &__x,
                                                   const __tree_iterator &__y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool operator!=(const __tree_iterator &__x,
                                                   const __tree_iterator &__y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __tree_iterator(__node_pointer __p) noexcept : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __tree_iterator(__end_node_pointer __p) noexcept : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  __node_pointer __get_np() const {
    return static_cast<__node_pointer>(__ptr_);
  }
  template <class, class, class> friend class __tree;
  template <class, class, class>
  friend class __attribute__((__visibility__("default"))) __tree_const_iterator;
  template <class> friend class __attribute__((__visibility__("default"))) __map_iterator;
  template <class, class, class, class> friend class __attribute__((__visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__visibility__("default"))) multimap;
  template <class, class, class> friend class __attribute__((__visibility__("default"))) set;
  template <class, class, class> friend class __attribute__((__visibility__("default"))) multiset;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__((__visibility__("default"))) __tree_const_iterator {
  typedef __tree_node_types<_NodePtr> _NodeTypes;
  typedef typename _NodeTypes::__node_pointer __node_pointer;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
  typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
  typedef typename _NodeTypes::__iter_pointer __iter_pointer;
  typedef pointer_traits<__node_pointer> __pointer_traits;

  __iter_pointer __ptr_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef _DiffType difference_type;
  typedef const value_type &reference;
  typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"), __always_inline__)) __tree_const_iterator() noexcept



  {
  }

private:
  typedef __tree_iterator<value_type, __node_pointer, difference_type>
      __non_const_iterator;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_const_iterator(__non_const_iterator __p) noexcept
      : __ptr_(__p.__ptr_) {}

  __attribute__((__visibility__("hidden"), __always_inline__)) reference operator*() const {
    return __get_np()->__value_;
  }
  __attribute__((__visibility__("hidden"), __always_inline__)) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__get_np()->__value_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_const_iterator &operator++() {
    __ptr_ = static_cast<__iter_pointer>(__tree_next_iter<__end_node_pointer>(
        static_cast<__node_base_pointer>(__ptr_)));
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_const_iterator operator++(int) {
    __tree_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_const_iterator &operator--() {
    __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(
        static_cast<__end_node_pointer>(__ptr_)));
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __tree_const_iterator operator--(int) {
    __tree_const_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator==(const __tree_const_iterator &__x,
             const __tree_const_iterator &__y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator!=(const __tree_const_iterator &__x,
             const __tree_const_iterator &__y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __tree_const_iterator(__node_pointer __p) noexcept : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __tree_const_iterator(__end_node_pointer __p) noexcept
      : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  __node_pointer __get_np() const {
    return static_cast<__node_pointer>(__ptr_);
  }

  template <class, class, class> friend class __tree;
  template <class, class, class, class> friend class __attribute__((__visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__visibility__("default"))) multimap;
  template <class, class, class> friend class __attribute__((__visibility__("default"))) set;
  template <class, class, class> friend class __attribute__((__visibility__("default"))) multiset;
  template <class> friend class __attribute__((__visibility__("default"))) __map_const_iterator;
};

template <class _Tp, class _Compare, class _Allocator> class __tree {
public:
  typedef _Tp value_type;
  typedef _Compare value_compare;
  typedef _Allocator allocator_type;

private:
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __make_tree_node_types<
      value_type, typename __alloc_traits::void_pointer>::type _NodeTypes;
  typedef typename _NodeTypes::key_type key_type;

public:
  typedef typename _NodeTypes::__node_value_type __node_value_type;
  typedef typename _NodeTypes::__container_value_type __container_value_type;

  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;

public:
  typedef typename _NodeTypes::__void_pointer __void_pointer;

  typedef typename _NodeTypes::__node_type __node;
  typedef typename _NodeTypes::__node_pointer __node_pointer;

  typedef typename _NodeTypes::__node_base_type __node_base;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;

  typedef typename _NodeTypes::__end_node_type __end_node_t;
  typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;

  typedef typename _NodeTypes::__parent_pointer __parent_pointer;
  typedef typename _NodeTypes::__iter_pointer __iter_pointer;

  typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type
      __node_allocator;
  typedef allocator_traits<__node_allocator> __node_traits;

private:



  static_assert(
      (is_same<__node_pointer, typename __node_traits::pointer>::value),
      "Allocator does not rebind pointers in a sane manner.");
  typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type
      __node_base_allocator;
  typedef allocator_traits<__node_base_allocator> __node_base_traits;
  static_assert((is_same<__node_base_pointer,
                         typename __node_base_traits::pointer>::value),
                "Allocator does not rebind pointers in a sane manner.");

private:
  __iter_pointer __begin_node_;
  __compressed_pair<__end_node_t, __node_allocator> __pair1_;
  __compressed_pair<size_type, value_compare> __pair3_;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  __iter_pointer __end_node() noexcept {
    return static_cast<__iter_pointer>(
        pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first()));
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __iter_pointer __end_node() const noexcept {
    return static_cast<__iter_pointer>(
        pointer_traits<__end_node_ptr>::pointer_to(
            const_cast<__end_node_t &>(__pair1_.first())));
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __node_allocator &__node_alloc() noexcept { return __pair1_.second(); }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  const __node_allocator &__node_alloc() const noexcept {
    return __pair1_.second();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __iter_pointer &__begin_node() noexcept { return __begin_node_; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const __iter_pointer &__begin_node() const noexcept { return __begin_node_; }

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type __alloc() const noexcept {
    return allocator_type(__node_alloc());
  }

private:
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type &size() noexcept { return __pair3_.first(); }

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  const size_type &size() const noexcept { return __pair3_.first(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  value_compare &value_comp() noexcept { return __pair3_.second(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const value_compare &value_comp() const noexcept {
    return __pair3_.second();
  }

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  __node_pointer __root() const noexcept {
    return static_cast<__node_pointer>(__end_node()->__left_);
  }

  __node_base_pointer *__root_ptr() const noexcept {
    return std::__1::addressof(__end_node()->__left_);
  }

  typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
  typedef __tree_const_iterator<value_type, __node_pointer, difference_type>
      const_iterator;

  explicit __tree(const value_compare &__comp)
      noexcept(is_nothrow_default_constructible<__node_allocator>::value &&is_nothrow_copy_constructible<value_compare>::value);

  explicit __tree(const allocator_type &__a);
  __tree(const value_compare &__comp, const allocator_type &__a);
  __tree(const __tree &__t);
  __tree &operator=(const __tree &__t);
  template <class _InputIterator>
  void __assign_unique(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator>
  void __assign_multi(_InputIterator __first, _InputIterator __last);

  __tree(__tree &&__t)
      noexcept(is_nothrow_move_constructible<__node_allocator>::value &&is_nothrow_move_constructible<value_compare>::value);

  __tree(__tree &&__t, const allocator_type &__a);
  __tree &operator=(__tree &&__t)
      noexcept(__node_traits::propagate_on_container_move_assignment::value &&is_nothrow_move_assignable<value_compare>::value &&is_nothrow_move_assignable<__node_allocator>::value);




  ~__tree();

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator begin() noexcept { return iterator(__begin_node()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator begin() const noexcept {
    return const_iterator(__begin_node());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator end() noexcept { return iterator(__end_node()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator end() const noexcept { return const_iterator(__end_node()); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type max_size() const noexcept {
    return __node_traits::max_size(__node_alloc());
  }

  void clear() noexcept;

  void swap(__tree &__t)

      noexcept(__is_nothrow_swappable<value_compare>::value && (!__node_traits::propagate_on_container_swap::value || __is_nothrow_swappable<__node_allocator>::value));







  template <class _Key, class... _Args>
  pair<iterator, bool> __emplace_unique_key_args(_Key const &,
                                                 _Args &&... __args);
  template <class _Key, class... _Args>
  iterator __emplace_hint_unique_key_args(const_iterator, _Key const &,
                                          _Args &&...);

  template <class... _Args>
  pair<iterator, bool> __emplace_unique_impl(_Args &&... __args);

  template <class... _Args>
  iterator __emplace_hint_unique_impl(const_iterator __p, _Args &&... __args);

  template <class... _Args> iterator __emplace_multi(_Args &&... __args);

  template <class... _Args>
  iterator __emplace_hint_multi(const_iterator __p, _Args &&... __args);

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair<iterator, bool> __emplace_unique(_Pp &&__x) {
    return __emplace_unique_extract_key(std::__1::forward<_Pp>(__x),
                                        __can_extract_key<_Pp, key_type>());
  }

  template <class _First, class _Second>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<
      __can_extract_map_key<_First, key_type, __container_value_type>::value,
      pair<iterator, bool>>::type
  __emplace_unique(_First &&__f, _Second &&__s) {
    return __emplace_unique_key_args(__f, std::__1::forward<_First>(__f),
                                     std::__1::forward<_Second>(__s));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair<iterator, bool>
  __emplace_unique(_Args &&... __args) {
    return __emplace_unique_impl(std::__1::forward<_Args>(__args)...);
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair<iterator, bool>
  __emplace_unique_extract_key(_Pp &&__x, __extract_key_fail_tag) {
    return __emplace_unique_impl(std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair<iterator, bool>
  __emplace_unique_extract_key(_Pp &&__x, __extract_key_self_tag) {
    return __emplace_unique_key_args(__x, std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair<iterator, bool>
  __emplace_unique_extract_key(_Pp &&__x, __extract_key_first_tag) {
    return __emplace_unique_key_args(__x.first, std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __emplace_hint_unique(const_iterator __p,
                                                           _Pp &&__x) {
    return __emplace_hint_unique_extract_key(
        __p, std::__1::forward<_Pp>(__x), __can_extract_key<_Pp, key_type>());
  }

  template <class _First, class _Second>
  __attribute__((__visibility__("hidden"), __always_inline__)) typename enable_if<
      __can_extract_map_key<_First, key_type, __container_value_type>::value,
      iterator>::type
  __emplace_hint_unique(const_iterator __p, _First &&__f, _Second &&__s) {
    return __emplace_hint_unique_key_args(__p, __f, std::__1::forward<_First>(__f),
                                          std::__1::forward<_Second>(__s));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __emplace_hint_unique(const_iterator __p,
                                                           _Args &&... __args) {
    return __emplace_hint_unique_impl(__p, std::__1::forward<_Args>(__args)...);
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __emplace_hint_unique_extract_key(
      const_iterator __p, _Pp &&__x, __extract_key_fail_tag) {
    return __emplace_hint_unique_impl(__p, std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __emplace_hint_unique_extract_key(
      const_iterator __p, _Pp &&__x, __extract_key_self_tag) {
    return __emplace_hint_unique_key_args(__p, __x, std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __emplace_hint_unique_extract_key(
      const_iterator __p, _Pp &&__x, __extract_key_first_tag) {
    return __emplace_hint_unique_key_args(__p, __x.first,
                                          std::__1::forward<_Pp>(__x));
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, bool> __insert_unique(const __container_value_type &__v) {
    return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator __insert_unique(const_iterator __p,
                           const __container_value_type &__v) {
    return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, bool> __insert_unique(__container_value_type &&__v) {
    return __emplace_unique_key_args(_NodeTypes::__get_key(__v),
                                     std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator __insert_unique(const_iterator __p, __container_value_type &&__v) {
    return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v),
                                          std::__1::move(__v));
  }

  template <class _Vp, class = typename enable_if<
                           !is_same<typename __unconstref<_Vp>::type,
                                    __container_value_type>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair<iterator, bool> __insert_unique(_Vp &&__v) {
    return __emplace_unique(std::__1::forward<_Vp>(__v));
  }

  template <class _Vp, class = typename enable_if<
                           !is_same<typename __unconstref<_Vp>::type,
                                    __container_value_type>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __insert_unique(const_iterator __p,
                                                     _Vp &&__v) {
    return __emplace_hint_unique(__p, std::__1::forward<_Vp>(__v));
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator __insert_multi(__container_value_type &&__v) {
    return __emplace_multi(std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator __insert_multi(const_iterator __p, __container_value_type &&__v) {
    return __emplace_hint_multi(__p, std::__1::move(__v));
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __insert_multi(_Vp &&__v) {
    return __emplace_multi(std::__1::forward<_Vp>(__v));
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator __insert_multi(const_iterator __p,
                                                    _Vp &&__v) {
    return __emplace_hint_multi(__p, std::__1::forward<_Vp>(__v));
  }



  pair<iterator, bool> __node_insert_unique(__node_pointer __nd);
  iterator __node_insert_unique(const_iterator __p, __node_pointer __nd);

  iterator __node_insert_multi(__node_pointer __nd);
  iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);

  iterator erase(const_iterator __p);
  iterator erase(const_iterator __f, const_iterator __l);
  template <class _Key> size_type __erase_unique(const _Key &__k);
  template <class _Key> size_type __erase_multi(const _Key &__k);

  void __insert_node_at(__parent_pointer __parent, __node_base_pointer &__child,
                        __node_base_pointer __new_node);

  template <class _Key> iterator find(const _Key &__v);
  template <class _Key> const_iterator find(const _Key &__v) const;

  template <class _Key> size_type __count_unique(const _Key &__k) const;
  template <class _Key> size_type __count_multi(const _Key &__k) const;

  template <class _Key>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator lower_bound(const _Key &__v) {
    return __lower_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  iterator __lower_bound(const _Key &__v, __node_pointer __root,
                         __iter_pointer __result);
  template <class _Key>
  __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator lower_bound(const _Key &__v) const {
    return __lower_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  const_iterator __lower_bound(const _Key &__v, __node_pointer __root,
                               __iter_pointer __result) const;
  template <class _Key>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator upper_bound(const _Key &__v) {
    return __upper_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  iterator __upper_bound(const _Key &__v, __node_pointer __root,
                         __iter_pointer __result);
  template <class _Key>
  __attribute__((__visibility__("hidden"), __always_inline__)) const_iterator upper_bound(const _Key &__v) const {
    return __upper_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  const_iterator __upper_bound(const _Key &__v, __node_pointer __root,
                               __iter_pointer __result) const;
  template <class _Key>
  pair<iterator, iterator> __equal_range_unique(const _Key &__k);
  template <class _Key>
  pair<const_iterator, const_iterator>
  __equal_range_unique(const _Key &__k) const;

  template <class _Key>
  pair<iterator, iterator> __equal_range_multi(const _Key &__k);
  template <class _Key>
  pair<const_iterator, const_iterator>
  __equal_range_multi(const _Key &__k) const;

  typedef __tree_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;

  __node_holder remove(const_iterator __p) noexcept;

private:
  __node_base_pointer &__find_leaf_low(__parent_pointer &__parent,
                                       const key_type &__v);
  __node_base_pointer &__find_leaf_high(__parent_pointer &__parent,
                                        const key_type &__v);
  __node_base_pointer &__find_leaf(const_iterator __hint,
                                   __parent_pointer &__parent,
                                   const key_type &__v);
  template <class _Key>
  __node_base_pointer &__find_equal(__parent_pointer &__parent,
                                    const _Key &__v);
  template <class _Key>
  __node_base_pointer &
  __find_equal(const_iterator __hint, __parent_pointer &__parent,
               __node_base_pointer &__dummy, const _Key &__v);


  template <class... _Args> __node_holder __construct_node(_Args &&... __args);




  void destroy(__node_pointer __nd) noexcept;

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const __tree &__t) {
    __copy_assign_alloc(
        __t,
        integral_constant<
            bool,
            __node_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const __tree &__t, true_type) {
    if (__node_alloc() != __t.__node_alloc())
      clear();
    __node_alloc() = __t.__node_alloc();
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __copy_assign_alloc(const __tree &__t, false_type) {}

  void __move_assign(__tree &__t, false_type);
  void __move_assign(__tree &__t, true_type)
      noexcept(is_nothrow_move_assignable<value_compare>::value &&is_nothrow_move_assignable<__node_allocator>::value);


  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__tree &__t) noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value) {


    __move_assign_alloc(
        __t,
        integral_constant<
            bool,
            __node_traits::propagate_on_container_move_assignment::value>());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__tree &__t, true_type)
      noexcept(is_nothrow_move_assignable<__node_allocator>::value) {
    __node_alloc() = std::__1::move(__t.__node_alloc());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void __move_assign_alloc(__tree &__t, false_type) noexcept {}

  __node_pointer __detach();
  static __node_pointer __detach(__node_pointer);

  template <class, class, class, class> friend class __attribute__((__visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__visibility__("default"))) multimap;
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare &__comp)
    noexcept(is_nothrow_default_constructible<__node_allocator>::value &&is_nothrow_copy_constructible<value_compare>::value)

    : __pair3_(0, __comp) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type &__a)
    : __begin_node_(__iter_pointer()), __pair1_(__node_allocator(__a)),
      __pair3_(0) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare &__comp,
                                          const allocator_type &__a)
    : __begin_node_(__iter_pointer()), __pair1_(__node_allocator(__a)),
      __pair3_(0, __comp) {
  __begin_node() = __end_node();
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::__detach() {
  __node_pointer __cache = static_cast<__node_pointer>(__begin_node());
  __begin_node() = __end_node();
  __end_node()->__left_->__parent_ = nullptr;
  __end_node()->__left_ = nullptr;
  size() = 0;

  if (__cache->__right_ != nullptr)
    __cache = static_cast<__node_pointer>(__cache->__right_);


  return __cache;
}





template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache) {
  if (__cache->__parent_ == nullptr)
    return nullptr;
  if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache))) {
    __cache->__parent_->__left_ = nullptr;
    __cache = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__right_ == nullptr)
      return __cache;
    return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));
  }

  __cache->__parent_unsafe()->__right_ = nullptr;
  __cache = static_cast<__node_pointer>(__cache->__parent_);
  if (__cache->__left_ == nullptr)
    return __cache;
  return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator> &__tree<_Tp, _Compare, _Allocator>::
operator=(const __tree &__t) {
  if (this != &__t) {
    value_comp() = __t.value_comp();
    __copy_assign_alloc(__t);
    __assign_multi(__t.begin(), __t.end());
  }
  return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first,
                                                        _InputIterator __last) {
  typedef iterator_traits<_InputIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  static_assert(
      (is_same<_ItValueType, __container_value_type>::value),
      "__assign_unique may only be called with the containers value type");

  if (size() != 0) {
    __node_pointer __cache = __detach();

    try {

      for (; __cache != nullptr && __first != __last; ++__first) {
        __cache->__value_ = *__first;
        __node_pointer __next = __detach(__cache);
        __node_insert_unique(__cache);
        __cache = __next;
      }

    } catch (...) {
      while (__cache->__parent_ != nullptr)
        __cache = static_cast<__node_pointer>(__cache->__parent_);
      destroy(__cache);
      throw;
    }

    if (__cache != nullptr) {
      while (__cache->__parent_ != nullptr)
        __cache = static_cast<__node_pointer>(__cache->__parent_);
      destroy(__cache);
    }
  }
  for (; __first != __last; ++__first)
    __insert_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first,
                                                       _InputIterator __last) {
  typedef iterator_traits<_InputIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  static_assert(
      (is_same<_ItValueType, __container_value_type>::value ||
       is_same<_ItValueType, __node_value_type>::value),
      "__assign_multi may only be called with the containers value type"
      " or the nodes value type");
  if (size() != 0) {
    __node_pointer __cache = __detach();

    try {

      for (; __cache != nullptr && __first != __last; ++__first) {
        __cache->__value_ = *__first;
        __node_pointer __next = __detach(__cache);
        __node_insert_multi(__cache);
        __cache = __next;
      }

    } catch (...) {
      while (__cache->__parent_ != nullptr)
        __cache = static_cast<__node_pointer>(__cache->__parent_);
      destroy(__cache);
      throw;
    }

    if (__cache != nullptr) {
      while (__cache->__parent_ != nullptr)
        __cache = static_cast<__node_pointer>(__cache->__parent_);
      destroy(__cache);
    }
  }
  for (; __first != __last; ++__first)
    __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree &__t)
    : __begin_node_(__iter_pointer()),
      __pair1_(__node_traits::select_on_container_copy_construction(
          __t.__node_alloc())),
      __pair3_(0, __t.value_comp()) {
  __begin_node() = __end_node();
}



template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree &&__t)
    noexcept(is_nothrow_move_constructible<__node_allocator>::value &&is_nothrow_move_constructible<value_compare>::value)

    : __begin_node_(std::__1::move(__t.__begin_node_)),
      __pair1_(std::__1::move(__t.__pair1_)), __pair3_(std::__1::move(__t.__pair3_)) {
  if (size() == 0)
    __begin_node() = __end_node();
  else {
    __end_node()->__left_->__parent_ =
        static_cast<__parent_pointer>(__end_node());
    __t.__begin_node() = __t.__end_node();
    __t.__end_node()->__left_ = nullptr;
    __t.size() = 0;
  }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree &&__t,
                                          const allocator_type &__a)
    : __pair1_(__node_allocator(__a)),
      __pair3_(0, std::__1::move(__t.value_comp())) {
  if (__a == __t.__alloc()) {
    if (__t.size() == 0)
      __begin_node() = __end_node();
    else {
      __begin_node() = __t.__begin_node();
      __end_node()->__left_ = __t.__end_node()->__left_;
      __end_node()->__left_->__parent_ =
          static_cast<__parent_pointer>(__end_node());
      size() = __t.size();
      __t.__begin_node() = __t.__end_node();
      __t.__end_node()->__left_ = nullptr;
      __t.size() = 0;
    }
  } else {
    __begin_node() = __end_node();
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(__tree &__t, true_type)
    noexcept(is_nothrow_move_assignable<value_compare>::value &&is_nothrow_move_assignable<__node_allocator>::value) {

  destroy(static_cast<__node_pointer>(__end_node()->__left_));
  __begin_node_ = __t.__begin_node_;
  __pair1_.first() = __t.__pair1_.first();
  __move_assign_alloc(__t);
  __pair3_ = std::__1::move(__t.__pair3_);
  if (size() == 0)
    __begin_node() = __end_node();
  else {
    __end_node()->__left_->__parent_ =
        static_cast<__parent_pointer>(__end_node());
    __t.__begin_node() = __t.__end_node();
    __t.__end_node()->__left_ = nullptr;
    __t.size() = 0;
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(__tree &__t, false_type) {
  if (__node_alloc() == __t.__node_alloc())
    __move_assign(__t, true_type());
  else {
    value_comp() = std::__1::move(__t.value_comp());
    const_iterator __e = end();
    if (size() != 0) {
      __node_pointer __cache = __detach();

      try {

        while (__cache != nullptr && __t.size() != 0) {
          __cache->__value_ = std::__1::move(__t.remove(__t.begin())->__value_);
          __node_pointer __next = __detach(__cache);
          __node_insert_multi(__cache);
          __cache = __next;
        }

      } catch (...) {
        while (__cache->__parent_ != nullptr)
          __cache = static_cast<__node_pointer>(__cache->__parent_);
        destroy(__cache);
        throw;
      }

      if (__cache != nullptr) {
        while (__cache->__parent_ != nullptr)
          __cache = static_cast<__node_pointer>(__cache->__parent_);
        destroy(__cache);
      }
    }
    while (__t.size() != 0)
      __insert_multi(__e,
                     _NodeTypes::__move(__t.remove(__t.begin())->__value_));
  }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator> &__tree<_Tp, _Compare, _Allocator>::
operator=(__tree &&__t)
    noexcept(__node_traits::propagate_on_container_move_assignment::value &&is_nothrow_move_assignable<value_compare>::value &&is_nothrow_move_assignable<__node_allocator>::value)



{
  __move_assign(
      __t, integral_constant<
               bool,
               __node_traits::propagate_on_container_move_assignment::value>());
  return *this;
}



template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree() {
  static_assert((is_copy_constructible<value_compare>::value),
                "Comparator must be copy-constructible.");
  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) noexcept {
  if (__nd != nullptr) {
    destroy(static_cast<__node_pointer>(__nd->__left_));
    destroy(static_cast<__node_pointer>(__nd->__right_));
    __node_allocator &__na = __node_alloc();
    __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
    __node_traits::deallocate(__na, __nd, 1);
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::swap(__tree &__t)

    noexcept(__is_nothrow_swappable<value_compare>::value && (!__node_traits::propagate_on_container_swap::value || __is_nothrow_swappable<__node_allocator>::value))





{
  using std::__1::swap;
  swap(__begin_node_, __t.__begin_node_);
  swap(__pair1_.first(), __t.__pair1_.first());
  __swap_allocator(__node_alloc(), __t.__node_alloc());
  __pair3_.swap(__t.__pair3_);
  if (size() == 0)
    __begin_node() = __end_node();
  else
    __end_node()->__left_->__parent_ =
        static_cast<__parent_pointer>(__end_node());
  if (__t.size() == 0)
    __t.__begin_node() = __t.__end_node();
  else
    __t.__end_node()->__left_->__parent_ =
        static_cast<__parent_pointer>(__t.__end_node());
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::clear() noexcept {
  destroy(__root());
  size() = 0;
  __begin_node() = __end_node();
  __end_node()->__left_ = nullptr;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer &__parent,
                                                   const key_type &__v) {
  __node_pointer __nd = __root();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__nd->__value_, __v)) {
        if (__nd->__right_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__right_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __nd->__right_;
        }
      } else {
        if (__nd->__left_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__left_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __parent->__left_;
        }
      }
    }
  }
  __parent = static_cast<__parent_pointer>(__end_node());
  return __parent->__left_;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer &__parent,
                                                    const key_type &__v) {
  __node_pointer __nd = __root();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__v, __nd->__value_)) {
        if (__nd->__left_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__left_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __parent->__left_;
        }
      } else {
        if (__nd->__right_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__right_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __nd->__right_;
        }
      }
    }
  }
  __parent = static_cast<__parent_pointer>(__end_node());
  return __parent->__left_;
}







template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,
                                               __parent_pointer &__parent,
                                               const key_type &__v) {
  if (__hint == end() || !value_comp()(*__hint, __v))
  {

    const_iterator __prior = __hint;
    if (__prior == begin() || !value_comp()(__v, *--__prior)) {

      if (__hint.__ptr_->__left_ == nullptr) {
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        return __parent->__left_;
      } else {
        __parent = static_cast<__parent_pointer>(__prior.__ptr_);
        return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
      }
    }

    return __find_leaf_high(__parent, __v);
  }

  return __find_leaf_low(__parent, __v);
}





template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer &__parent,
                                                const _Key &__v) {
  __node_pointer __nd = __root();
  __node_base_pointer *__nd_ptr = __root_ptr();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__v, __nd->__value_)) {
        if (__nd->__left_ != nullptr) {
          __nd_ptr = std::__1::addressof(__nd->__left_);
          __nd = static_cast<__node_pointer>(__nd->__left_);
        } else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __parent->__left_;
        }
      } else if (value_comp()(__nd->__value_, __v)) {
        if (__nd->__right_ != nullptr) {
          __nd_ptr = std::__1::addressof(__nd->__right_);
          __nd = static_cast<__node_pointer>(__nd->__right_);
        } else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __nd->__right_;
        }
      } else {
        __parent = static_cast<__parent_pointer>(__nd);
        return *__nd_ptr;
      }
    }
  }
  __parent = static_cast<__parent_pointer>(__end_node());
  return __parent->__left_;
}
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
                                                __parent_pointer &__parent,
                                                __node_base_pointer &__dummy,
                                                const _Key &__v) {
  if (__hint == end() || value_comp()(__v, *__hint))
  {

    const_iterator __prior = __hint;
    if (__prior == begin() || value_comp()(*--__prior, __v)) {

      if (__hint.__ptr_->__left_ == nullptr) {
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        return __parent->__left_;
      } else {
        __parent = static_cast<__parent_pointer>(__prior.__ptr_);
        return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
      }
    }

    return __find_equal(__parent, __v);
  } else if (value_comp()(*__hint, __v))
  {

    const_iterator __next = std::__1::next(__hint);
    if (__next == end() || value_comp()(__v, *__next)) {

      if (__hint.__get_np()->__right_ == nullptr) {
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
      } else {
        __parent = static_cast<__parent_pointer>(__next.__ptr_);
        return __parent->__left_;
      }
    }

    return __find_equal(__parent, __v);
  }

  __parent = static_cast<__parent_pointer>(__hint.__ptr_);
  __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
  return __dummy;
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(
    __parent_pointer __parent, __node_base_pointer &__child,
    __node_base_pointer __new_node) {
  __new_node->__left_ = nullptr;
  __new_node->__right_ = nullptr;
  __new_node->__parent_ = __parent;

  __child = __new_node;
  if (__begin_node()->__left_ != nullptr)
    __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);
  __tree_balance_after_insert(__end_node()->__left_, __child);
  ++size();
}


template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const &__k,
                                                             _Args &&... __args)







{
  __parent_pointer __parent;
  __node_base_pointer &__child = __find_equal(__parent, __k);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {

    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);



    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}


template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const &__k, _Args &&... __args)







{
  __parent_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer &__child = __find_equal(__p, __parent, __dummy, __k);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  if (__child == nullptr) {

    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);



    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
  }
  return iterator(__r);
}



template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args &&... __args) {
  static_assert(!__is_tree_value_type<_Args...>::value,
                "Cannot construct from __value_type");
  __node_allocator &__na = __node_alloc();
  __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
  __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),
                           std::__1::forward<_Args>(__args)...);
  __h.get_deleter().__value_constructed = true;
  return __h;
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args &&... __args) {
  __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer &__child = __find_equal(__parent, __h->__value_);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {
    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(
    const_iterator __p, _Args &&... __args) {
  __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer &__child =
      __find_equal(__p, __parent, __dummy, __h->__value_);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  if (__child == nullptr) {
    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
  }
  return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args &&... __args) {
  __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer &__child =
      __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));
  __insert_node_at(__parent, __child,
                   static_cast<__node_base_pointer>(__h.get()));
  return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,
                                                        _Args &&... __args) {
  __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer &__child =
      __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));
  __insert_node_at(__parent, __child,
                   static_cast<__node_base_pointer>(__h.get()));
  return iterator(static_cast<__node_pointer>(__h.release()));
}
template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer &__child = __find_equal(__parent, __nd->__value_);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    __r = __nd;
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,
                                                        __node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer &__child = __find_equal(__p, __parent, __nd->__value_);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  if (__child == nullptr) {
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    __r = __nd;
  }
  return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer &__child =
      __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
  return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,
                                                       __node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer &__child =
      __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
  return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p) {
  __node_pointer __np = __p.__get_np();
  iterator __r(__p.__ptr_);
  ++__r;
  if (__begin_node() == __p.__ptr_)
    __begin_node() = __r.__ptr_;
  --size();
  __node_allocator &__na = __node_alloc();
  __tree_remove(__end_node()->__left_, static_cast<__node_base_pointer>(__np));
  __node_traits::destroy(
      __na, _NodeTypes::__get_ptr(const_cast<__node_value_type &>(*__p)));
  __node_traits::deallocate(__na, __np, 1);
  return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f,
                                         const_iterator __l) {
  while (__f != __l)
    __f = erase(__f);
  return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key &__k) {
  iterator __i = find(__k);
  if (__i == end())
    return 0;
  erase(__i);
  return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key &__k) {
  pair<iterator, iterator> __p = __equal_range_multi(__k);
  size_type __r = 0;
  for (; __p.first != __p.second; ++__r)
    __p.first = erase(__p.first);
  return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key &__v) {
  iterator __p = __lower_bound(__v, __root(), __end_node());
  if (__p != end() && !value_comp()(__v, *__p))
    return __p;
  return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key &__v) const {
  const_iterator __p = __lower_bound(__v, __root(), __end_node());
  if (__p != end() && !value_comp()(__v, *__p))
    return __p;
  return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key &__k) const {
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return 1;
  }
  return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key &__k) const {
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return std::__1::distance(
          __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_),
                        static_cast<__iter_pointer>(__rt)),
          __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_),
                        __result));
  }
  return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key &__v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) {
  while (__root != nullptr) {
    if (!value_comp()(__root->__value_, __v)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(
    const _Key &__v, __node_pointer __root, __iter_pointer __result) const {
  while (__root != nullptr) {
    if (!value_comp()(__root->__value_, __v)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key &__v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) {
  while (__root != nullptr) {
    if (value_comp()(__v, __root->__value_)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(
    const _Key &__v, __node_pointer __root, __iter_pointer __result) const {
  while (__root != nullptr) {
    if (value_comp()(__v, __root->__value_)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key &__k) {
  typedef pair<iterator, iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(iterator(__rt), iterator(__rt->__right_ != nullptr
                                              ? static_cast<__iter_pointer>(
                                                    __tree_min(__rt->__right_))
                                              : __result));
  }
  return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key &__k) const {
  typedef pair<const_iterator, const_iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(const_iterator(__rt),
                 const_iterator(__rt->__right_ != nullptr
                                    ? static_cast<__iter_pointer>(
                                          __tree_min(__rt->__right_))
                                    : __result));
  }
  return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key &__k) {
  typedef pair<iterator, iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_),
                               static_cast<__iter_pointer>(__rt)),
                 __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_),
                               __result));
  }
  return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key &__k) const {
  typedef pair<const_iterator, const_iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_),
                               static_cast<__iter_pointer>(__rt)),
                 __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_),
                               __result));
  }
  return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) noexcept {
  __node_pointer __np = __p.__get_np();
  if (__begin_node() == __p.__ptr_) {
    if (__np->__right_ != nullptr)
      __begin_node() = static_cast<__iter_pointer>(__np->__right_);
    else
      __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
  }
  --size();
  __tree_remove(__end_node()->__left_, static_cast<__node_base_pointer>(__np));
  return __node_holder(__np, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(__tree<_Tp, _Compare, _Allocator> &__x,
     __tree<_Tp, _Compare, _Allocator> &__y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

} }


namespace std { inline namespace __1 {

template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key>>
class __attribute__((__visibility__("default"))) set {
public:

  typedef _Key key_type;
  typedef key_type value_type;
  typedef _Compare key_compare;
  typedef key_compare value_compare;
  typedef _Allocator allocator_type;
  typedef value_type &reference;
  typedef const value_type &const_reference;

  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

private:
  typedef __tree<value_type, value_compare, allocator_type> __base;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __base::__node_holder __node_holder;

  __base __tree_;

public:
  typedef typename __base::pointer pointer;
  typedef typename __base::const_pointer const_pointer;
  typedef typename __base::size_type size_type;
  typedef typename __base::difference_type difference_type;
  typedef typename __base::const_iterator iterator;
  typedef typename __base::const_iterator const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

  __attribute__((__visibility__("hidden"), __always_inline__))
  set() noexcept(is_nothrow_default_constructible<allocator_type>::value &&is_nothrow_default_constructible<key_compare>::value &&is_nothrow_copy_constructible<key_compare>::value)


      : __tree_(value_compare()) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit set(const value_compare &__comp)
      noexcept(is_nothrow_default_constructible<allocator_type>::value &&is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__comp) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit set(const value_compare &__comp, const allocator_type &__a)
      : __tree_(__comp, __a) {}
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) set(_InputIterator __f, _InputIterator __l,
                                const value_compare &__comp = value_compare())
      : __tree_(__comp) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) set(_InputIterator __f, _InputIterator __l,
                                const value_compare &__comp,
                                const allocator_type &__a)
      : __tree_(__comp, __a) {
    insert(__f, __l);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  set(const set &__s) : __tree_(__s.__tree_) { insert(__s.begin(), __s.end()); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  set &operator=(const set &__s) {
    __tree_ = __s.__tree_;
    return *this;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  set(set &&__s) noexcept(is_nothrow_move_constructible<__base>::value)
      : __tree_(std::__1::move(__s.__tree_)) {}


  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit set(const allocator_type &__a) : __tree_(__a) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  set(const set &__s, const allocator_type &__a)
      : __tree_(__s.__tree_.value_comp(), __a) {
    insert(__s.begin(), __s.end());
  }


  set(set &&__s, const allocator_type &__a);



  __attribute__((__visibility__("hidden"), __always_inline__))
  set(initializer_list<value_type> __il,
      const value_compare &__comp = value_compare())
      : __tree_(__comp) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  set(initializer_list<value_type> __il, const value_compare &__comp,
      const allocator_type &__a)
      : __tree_(__comp, __a) {
    insert(__il.begin(), __il.end());
  }







  __attribute__((__visibility__("hidden"), __always_inline__))
  set &operator=(initializer_list<value_type> __il) {
    __tree_.__assign_unique(__il.begin(), __il.end());
    return *this;
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  set &operator=(set &&__s)
      noexcept(is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::__1::move(__s.__tree_);
    return *this;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator begin() noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator begin() const noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator end() noexcept { return __tree_.end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator end() const noexcept { return __tree_.end(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crend() const noexcept { return rend(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool empty() const noexcept { return __tree_.size() == 0; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type size() const noexcept { return __tree_.size(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type max_size() const noexcept { return __tree_.max_size(); }




  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair<iterator, bool> emplace(_Args &&... __args) {
    return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);
  }
  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator emplace_hint(const_iterator __p,
                                                  _Args &&... __args) {
    return __tree_.__emplace_hint_unique(__p, std::__1::forward<_Args>(__args)...);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, bool> insert(const value_type &__v) {
    return __tree_.__insert_unique(__v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, bool> insert(value_type &&__v) {
    return __tree_.__insert_unique(std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __p, const value_type &__v) {
    return __tree_.__insert_unique(__p, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __p, value_type &&__v) {
    return __tree_.__insert_unique(__p, std::__1::move(__v));
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) void insert(_InputIterator __f,
                                        _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      __tree_.__insert_unique(__e, *__f);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  void insert(initializer_list<value_type> __il) {
    insert(__il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __p) { return __tree_.erase(__p); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type erase(const key_type &__k) { return __tree_.__erase_unique(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __f, const_iterator __l) {
    return __tree_.erase(__f, __l);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept { __tree_.clear(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(set &__s) noexcept(__is_nothrow_swappable<__base>::value) {
    __tree_.swap(__s.__tree_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type get_allocator() const noexcept { return __tree_.__alloc(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  key_compare key_comp() const { return __tree_.value_comp(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  value_compare value_comp() const { return __tree_.value_comp(); }


  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator find(const key_type &__k) { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator find(const key_type &__k) const { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type count(const key_type &__k) const {
    return __tree_.__count_unique(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator lower_bound(const key_type &__k) { return __tree_.lower_bound(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator lower_bound(const key_type &__k) const {
    return __tree_.lower_bound(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator upper_bound(const key_type &__k) { return __tree_.upper_bound(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator upper_bound(const key_type &__k) const {
    return __tree_.upper_bound(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, iterator> equal_range(const key_type &__k) {
    return __tree_.__equal_range_unique(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<const_iterator, const_iterator> equal_range(const key_type &__k) const {
    return __tree_.__equal_range_unique(__k);
  }
};



template <class _Key, class _Compare, class _Allocator>
set<_Key, _Compare, _Allocator>::set(set &&__s, const allocator_type &__a)
    : __tree_(std::__1::move(__s.__tree_), __a) {
  if (__a != __s.get_allocator()) {
    const_iterator __e = cend();
    while (!__s.empty())
      insert(__e, std::__1::move(__s.__tree_.remove(__s.begin())->__value_));
  }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const set<_Key, _Compare, _Allocator> &__x,
           const set<_Key, _Compare, _Allocator> &__y) {
  return __x.size() == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const set<_Key, _Compare, _Allocator> &__x,
          const set<_Key, _Compare, _Allocator> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                        __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const set<_Key, _Compare, _Allocator> &__x,
           const set<_Key, _Compare, _Allocator> &__y) {
  return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const set<_Key, _Compare, _Allocator> &__x,
          const set<_Key, _Compare, _Allocator> &__y) {
  return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const set<_Key, _Compare, _Allocator> &__x,
           const set<_Key, _Compare, _Allocator> &__y) {
  return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const set<_Key, _Compare, _Allocator> &__x,
           const set<_Key, _Compare, _Allocator> &__y) {
  return !(__y < __x);
}


template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void swap(set<_Key, _Compare, _Allocator> &__x,
                                           set<_Key, _Compare, _Allocator> &__y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key>>
class __attribute__((__visibility__("default"))) multiset {
public:

  typedef _Key key_type;
  typedef key_type value_type;
  typedef _Compare key_compare;
  typedef key_compare value_compare;
  typedef _Allocator allocator_type;
  typedef value_type &reference;
  typedef const value_type &const_reference;

  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

private:
  typedef __tree<value_type, value_compare, allocator_type> __base;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __base::__node_holder __node_holder;

  __base __tree_;

public:
  typedef typename __base::pointer pointer;
  typedef typename __base::const_pointer const_pointer;
  typedef typename __base::size_type size_type;
  typedef typename __base::difference_type difference_type;
  typedef typename __base::const_iterator iterator;
  typedef typename __base::const_iterator const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset()
      noexcept(is_nothrow_default_constructible<allocator_type>::value &&is_nothrow_default_constructible<key_compare>::value &&is_nothrow_copy_constructible<key_compare>::value)


      : __tree_(value_compare()) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit multiset(const value_compare &__comp)
      noexcept(is_nothrow_default_constructible<allocator_type>::value &&is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__comp) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit multiset(const value_compare &__comp, const allocator_type &__a)
      : __tree_(__comp, __a) {}
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset(_InputIterator __f, _InputIterator __l,
           const value_compare &__comp = value_compare())
      : __tree_(__comp) {
    insert(__f, __l);
  }
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) multiset(_InputIterator __f, _InputIterator __l,
                                     const value_compare &__comp,
                                     const allocator_type &__a)
      : __tree_(__comp, __a) {
    insert(__f, __l);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset(const multiset &__s)
      : __tree_(__s.__tree_.value_comp(),
                __alloc_traits::select_on_container_copy_construction(
                    __s.__tree_.__alloc())) {
    insert(__s.begin(), __s.end());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset &operator=(const multiset &__s) {
    __tree_ = __s.__tree_;
    return *this;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset(multiset &&__s)
      noexcept(is_nothrow_move_constructible<__base>::value)
      : __tree_(std::__1::move(__s.__tree_)) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit multiset(const allocator_type &__a) : __tree_(__a) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset(const multiset &__s, const allocator_type &__a)
      : __tree_(__s.__tree_.value_comp(), __a) {
    insert(__s.begin(), __s.end());
  }

  multiset(multiset &&__s, const allocator_type &__a);



  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset(initializer_list<value_type> __il,
           const value_compare &__comp = value_compare())
      : __tree_(__comp) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset(initializer_list<value_type> __il, const value_compare &__comp,
           const allocator_type &__a)
      : __tree_(__comp, __a) {
    insert(__il.begin(), __il.end());
  }







  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset &operator=(initializer_list<value_type> __il) {
    __tree_.__assign_multi(__il.begin(), __il.end());
    return *this;
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  multiset &operator=(multiset &&__s)
      noexcept(is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::__1::move(__s.__tree_);
    return *this;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator begin() noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator begin() const noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator end() noexcept { return __tree_.end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator end() const noexcept { return __tree_.end(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crend() const noexcept { return rend(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool empty() const noexcept { return __tree_.size() == 0; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type size() const noexcept { return __tree_.size(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type max_size() const noexcept { return __tree_.max_size(); }




  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator emplace(_Args &&... __args) {
    return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);
  }
  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator emplace_hint(const_iterator __p,
                                                  _Args &&... __args) {
    return __tree_.__emplace_hint_multi(__p, std::__1::forward<_Args>(__args)...);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const value_type &__v) { return __tree_.__insert_multi(__v); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(value_type &&__v) {
    return __tree_.__insert_multi(std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __p, const value_type &__v) {
    return __tree_.__insert_multi(__p, __v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __p, value_type &&__v) {
    return __tree_.__insert_multi(std::__1::move(__v));
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) void insert(_InputIterator __f,
                                        _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      __tree_.__insert_multi(__e, *__f);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  void insert(initializer_list<value_type> __il) {
    insert(__il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __p) { return __tree_.erase(__p); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type erase(const key_type &__k) { return __tree_.__erase_multi(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __f, const_iterator __l) {
    return __tree_.erase(__f, __l);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept { __tree_.clear(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(multiset &__s) noexcept(__is_nothrow_swappable<__base>::value) {
    __tree_.swap(__s.__tree_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type get_allocator() const noexcept { return __tree_.__alloc(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  key_compare key_comp() const { return __tree_.value_comp(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  value_compare value_comp() const { return __tree_.value_comp(); }


  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator find(const key_type &__k) { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator find(const key_type &__k) const { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type count(const key_type &__k) const {
    return __tree_.__count_multi(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator lower_bound(const key_type &__k) { return __tree_.lower_bound(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator lower_bound(const key_type &__k) const {
    return __tree_.lower_bound(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator upper_bound(const key_type &__k) { return __tree_.upper_bound(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator upper_bound(const key_type &__k) const {
    return __tree_.upper_bound(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, iterator> equal_range(const key_type &__k) {
    return __tree_.__equal_range_multi(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<const_iterator, const_iterator> equal_range(const key_type &__k) const {
    return __tree_.__equal_range_multi(__k);
  }
};



template <class _Key, class _Compare, class _Allocator>
multiset<_Key, _Compare, _Allocator>::multiset(multiset &&__s,
                                               const allocator_type &__a)
    : __tree_(std::__1::move(__s.__tree_), __a) {
  if (__a != __s.get_allocator()) {
    const_iterator __e = cend();
    while (!__s.empty())
      insert(__e, std::__1::move(__s.__tree_.remove(__s.begin())->__value_));
  }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const multiset<_Key, _Compare, _Allocator> &__x,
           const multiset<_Key, _Compare, _Allocator> &__y) {
  return __x.size() == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const multiset<_Key, _Compare, _Allocator> &__x,
          const multiset<_Key, _Compare, _Allocator> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                        __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const multiset<_Key, _Compare, _Allocator> &__x,
           const multiset<_Key, _Compare, _Allocator> &__y) {
  return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const multiset<_Key, _Compare, _Allocator> &__x,
          const multiset<_Key, _Compare, _Allocator> &__y) {
  return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const multiset<_Key, _Compare, _Allocator> &__x,
           const multiset<_Key, _Compare, _Allocator> &__y) {
  return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const multiset<_Key, _Compare, _Allocator> &__x,
           const multiset<_Key, _Compare, _Allocator> &__y) {
  return !(__y < __x);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(multiset<_Key, _Compare, _Allocator> &__x,
     multiset<_Key, _Compare, _Allocator> &__y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

} }

namespace v8 {


enum DebugEvent {
  Break = 1,
  Exception = 2,
  NewFunction = 3,
  BeforeCompile = 4,
  AfterCompile = 5,
  CompileError = 6,
  AsyncTaskEvent = 7,
};

class Debug {
 public:




  class ClientData {
   public:
    virtual ~ClientData() {}
  };





  class Message {
   public:



    virtual bool IsEvent() const = 0;
    virtual bool IsResponse() const = 0;
    virtual DebugEvent GetEvent() const = 0;





    virtual bool WillStartRunning() const = 0;






    virtual Local<Object> GetExecutionState() const = 0;
    virtual Local<Object> GetEventData() const = 0;




    virtual Local<String> GetJSON() const = 0;






    virtual Local<Context> GetEventContext() const = 0;
    virtual ClientData* GetClientData() const = 0;

    virtual Isolate* GetIsolate() const = 0;

    virtual ~Message() {}
  };





  class EventDetails {
   public:



    virtual DebugEvent GetEvent() const = 0;





    virtual Local<Object> GetExecutionState() const = 0;
    virtual Local<Object> GetEventData() const = 0;






    virtual Local<Context> GetEventContext() const = 0;





    virtual Local<Value> GetCallbackData() const = 0;






    virtual ClientData* GetClientData() const = 0;

    virtual ~EventDetails() {}
  };
  typedef void (*EventCallback)(const EventDetails& event_details);
  typedef void (*MessageHandler)(const Message& message);




  typedef void (*DebugMessageDispatchHandler)();

  static bool SetDebugEventListener(Isolate* isolate, EventCallback that,
                                    Local<Value> data = Local<Value>());
  static bool SetDebugEventListener( EventCallback that, Local<Value> data = Local<Value>()) __attribute__((deprecated));





  static void DebugBreak(Isolate* isolate);



  static void CancelDebugBreak(Isolate* isolate);


  static bool CheckDebugBreak(Isolate* isolate);


  static void SetMessageHandler(Isolate* isolate, MessageHandler handler);
  static void SetMessageHandler(MessageHandler handler) __attribute__((deprecated));


  static void SendCommand(Isolate* isolate,
                          const uint16_t* command, int length,
                          ClientData* client_data = 0);
  static Local<Value> Call(v8::Local<v8::Function> fun, Local<Value> data = Local<Value>()) __attribute__((deprecated));



  static MaybeLocal<Value> Call(Local<Context> context,
                                v8::Local<v8::Function> fun,
                                Local<Value> data = Local<Value>());




  static Local<Value> GetMirror(v8::Local<v8::Value> obj) __attribute__((deprecated));

  static MaybeLocal<Value> GetMirror(Local<Context> context,
                                     v8::Local<v8::Value> obj);
  static void ProcessDebugMessages(Isolate* isolate);
  static void ProcessDebugMessages() __attribute__((deprecated));
  static Local<Context> GetDebugContext(Isolate* isolate);
  static Local<Context> GetDebugContext() __attribute__((deprecated));
  static void SetLiveEditEnabled(Isolate* isolate, bool enable);






  static MaybeLocal<Array> GetInternalProperties(Isolate* isolate,
                                                 Local<Value> value);






  static bool IsTailCallEliminationEnabled(Isolate* isolate);
  static void SetTailCallEliminationEnabled(Isolate* isolate, bool enabled);
};


}

namespace v8 {
namespace internal {


class Isolate;
class PerThreadAssertData;


enum PerThreadAssertType {
  HEAP_ALLOCATION_ASSERT,
  HANDLE_ALLOCATION_ASSERT,
  HANDLE_DEREFERENCE_ASSERT,
  DEFERRED_HANDLE_DEREFERENCE_ASSERT,
  CODE_DEPENDENCY_CHANGE_ASSERT,
  LAST_PER_THREAD_ASSERT_TYPE
};


enum PerIsolateAssertType {
  JAVASCRIPT_EXECUTION_ASSERT,
  JAVASCRIPT_EXECUTION_THROWS,
  DEOPTIMIZATION_ASSERT,
  COMPILATION_ASSERT
};


template <PerThreadAssertType kType, bool kAllow>
class PerThreadAssertScope {
 public:
  PerThreadAssertScope();
  ~PerThreadAssertScope();

  static bool IsAllowed();

 private:
  PerThreadAssertData* data_;
  bool old_state_;

  PerThreadAssertScope(const PerThreadAssertScope&) = delete; void operator=(const PerThreadAssertScope&) = delete;
};


template <PerIsolateAssertType type, bool allow>
class PerIsolateAssertScope {
 public:
  explicit PerIsolateAssertScope(Isolate* isolate);
  ~PerIsolateAssertScope();

  static bool IsAllowed(Isolate* isolate);

 private:
  class DataBit;

  Isolate* isolate_;
  uint32_t old_data_;

  PerIsolateAssertScope(const PerIsolateAssertScope&) = delete; void operator=(const PerIsolateAssertScope&) = delete;
};


template <PerThreadAssertType type, bool allow>

class PerThreadAssertScopeDebugOnly : public
    PerThreadAssertScope<type, allow> {





};


template <PerIsolateAssertType type, bool allow>

class PerIsolateAssertScopeDebugOnly : public
    PerIsolateAssertScope<type, allow> {
 public:
  explicit PerIsolateAssertScopeDebugOnly(Isolate* isolate)
      : PerIsolateAssertScope<type, allow>(isolate) { }





};




typedef PerThreadAssertScopeDebugOnly<HANDLE_ALLOCATION_ASSERT, false>
    DisallowHandleAllocation;


typedef PerThreadAssertScopeDebugOnly<HANDLE_ALLOCATION_ASSERT, true>
    AllowHandleAllocation;


typedef PerThreadAssertScopeDebugOnly<HEAP_ALLOCATION_ASSERT, false>
    DisallowHeapAllocation;


typedef PerThreadAssertScopeDebugOnly<HEAP_ALLOCATION_ASSERT, true>
    AllowHeapAllocation;


typedef PerThreadAssertScopeDebugOnly<HANDLE_DEREFERENCE_ASSERT, false>
    DisallowHandleDereference;


typedef PerThreadAssertScopeDebugOnly<HANDLE_DEREFERENCE_ASSERT, true>
    AllowHandleDereference;


typedef PerThreadAssertScopeDebugOnly<DEFERRED_HANDLE_DEREFERENCE_ASSERT, false>
    DisallowDeferredHandleDereference;


typedef PerThreadAssertScopeDebugOnly<DEFERRED_HANDLE_DEREFERENCE_ASSERT, true>
    AllowDeferredHandleDereference;


typedef PerThreadAssertScopeDebugOnly<CODE_DEPENDENCY_CHANGE_ASSERT, false>
    DisallowCodeDependencyChange;


typedef PerThreadAssertScopeDebugOnly<CODE_DEPENDENCY_CHANGE_ASSERT, true>
    AllowCodeDependencyChange;





typedef PerIsolateAssertScope<JAVASCRIPT_EXECUTION_ASSERT, false>
    DisallowJavascriptExecution;


typedef PerIsolateAssertScope<JAVASCRIPT_EXECUTION_ASSERT, true>
    AllowJavascriptExecution;


typedef PerIsolateAssertScope<JAVASCRIPT_EXECUTION_THROWS, false>
    ThrowOnJavascriptExecution;


typedef PerIsolateAssertScope<JAVASCRIPT_EXECUTION_THROWS, true>
    NoThrowOnJavascriptExecution;


typedef PerIsolateAssertScopeDebugOnly<DEOPTIMIZATION_ASSERT, false>
    DisallowDeoptimization;


typedef PerIsolateAssertScopeDebugOnly<DEOPTIMIZATION_ASSERT, true>
    AllowDeoptimization;


typedef PerIsolateAssertScopeDebugOnly<COMPILATION_ASSERT, false>
    DisallowCompilation;


typedef PerIsolateAssertScopeDebugOnly<COMPILATION_ASSERT, true>
    AllowCompilation;
}
}



















namespace v8 {

class Isolate;




class Task {
 public:
  virtual ~Task() {}

  virtual void Run() = 0;
};
class IdleTask {
 public:
  virtual ~IdleTask() {}
  virtual void Run(double deadline_in_seconds) = 0;
};
class Platform {
 public:





  enum ExpectedRuntime {
    kShortRunningTask,
    kLongRunningTask
  };

  virtual ~Platform() {}
  virtual size_t NumberOfAvailableBackgroundThreads() { return 0; }
  virtual void CallOnBackgroundThread(Task* task,
                                      ExpectedRuntime expected_runtime) = 0;






  virtual void CallOnForegroundThread(Isolate* isolate, Task* task) = 0;







  virtual void CallDelayedOnForegroundThread(Isolate* isolate, Task* task,
                                             double delay_in_seconds) = 0;
  virtual void CallIdleOnForegroundThread(Isolate* isolate, IdleTask* task) {

  }




  virtual bool IdleTasksEnabled(Isolate* isolate) {

    return false;
  }
  virtual double MonotonicallyIncreasingTime() = 0;
  virtual const uint8_t* GetCategoryGroupEnabled(const char* name) {
    static uint8_t no = 0;
    return &no;
  }





  virtual const char* GetCategoryGroupName(
      const uint8_t* category_enabled_flag) {
    static const char dummy[] = "dummy";
    return dummy;
  }
  virtual uint64_t AddTraceEvent(
      char phase, const uint8_t* category_enabled_flag, const char* name,
      const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
      const char** arg_names, const uint8_t* arg_types,
      const uint64_t* arg_values, unsigned int flags) {
    return 0;
  }





  virtual void UpdateTraceEventDuration(const uint8_t* category_enabled_flag,
                                        const char* name, uint64_t handle) {}
};

}
namespace v8 {
namespace internal {

template <class T>
class AtomicNumber {
 public:
  AtomicNumber() : value_(0) {}
  explicit AtomicNumber(T initial) : value_(initial) {}


  inline T Increment(T increment) {
    return static_cast<T>(base::Barrier_AtomicIncrement(
        &value_, static_cast<base::AtomicWord>(increment)));
  }

  inline T Value() { return static_cast<T>(base::Acquire_Load(&value_)); }

  inline void SetValue(T new_value) {
    base::Release_Store(&value_, static_cast<base::AtomicWord>(new_value));
  }

  inline T operator=(T value) {
    SetValue(value);
    return value;
  }

 private:
  static_assert(sizeof(T) <= sizeof(base::AtomicWord), "sizeof(T) <= sizeof(base::AtomicWord)");

  base::AtomicWord value_;
};



template <typename T>
class AtomicValue {
 public:
  AtomicValue() : value_(0) {}

  explicit AtomicValue(T initial)
      : value_(cast_helper<T>::to_storage_type(initial)) {}

  inline T Value() {
    return cast_helper<T>::to_return_type(base::Acquire_Load(&value_));
  }

  inline bool TrySetValue(T old_value, T new_value) {
    return base::Release_CompareAndSwap(
               &value_, cast_helper<T>::to_storage_type(old_value),
               cast_helper<T>::to_storage_type(new_value)) ==
           cast_helper<T>::to_storage_type(old_value);
  }

  inline void SetValue(T new_value) {
    base::Release_Store(&value_, cast_helper<T>::to_storage_type(new_value));
  }

 private:
  static_assert(sizeof(T) <= sizeof(base::AtomicWord), "sizeof(T) <= sizeof(base::AtomicWord)");

  template <typename S>
  struct cast_helper {
    static base::AtomicWord to_storage_type(S value) {
      return static_cast<base::AtomicWord>(value);
    }
    static S to_return_type(base::AtomicWord value) {
      return static_cast<S>(value);
    }
  };

  template <typename S>
  struct cast_helper<S*> {
    static base::AtomicWord to_storage_type(S* value) {
      return reinterpret_cast<base::AtomicWord>(value);
    }
    static S* to_return_type(base::AtomicWord value) {
      return reinterpret_cast<S*>(value);
    }
  };

  base::AtomicWord value_;
};
template <class E>
class AtomicEnumSet {
 public:
  explicit AtomicEnumSet(base::AtomicWord bits = 0) : bits_(bits) {}

  bool IsEmpty() const { return ToIntegral() == 0; }

  bool Contains(E element) const { return (ToIntegral() & Mask(element)) != 0; }
  bool ContainsAnyOf(const AtomicEnumSet& set) const {
    return (ToIntegral() & set.ToIntegral()) != 0;
  }

  void RemoveAll() { base::Release_Store(&bits_, 0); }

  bool operator==(const AtomicEnumSet& set) const {
    return ToIntegral() == set.ToIntegral();
  }

  bool operator!=(const AtomicEnumSet& set) const {
    return ToIntegral() != set.ToIntegral();
  }

  AtomicEnumSet<E> operator|(const AtomicEnumSet& set) const {
    return AtomicEnumSet<E>(ToIntegral() | set.ToIntegral());
  }
  void Add(E element) { do { base::AtomicWord old; do { old = base::Acquire_Load(&bits_); } while (base::Release_CompareAndSwap(&bits_, old, old | Mask(element)) != old); } while (false); }

  void Add(const AtomicEnumSet& set) { do { base::AtomicWord old; do { old = base::Acquire_Load(&bits_); } while (base::Release_CompareAndSwap(&bits_, old, old | set.ToIntegral()) != old); } while (false); }

  void Remove(E element) { do { base::AtomicWord old; do { old = base::Acquire_Load(&bits_); } while (base::Release_CompareAndSwap(&bits_, old, old & ~Mask(element)) != old); } while (false); }

  void Remove(const AtomicEnumSet& set) {
    do { base::AtomicWord old; do { old = base::Acquire_Load(&bits_); } while (base::Release_CompareAndSwap(&bits_, old, old & ~set.ToIntegral()) != old); } while (false);
  }

  void Intersect(const AtomicEnumSet& set) {
    do { base::AtomicWord old; do { old = base::Acquire_Load(&bits_); } while (base::Release_CompareAndSwap(&bits_, old, old & set.ToIntegral()) != old); } while (false);
  }



 private:

  static_assert(E::kLastValue < (sizeof(base::AtomicWord) * 8), "E::kLastValue < (sizeof(base::AtomicWord) * CHAR_BIT)");

  inline base::AtomicWord ToIntegral() const {
    return base::Acquire_Load(&bits_);
  }

  inline base::AtomicWord Mask(E element) const {
    return static_cast<base::AtomicWord>(1) << element;
  }

  base::AtomicWord bits_;
};

}
}

namespace v8 {
namespace base {


class ConditionVariableEvent;
class TimeDelta;
class ConditionVariable final {
 public:
  ConditionVariable();
  ~ConditionVariable();



  void NotifyOne();


  void NotifyAll();
  void Wait(Mutex* mutex);
  bool WaitFor(Mutex* mutex, const TimeDelta& rel_time) __attribute__((warn_unused_result));



  typedef pthread_cond_t NativeHandle;
  NativeHandle& native_handle() {
    return native_handle_;
  }
  const NativeHandle& native_handle() const {
    return native_handle_;
  }

 private:
  NativeHandle native_handle_;

  ConditionVariable(const ConditionVariable&) = delete; void operator=(const ConditionVariable&) = delete;
};
typedef LazyStaticInstance<
    ConditionVariable, DefaultConstructTrait<ConditionVariable>,
    ThreadSafeInitOnceTrait>::type LazyConditionVariable;



}
}


namespace v8 {
namespace internal {

class Cancelable;
class Isolate;




class CancelableTaskManager {
 public:
  CancelableTaskManager();



  uint32_t Register(Cancelable* task);
  bool TryAbort(uint32_t id);



  void CancelAndWait();

 private:


  void RemoveFinishedTask(uint32_t id);


  uint32_t task_id_counter_;


  HashMap cancelable_tasks_;



  base::ConditionVariable cancelable_tasks_barrier_;
  base::Mutex mutex_;

  friend class Cancelable;

  CancelableTaskManager(const CancelableTaskManager&) = delete; void operator=(const CancelableTaskManager&) = delete;
};


class Cancelable {
 public:
  explicit Cancelable(CancelableTaskManager* parent);
  virtual ~Cancelable();






  uint32_t id() { return id_; }

 protected:
  bool TryRun() { return status_.TrySetValue(kWaiting, kRunning); }
  bool IsRunning() { return status_.Value() == kRunning; }
  intptr_t CancelAttempts() { return cancel_counter_.Value(); }

 private:





  enum Status {
    kWaiting,
    kCanceled,
    kRunning,
  };



  bool Cancel() {
    if (status_.TrySetValue(kWaiting, kCanceled)) {
      return true;
    }
    cancel_counter_.Increment(1);
    return false;
  }

  CancelableTaskManager* parent_;
  AtomicValue<Status> status_;
  uint32_t id_;




  AtomicNumber<intptr_t> cancel_counter_;

  friend class CancelableTaskManager;

  Cancelable(const Cancelable&) = delete; void operator=(const Cancelable&) = delete;
};



class CancelableTask : public Cancelable, public Task {
 public:
  explicit CancelableTask(Isolate* isolate);


  void Run() final {
    if (TryRun()) {
      RunInternal();
    }
  }

  virtual void RunInternal() = 0;

  Isolate* isolate() { return isolate_; }

 private:
  Isolate* isolate_;
  CancelableTask(const CancelableTask&) = delete; void operator=(const CancelableTask&) = delete;
};



class CancelableIdleTask : public Cancelable, public IdleTask {
 public:
  explicit CancelableIdleTask(Isolate* isolate);


  void Run(double deadline_in_seconds) final {
    if (TryRun()) {
      RunInternal(deadline_in_seconds);
    }
  }

  virtual void RunInternal(double deadline_in_seconds) = 0;

  Isolate* isolate() { return isolate_; }

 private:
  Isolate* isolate_;
  CancelableIdleTask(const CancelableIdleTask&) = delete; void operator=(const CancelableIdleTask&) = delete;
};


}
}

















namespace std { inline namespace __1 {

template <class _Key, class _CP, class _Compare,
          bool =
              is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare : private _Compare {
public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_value_compare()
      noexcept(is_nothrow_default_constructible<_Compare>::value)
      : _Compare() {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_value_compare(_Compare c)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _Compare(c) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  const _Compare &key_comp() const noexcept { return *this; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(const _CP &__x, const _CP &__y) const {
    return static_cast<const _Compare &>(*this)(__x.__cc.first, __y.__cc.first);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(const _CP &__x, const _Key &__y) const {
    return static_cast<const _Compare &>(*this)(__x.__cc.first, __y);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(const _Key &__x, const _CP &__y) const {
    return static_cast<const _Compare &>(*this)(__x, __y.__cc.first);
  }
  void swap(__map_value_compare &__y)
      noexcept(__is_nothrow_swappable<_Compare>::value) {
    using std::__1::swap;
    swap(static_cast<const _Compare &>(*this),
         static_cast<const _Compare &>(__y));
  }
};

template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false> {
  _Compare comp;

public:
  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_value_compare()
      noexcept(is_nothrow_default_constructible<_Compare>::value)
      : comp() {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_value_compare(_Compare c)
      noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : comp(c) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  const _Compare &key_comp() const noexcept { return comp; }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(const _CP &__x, const _CP &__y) const {
    return comp(__x.__cc.first, __y.__cc.first);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(const _CP &__x, const _Key &__y) const {
    return comp(__x.__cc.first, __y);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  bool operator()(const _Key &__x, const _CP &__y) const {
    return comp(__x, __y.__cc.first);
  }
  void swap(__map_value_compare &__y)
      noexcept(__is_nothrow_swappable<_Compare>::value) {
    using std::__1::swap;
    swap(comp, __y.comp);
  }
};

template <class _Key, class _CP, class _Compare, bool __b>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(__map_value_compare<_Key, _CP, _Compare, __b> &__x,
     __map_value_compare<_Key, _CP, _Compare, __b> &__y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

template <class _Allocator> class __map_node_destructor {
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;

private:
  allocator_type &__na_;

  __map_node_destructor &operator=(const __map_node_destructor &);

public:
  bool __first_constructed;
  bool __second_constructed;

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit __map_node_destructor(allocator_type &__na) noexcept
      : __na_(__na),
        __first_constructed(false),
        __second_constructed(false) {}


  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_node_destructor(__tree_node_destructor<allocator_type> &&__x) noexcept
      : __na_(__x.__na_),
        __first_constructed(__x.__value_constructed),
        __second_constructed(__x.__value_constructed) {
    __x.__value_constructed = false;
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  void operator()(pointer __p) noexcept {
    if (__second_constructed)
      __alloc_traits::destroy(__na_,
                              std::__1::addressof(__p->__value_.__cc.second));
    if (__first_constructed)
      __alloc_traits::destroy(__na_,
                              std::__1::addressof(__p->__value_.__cc.first));
    if (__p)
      __alloc_traits::deallocate(__na_, __p, 1);
  }
};

template <class _Key, class _Tp, class _Compare, class _Allocator> class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
class multimap;
template <class _TreeIterator> class __map_const_iterator;



template <class _Key, class _Tp> union __value_type {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef pair<key_type, mapped_type> __nc_value_type;

  value_type __cc;
  __nc_value_type __nc;

  __attribute__((__visibility__("hidden"), __always_inline__))
  __value_type &operator=(const __value_type &__v) {
    __nc = __v.__cc;
    return *this;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __value_type &operator=(__value_type &&__v) {
    __nc = std::__1::move(__v.__nc);
    return *this;
  }

  template <class _ValueTp, class = typename enable_if<__is_same_uncvref<
                                _ValueTp, value_type>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) __value_type &operator=(_ValueTp &&__v) {
    __nc = std::__1::forward<_ValueTp>(__v);
    return *this;
  }

private:
  __value_type() = delete;
  ~__value_type() = delete;
  __value_type(const __value_type &__v) = delete;
  __value_type(__value_type &&__v) = delete;
};
template <class _Tp> struct __extract_key_value_types;

template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp>> {
  typedef _Key const __key_type;
  typedef _Tp __mapped_type;
};

template <class _TreeIterator> class __attribute__((__visibility__("default"))) __map_iterator {
  typedef typename _TreeIterator::_NodeTypes _NodeTypes;
  typedef typename _TreeIterator::__pointer_traits __pointer_traits;

  _TreeIterator __i_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef typename _NodeTypes::__map_value_type value_type;
  typedef typename _TreeIterator::difference_type difference_type;
  typedef value_type &reference;
  typedef typename _NodeTypes::__map_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_iterator() noexcept {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_iterator(_TreeIterator __i) noexcept : __i_(__i) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  reference operator*() const { return __i_->__cc; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__i_->__cc);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_iterator &operator++() {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_iterator operator++(int) {
    __map_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_iterator &operator--() {
    --__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_iterator operator--(int) {
    __map_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool operator==(const __map_iterator &__x,
                                                   const __map_iterator &__y) {
    return __x.__i_ == __y.__i_;
  }
  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool operator!=(const __map_iterator &__x,
                                                   const __map_iterator &__y) {
    return __x.__i_ != __y.__i_;
  }

  template <class, class, class, class> friend class __attribute__((__visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__visibility__("default"))) multimap;
  template <class> friend class __attribute__((__visibility__("default"))) __map_const_iterator;
};

template <class _TreeIterator>
class __attribute__((__visibility__("default"))) __map_const_iterator {
  typedef typename _TreeIterator::_NodeTypes _NodeTypes;
  typedef typename _TreeIterator::__pointer_traits __pointer_traits;

  _TreeIterator __i_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef typename _NodeTypes::__map_value_type value_type;
  typedef typename _TreeIterator::difference_type difference_type;
  typedef const value_type &reference;
  typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_const_iterator() noexcept {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_const_iterator(_TreeIterator __i) noexcept : __i_(__i) {}
  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_const_iterator(
      __map_iterator<typename _TreeIterator::__non_const_iterator> __i)
      noexcept : __i_(__i.__i_) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  reference operator*() const { return __i_->__cc; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__i_->__cc);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_const_iterator &operator++() {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_const_iterator operator++(int) {
    __map_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_const_iterator &operator--() {
    --__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  __map_const_iterator operator--(int) {
    __map_const_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator==(const __map_const_iterator &__x, const __map_const_iterator &__y) {
    return __x.__i_ == __y.__i_;
  }
  friend __attribute__((__visibility__("hidden"), __always_inline__)) bool
  operator!=(const __map_const_iterator &__x, const __map_const_iterator &__y) {
    return __x.__i_ != __y.__i_;
  }

  template <class, class, class, class> friend class __attribute__((__visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__visibility__("default"))) multimap;
  template <class, class, class>
  friend class __attribute__((__visibility__("default"))) __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp>>>
class __attribute__((__visibility__("default"))) map {
public:

  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef pair<key_type, mapped_type> __nc_value_type;
  typedef _Compare key_compare;
  typedef _Allocator allocator_type;
  typedef value_type &reference;
  typedef const value_type &const_reference;

  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

  class __attribute__((__visibility__("default"))) value_compare
      : public binary_function<value_type, value_type, bool> {
    friend class map;

  protected:
    key_compare comp;

    __attribute__((__visibility__("hidden"), __always_inline__)) value_compare(key_compare c) : comp(c) {}

  public:
    __attribute__((__visibility__("hidden"), __always_inline__))
    bool operator()(const value_type &__x, const value_type &__y) const {
      return comp(__x.first, __y.first);
    }
  };

private:
  typedef std::__1::__value_type<key_type, mapped_type> __value_type;
  typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
  typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                         __value_type>::type __allocator_type;
  typedef __tree<__value_type, __vc, __allocator_type> __base;
  typedef typename __base::__node_traits __node_traits;
  typedef allocator_traits<allocator_type> __alloc_traits;

  __base __tree_;

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef __map_iterator<typename __base::iterator> iterator;
  typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

  __attribute__((__visibility__("hidden"), __always_inline__))
  map() noexcept(is_nothrow_default_constructible<allocator_type>::value &&is_nothrow_default_constructible<key_compare>::value &&is_nothrow_copy_constructible<key_compare>::value)


      : __tree_(__vc(key_compare())) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit map(const key_compare &__comp)
      noexcept(is_nothrow_default_constructible<allocator_type>::value &&is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__vc(__comp)) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit map(const key_compare &__comp, const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) map(_InputIterator __f, _InputIterator __l,
                                const key_compare &__comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) map(_InputIterator __f, _InputIterator __l,
                                const key_compare &__comp,
                                const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__f, __l);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  map(const map &__m) : __tree_(__m.__tree_) { insert(__m.begin(), __m.end()); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  map &operator=(const map &__m) {

    __tree_ = __m.__tree_;
    return *this;
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  map(map &&__m) noexcept(is_nothrow_move_constructible<__base>::value)
      : __tree_(std::__1::move(__m.__tree_)) {}

  map(map &&__m, const allocator_type &__a);

  __attribute__((__visibility__("hidden"), __always_inline__))
  map &operator=(map &&__m)
      noexcept(is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::__1::move(__m.__tree_);
    return *this;
  }





  __attribute__((__visibility__("hidden"), __always_inline__))
  map(initializer_list<value_type> __il,
      const key_compare &__comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  map(initializer_list<value_type> __il, const key_compare &__comp,
      const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__il.begin(), __il.end());
  }







  __attribute__((__visibility__("hidden"), __always_inline__))
  map &operator=(initializer_list<value_type> __il) {
    __tree_.__assign_unique(__il.begin(), __il.end());
    return *this;
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit map(const allocator_type &__a)
      : __tree_(typename __base::allocator_type(__a)) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  map(const map &__m, const allocator_type &__a)
      : __tree_(__m.__tree_.value_comp(),
                typename __base::allocator_type(__a)) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator begin() noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator begin() const noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator end() noexcept { return __tree_.end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator end() const noexcept { return __tree_.end(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crend() const noexcept { return rend(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool empty() const noexcept { return __tree_.size() == 0; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type size() const noexcept { return __tree_.size(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type max_size() const noexcept { return __tree_.max_size(); }

  mapped_type &operator[](const key_type &__k);

  mapped_type &operator[](key_type &&__k);


  mapped_type &at(const key_type &__k);
  const mapped_type &at(const key_type &__k) const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type get_allocator() const noexcept {
    return allocator_type(__tree_.__alloc());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  key_compare key_comp() const { return __tree_.value_comp().key_comp(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  value_compare value_comp() const {
    return value_compare(__tree_.value_comp().key_comp());
  }


  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair<iterator, bool> emplace(_Args &&... __args) {
    return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator emplace_hint(const_iterator __p,
                                                  _Args &&... __args) {
    return __tree_.__emplace_hint_unique(__p.__i_,
                                         std::__1::forward<_Args>(__args)...);
  }

  template <class _Pp, class = typename enable_if<
                           is_constructible<value_type, _Pp>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) pair<iterator, bool> insert(_Pp &&__p) {
    return __tree_.__insert_unique(std::__1::forward<_Pp>(__p));
  }

  template <class _Pp, class = typename enable_if<
                           is_constructible<value_type, _Pp>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator insert(const_iterator __pos, _Pp &&__p) {
    return __tree_.__insert_unique(__pos.__i_, std::__1::forward<_Pp>(__p));
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, bool> insert(const value_type &__v) {
    return __tree_.__insert_unique(__v);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __p, const value_type &__v) {
    return __tree_.__insert_unique(__p.__i_, __v);
  }


  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, bool> insert(value_type &&__v) {
    return __tree_.__insert_unique(std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __p, value_type &&__v) {
    return __tree_.__insert_unique(__p.__i_, std::__1::move(__v));
  }


  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) void insert(_InputIterator __f,
                                        _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      insert(__e.__i_, *__f);
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  void insert(initializer_list<value_type> __il) {
    insert(__il.begin(), __il.end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __p) { return __tree_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(iterator __p) { return __tree_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type erase(const key_type &__k) { return __tree_.__erase_unique(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __f, const_iterator __l) {
    return __tree_.erase(__f.__i_, __l.__i_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() noexcept { __tree_.clear(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(map &__m) noexcept(__is_nothrow_swappable<__base>::value) {
    __tree_.swap(__m.__tree_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator find(const key_type &__k) { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator find(const key_type &__k) const { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type count(const key_type &__k) const {
    return __tree_.__count_unique(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator lower_bound(const key_type &__k) { return __tree_.lower_bound(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator lower_bound(const key_type &__k) const {
    return __tree_.lower_bound(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator upper_bound(const key_type &__k) { return __tree_.upper_bound(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator upper_bound(const key_type &__k) const {
    return __tree_.upper_bound(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, iterator> equal_range(const key_type &__k) {
    return __tree_.__equal_range_unique(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<const_iterator, const_iterator> equal_range(const key_type &__k) const {
    return __tree_.__equal_range_unique(__k);
  }
private:
  typedef typename __base::__node __node;
  typedef typename __base::__node_allocator __node_allocator;
  typedef typename __base::__node_pointer __node_pointer;
  typedef typename __base::__node_base_pointer __node_base_pointer;

  typedef __map_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;





  __node_base_pointer const &__find_equal_key(__node_base_pointer &__parent,
                                              const key_type &__k) const;

  __attribute__((__visibility__("hidden"), __always_inline__))
  __node_base_pointer &__find_equal_key(__node_base_pointer &__parent,
                                        const key_type &__k) {
    map const *__const_this = this;
    return const_cast<__node_base_pointer &>(
        __const_this->__find_equal_key(__parent, __k));
  }
};





template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer const &
map<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(
    __node_base_pointer &__parent, const key_type &__k) const {
  __node_pointer __nd = __tree_.__root();
  if (__nd != nullptr) {
    while (true) {
      if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first)) {
        if (__nd->__left_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__left_);
        else {
          __parent = static_cast<__node_base_pointer>(__nd);
          return __parent->__left_;
        }
      } else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first,
                                                 __k)) {
        if (__nd->__right_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__right_);
        else {
          __parent = static_cast<__node_base_pointer>(__nd);
          return __parent->__right_;
        }
      } else {
        __parent = static_cast<__node_base_pointer>(__nd);
        return __parent;
      }
    }
  }
  __parent = static_cast<__node_base_pointer>(__tree_.__end_node());
  return __parent->__left_;
}



template <class _Key, class _Tp, class _Compare, class _Allocator>
map<_Key, _Tp, _Compare, _Allocator>::map(map &&__m, const allocator_type &__a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a)) {
  if (__a != __m.get_allocator()) {
    const_iterator __e = cend();
    while (!__m.empty())
      __tree_.__insert_unique(
          __e.__i_,
          std::__1::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));
  }
}
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp &map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type &__k) {
  return __tree_
      .__emplace_unique_key_args(__k, std::__1::piecewise_construct,
                                 std::__1::forward_as_tuple(__k),
                                 std::__1::forward_as_tuple())
      .first->__cc.second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp &map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type &&__k) {
  return __tree_
      .__emplace_unique_key_args(__k, std::__1::piecewise_construct,
                                 std::__1::forward_as_tuple(std::__1::move(__k)),
                                 std::__1::forward_as_tuple())
      .first->__cc.second;
}



template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp &map<_Key, _Tp, _Compare, _Allocator>::at(const key_type &__k) {
  __node_base_pointer __parent;
  __node_base_pointer &__child = __find_equal_key(__parent, __k);

  if (__child == nullptr)
    throw out_of_range("map::at:  key not found");

  return static_cast<__node_pointer>(__child)->__value_.__cc.second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp &map<_Key, _Tp, _Compare, _Allocator>::at(const key_type &__k) const {
  __node_base_pointer __parent;
  __node_base_pointer __child = __find_equal_key(__parent, __k);

  if (__child == nullptr)
    throw out_of_range("map::at:  key not found");

  return static_cast<__node_pointer>(__child)->__value_.__cc.second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return __x.size() == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const map<_Key, _Tp, _Compare, _Allocator> &__x,
          const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                        __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const map<_Key, _Tp, _Compare, _Allocator> &__x,
          const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(map<_Key, _Tp, _Compare, _Allocator> &__x,
     map<_Key, _Tp, _Compare, _Allocator> &__y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp>>>
class __attribute__((__visibility__("default"))) multimap {
public:

  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef pair<key_type, mapped_type> __nc_value_type;
  typedef _Compare key_compare;
  typedef _Allocator allocator_type;
  typedef value_type &reference;
  typedef const value_type &const_reference;

  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

  class __attribute__((__visibility__("default"))) value_compare
      : public binary_function<value_type, value_type, bool> {
    friend class multimap;

  protected:
    key_compare comp;

    __attribute__((__visibility__("hidden"), __always_inline__))
    value_compare(key_compare c) : comp(c) {}

  public:
    __attribute__((__visibility__("hidden"), __always_inline__))
    bool operator()(const value_type &__x, const value_type &__y) const {
      return comp(__x.first, __y.first);
    }
  };

private:
  typedef std::__1::__value_type<key_type, mapped_type> __value_type;
  typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
  typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                         __value_type>::type __allocator_type;
  typedef __tree<__value_type, __vc, __allocator_type> __base;
  typedef typename __base::__node_traits __node_traits;
  typedef allocator_traits<allocator_type> __alloc_traits;

  __base __tree_;

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef __map_iterator<typename __base::iterator> iterator;
  typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

  __attribute__((__visibility__("hidden"), __always_inline__))
  multimap()
      noexcept(is_nothrow_default_constructible<allocator_type>::value &&is_nothrow_default_constructible<key_compare>::value &&is_nothrow_copy_constructible<key_compare>::value)


      : __tree_(__vc(key_compare())) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit multimap(const key_compare &__comp)
      noexcept(is_nothrow_default_constructible<allocator_type>::value &&is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__vc(__comp)) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit multimap(const key_compare &__comp, const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) multimap(_InputIterator __f, _InputIterator __l,
                                     const key_compare &__comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) multimap(_InputIterator __f, _InputIterator __l,
                                     const key_compare &__comp,
                                     const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__f, __l);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  multimap(const multimap &__m)
      : __tree_(__m.__tree_.value_comp(),
                __alloc_traits::select_on_container_copy_construction(
                    __m.__tree_.__alloc())) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  multimap &operator=(const multimap &__m) {

    __tree_ = __m.__tree_;
    return *this;
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  multimap(multimap &&__m)
      noexcept(is_nothrow_move_constructible<__base>::value)
      : __tree_(std::__1::move(__m.__tree_)) {}

  multimap(multimap &&__m, const allocator_type &__a);

  __attribute__((__visibility__("hidden"), __always_inline__))
  multimap &operator=(multimap &&__m)
      noexcept(is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::__1::move(__m.__tree_);
    return *this;
  }





  __attribute__((__visibility__("hidden"), __always_inline__))
  multimap(initializer_list<value_type> __il,
           const key_compare &__comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  multimap(initializer_list<value_type> __il, const key_compare &__comp,
           const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__il.begin(), __il.end());
  }







  __attribute__((__visibility__("hidden"), __always_inline__))
  multimap &operator=(initializer_list<value_type> __il) {
    __tree_.__assign_multi(__il.begin(), __il.end());
    return *this;
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  explicit multimap(const allocator_type &__a)
      : __tree_(typename __base::allocator_type(__a)) {}

  __attribute__((__visibility__("hidden"), __always_inline__))
  multimap(const multimap &__m, const allocator_type &__a)
      : __tree_(__m.__tree_.value_comp(),
                typename __base::allocator_type(__a)) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator begin() noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator begin() const noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator end() noexcept { return __tree_.end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator end() const noexcept { return __tree_.end(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_reverse_iterator crend() const noexcept { return rend(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  bool empty() const noexcept { return __tree_.size() == 0; }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type size() const noexcept { return __tree_.size(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type max_size() const noexcept { return __tree_.max_size(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  allocator_type get_allocator() const noexcept {
    return allocator_type(__tree_.__alloc());
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  key_compare key_comp() const { return __tree_.value_comp().key_comp(); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  value_compare value_comp() const {
    return value_compare(__tree_.value_comp().key_comp());
  }



  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator emplace(_Args &&... __args) {
    return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator emplace_hint(const_iterator __p,
                                                  _Args &&... __args) {
    return __tree_.__emplace_hint_multi(__p.__i_,
                                        std::__1::forward<_Args>(__args)...);
  }

  template <class _Pp, class = typename enable_if<
                           is_constructible<value_type, _Pp>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator insert(_Pp &&__p) {
    return __tree_.__insert_multi(std::__1::forward<_Pp>(__p));
  }

  template <class _Pp, class = typename enable_if<
                           is_constructible<value_type, _Pp>::value>::type>
  __attribute__((__visibility__("hidden"), __always_inline__)) iterator insert(const_iterator __pos, _Pp &&__p) {
    return __tree_.__insert_multi(__pos.__i_, std::__1::forward<_Pp>(__p));
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(value_type &&__v) {
    return __tree_.__insert_multi(std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __p, value_type &&__v) {
    return __tree_.__insert_multi(__p.__i_, std::__1::move(__v));
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const value_type &__v) { return __tree_.__insert_multi(__v); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator insert(const_iterator __p, const value_type &__v) {
    return __tree_.__insert_multi(__p.__i_, __v);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"), __always_inline__)) void insert(_InputIterator __f,
                                        _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      __tree_.__insert_multi(__e.__i_, *__f);
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  void insert(initializer_list<value_type> __il) {
    insert(__il.begin(), __il.end());
  }



  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __p) { return __tree_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(iterator __p) { return __tree_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type erase(const key_type &__k) { return __tree_.__erase_multi(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator erase(const_iterator __f, const_iterator __l) {
    return __tree_.erase(__f.__i_, __l.__i_);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  void clear() { __tree_.clear(); }

  __attribute__((__visibility__("hidden"), __always_inline__))
  void swap(multimap &__m) noexcept(__is_nothrow_swappable<__base>::value) {
    __tree_.swap(__m.__tree_);
  }

  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator find(const key_type &__k) { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator find(const key_type &__k) const { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  size_type count(const key_type &__k) const {
    return __tree_.__count_multi(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator lower_bound(const key_type &__k) { return __tree_.lower_bound(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator lower_bound(const key_type &__k) const {
    return __tree_.lower_bound(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  iterator upper_bound(const key_type &__k) { return __tree_.upper_bound(__k); }
  __attribute__((__visibility__("hidden"), __always_inline__))
  const_iterator upper_bound(const key_type &__k) const {
    return __tree_.upper_bound(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<iterator, iterator> equal_range(const key_type &__k) {
    return __tree_.__equal_range_multi(__k);
  }
  __attribute__((__visibility__("hidden"), __always_inline__))
  pair<const_iterator, const_iterator> equal_range(const key_type &__k) const {
    return __tree_.__equal_range_multi(__k);
  }
private:
  typedef typename __base::__node __node;
  typedef typename __base::__node_allocator __node_allocator;
  typedef typename __base::__node_pointer __node_pointer;

  typedef __map_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;
};


template <class _Key, class _Tp, class _Compare, class _Allocator>
multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap &&__m,
                                                    const allocator_type &__a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a)) {
  if (__a != __m.get_allocator()) {
    const_iterator __e = cend();
    while (!__m.empty())
      __tree_.__insert_multi(
          __e.__i_,
          std::__1::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__nc));
  }
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return __x.size() == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
          const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                        __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
          const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"), __always_inline__)) void
swap(multimap<_Key, _Tp, _Compare, _Allocator> &__x,
     multimap<_Key, _Tp, _Compare, _Allocator> &__y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

} }
















namespace v8 {
namespace internal {
enum BailoutReason {
  kNoReason, k32BitValueInRegisterIsNotZeroExtended, kAllocationIsNotDoubleAligned, kAPICallReturnedInvalidObject, kArgumentsObjectValueInATestContext, kArrayBoilerplateCreationFailed, kArrayIndexConstantValueTooBig, kAssignmentToArguments, kAssignmentToLetVariableBeforeInitialization, kAssignmentToLOOKUPVariable, kAssignmentToParameterFunctionUsesArgumentsObject, kAssignmentToParameterInArgumentsObject, kBadValueContextForArgumentsObjectValue, kBadValueContextForArgumentsValue, kBailedOutDueToDependencyChange, kBailoutWasNotPrepared, kBothRegistersWereSmisInSelectNonSmi, kClassLiteral, kCodeGenerationFailed, kCodeObjectNotProperlyPatched, kCompoundAssignmentToLookupSlot, kComputedPropertyName, kContextAllocatedArguments, kCopyBuffersOverlap, kCouldNotGenerateZero, kCouldNotGenerateNegativeZero, kDebuggerStatement, kDeclarationInCatchContext, kDeclarationInWithContext, kDefaultNaNModeNotSet, kDeleteWithGlobalVariable, kDeleteWithNonGlobalVariable, kDestinationOfCopyNotAligned, kDontDeleteCellsCannotContainTheHole, kDoExpressionUnmodelable, kDoPushArgumentNotImplementedForDoubleType, kEliminatedBoundsCheckFailed, kEmitLoadRegisterUnsupportedDoubleImmediate, kEval, kExpectedAlignmentMarker, kExpectedAllocationSite, kExpectedFunctionObject, kExpectedHeapNumber, kExpectedNativeContext, kExpectedNonIdenticalObjects, kExpectedNonNullContext, kExpectedPositiveZero, kExpectedNewSpaceObject, kExpectedUndefinedOrCell, kExpectingAlignmentForCopyBytes, kExportDeclaration, kExternalStringExpectedButNotFound, kForInStatementWithNonLocalEachVariable, kForOfStatement, kFrameIsExpectedToBeAligned, kFunctionBeingDebugged, kFunctionCallsEval, kFunctionDataShouldBeBytecodeArrayOnInterpreterEntry, kGeneratedCodeIsTooLarge, kGeneratorFailedToResume, kGeneratorResumeMethod, kGenerator, kGlobalFunctionsMustHaveInitialMap, kHeapNumberMapRegisterClobbered, kHydrogenFilter, kImportDeclaration, kIndexIsNegative, kIndexIsTooLarge, kInliningBailedOut, kInputGPRIsExpectedToHaveUpper32Cleared, kInputStringTooLong, kInteger32ToSmiFieldWritingToNonSmiLocation, kInvalidBytecode, kInvalidCaptureReferenced, kInvalidElementsKindForInternalArrayOrInternalPackedArray, kInvalidFullCodegenState, kInvalidHandleScopeLevel, kInvalidLeftHandSideInAssignment, kInvalidLhsInCompoundAssignment, kInvalidLhsInCountOperation, kInvalidMinLength, kJSGlobalObjectNativeContextShouldBeANativeContext, kJSGlobalProxyContextShouldNotBeNull, kJSObjectWithFastElementsMapHasSlowElements, kLetBindingReInitialization, kLiveBytesCountOverflowChunkSize, kLiveEdit, kLookupVariableInCountOperation, kMapBecameDeprecated, kMapBecameUnstable, kNativeFunctionLiteral, kNeedSmiLiteral, kNoCasesLeft, kNonInitializerAssignmentToConst, kNonSmiIndex, kNonSmiKeyInArrayLiteral, kNonSmiValue, kNonObject, kNotEnoughVirtualRegistersForValues, kNotEnoughSpillSlotsForOsr, kNotEnoughVirtualRegistersRegalloc, kObjectFoundInSmiOnlyArray, kObjectLiteralWithComplexProperty, kOffsetOutOfRange, kOperandIsANumber, kOperandIsASmiAndNotABoundFunction, kOperandIsASmiAndNotAFunction, kOperandIsASmiAndNotAName, kOperandIsASmiAndNotAReceiver, kOperandIsASmiAndNotAString, kOperandIsASmi, kOperandIsNotADate, kOperandIsNotABoundFunction, kOperandIsNotAFunction, kOperandIsNotAName, kOperandIsNotANumber, kOperandIsNotAReceiver, kOperandIsNotASmi, kOperandIsNotAString, kOperandIsNotSmi, kOperandNotANumber, kObjectTagged, kObjectNotTagged, kOptimizationDisabled, kOptimizedTooManyTimes, kOutOfVirtualRegistersWhileTryingToAllocateTempRegister, kParseScopeError, kPossibleDirectCallToEval, kReceivedInvalidReturnAddress, kReferenceToAVariableWhichRequiresDynamicLookup, kReferenceToGlobalLexicalVariable, kReferenceToUninitializedVariable, kRegisterDidNotMatchExpectedRoot, kRegisterWasClobbered, kRememberedSetPointerInNewSpace, kRestParameter, kReturnAddressNotFoundInFrame, kSloppyFunctionExpectsJSReceiverReceiver, kSmiAdditionOverflow, kSmiSubtractionOverflow, kStackAccessBelowStackPointer, kStackFrameTypesMustMatch, kSuperReference, kTailCall, kTheCurrentStackPointerIsBelowCsp, kTheSourceAndDestinationAreTheSame, kTheStackWasCorruptedByMacroAssemblerCall, kTooManyParametersLocals, kTooManyParameters, kTooManySpillSlotsNeededForOSR, kToOperand32UnsupportedImmediate, kToOperandIsDoubleRegisterUnimplemented, kToOperandUnsupportedDoubleImmediate, kTryCatchStatement, kTryFinallyStatement, kUnalignedAllocationInNewSpace, kUnalignedCellInWriteBarrier, kUnexpectedAllocationTop, kUnexpectedColorFound, kUnexpectedElementsKindInArrayConstructor, kUnexpectedFallthroughFromCharCodeAtSlowCase, kUnexpectedFallthroughFromCharFromCodeSlowCase, kUnexpectedFallThroughFromStringComparison, kUnexpectedFallthroughToCharCodeAtSlowCase, kUnexpectedFallthroughToCharFromCodeSlowCase, kUnexpectedFPUStackDepthAfterInstruction, kUnexpectedInitialMapForArrayFunction1, kUnexpectedInitialMapForArrayFunction2, kUnexpectedInitialMapForArrayFunction, kUnexpectedInitialMapForInternalArrayFunction, kUnexpectedLevelAfterReturnFromApiCall, kUnexpectedNegativeValue, kUnexpectedNumberOfPreAllocatedPropertyFields, kUnexpectedFunctionIDForInvokeIntrinsic, kUnexpectedFPCRMode, kUnexpectedSmi, kUnexpectedStackDepth, kUnexpectedStackPointer, kUnexpectedStringType, kUnexpectedTypeForRegExpDataFixedArrayExpected, kUnexpectedValue, kUnsupportedConstCompoundAssignment, kUnsupportedCountOperationWithConst, kUnsupportedDoubleImmediate, kUnsupportedLetCompoundAssignment, kUnsupportedLookupSlotInDeclaration, kUnsupportedNonPrimitiveCompare, kUnsupportedPhiUseOfArguments, kUnsupportedPhiUseOfConstVariable, kUnexpectedReturnFromBytecodeHandler, kUnexpectedReturnFromThrow, kUnsupportedSwitchStatement, kUnsupportedTaggedImmediate, kVariableResolvedToWithContext, kWeShouldNotHaveAnEmptyLexicalContext, kWithStatement, kWrongFunctionContext, kWrongAddressOrValuePassedToRecordWrite, kWrongArgumentCountForInvokeIntrinsic, kShouldNotDirectlyEnterOsrFunction, kYield, kLastErrorMessage
};



const char* GetBailoutReason(BailoutReason reason);

}
}


namespace v8 {
namespace base {

template <typename Deallocator, typename T>
class SmartPointerBase {
 public:

  SmartPointerBase() : p_(0) {}


  explicit SmartPointerBase(T* ptr) : p_(ptr) {}



  SmartPointerBase(const SmartPointerBase<Deallocator, T>& rhs) : p_(rhs.p_) {
    const_cast<SmartPointerBase<Deallocator, T>&>(rhs).p_ = 0;
  }

  T* operator->() const { return p_; }

  T& operator*() const { return *p_; }

  T* get() const { return p_; }


  T& operator[](size_t i) { return p_[i]; }


  const T& operator[](size_t i) const { return p_[i]; }
  T* Detach() {
    T* temp = p_;
    p_ = 0;
    return temp;
  }

  void Reset(T* new_value) {
    do { if ((!(p_ == 0 || p_ != new_value))) { V8_Fatal(".././src/base/smart-pointers.h", 55, "Check failed: %s.", "p_ == 0 || p_ != new_value"); } } while (0);
    if (p_) Deallocator::Delete(p_);
    p_ = new_value;
  }




  SmartPointerBase<Deallocator, T>& operator=(
      const SmartPointerBase<Deallocator, T>& rhs) {
    do { if ((!(is_empty()))) { V8_Fatal(".././src/base/smart-pointers.h", 65, "Check failed: %s.", "is_empty()"); } } while (0);
    T* tmp = rhs.p_;
    const_cast<SmartPointerBase<Deallocator, T>&>(rhs).p_ = 0;
    p_ = tmp;
    return *this;
  }

  bool is_empty() const { return p_ == 0; }

 protected:



  ~SmartPointerBase() {
    if (p_) Deallocator::Delete(p_);
  }

 private:
  T* p_;
};




template <typename T>
struct ArrayDeallocator {
  static void Delete(T* array) { delete[] array; }
};


template <typename T>
class SmartArrayPointer : public SmartPointerBase<ArrayDeallocator<T>, T> {
 public:
  SmartArrayPointer() {}
  explicit SmartArrayPointer(T* ptr)
      : SmartPointerBase<ArrayDeallocator<T>, T>(ptr) {}
  SmartArrayPointer(const SmartArrayPointer<T>& rhs)
      : SmartPointerBase<ArrayDeallocator<T>, T>(rhs) {}
};


template <typename T>
struct ObjectDeallocator {
  static void Delete(T* object) { delete object; }
};

template <typename T>
class SmartPointer : public SmartPointerBase<ObjectDeallocator<T>, T> {
 public:
  SmartPointer() {}
  explicit SmartPointer(T* ptr)
      : SmartPointerBase<ObjectDeallocator<T>, T>(ptr) {}
  SmartPointer(const SmartPointer<T>& rhs)
      : SmartPointerBase<ObjectDeallocator<T>, T>(rhs) {}
};

}
}


namespace v8 {
namespace internal {

enum ElementsKind {


  FAST_SMI_ELEMENTS,
  FAST_HOLEY_SMI_ELEMENTS,




  FAST_ELEMENTS,
  FAST_HOLEY_ELEMENTS,


  FAST_DOUBLE_ELEMENTS,
  FAST_HOLEY_DOUBLE_ELEMENTS,


  DICTIONARY_ELEMENTS,


  FAST_SLOPPY_ARGUMENTS_ELEMENTS,
  SLOW_SLOPPY_ARGUMENTS_ELEMENTS,



  FAST_STRING_WRAPPER_ELEMENTS,
  SLOW_STRING_WRAPPER_ELEMENTS,


  UINT8_ELEMENTS,
  INT8_ELEMENTS,
  UINT16_ELEMENTS,
  INT16_ELEMENTS,
  UINT32_ELEMENTS,
  INT32_ELEMENTS,
  FLOAT32_ELEMENTS,
  FLOAT64_ELEMENTS,
  UINT8_CLAMPED_ELEMENTS,


  NO_ELEMENTS,


  FIRST_ELEMENTS_KIND = FAST_SMI_ELEMENTS,
  LAST_ELEMENTS_KIND = UINT8_CLAMPED_ELEMENTS,
  FIRST_FAST_ELEMENTS_KIND = FAST_SMI_ELEMENTS,
  LAST_FAST_ELEMENTS_KIND = FAST_HOLEY_DOUBLE_ELEMENTS,
  FIRST_FIXED_TYPED_ARRAY_ELEMENTS_KIND = UINT8_ELEMENTS,
  LAST_FIXED_TYPED_ARRAY_ELEMENTS_KIND = UINT8_CLAMPED_ELEMENTS,
  TERMINAL_FAST_ELEMENTS_KIND = FAST_HOLEY_ELEMENTS
};

const int kElementsKindCount = LAST_ELEMENTS_KIND - FIRST_ELEMENTS_KIND + 1;
const int kFastElementsKindCount = LAST_FAST_ELEMENTS_KIND -
    FIRST_FAST_ELEMENTS_KIND + 1;


const int kFastElementsKindPackedToHoley =
    FAST_HOLEY_SMI_ELEMENTS - FAST_SMI_ELEMENTS;

int ElementsKindToShiftSize(ElementsKind elements_kind);
int GetDefaultHeaderSizeForElementsKind(ElementsKind elements_kind);
const char* ElementsKindToString(ElementsKind kind);

inline ElementsKind GetInitialFastElementsKind() { return FAST_SMI_ELEMENTS; }

ElementsKind GetFastElementsKindFromSequenceIndex(int sequence_number);
int GetSequenceIndexFromFastElementsKind(ElementsKind elements_kind);

ElementsKind GetNextTransitionElementsKind(ElementsKind elements_kind);

inline bool IsDictionaryElementsKind(ElementsKind kind) {
  return kind == DICTIONARY_ELEMENTS;
}


inline bool IsSloppyArgumentsElements(ElementsKind kind) {
  return kind == FAST_SLOPPY_ARGUMENTS_ELEMENTS ||
         kind == SLOW_SLOPPY_ARGUMENTS_ELEMENTS;
}

inline bool IsStringWrapperElementsKind(ElementsKind kind) {
  return kind == FAST_STRING_WRAPPER_ELEMENTS ||
         kind == SLOW_STRING_WRAPPER_ELEMENTS;
}

inline bool IsFixedTypedArrayElementsKind(ElementsKind kind) {
  return kind >= FIRST_FIXED_TYPED_ARRAY_ELEMENTS_KIND &&
         kind <= LAST_FIXED_TYPED_ARRAY_ELEMENTS_KIND;
}


inline bool IsTerminalElementsKind(ElementsKind kind) {
  return kind == TERMINAL_FAST_ELEMENTS_KIND ||
         IsFixedTypedArrayElementsKind(kind);
}


inline bool IsFastElementsKind(ElementsKind kind) {
  static_assert(FIRST_FAST_ELEMENTS_KIND == 0, "FIRST_FAST_ELEMENTS_KIND == 0");
  return kind <= FAST_HOLEY_DOUBLE_ELEMENTS;
}


inline bool IsTransitionElementsKind(ElementsKind kind) {
  return IsFastElementsKind(kind) || IsFixedTypedArrayElementsKind(kind) ||
         kind == FAST_SLOPPY_ARGUMENTS_ELEMENTS ||
         kind == FAST_STRING_WRAPPER_ELEMENTS;
}


inline bool IsFastDoubleElementsKind(ElementsKind kind) {
  return kind == FAST_DOUBLE_ELEMENTS ||
      kind == FAST_HOLEY_DOUBLE_ELEMENTS;
}


inline bool IsFixedFloatElementsKind(ElementsKind kind) {
  return kind == FLOAT32_ELEMENTS || kind == FLOAT64_ELEMENTS;
}


inline bool IsDoubleOrFloatElementsKind(ElementsKind kind) {
  return IsFastDoubleElementsKind(kind) || IsFixedFloatElementsKind(kind);
}


inline bool IsFastSmiOrObjectElementsKind(ElementsKind kind) {
  return kind == FAST_SMI_ELEMENTS ||
      kind == FAST_HOLEY_SMI_ELEMENTS ||
      kind == FAST_ELEMENTS ||
      kind == FAST_HOLEY_ELEMENTS;
}


inline bool IsFastSmiElementsKind(ElementsKind kind) {
  return kind == FAST_SMI_ELEMENTS ||
      kind == FAST_HOLEY_SMI_ELEMENTS;
}


inline bool IsFastObjectElementsKind(ElementsKind kind) {
  return kind == FAST_ELEMENTS ||
      kind == FAST_HOLEY_ELEMENTS;
}


inline bool IsFastHoleyElementsKind(ElementsKind kind) {
  return kind == FAST_HOLEY_SMI_ELEMENTS ||
      kind == FAST_HOLEY_DOUBLE_ELEMENTS ||
      kind == FAST_HOLEY_ELEMENTS;
}


inline bool IsHoleyElementsKind(ElementsKind kind) {
  return IsFastHoleyElementsKind(kind) ||
      kind == DICTIONARY_ELEMENTS;
}


inline bool IsFastPackedElementsKind(ElementsKind kind) {
  return kind == FAST_SMI_ELEMENTS || kind == FAST_DOUBLE_ELEMENTS ||
         kind == FAST_ELEMENTS;
}


inline ElementsKind GetPackedElementsKind(ElementsKind holey_kind) {
  if (holey_kind == FAST_HOLEY_SMI_ELEMENTS) {
    return FAST_SMI_ELEMENTS;
  }
  if (holey_kind == FAST_HOLEY_DOUBLE_ELEMENTS) {
    return FAST_DOUBLE_ELEMENTS;
  }
  if (holey_kind == FAST_HOLEY_ELEMENTS) {
    return FAST_ELEMENTS;
  }
  return holey_kind;
}


inline ElementsKind GetHoleyElementsKind(ElementsKind packed_kind) {
  if (packed_kind == FAST_SMI_ELEMENTS) {
    return FAST_HOLEY_SMI_ELEMENTS;
  }
  if (packed_kind == FAST_DOUBLE_ELEMENTS) {
    return FAST_HOLEY_DOUBLE_ELEMENTS;
  }
  if (packed_kind == FAST_ELEMENTS) {
    return FAST_HOLEY_ELEMENTS;
  }
  return packed_kind;
}


inline ElementsKind FastSmiToObjectElementsKind(ElementsKind from_kind) {
  do { if ((!(IsFastSmiElementsKind(from_kind)))) { V8_Fatal(".././src/elements-kind.h", 209, "Check failed: %s.", "IsFastSmiElementsKind(from_kind)"); } } while (0);
  return (from_kind == FAST_SMI_ELEMENTS)
      ? FAST_ELEMENTS
      : FAST_HOLEY_ELEMENTS;
}


inline bool IsSimpleMapChangeTransition(ElementsKind from_kind,
                                        ElementsKind to_kind) {
  return (GetHoleyElementsKind(from_kind) == to_kind) ||
      (IsFastSmiElementsKind(from_kind) &&
       IsFastObjectElementsKind(to_kind));
}


bool IsMoreGeneralElementsKindTransition(ElementsKind from_kind,
                                         ElementsKind to_kind);


inline ElementsKind GetMoreGeneralElementsKind(ElementsKind from_kind,
                                               ElementsKind to_kind) {
  if (IsMoreGeneralElementsKindTransition(from_kind, to_kind)) {
    return to_kind;
  }
  return from_kind;
}


inline bool IsTransitionableFastElementsKind(ElementsKind from_kind) {
  return IsFastElementsKind(from_kind) &&
      from_kind != TERMINAL_FAST_ELEMENTS_KIND;
}


}
}







namespace v8 {
namespace internal {


enum PropertyAttributes {
  NONE = ::v8::None,
  READ_ONLY = ::v8::ReadOnly,
  DONT_ENUM = ::v8::DontEnum,
  DONT_DELETE = ::v8::DontDelete,

  ALL_ATTRIBUTES_MASK = READ_ONLY | DONT_ENUM | DONT_DELETE,

  SEALED = DONT_DELETE,
  FROZEN = SEALED | READ_ONLY,

  ABSENT = 64,







  EVAL_DECLARED = 128
};


enum PropertyFilter {
  ALL_PROPERTIES = 0,
  ONLY_WRITABLE = 1,
  ONLY_ENUMERABLE = 2,
  ONLY_CONFIGURABLE = 4,
  SKIP_STRINGS = 8,
  SKIP_SYMBOLS = 16,
  ONLY_ALL_CAN_READ = 32,
  ENUMERABLE_STRINGS = ONLY_ENUMERABLE | SKIP_SYMBOLS,
};

static_assert(ALL_PROPERTIES == static_cast<PropertyFilter>(NONE), "ALL_PROPERTIES == static_cast<PropertyFilter>(NONE)");
static_assert(ONLY_WRITABLE == static_cast<PropertyFilter>(READ_ONLY), "ONLY_WRITABLE == static_cast<PropertyFilter>(READ_ONLY)");
static_assert(ONLY_ENUMERABLE == static_cast<PropertyFilter>(DONT_ENUM), "ONLY_ENUMERABLE == static_cast<PropertyFilter>(DONT_ENUM)");
static_assert(ONLY_CONFIGURABLE == static_cast<PropertyFilter>(DONT_DELETE), "ONLY_CONFIGURABLE == static_cast<PropertyFilter>(DONT_DELETE)");
static_assert(((SKIP_STRINGS | SKIP_SYMBOLS | ONLY_ALL_CAN_READ) & ALL_ATTRIBUTES_MASK) == 0, "((SKIP_STRINGS | SKIP_SYMBOLS | ONLY_ALL_CAN_READ) & ALL_ATTRIBUTES_MASK) == 0");



class Smi;
class Type;
class TypeInfo;




enum PropertyKind { kData = 0, kAccessor = 1 };




enum PropertyLocation { kField = 0, kDescriptor = 1 };





enum PropertyType {
  DATA = (kField << 1) | kData,
  DATA_CONSTANT = (kDescriptor << 1) | kData,
  ACCESSOR = (kField << 1) | kAccessor,
  ACCESSOR_CONSTANT = (kDescriptor << 1) | kAccessor
};


class Representation {
 public:
  enum Kind {
    kNone,
    kInteger8,
    kUInteger8,
    kInteger16,
    kUInteger16,
    kSmi,
    kInteger32,
    kDouble,
    kHeapObject,
    kTagged,
    kExternal,
    kNumRepresentations
  };

  Representation() : kind_(kNone) { }

  static Representation None() { return Representation(kNone); }
  static Representation Tagged() { return Representation(kTagged); }
  static Representation Integer8() { return Representation(kInteger8); }
  static Representation UInteger8() { return Representation(kUInteger8); }
  static Representation Integer16() { return Representation(kInteger16); }
  static Representation UInteger16() { return Representation(kUInteger16); }
  static Representation Smi() { return Representation(kSmi); }
  static Representation Integer32() { return Representation(kInteger32); }
  static Representation Double() { return Representation(kDouble); }
  static Representation HeapObject() { return Representation(kHeapObject); }
  static Representation External() { return Representation(kExternal); }

  static Representation FromKind(Kind kind) { return Representation(kind); }

  bool Equals(const Representation& other) const {
    return kind_ == other.kind_;
  }

  bool IsCompatibleForLoad(const Representation& other) const {
    return (IsDouble() && other.IsDouble()) ||
        (!IsDouble() && !other.IsDouble());
  }

  bool IsCompatibleForStore(const Representation& other) const {
    return Equals(other);
  }

  bool is_more_general_than(const Representation& other) const {
    if (kind_ == kExternal && other.kind_ == kNone) return true;
    if (kind_ == kExternal && other.kind_ == kExternal) return false;
    if (kind_ == kNone && other.kind_ == kExternal) return false;

    do { if ((!(kind_ != kExternal))) { V8_Fatal(".././src/property-details.h", 135, "Check failed: %s.", "kind_ != kExternal"); } } while (0);
    do { if ((!(other.kind_ != kExternal))) { V8_Fatal(".././src/property-details.h", 136, "Check failed: %s.", "other.kind_ != kExternal"); } } while (0);
    if (IsHeapObject()) return other.IsNone();
    if (kind_ == kUInteger8 && other.kind_ == kInteger8) return false;
    if (kind_ == kUInteger16 && other.kind_ == kInteger16) return false;
    return kind_ > other.kind_;
  }

  bool fits_into(const Representation& other) const {
    return other.is_more_general_than(*this) || other.Equals(*this);
  }

  Representation generalize(Representation other) {
    if (other.fits_into(*this)) return *this;
    if (other.is_more_general_than(*this)) return other;
    return Representation::Tagged();
  }

  int size() const {
    do { if ((!(!IsNone()))) { V8_Fatal(".././src/property-details.h", 154, "Check failed: %s.", "!IsNone()"); } } while (0);
    if (IsInteger8() || IsUInteger8()) {
      return sizeof(uint8_t);
    }
    if (IsInteger16() || IsUInteger16()) {
      return sizeof(uint16_t);
    }
    if (IsInteger32()) {
      return sizeof(uint32_t);
    }
    return kPointerSize;
  }

  Kind kind() const { return static_cast<Kind>(kind_); }
  bool IsNone() const { return kind_ == kNone; }
  bool IsInteger8() const { return kind_ == kInteger8; }
  bool IsUInteger8() const { return kind_ == kUInteger8; }
  bool IsInteger16() const { return kind_ == kInteger16; }
  bool IsUInteger16() const { return kind_ == kUInteger16; }
  bool IsTagged() const { return kind_ == kTagged; }
  bool IsSmi() const { return kind_ == kSmi; }
  bool IsSmiOrTagged() const { return IsSmi() || IsTagged(); }
  bool IsInteger32() const { return kind_ == kInteger32; }
  bool IsSmiOrInteger32() const { return IsSmi() || IsInteger32(); }
  bool IsDouble() const { return kind_ == kDouble; }
  bool IsHeapObject() const { return kind_ == kHeapObject; }
  bool IsExternal() const { return kind_ == kExternal; }
  bool IsSpecialization() const {
    return IsInteger8() || IsUInteger8() ||
      IsInteger16() || IsUInteger16() ||
      IsSmi() || IsInteger32() || IsDouble();
  }
  const char* Mnemonic() const;

 private:
  explicit Representation(Kind k) : kind_(k) { }


  static_assert(kNumRepresentations <= (1 << kBitsPerByte), "kNumRepresentations <= (1 << kBitsPerByte)");

  int8_t kind_;
};


static const int kDescriptorIndexBitCount = 10;


static const int kMaxNumberOfDescriptors =
    (1 << kDescriptorIndexBitCount) - 2;
static const int kInvalidEnumCacheSentinel =
    (1 << kDescriptorIndexBitCount) - 1;


enum class PropertyCellType {

  kUndefined,
  kConstant,
  kConstantType,
  kMutable,


  kUninitialized = kUndefined,
  kInvalidated = kConstant,


  kNoCell = kMutable,
};


enum class PropertyCellConstantType {
  kSmi,
  kStableMap,
};




class PropertyDetails : public Embedded {
 public:
  PropertyDetails(PropertyAttributes attributes, PropertyType type, int index,
                  PropertyCellType cell_type) {
    value_ = TypeField::encode(type) | AttributesField::encode(attributes) |
             DictionaryStorageField::encode(index) |
             PropertyCellTypeField::encode(cell_type);

    do { if ((!(type == this->type()))) { V8_Fatal(".././src/property-details.h", 239, "Check failed: %s.", "type == this->type()"); } } while (0);
    do { if ((!(attributes == this->attributes()))) { V8_Fatal(".././src/property-details.h", 240, "Check failed: %s.", "attributes == this->attributes()"); } } while (0);
  }

  PropertyDetails(PropertyAttributes attributes,
                  PropertyType type,
                  Representation representation,
                  int field_index = 0) {
    value_ = TypeField::encode(type)
        | AttributesField::encode(attributes)
        | RepresentationField::encode(EncodeRepresentation(representation))
        | FieldIndexField::encode(field_index);
  }

  PropertyDetails(PropertyAttributes attributes, PropertyKind kind,
                  PropertyLocation location, Representation representation,
                  int field_index = 0) {
    value_ = KindField::encode(kind) | LocationField::encode(location) |
             AttributesField::encode(attributes) |
             RepresentationField::encode(EncodeRepresentation(representation)) |
             FieldIndexField::encode(field_index);
  }

  static PropertyDetails Empty() {
    return PropertyDetails(NONE, DATA, 0, PropertyCellType::kNoCell);
  }

  int pointer() const { return DescriptorPointer::decode(value_); }

  PropertyDetails set_pointer(int i) const {
    return PropertyDetails(value_, i);
  }

  PropertyDetails set_cell_type(PropertyCellType type) const {
    PropertyDetails details = *this;
    details.value_ = PropertyCellTypeField::update(details.value_, type);
    return details;
  }

  PropertyDetails set_index(int index) const {
    PropertyDetails details = *this;
    details.value_ = DictionaryStorageField::update(details.value_, index);
    return details;
  }

  PropertyDetails CopyWithRepresentation(Representation representation) const {
    return PropertyDetails(value_, representation);
  }
  PropertyDetails CopyAddAttributes(PropertyAttributes new_attributes) const {
    new_attributes =
        static_cast<PropertyAttributes>(attributes() | new_attributes);
    return PropertyDetails(value_, new_attributes);
  }


  explicit inline PropertyDetails(Smi* smi);
  inline Smi* AsSmi() const;

  static uint8_t EncodeRepresentation(Representation representation) {
    return representation.kind();
  }

  static Representation DecodeRepresentation(uint32_t bits) {
    return Representation::FromKind(static_cast<Representation::Kind>(bits));
  }

  PropertyKind kind() const { return KindField::decode(value_); }
  PropertyLocation location() const { return LocationField::decode(value_); }

  PropertyType type() const { return TypeField::decode(value_); }

  PropertyAttributes attributes() const {
    return AttributesField::decode(value_);
  }

  int dictionary_index() const {
    return DictionaryStorageField::decode(value_);
  }

  Representation representation() const {
    return DecodeRepresentation(RepresentationField::decode(value_));
  }

  int field_index() const { return FieldIndexField::decode(value_); }

  inline int field_width_in_words() const;

  static bool IsValidIndex(int index) {
    return DictionaryStorageField::is_valid(index);
  }

  bool IsReadOnly() const { return (attributes() & READ_ONLY) != 0; }
  bool IsConfigurable() const { return (attributes() & DONT_DELETE) == 0; }
  bool IsDontEnum() const { return (attributes() & DONT_ENUM) != 0; }
  bool IsEnumerable() const { return !IsDontEnum(); }
  PropertyCellType cell_type() const {
    return PropertyCellTypeField::decode(value_);
  }



  class KindField : public BitField<PropertyKind, 0, 1> {};
  class LocationField : public BitField<PropertyLocation, 1, 1> {};
  class AttributesField : public BitField<PropertyAttributes, 2, 3> {};
  static const int kAttributesReadOnlyMask =
      (READ_ONLY << AttributesField::kShift);


  class PropertyCellTypeField : public BitField<PropertyCellType, 5, 2> {};
  class DictionaryStorageField : public BitField<uint32_t, 7, 24> {};


  class RepresentationField : public BitField<uint32_t, 5, 4> {};
  class DescriptorPointer
      : public BitField<uint32_t, 9, kDescriptorIndexBitCount> {};
  class FieldIndexField
      : public BitField<uint32_t, 9 + kDescriptorIndexBitCount,
                        kDescriptorIndexBitCount> {};


  class TypeField : public BitField<PropertyType, 0, 2> {};
  static_assert(KindField::kNext == LocationField::kShift, "KindField::kNext == LocationField::kShift");
  static_assert(TypeField::kShift == KindField::kShift, "TypeField::kShift == KindField::kShift");
  static_assert(TypeField::kNext == LocationField::kNext, "TypeField::kNext == LocationField::kNext");


  static_assert(DictionaryStorageField::kNext <= 31, "DictionaryStorageField::kNext <= 31");
  static_assert(FieldIndexField::kNext <= 31, "FieldIndexField::kNext <= 31");

  static const int kInitialIndex = 1;



  void Print(bool dictionary_mode);


 private:
  PropertyDetails(int value, int pointer) {
    value_ = DescriptorPointer::update(value, pointer);
  }
  PropertyDetails(int value, Representation representation) {
    value_ = RepresentationField::update(
        value, EncodeRepresentation(representation));
  }
  PropertyDetails(int value, PropertyAttributes attributes) {
    value_ = AttributesField::update(value, attributes);
  }

  uint32_t value_;
};


std::ostream& operator<<(std::ostream& os,
                         const PropertyAttributes& attributes);
std::ostream& operator<<(std::ostream& os, const PropertyDetails& details);
}
}




namespace v8 {
namespace internal {

class Map;





class FieldIndex final {
 public:
  FieldIndex() : bit_field_(0) {}

  static FieldIndex ForPropertyIndex(Map* map,
                                     int index,
                                     bool is_double = false);
  static FieldIndex ForInObjectOffset(int offset, Map* map = 0);
  static FieldIndex ForDescriptor(Map* map, int descriptor_index);
  static FieldIndex ForLoadByFieldIndex(Map* map, int index);
  static FieldIndex ForKeyedLookupCacheIndex(Map* map, int index);
  static FieldIndex FromFieldAccessStubKey(int key);

  int GetLoadByFieldIndex() const;

  bool is_inobject() const {
    return IsInObjectBits::decode(bit_field_);
  }

  bool is_hidden_field() const { return IsHiddenField::decode(bit_field_); }

  bool is_double() const {
    return IsDoubleBits::decode(bit_field_);
  }

  int offset() const {
    return index() * kPointerSize;
  }


  int index() const {
    return IndexBits::decode(bit_field_);
  }

  int outobject_array_index() const {
    do { if ((!(!is_inobject()))) { V8_Fatal(".././src/field-index.h", 57, "Check failed: %s.", "!is_inobject()"); } } while (0);
    return index() - first_inobject_property_offset() / kPointerSize;
  }



  int property_index() const {
    do { if ((!(!is_hidden_field()))) { V8_Fatal(".././src/field-index.h", 64, "Check failed: %s.", "!is_hidden_field()"); } } while (0);
    int result = index() - first_inobject_property_offset() / kPointerSize;
    if (!is_inobject()) {
      result += InObjectPropertyBits::decode(bit_field_);
    }
    return result;
  }

  int GetKeyedLookupCacheIndex() const;

  int GetFieldAccessStubKey() const {
    return bit_field_ &
        (IsInObjectBits::kMask | IsDoubleBits::kMask | IndexBits::kMask);
  }

 private:
  FieldIndex(bool is_inobject, int local_index, bool is_double,
             int inobject_properties, int first_inobject_property_offset,
             bool is_hidden = false) {
    do { if ((!((first_inobject_property_offset & (kPointerSize - 1)) == 0))) { V8_Fatal(".././src/field-index.h", 83, "Check failed: %s.", "(first_inobject_property_offset & (kPointerSize - 1)) == 0"); } } while (0);
    bit_field_ = IsInObjectBits::encode(is_inobject) |
      IsDoubleBits::encode(is_double) |
      FirstInobjectPropertyOffsetBits::encode(first_inobject_property_offset) |
      IsHiddenField::encode(is_hidden) |
      IndexBits::encode(local_index) |
      InObjectPropertyBits::encode(inobject_properties);
  }

  explicit FieldIndex(int bit_field) : bit_field_(bit_field) {}

  int first_inobject_property_offset() const {
    do { if ((!(!is_hidden_field()))) { V8_Fatal(".././src/field-index.h", 95, "Check failed: %s.", "!is_hidden_field()"); } } while (0);
    return FirstInobjectPropertyOffsetBits::decode(bit_field_);
  }

  static const int kIndexBitsSize = kDescriptorIndexBitCount + 1;


  class IndexBits: public BitField<int, 0, kIndexBitsSize> {};
  class IsInObjectBits: public BitField<bool, IndexBits::kNext, 1> {};
  class IsDoubleBits: public BitField<bool, IsInObjectBits::kNext, 1> {};

  class InObjectPropertyBits
      : public BitField<int, IsDoubleBits::kNext, kDescriptorIndexBitCount> {};

  class FirstInobjectPropertyOffsetBits
      : public BitField<int, InObjectPropertyBits::kNext, 7> {};
  class IsHiddenField
      : public BitField<bool, FirstInobjectPropertyOffsetBits::kNext, 1> {};
  static_assert(IsHiddenField::kNext <= 32, "IsHiddenField::kNext <= 32");

  int bit_field_;
};

}
}



namespace unibrow {

typedef unsigned int uchar;
typedef unsigned char byte;





const int kMaxMappingSize = 4;

template <class T, int size = 256>
class Predicate {
 public:
  inline Predicate() { }
  inline bool get(uchar c);

 private:
  friend class Test;
  bool CalculateValue(uchar c);
  class CacheEntry {
   public:
    inline CacheEntry()
        : bit_field_(CodePointField::encode(0) | ValueField::encode(0)) {}
    inline CacheEntry(uchar code_point, bool value)
        : bit_field_(CodePointField::encode(code_point) |
                     ValueField::encode(value)) {}

    uchar code_point() const { return CodePointField::decode(bit_field_); }
    bool value() const { return ValueField::decode(bit_field_); }

   private:
    class CodePointField : public v8::internal::BitField<uchar, 0, 21> {};
    class ValueField : public v8::internal::BitField<bool, 21, 1> {};

    uint32_t bit_field_;
  };
  static const int kSize = size;
  static const int kMask = kSize - 1;
  CacheEntry entries_[kSize];
};






template <class T, int size = 256>
class Mapping {
 public:
  inline Mapping() { }
  inline int get(uchar c, uchar n, uchar* result);
 private:
  friend class Test;
  int CalculateValue(uchar c, uchar n, uchar* result);
  struct CacheEntry {
    inline CacheEntry() : code_point_(kNoChar), offset_(0) { }
    inline CacheEntry(uchar code_point, signed offset)
      : code_point_(code_point),
        offset_(offset) { }
    uchar code_point_;
    signed offset_;
    static const int kNoChar = (1 << 21) - 1;
  };
  static const int kSize = size;
  static const int kMask = kSize - 1;
  CacheEntry entries_[kSize];
};


class UnicodeData {
 private:
  friend class Test;
  static int GetByteCount();
  static const uchar kMaxCodePoint;
};


class Utf16 {
 public:
  static inline bool IsSurrogatePair(int lead, int trail) {
    return IsLeadSurrogate(lead) && IsTrailSurrogate(trail);
  }
  static inline bool IsLeadSurrogate(int code) {
    if (code == kNoPreviousCharacter) return false;
    return (code & 0xfc00) == 0xd800;
  }
  static inline bool IsTrailSurrogate(int code) {
    if (code == kNoPreviousCharacter) return false;
    return (code & 0xfc00) == 0xdc00;
  }

  static inline int CombineSurrogatePair(uchar lead, uchar trail) {
    return 0x10000 + ((lead & 0x3ff) << 10) + (trail & 0x3ff);
  }
  static const int kNoPreviousCharacter = -1;
  static const uchar kMaxNonSurrogateCharCode = 0xffff;





  static const int kMaxExtraUtf8BytesForOneUtf16CodeUnit = 3;


  static const int kUtf8BytesToCodeASurrogate = 3;
  static inline uint16_t LeadSurrogate(uint32_t char_code) {
    return 0xd800 + (((char_code - 0x10000) >> 10) & 0x3ff);
  }
  static inline uint16_t TrailSurrogate(uint32_t char_code) {
    return 0xdc00 + (char_code & 0x3ff);
  }
};


class Utf8 {
 public:
  static inline uchar Length(uchar chr, int previous);
  static inline unsigned EncodeOneByte(char* out, uint8_t c);
  static inline unsigned Encode(char* out,
                                uchar c,
                                int previous,
                                bool replace_invalid = false);
  static uchar CalculateValue(const byte* str, size_t length, size_t* cursor);



  static const uchar kBadChar = 0xFFFD;
  static const unsigned kMaxEncodedSize = 4;
  static const unsigned kMaxOneByteChar = 0x7f;
  static const unsigned kMaxTwoByteChar = 0x7ff;
  static const unsigned kMaxThreeByteChar = 0xffff;
  static const unsigned kMaxFourByteChar = 0x1fffff;



  static const unsigned kBytesSavedByCombiningSurrogates = 2;
  static const unsigned kSizeOfUnmatchedSurrogate = 3;


  static const unsigned kMax16BitCodeUnitSize = 3;
  static inline uchar ValueOf(const byte* str, size_t length, size_t* cursor);
};

struct Uppercase {
  static bool Is(uchar c);
};
struct Lowercase {
  static bool Is(uchar c);
};
struct Letter {
  static bool Is(uchar c);
};
struct ID_Start {
  static bool Is(uchar c);
};
struct ID_Continue {
  static bool Is(uchar c);
};
struct WhiteSpace {
  static bool Is(uchar c);
};
struct LineTerminator {
  static bool Is(uchar c);
};
struct ToLowercase {
  static const int kMaxWidth = 3;
  static const bool kIsToLower = true;
  static int Convert(uchar c,
                     uchar n,
                     uchar* result,
                     bool* allow_caching_ptr);
};
struct ToUppercase {
  static const int kMaxWidth = 3;
  static const bool kIsToLower = false;
  static int Convert(uchar c,
                     uchar n,
                     uchar* result,
                     bool* allow_caching_ptr);
};
struct Ecma262Canonicalize {
  static const int kMaxWidth = 1;
  static int Convert(uchar c,
                     uchar n,
                     uchar* result,
                     bool* allow_caching_ptr);
};
struct Ecma262UnCanonicalize {
  static const int kMaxWidth = 4;
  static int Convert(uchar c,
                     uchar n,
                     uchar* result,
                     bool* allow_caching_ptr);
};
struct CanonicalizationRange {
  static const int kMaxWidth = 1;
  static int Convert(uchar c,
                     uchar n,
                     uchar* result,
                     bool* allow_caching_ptr);
};

}
namespace unibrow {

class Utf8DecoderBase {
 public:

  inline Utf8DecoderBase();
  inline Utf8DecoderBase(uint16_t* buffer, size_t buffer_length,
                         const uint8_t* stream, size_t stream_length);
  inline size_t Utf16Length() const { return utf16_length_; }

 protected:


  void Reset(uint16_t* buffer, size_t buffer_length, const uint8_t* stream,
             size_t stream_length);
  static void WriteUtf16Slow(const uint8_t* stream, size_t stream_length,
                             uint16_t* data, size_t length);
  const uint8_t* unbuffered_start_;
  size_t unbuffered_length_;
  size_t utf16_length_;
  bool last_byte_of_buffer_unused_;

 private:
  Utf8DecoderBase(const Utf8DecoderBase&) = delete; void operator=(const Utf8DecoderBase&) = delete;
};

template <size_t kBufferSize>
class Utf8Decoder : public Utf8DecoderBase {
 public:
  inline Utf8Decoder() {}
  inline Utf8Decoder(const char* stream, size_t length);
  inline void Reset(const char* stream, size_t length);
  inline size_t WriteUtf16(uint16_t* data, size_t length) const;

 private:
  uint16_t buffer_[kBufferSize];
};


Utf8DecoderBase::Utf8DecoderBase()
    : unbuffered_start_(0),
      unbuffered_length_(0),
      utf16_length_(0),
      last_byte_of_buffer_unused_(false) {}


Utf8DecoderBase::Utf8DecoderBase(uint16_t* buffer, size_t buffer_length,
                                 const uint8_t* stream, size_t stream_length) {
  Reset(buffer, buffer_length, stream, stream_length);
}


template <size_t kBufferSize>
Utf8Decoder<kBufferSize>::Utf8Decoder(const char* stream, size_t length)
    : Utf8DecoderBase(buffer_, kBufferSize,
                      reinterpret_cast<const uint8_t*>(stream), length) {}


template <size_t kBufferSize>
void Utf8Decoder<kBufferSize>::Reset(const char* stream, size_t length) {
  Utf8DecoderBase::Reset(buffer_, kBufferSize,
                         reinterpret_cast<const uint8_t*>(stream), length);
}


template <size_t kBufferSize>
size_t Utf8Decoder<kBufferSize>::WriteUtf16(uint16_t* data,
                                            size_t length) const {
  do { if ((!(length > 0))) { V8_Fatal(".././src/unicode-decoder.h", 79, "Check failed: %s.", "length > 0"); } } while (0);
  if (length > utf16_length_) length = utf16_length_;

  size_t buffer_length =
      last_byte_of_buffer_unused_ ? kBufferSize - 1 : kBufferSize;
  size_t memcpy_length = length <= buffer_length ? length : buffer_length;
  v8::internal::MemCopy(data, buffer_, memcpy_length * sizeof(uint16_t));
  if (length <= buffer_length) return length;
  do { if ((!(unbuffered_start_ != 0))) { V8_Fatal(".././src/unicode-decoder.h", 87, "Check failed: %s.", "unbuffered_start_ != 0"); } } while (0);

  WriteUtf16Slow(unbuffered_start_, unbuffered_length_, data + buffer_length,
                 length - buffer_length);
  return length;
}

class Latin1 {
 public:
  static const unsigned kMaxChar = 0xff;



  static inline uint16_t ConvertNonLatin1ToLatin1(uint16_t);
};


uint16_t Latin1::ConvertNonLatin1ToLatin1(uint16_t c) {
  do { if ((!(c > Latin1::kMaxChar))) { V8_Fatal(".././src/unicode-decoder.h", 105, "Check failed: %s.", "c > Latin1::kMaxChar"); } } while (0);
  switch (c) {

    case 0x39c:
    case 0x3bc:
      return 0xb5;


    case 0x178:
      return 0xff;
  }
  return 0;
}


}
namespace v8 {
namespace internal {


const int kNumRegisters = 16;


const int kNumDoubleRegisters = 16;

const int kNoRegister = -1;
enum Condition {
  kNoCondition = -1,
  eq = 0x8,
  ne = 0x7,
  ge = 0xa,
  lt = 0x4,
  gt = 0x2,
  le = 0xc,
  al = 0xf,

  CC_NOP = 0x0,
  CC_EQ = 0x08,
  CC_LT = 0x04,
  CC_LE = CC_EQ | CC_LT,
  CC_GT = 0x02,
  CC_GE = CC_EQ | CC_GT,
  CC_OF = 0x01,
  CC_NOF = 0x0E,
  CC_ALWAYS = 0x0F,
  unordered = CC_OF,
  ordered = CC_NOF,
  overflow = CC_OF,
  nooverflow = CC_NOF,

  mask0x0 = 0,
  mask0x1 = 1,
  mask0x2 = 2,
  mask0x3 = 3,
  mask0x4 = 4,
  mask0x5 = 5,
  mask0x6 = 6,
  mask0x7 = 7,
  mask0x8 = 8,
  mask0x9 = 9,
  mask0xA = 10,
  mask0xB = 11,
  mask0xC = 12,
  mask0xD = 13,
  mask0xE = 14,
  mask0xF = 15,


  CURRENT_ROUNDING_MODE = 0,
  ROUND_TO_NEAREST_WITH_TIES_AWAY_FROM_0 = 1,
  ROUND_TO_PREPARE_FOR_SHORTER_PRECISION = 3,
  ROUND_TO_NEAREST_WITH_TIES_TO_EVEN = 4,
  ROUND_TOWARD_0 = 5,
  ROUND_TOWARD_PLUS_INFINITE = 6,
  ROUND_TOWARD_MINUS_INFINITE = 7
};

inline Condition NegateCondition(Condition cond) {
  do { if ((!(cond != al))) { V8_Fatal(".././src/s390/constants-s390.h", 101, "Check failed: %s.", "cond != al"); } } while (0);
  switch (cond) {
    case eq:
      return ne;
    case ne:
      return eq;
    case ge:
      return lt;
    case gt:
      return le;
    case le:
      return gt;
    case lt:
      return ge;
    case lt | gt:
      return eq;
    case le | ge:
      return CC_OF;
    case CC_OF:
      return CC_NOF;
    default:
      do { if ((!(false))) { V8_Fatal(".././src/s390/constants-s390.h", 122, "Check failed: %s.", "false"); } } while (0);
  }
  return al;
}


inline Condition CommuteCondition(Condition cond) {
  switch (cond) {
    case lt:
      return gt;
    case gt:
      return lt;
    case ge:
      return le;
    case le:
      return ge;
    case eq:
      return eq;
    case ne:
      return ne;
    default:
      do { if ((!(false))) { V8_Fatal(".././src/s390/constants-s390.h", 143, "Check failed: %s.", "false"); } } while (0);
      return cond;
  }
}
typedef int32_t Instr;
typedef uint16_t TwoByteInstr;
typedef uint32_t FourByteInstr;
typedef uint64_t SixByteInstr;


enum Opcode {
  A = 0x5A,
  ADB = 0xED1A,
  ADBR = 0xB31A,
  ADTR = 0xB3D2,
  ADTRA = 0xB3D2,
  AEB = 0xED0A,
  AEBR = 0xB30A,
  AFI = 0xC29,
  AG = 0xE308,
  AGF = 0xE318,
  AGFI = 0xC28,
  AGFR = 0xB918,
  AGHI = 0xA7B,
  AGHIK = 0xECD9,
  AGR = 0xB908,
  AGRK = 0xB9E8,
  AGSI = 0xEB7A,
  AH = 0x4A,
  AHHHR = 0xB9C8,
  AHHLR = 0xB9D8,
  AHI = 0xA7A,
  AHIK = 0xECD8,
  AHY = 0xE37A,
  AIH = 0xCC8,
  AL = 0x5E,
  ALC = 0xE398,
  ALCG = 0xE388,
  ALCGR = 0xB988,
  ALCR = 0xB998,
  ALFI = 0xC2B,
  ALG = 0xE30A,
  ALGF = 0xE31A,
  ALGFI = 0xC2A,
  ALGFR = 0xB91A,
  ALGHSIK = 0xECDB,
  ALGR = 0xB90A,
  ALGRK = 0xB9EA,
  ALGSI = 0xEB7E,
  ALHHHR = 0xB9CA,
  ALHHLR = 0xB9DA,
  ALHSIK = 0xECDA,
  ALR = 0x1E,
  ALRK = 0xB9FA,
  ALSI = 0xEB6E,
  ALSIH = 0xCCA,
  ALSIHN = 0xCCB,
  ALY = 0xE35E,
  AP = 0xFA,
  AR = 0x1A,
  ARK = 0xB9F8,
  ASI = 0xEB6A,
  AXBR = 0xB34A,
  AXTR = 0xB3DA,
  AXTRA = 0xB3DA,
  AY = 0xE35A,
  BAL = 0x45,
  BALR = 0x05,
  BAS = 0x4D,
  BASR = 0x0D,
  BASSM = 0x0C,
  BC = 0x47,
  BCR = 0x07,
  BCT = 0x46,
  BCTG = 0xE346,
  BCTGR = 0xB946,
  BCTR = 0x06,
  BPP = 0xC7,
  BPRP = 0xC5,
  BRAS = 0xA75,
  BRASL = 0xC05,
  BRC = 0xA74,
  BRCL = 0xC04,
  BRCT = 0xA76,
  BRCTG = 0xA77,
  BRCTH = 0xCC6,
  BRXH = 0x84,
  BRXHG = 0xEC44,
  BRXLE = 0x85,
  BRXLG = 0xEC45,
  BSM = 0x0B,
  BXH = 0x86,
  BXHG = 0xEB44,
  BXLE = 0x87,
  BXLEG = 0xEB45,
  C = 0x59,
  CDB = 0xED19,
  CDBR = 0xB319,
  CDFBR = 0xB395,
  CDFBRA = 0xB395,
  CDFTR = 0xB951,
  CDGBR = 0xB3A5,
  CDGBRA = 0xB3A5,
  CDGTR = 0xB3F1,
  CDGTRA = 0xB3F1,
  CDLFBR = 0xB391,
  CDLFTR = 0xB953,
  CDLGBR = 0xB3A1,
  CDLGTR = 0xB952,
  CDS = 0xBB,
  CDSG = 0xEB3E,
  CDSTR = 0xB3F3,
  CDSY = 0xEB31,
  CDTR = 0xB3E4,
  CDUTR = 0xB3F2,
  CDZT = 0xEDAA,
  CEB = 0xED09,
  CEBR = 0xB309,
  CEDTR = 0xB3F4,
  CEFBR = 0xB394,
  CEFBRA = 0xB394,
  CEGBR = 0xB3A4,
  CEGBRA = 0xB3A4,
  CELFBR = 0xB390,
  CELGBR = 0xB3A0,
  CEXTR = 0xB3FC,
  CFC = 0xB21A,
  CFDBR = 0xB399,
  CFDBRA = 0xB399,
  CFDR = 0xB3B9,
  CFDTR = 0xB941,
  CFEBR = 0xB398,
  CFEBRA = 0xB398,
  CFER = 0xB3B8,
  CFI = 0xC2D,
  CFXBR = 0xB39A,
  CFXBRA = 0xB39A,
  CFXR = 0xB3BA,
  CFXTR = 0xB949,
  CG = 0xE320,
  CGDBR = 0xB3A9,
  CGDBRA = 0xB3A9,
  CGDR = 0xB3C9,
  CGDTR = 0xB3E1,
  CGDTRA = 0xB3E1,
  CGEBR = 0xB3A8,
  CGEBRA = 0xB3A8,
  CGER = 0xB3C8,
  CGF = 0xE330,
  CGFI = 0xC2C,
  CGFR = 0xB930,
  CGFRL = 0xC6C,
  CGH = 0xE334,
  CGHI = 0xA7F,
  CGHRL = 0xC64,
  CGHSI = 0xE558,
  CGIB = 0xECFC,
  CGIJ = 0xEC7C,
  CGIT = 0xEC70,
  CGR = 0xB920,
  CGRB = 0xECE4,
  CGRJ = 0xEC64,
  CGRL = 0xC68,
  CGRT = 0xB960,
  CGXBR = 0xB3AA,
  CGXBRA = 0xB3AA,
  CGXR = 0xB3CA,
  CGXTR = 0xB3E9,
  CGXTRA = 0xB3E9,
  CH = 0x49,
  CHF = 0xE3CD,
  CHHR = 0xB9CD,
  CHHSI = 0xE554,
  CHI = 0xA7E,
  CHLR = 0xB9DD,
  CHRL = 0xC65,
  CHSI = 0xE55C,
  CHY = 0xE379,
  CIB = 0xECFE,
  CIH = 0xCCD,
  CIJ = 0xEC7E,
  CIT = 0xEC72,
  CKSM = 0xB241,
  CL = 0x55,
  CLC = 0xD5,
  CLCL = 0x0F,
  CLCLE = 0xA9,
  CLCLU = 0xEB8F,
  CLFDBR = 0xB39D,
  CLFDTR = 0xB943,
  CLFEBR = 0xB39C,
  CLFHSI = 0xE55D,
  CLFI = 0xC2F,
  CLFIT = 0xEC73,
  CLFXBR = 0xB39E,
  CLFXTR = 0xB94B,
  CLG = 0xE321,
  CLGDBR = 0xB3AD,
  CLGDTR = 0xB942,
  CLGEBR = 0xB3AC,
  CLGF = 0xE331,
  CLGFI = 0xC2E,
  CLGR = 0xB921,
  CLI = 0x95,
  CLIY = 0xEB55,
  CLR = 0x15,
  CLY = 0xE355,
  CD = 0x69,
  CDR = 0x29,
  CR = 0x19,
  CSST = 0xC82,
  CSXTR = 0xB3EB,
  CSY = 0xEB14,
  CU12 = 0xB2A7,
  CU14 = 0xB9B0,
  CU21 = 0xB2A6,
  CU24 = 0xB9B1,
  CU41 = 0xB9B2,
  CU42 = 0xB9B3,
  CUDTR = 0xB3E2,
  CUSE = 0xB257,
  CUTFU = 0xB2A7,
  CUUTF = 0xB2A6,
  CUXTR = 0xB3EA,
  CVB = 0x4F,
  CVBG = 0xE30E,
  CVBY = 0xE306,
  CVD = 0x4E,
  CVDG = 0xE32E,
  CVDY = 0xE326,
  CXBR = 0xB349,
  CXFBR = 0xB396,
  CXFBRA = 0xB396,
  CXFTR = 0xB959,
  CXGBR = 0xB3A6,
  CXGBRA = 0xB3A6,
  CXGTR = 0xB3F9,
  CXGTRA = 0xB3F9,
  CXLFBR = 0xB392,
  CXLFTR = 0xB95B,
  CXLGBR = 0xB3A2,
  CXLGTR = 0xB95A,
  CXSTR = 0xB3FB,
  CXTR = 0xB3EC,
  CXUTR = 0xB3FA,
  CXZT = 0xEDAB,
  CY = 0xE359,
  CZDT = 0xEDA8,
  CZXT = 0xEDA9,
  D = 0x5D,
  DDB = 0xED1D,
  DDBR = 0xB31D,
  DDTR = 0xB3D1,
  DDTRA = 0xB3D1,
  DEB = 0xED0D,
  DEBR = 0xB30D,
  DIDBR = 0xB35B,
  DIEBR = 0xB353,
  DL = 0xE397,
  DLG = 0xE387,
  DLGR = 0xB987,
  DLR = 0xB997,
  DP = 0xFD,
  DR = 0x1D,
  DSG = 0xE30D,
  DSGF = 0xE31D,
  DSGFR = 0xB91D,
  DSGR = 0xB90D,
  DXBR = 0xB34D,
  DXTR = 0xB3D9,
  DXTRA = 0xB3D9,
  EAR = 0xB24F,
  ECAG = 0xEB4C,
  ECTG = 0xC81,
  ED = 0xDE,
  EDMK = 0xDF,
  EEDTR = 0xB3E5,
  EEXTR = 0xB3ED,
  EFPC = 0xB38C,
  EPSW = 0xB98D,
  ESDTR = 0xB3E7,
  ESXTR = 0xB3EF,
  ETND = 0xB2EC,
  EX = 0x44,
  EXRL = 0xC60,
  FIDBR = 0xB35F,
  FIDBRA = 0xB35F,
  FIDTR = 0xB3D7,
  FIEBR = 0xB357,
  FIEBRA = 0xB357,
  FIXBR = 0xB347,
  FIXBRA = 0xB347,
  FIXTR = 0xB3DF,
  FLOGR = 0xB983,
  HSCH = 0xB231,
  IC_z = 0x43,
  ICM = 0xBF,
  ICMH = 0xEB80,
  ICMY = 0xEB81,
  ICY = 0xE373,
  IEDTR = 0xB3F6,
  IEXTR = 0xB3FE,
  IIHF = 0xC08,
  IIHH = 0xA50,
  IIHL = 0xA51,
  IILF = 0xC09,
  IILH = 0xA52,
  IILL = 0xA53,
  IPM = 0xB222,
  KDB = 0xED18,
  KDBR = 0xB318,
  KDTR = 0xB3E0,
  KEB = 0xED08,
  KEBR = 0xB308,
  KIMD = 0xB93E,
  KLMD = 0xB93F,
  KM = 0xB92E,
  KMAC = 0xB91E,
  KMC = 0xB92F,
  KMCTR = 0xB92D,
  KMF = 0xB92A,
  KMO = 0xB92B,
  KXBR = 0xB348,
  KXTR = 0xB3E8,
  L = 0x58,
  LA = 0x41,
  LAA = 0xEBF8,
  LAAG = 0xEBE8,
  LAAL = 0xEBFA,
  LAALG = 0xEBEA,
  LAE = 0x51,
  LAEY = 0xE375,
  LAN = 0xEBF4,
  LANG = 0xEBE4,
  LAO = 0xEBF6,
  LAOG = 0xEBE6,
  LARL = 0xC00,
  LAT = 0xE39F,
  LAX = 0xEBF7,
  LAXG = 0xEBE7,
  LAY = 0xE371,
  LB = 0xE376,
  LBH = 0xE3C0,
  LBR = 0xB926,
  LCDBR = 0xB313,
  LCDFR = 0xB373,
  LCEBR = 0xB303,
  LCGFR = 0xB913,
  LCGR = 0xB903,
  LCR = 0x13,
  LCXBR = 0xB343,
  LD = 0x68,
  LDEB = 0xED04,
  LDEBR = 0xB304,
  LDETR = 0xB3D4,
  LDGR = 0xB3C1,
  LDR = 0x28,
  LDXBR = 0xB345,
  LDXBRA = 0xB345,
  LDXTR = 0xB3DD,
  LDY = 0xED65,
  LE = 0x78,
  LEDBR = 0xB344,
  LEDBRA = 0xB344,
  LEDTR = 0xB3D5,
  LER = 0x38,
  LEXBR = 0xB346,
  LEXBRA = 0xB346,
  LEY = 0xED64,
  LFAS = 0xB2BD,
  LFH = 0xE3CA,
  LFHAT = 0xE3C8,
  LFPC = 0xB29D,
  LG = 0xE304,
  LGAT = 0xE385,
  LGB = 0xE377,
  LGBR = 0xB906,
  LGDR = 0xB3CD,
  LGF = 0xE314,
  LGFI = 0xC01,
  LGFR = 0xB914,
  LGFRL = 0xC4C,
  LGH = 0xE315,
  LGHI = 0xA79,
  LGHR = 0xB907,
  LGHRL = 0xC44,
  LGR = 0xB904,
  LGRL = 0xC48,
  LH = 0x48,
  LHH = 0xE3C4,
  LHI = 0xA78,
  LHR = 0xB927,
  LHRL = 0xC45,
  LHY = 0xE378,
  LLC = 0xE394,
  LLCH = 0xE3C2,
  LLCR = 0xB994,
  LLGC = 0xE390,
  LLGCR = 0xB984,
  LLGF = 0xE316,
  LLGFAT = 0xE39D,
  LLGFR = 0xB916,
  LLGFRL = 0xC4E,
  LLGH = 0xE391,
  LLGHR = 0xB985,
  LLGHRL = 0xC46,
  LLGT = 0xE317,
  LLGTAT = 0xE39C,
  LLGTR = 0xB917,
  LLH = 0xE395,
  LLHH = 0xE3C6,
  LLHR = 0xB995,
  LLHRL = 0xC42,
  LLIHF = 0xC0E,
  LLIHH = 0xA5C,
  LLIHL = 0xA5D,
  LLILF = 0xC0F,
  LLILH = 0xA5E,
  LLILL = 0xA5F,
  LM = 0x98,
  LMD = 0xEF,
  LMG = 0xEB04,
  LMH = 0xEB96,
  LMY = 0xEB98,
  LNDBR = 0xB311,
  LNDFR = 0xB371,
  LNEBR = 0xB301,
  LNGFR = 0xB911,
  LNGR = 0xB901,
  LNR = 0x11,
  LNXBR = 0xB341,
  LOC = 0xEBF2,
  LOCG = 0xEBE2,
  LOCGR = 0xB9E2,
  LOCR = 0xB9F2,
  LPD = 0xC84,
  LPDBR = 0xB310,
  LPDFR = 0xB370,
  LPDG = 0xC85,
  LPEBR = 0xB300,
  LPGFR = 0xB910,
  LPGR = 0xB900,
  LPQ = 0xE38F,
  LPR = 0x10,
  LPXBR = 0xB340,
  LR = 0x18,
  LRL = 0xC4D,
  LRV = 0xE31E,
  LRVG = 0xE30F,
  LRVGR = 0xB90F,
  LRVH = 0xE31F,
  LRVR = 0xB91F,
  LT = 0xE312,
  LTDBR = 0xB312,
  LTDTR = 0xB3D6,
  LTEBR = 0xB302,
  LTG = 0xE302,
  LTGF = 0xE332,
  LTGFR = 0xB912,
  LTGR = 0xB902,
  LTR = 0x12,
  LTXBR = 0xB342,
  LTXTR = 0xB3DE,
  LXDB = 0xED05,
  LXDBR = 0xB305,
  LXDTR = 0xB3DC,
  LXEB = 0xED06,
  LXEBR = 0xB306,
  LXR = 0xB365,
  LY = 0xE358,
  LZDR = 0xB375,
  LZER = 0xB374,
  LZXR = 0xB376,
  M = 0x5C,
  MADB = 0xED1E,
  MADBR = 0xB31E,
  MAEB = 0xED0E,
  MAEBR = 0xB30E,
  MC = 0xAF,
  MDB = 0xED1C,
  MDBR = 0xB31C,
  MDEB = 0xED0C,
  MDEBR = 0xB30C,
  MDTR = 0xB3D0,
  MDTRA = 0xB3D0,
  MEEB = 0xED17,
  MEEBR = 0xB317,
  MFY = 0xE35C,
  MGHI = 0xA7D,
  MH = 0x4C,
  MHI = 0xA7C,
  MHY = 0xE37C,
  ML = 0xE396,
  MLG = 0xE386,
  MLGR = 0xB986,
  MLR = 0xB996,
  MP = 0xFC,
  MR = 0x1C,
  MS = 0x71,
  MSCH = 0xB232,
  MSDB = 0xED1F,
  MSDBR = 0xB31F,
  MSEB = 0xED0F,
  MSEBR = 0xB30F,
  MSFI = 0xC21,
  MSG = 0xE30C,
  MSGF = 0xE31C,
  MSGFI = 0xC20,
  MSGFR = 0xB91C,
  MSGR = 0xB90C,
  MSR = 0xB252,
  MSY = 0xE351,
  MVC = 0xD2,
  MVCP = 0xDA,
  MVCDK = 0xE50F,
  MVCIN = 0xE8,
  MVCL = 0x0E,
  MVCLE = 0xA8,
  MVCLU = 0xEB8E,
  MVGHI = 0xE548,
  MVHHI = 0xE544,
  MVHI = 0xE54C,
  MVI = 0x92,
  MVIY = 0xEB52,
  MVN = 0xD1,
  MVO = 0xF1,
  MVST = 0xB255,
  MVZ = 0xD3,
  MXBR = 0xB34C,
  MXDB = 0xED07,
  MXDBR = 0xB307,
  MXTR = 0xB3D8,
  MXTRA = 0xB3D8,
  N = 0x54,
  NC = 0xD4,
  NG = 0xE380,
  NGR = 0xB980,
  NGRK = 0xB9E4,
  NI = 0x94,
  NIAI = 0xB2FA,
  NIHF = 0xC0A,
  NIHH = 0xA54,
  NIHL = 0xA55,
  NILF = 0xC0B,
  NILH = 0xA56,
  NILL = 0xA57,
  NIY = 0xEB54,
  NR = 0x14,
  NRK = 0xB9F4,
  NTSTG = 0xE325,
  NY = 0xE354,
  O = 0x56,
  OC = 0xD6,
  OG = 0xE381,
  OGR = 0xB981,
  OGRK = 0xB9E6,
  OI = 0x96,
  OIHF = 0xC0C,
  OIHH = 0xA58,
  OIHL = 0xA59,
  OILF = 0xC0D,
  OILH = 0xA5A,
  OILL = 0xA5B,
  OIY = 0xEB56,
  OR = 0x16,
  ORK = 0xB9F6,
  OY = 0xE356,
  PACK = 0xF2,
  PCC = 0xB92C,
  PFD = 0xE336,
  PFDRL = 0xC62,
  PFPO = 0x010A,
  PKA = 0xE9,
  PKU = 0xE1,
  PLO = 0xEE,
  POPCNT_Z = 0xB9E1,
  PPA = 0xB2E8,
  QADTR = 0xB3F5,
  QAXTR = 0xB3FD,
  RCHP = 0xB23B,
  RISBG = 0xEC55,
  RISBGN = 0xEC59,
  RISBHG = 0xEC5D,
  RISBLG = 0xEC51,
  RLL = 0xEB1D,
  RLLG = 0xEB1C,
  RNSBG = 0xEC54,
  ROSBG = 0xEC56,
  RRDTR = 0xB3F7,
  RRXTR = 0xB3FF,
  RSCH = 0xB238,
  RXSBG = 0xEC57,
  S = 0x5B,
  SAL = 0xB237,
  SAR = 0xB24E,
  SCHM = 0xB23C,
  SDB = 0xED1B,
  SDBR = 0xB31B,
  SDTR = 0xB3D3,
  SDTRA = 0xB3D3,
  SEB = 0xED0B,
  SEBR = 0xB30B,
  SFASR = 0xB385,
  SFPC = 0xB384,
  SG = 0xE309,
  SGF = 0xE319,
  SGFR = 0xB919,
  SGR = 0xB909,
  SGRK = 0xB9E9,
  SH = 0x4B,
  SHHHR = 0xB9C9,
  SHHLR = 0xB9D9,
  SHY = 0xE37B,
  SL = 0x5F,
  SLA = 0x8B,
  SLAG = 0xEB0B,
  SLAK = 0xEBDD,
  SLB = 0xE399,
  SLBG = 0xE389,
  SLBGR = 0xB989,
  SLBR = 0xB999,
  SLDA = 0x8F,
  SLDL = 0x8D,
  SLDT = 0xED40,
  SLFI = 0xC25,
  SLG = 0xE30B,
  SLGF = 0xE31B,
  SLGFI = 0xC24,
  SLGFR = 0xB91B,
  SLGR = 0xB90B,
  SLGRK = 0xB9EB,
  SLHHHR = 0xB9CB,
  SLHHLR = 0xB9DB,
  SLL = 0x89,
  SLLG = 0xEB0D,
  SLLK = 0xEBDF,
  SLR = 0x1F,
  SLRK = 0xB9FB,
  SLXT = 0xED48,
  SLY = 0xE35F,
  SP = 0xFB,
  SPM = 0x04,
  SQDB = 0xED15,
  SQDBR = 0xB315,
  SQEB = 0xED14,
  SQEBR = 0xB314,
  SQXBR = 0xB316,
  SR = 0x1B,
  SRA = 0x8A,
  SRAG = 0xEB0A,
  SRAK = 0xEBDC,
  SRDA = 0x8E,
  SRDL = 0x8C,
  SRDT = 0xED41,
  SRK = 0xB9F9,
  SRL = 0x88,
  SRLG = 0xEB0C,
  SRLK = 0xEBDE,
  SRNM = 0xB299,
  SRNMB = 0xB2B8,
  SRNMT = 0xB2B9,
  SRP = 0xF0,
  SRST = 0xB25E,
  SRSTU = 0xB9BE,
  SRXT = 0xED49,
  SSCH = 0xB233,
  ST = 0x50,
  STC = 0x42,
  STCH = 0xE3C3,
  STCK = 0xB205,
  STCKE = 0xB278,
  STCKF = 0xB27C,
  STCM = 0xBE,
  STCMH = 0xEB2C,
  STCMY = 0xEB2D,
  STCPS = 0xB23A,
  STCRW = 0xB239,
  STCY = 0xE372,
  STD = 0x60,
  STDY = 0xED67,
  STE = 0x70,
  STEY = 0xED66,
  STFH = 0xE3CB,
  STFLE = 0xB2B0,
  STFPC = 0xB29C,
  STG = 0xE324,
  STGRL = 0xC4B,
  STH = 0x40,
  STHH = 0xE3C7,
  STHRL = 0xC47,
  STHY = 0xE370,
  STM = 0x90,
  STMG = 0xEB24,
  STMH = 0xEB26,
  STMY = 0xEB90,
  STOC = 0xEBF3,
  STOCG = 0xEBE3,
  STPQ = 0xE38E,
  STRL = 0xC4F,
  STRV = 0xE33E,
  STRVG = 0xE32F,
  STRVH = 0xE33F,
  STSCH = 0xB234,
  STY = 0xE350,
  SVC = 0x0A,
  SXBR = 0xB34B,
  SXTR = 0xB3DB,
  SXTRA = 0xB3DB,
  SY = 0xE35B,
  TABORT = 0xB2FC,
  TBDR = 0xB351,
  TBEDR = 0xB350,
  TBEGIN = 0xE560,
  TBEGINC = 0xE561,
  TCDB = 0xED11,
  TCEB = 0xED10,
  TCXB = 0xED12,
  TDCDT = 0xED54,
  TDCET = 0xED50,
  TDCXT = 0xED58,
  TDGDT = 0xED55,
  TDGET = 0xED51,
  TDGXT = 0xED59,
  TEND = 0xB2F8,
  THDER = 0xB358,
  THDR = 0xB359,
  TM = 0x91,
  TMH = 0xA70,
  TMHH = 0xA72,
  TMHL = 0xA73,
  TML = 0xA71,
  TMLH = 0xA70,
  TMLL = 0xA71,
  TMY = 0xEB51,
  TP = 0xEBC0,
  TPI = 0xB236,
  TR = 0xDC,
  TRAP4 = 0xB2FF,
  TRE = 0xB2A5,
  TROO = 0xB993,
  TROT = 0xB992,
  TRT = 0xDD,
  TRTE = 0xB9BF,
  TRTO = 0xB991,
  TRTR = 0xD0,
  TRTRE = 0xB9BD,
  TRTT = 0xB990,
  TS = 0x93,
  TSCH = 0xB235,
  UNPK = 0xF3,
  UNPKA = 0xEA,
  UNPKU = 0xE2,
  UPT = 0x0102,
  X = 0x57,
  XC = 0xD7,
  XG = 0xE382,
  XGR = 0xB982,
  XGRK = 0xB9E7,
  XI = 0x97,
  XIHF = 0xC06,
  XILF = 0xC07,
  XIY = 0xEB57,
  XR = 0x17,
  XRK = 0xB9F7,
  XSCH = 0xB276,
  XY = 0xE357,
  ZAP = 0xF8,
  BKPT = 0x0001
};


enum {

  B1 = 1 << 1,
  B4 = 1 << 4,
  B5 = 1 << 5,
  B7 = 1 << 7,
  B8 = 1 << 8,
  B9 = 1 << 9,
  B12 = 1 << 12,
  B18 = 1 << 18,
  B19 = 1 << 19,
  B20 = 1 << 20,
  B22 = 1 << 22,
  B23 = 1 << 23,
  B24 = 1 << 24,
  B25 = 1 << 25,
  B26 = 1 << 26,
  B27 = 1 << 27,
  B28 = 1 << 28,

  B6 = 1 << 6,
  B10 = 1 << 10,
  B11 = 1 << 11,
  B16 = 1 << 16,
  B17 = 1 << 17,
  B21 = 1 << 21,


  kCondMask = 0x1F << 21,
  kOff12Mask = (1 << 12) - 1,
  kImm24Mask = (1 << 24) - 1,
  kOff16Mask = (1 << 16) - 1,
  kImm16Mask = (1 << 16) - 1,
  kImm26Mask = (1 << 26) - 1,
  kBOfieldMask = 0x1f << 21,
  kOpcodeMask = 0x3f << 26,
  kExt2OpcodeMask = 0x1f << 1,
  kExt5OpcodeMask = 0x3 << 2,
  kBIMask = 0x1F << 16,
  kBDMask = 0x14 << 2,
  kAAMask = 0x01 << 1,
  kLKMask = 0x01,
  kRCMask = 0x01,
  kTOMask = 0x1f << 21
};






const FourByteInstr kFourByteBrCondMask = 0xF << 20;
const SixByteInstr kSixByteBrCondMask = static_cast<SixByteInstr>(0xF) << 36;





enum OEBit {
  SetOE = 1 << 10,
  LeaveOE = 0 << 10
};


enum RCBit {
  SetRC = 1,
  LeaveRC = 0
};


enum LKBit {
  SetLK = 1,
  LeaveLK = 0
};

enum BOfield {
  DCBNZF = 0 << 21,
  DCBEZF = 2 << 21,
  BF = 4 << 21,
  DCBNZT = 8 << 21,
  DCBEZT = 10 << 21,
  BT = 12 << 21,
  DCBNZ = 16 << 21,
  DCBEZ = 18 << 21,
  BA = 20 << 21
};
enum CRBit { CR_LT = 0, CR_GT = 1, CR_EQ = 2, CR_SO = 3, CR_FU = 3 };
enum SoftwareInterruptCodes {

  kCallRtRedirected = 0x0010,

  kBreakpoint = 0x0000,

  kStopCode = 1 << 23
};
const uint32_t kStopCodeMask = kStopCode - 1;
const uint32_t kMaxStopCode = kStopCode - 1;
const int32_t kDefaultStopCode = -1;


enum FPRoundingMode {
  RN = 0,
  RZ = 1,
  RP = 2,
  RM = 3,


  kRoundToNearest = RN,
  kRoundToZero = RZ,
  kRoundToPlusInf = RP,
  kRoundToMinusInf = RM
};

const uint32_t kFPRoundingModeMask = 3;

enum CheckForInexactConversion {
  kCheckForInexactConversion,
  kDontCheckForInexactConversion
};





const Instr rtCallRedirInstr = TRAP4;






class Instruction {
 public:



  enum OpcodeFormatType {
    ONE_BYTE_OPCODE,
    TWO_BYTE_OPCODE,
    TWO_BYTE_DISJOINT_OPCODE,
    THREE_NIBBLE_OPCODE
  };
  template <typename T>
  inline T InstructionBits() const {
    return Instruction::InstructionBits<T>(reinterpret_cast<const byte*>(this));
  }
  inline Instr InstructionBits() const {
    return *reinterpret_cast<const Instr*>(this);
  }


  template <typename T>
  inline void SetInstructionBits(T value) const {
    Instruction::SetInstructionBits<T>(reinterpret_cast<const byte*>(this),
                                       value);
  }
  inline void SetInstructionBits(Instr value) {
    *reinterpret_cast<Instr*>(this) = value;
  }


  inline int Bit(int nr) const { return (InstructionBits() >> nr) & 1; }


  inline int Bits(int hi, int lo) const {
    return (InstructionBits() >> lo) & ((2 << (hi - lo)) - 1);
  }


  template <typename T, typename U>
  inline U Bits(int hi, int lo) const {
    return (InstructionBits<T>() >> lo) & ((2 << (hi - lo)) - 1);
  }


  inline int BitField(int hi, int lo) const {
    return InstructionBits() & (((2 << (hi - lo)) - 1) << lo);
  }


  inline int InstructionLength() {
    return Instruction::InstructionLength(reinterpret_cast<const byte*>(this));
  }

  inline Opcode S390OpcodeValue() {
    return Instruction::S390OpcodeValue(reinterpret_cast<const byte*>(this));
  }




  static inline int Bit(Instr instr, int nr) { return (instr >> nr) & 1; }


  static inline int Bits(Instr instr, int hi, int lo) {
    return (instr >> lo) & ((2 << (hi - lo)) - 1);
  }


  static inline int BitField(Instr instr, int hi, int lo) {
    return instr & (((2 << (hi - lo)) - 1) << lo);
  }


  static inline int InstructionLength(const byte* instr) {




    byte topNibble = (*instr >> 4) & 0xF;
    if (topNibble <= 3)
      return 2;
    else if (topNibble <= 0xB)
      return 4;
    return 6;
  }


  static inline uint64_t InstructionBits(const byte* instr) {
    int length = InstructionLength(instr);
    if (2 == length)
      return static_cast<uint64_t>(InstructionBits<TwoByteInstr>(instr));
    else if (4 == length)
      return static_cast<uint64_t>(InstructionBits<FourByteInstr>(instr));
    else
      return InstructionBits<SixByteInstr>(instr);
  }


  template <typename T>
  static inline T InstructionBits(const byte* instr) {

    if (sizeof(T) <= 4) {
      return *reinterpret_cast<const T*>(instr);
    } else {



      uint64_t fourBytes = *reinterpret_cast<const uint32_t*>(instr);
      uint16_t twoBytes = *reinterpret_cast<const uint16_t*>(instr + 4);
      return (fourBytes << 16 | twoBytes);
    }
  }


  template <typename T>
  static inline void SetInstructionBits(byte* instr, T value) {
    if (sizeof(T) <= 4) {
      *reinterpret_cast<T*>(instr) = value;
    } else {






      *reinterpret_cast<uint32_t*>(instr) = static_cast<uint32_t>(value >> 16);
      *reinterpret_cast<uint16_t*>(instr + 4) =
          static_cast<uint16_t>(value & 0xFFFF);

    }
  }


  static OpcodeFormatType getOpcodeFormatType(const byte* instr) {
    const byte firstByte = *instr;





    if ((0x04 <= firstByte && 0x9B >= firstByte) ||
        (0xA8 <= firstByte && 0xB1 >= firstByte) ||
        (0xBA <= firstByte && 0xBF >= firstByte) || (0xC5 == firstByte) ||
        (0xC7 == firstByte) || (0xD0 <= firstByte && 0xE2 >= firstByte) ||
        (0xE8 <= firstByte && 0xEA >= firstByte) ||
        (0xEE <= firstByte && 0xFD >= firstByte)) {
      return ONE_BYTE_OPCODE;
    }



    if ((0x00 == firstByte) ||
        (0x01 == firstByte) || (0xB2 == firstByte) || (0xB3 == firstByte) ||
        (0xB9 == firstByte) || (0xE5 == firstByte)) {
      return TWO_BYTE_OPCODE;
    }



    if ((0xA5 == firstByte) || (0xA7 == firstByte) ||
        (0xC0 <= firstByte && 0xCC >= firstByte)) {
      return THREE_NIBBLE_OPCODE;
    }

    do { if ((!(InstructionLength(instr) == 6))) { V8_Fatal(".././src/s390/constants-s390.h", 1286, "Check failed: %s.", "InstructionLength(instr) == 6"); } } while (0);
    return TWO_BYTE_DISJOINT_OPCODE;
  }


  static inline Opcode S390OpcodeValue(const byte* instr) {
    OpcodeFormatType opcodeType = getOpcodeFormatType(instr);




    switch (opcodeType) {
      case ONE_BYTE_OPCODE:

        return static_cast<Opcode>(*instr);
      case TWO_BYTE_OPCODE:

        return static_cast<Opcode>((*instr << 8) | (*(instr + 1)));
      case TWO_BYTE_DISJOINT_OPCODE:

        return static_cast<Opcode>((*instr << 8) | (*(instr + 5) & 0xFF));
      case THREE_NIBBLE_OPCODE:

        return static_cast<Opcode>((*instr << 4) | (*(instr + 1) & 0xF));
      default:
        break;
    }

    V8_Fatal(".././src/s390/constants-s390.h", 1314, "unreachable code");
    return static_cast<Opcode>(-1);
  }


  inline SoftwareInterruptCodes SvcValue() const {
    return static_cast<SoftwareInterruptCodes>(Bits<FourByteInstr, int>(15, 0));
  }





  static Instruction* At(byte* pc) {
    return reinterpret_cast<Instruction*>(pc);
  }

 private:

  Instruction() = delete; Instruction(const Instruction&) = delete; void operator=(const Instruction&) = delete;
};



class IInstruction : private Instruction {
 public:
  inline int IValue() const { return Bits<TwoByteInstr, int>(7, 0); }

  inline int size() const { return 2; }
};


class RRInstruction : private Instruction {
 public:
  inline int R1Value() const {


    return Bits<TwoByteInstr, int>(7, 4);
  }
  inline int R2Value() const { return Bits<TwoByteInstr, int>(3, 0); }
  inline Condition M1Value() const {
    return static_cast<Condition>(Bits<TwoByteInstr, int>(7, 4));
  }

  inline int size() const { return 2; }
};


class RREInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<FourByteInstr, int>(7, 4); }
  inline int R2Value() const { return Bits<FourByteInstr, int>(3, 0); }
  inline int M3Value() const { return Bits<FourByteInstr, int>(15, 12); }
  inline int M4Value() const { return Bits<FourByteInstr, int>(19, 16); }
  inline int size() const { return 4; }
};


class RRFInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<FourByteInstr, int>(7, 4); }
  inline int R2Value() const { return Bits<FourByteInstr, int>(3, 0); }
  inline int R3Value() const { return Bits<FourByteInstr, int>(15, 12); }
  inline int M3Value() const { return Bits<FourByteInstr, int>(15, 12); }
  inline int M4Value() const { return Bits<FourByteInstr, int>(11, 8); }
  inline int size() const { return 4; }
};


class RRDInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<FourByteInstr, int>(15, 12); }
  inline int R2Value() const { return Bits<FourByteInstr, int>(3, 0); }
  inline int R3Value() const { return Bits<FourByteInstr, int>(7, 4); }
  inline int size() const { return 4; }
};


class RIInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<FourByteInstr, int>(23, 20); }
  inline int16_t I2Value() const { return Bits<FourByteInstr, int16_t>(15, 0); }
  inline uint16_t I2UnsignedValue() const {
    return Bits<FourByteInstr, uint16_t>(15, 0);
  }
  inline Condition M1Value() const {
    return static_cast<Condition>(Bits<FourByteInstr, int>(23, 20));
  }
  inline int size() const { return 4; }
};


class RSInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<FourByteInstr, int>(23, 20); }
  inline int R3Value() const { return Bits<FourByteInstr, int>(19, 16); }
  inline int B2Value() const { return Bits<FourByteInstr, int>(15, 12); }
  inline unsigned int D2Value() const {
    return Bits<FourByteInstr, unsigned int>(11, 0);
  }
  inline int size() const { return 4; }
};


class RSYInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<SixByteInstr, int>(39, 36); }
  inline int R3Value() const { return Bits<SixByteInstr, int>(35, 32); }
  inline int B2Value() const { return Bits<SixByteInstr, int>(31, 28); }
  inline int32_t D2Value() const {
    int32_t value = Bits<SixByteInstr, int32_t>(27, 16);
    value += Bits<SixByteInstr, int8_t>(15, 8) << 12;
    return value;
  }
  inline int size() const { return 6; }
};


class RXInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<FourByteInstr, int>(23, 20); }
  inline int X2Value() const { return Bits<FourByteInstr, int>(19, 16); }
  inline int B2Value() const { return Bits<FourByteInstr, int>(15, 12); }
  inline uint32_t D2Value() const {
    return Bits<FourByteInstr, uint32_t>(11, 0);
  }
  inline int size() const { return 4; }
};


class RXYInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<SixByteInstr, int>(39, 36); }
  inline int X2Value() const { return Bits<SixByteInstr, int>(35, 32); }
  inline int B2Value() const { return Bits<SixByteInstr, int>(31, 28); }
  inline int32_t D2Value() const {
    int32_t value = Bits<SixByteInstr, uint32_t>(27, 16);
    value += Bits<SixByteInstr, int8_t>(15, 8) << 12;
    return value;
  }
  inline int size() const { return 6; }
};


class RILInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<SixByteInstr, int>(39, 36); }
  inline int32_t I2Value() const { return Bits<SixByteInstr, int32_t>(31, 0); }
  inline uint32_t I2UnsignedValue() const {
    return Bits<SixByteInstr, uint32_t>(31, 0);
  }
  inline int size() const { return 6; }
};


class SIInstruction : private Instruction {
 public:
  inline int B1Value() const { return Bits<FourByteInstr, int>(15, 12); }
  inline uint32_t D1Value() const {
    return Bits<FourByteInstr, uint32_t>(11, 0);
  }
  inline uint8_t I2Value() const {
    return Bits<FourByteInstr, uint8_t>(23, 16);
  }
  inline int size() const { return 4; }
};


class SIYInstruction : private Instruction {
 public:
  inline int B1Value() const { return Bits<SixByteInstr, int>(31, 28); }
  inline int32_t D1Value() const {
    int32_t value = Bits<SixByteInstr, uint32_t>(27, 16);
    value += Bits<SixByteInstr, int8_t>(15, 8) << 12;
    return value;
  }
  inline uint8_t I2Value() const { return Bits<SixByteInstr, uint8_t>(39, 32); }
  inline int size() const { return 6; }
};


class SILInstruction : private Instruction {
 public:
  inline int B1Value() const { return Bits<SixByteInstr, int>(31, 28); }
  inline int D1Value() const { return Bits<SixByteInstr, int>(27, 16); }
  inline int I2Value() const { return Bits<SixByteInstr, int>(15, 0); }
  inline int size() const { return 6; }
};


class SSInstruction : private Instruction {
 public:
  inline int B1Value() const { return Bits<SixByteInstr, int>(31, 28); }
  inline int B2Value() const { return Bits<SixByteInstr, int>(15, 12); }
  inline int D1Value() const { return Bits<SixByteInstr, int>(27, 16); }
  inline int D2Value() const { return Bits<SixByteInstr, int>(11, 0); }
  inline int Length() const { return Bits<SixByteInstr, int>(39, 32); }
  inline int size() const { return 6; }
};


class RXEInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<SixByteInstr, int>(39, 36); }
  inline int X2Value() const { return Bits<SixByteInstr, int>(35, 32); }
  inline int B2Value() const { return Bits<SixByteInstr, int>(31, 28); }
  inline int D2Value() const { return Bits<SixByteInstr, int>(27, 16); }
  inline int size() const { return 6; }
};


class RIEInstruction : private Instruction {
 public:
  inline int R1Value() const { return Bits<SixByteInstr, int>(39, 36); }
  inline int R2Value() const { return Bits<SixByteInstr, int>(35, 32); }
  inline int I3Value() const { return Bits<SixByteInstr, uint32_t>(31, 24); }
  inline int I4Value() const { return Bits<SixByteInstr, uint32_t>(23, 16); }
  inline int I5Value() const { return Bits<SixByteInstr, uint32_t>(15, 8); }
  inline int I6Value() const {
    return static_cast<int32_t>(Bits<SixByteInstr, int16_t>(31, 16));
  }
  inline int size() const { return 6; }
};


class Registers {
 public:

  static int Number(const char* name);

 private:
  static const char* names_[kNumRegisters];
};


class DoubleRegisters {
 public:

  static int Number(const char* name);

 private:
  static const char* names_[kNumDoubleRegisters];
};

}
}
namespace v8 {
namespace internal {

enum KeyedAccessStoreMode {
  STANDARD_STORE,
  STORE_TRANSITION_TO_OBJECT,
  STORE_TRANSITION_TO_DOUBLE,
  STORE_AND_GROW_NO_TRANSITION,
  STORE_AND_GROW_TRANSITION_TO_OBJECT,
  STORE_AND_GROW_TRANSITION_TO_DOUBLE,
  STORE_NO_TRANSITION_IGNORE_OUT_OF_BOUNDS,
  STORE_NO_TRANSITION_HANDLE_COW
};




enum class ToPrimitiveHint { kDefault, kNumber, kString };




enum class OrdinaryToPrimitiveHint { kNumber, kString };


enum TypeofMode : int { INSIDE_TYPEOF, NOT_INSIDE_TYPEOF };


enum MutableMode {
  MUTABLE,
  IMMUTABLE
};


enum ExternalArrayType {
  kExternalInt8Array = 1,
  kExternalUint8Array,
  kExternalInt16Array,
  kExternalUint16Array,
  kExternalInt32Array,
  kExternalUint32Array,
  kExternalFloat32Array,
  kExternalFloat64Array,
  kExternalUint8ClampedArray,
};


static inline bool IsTransitionStoreMode(KeyedAccessStoreMode store_mode) {
  return store_mode == STORE_TRANSITION_TO_OBJECT ||
         store_mode == STORE_TRANSITION_TO_DOUBLE ||
         store_mode == STORE_AND_GROW_TRANSITION_TO_OBJECT ||
         store_mode == STORE_AND_GROW_TRANSITION_TO_DOUBLE;
}


static inline KeyedAccessStoreMode GetNonTransitioningStoreMode(
    KeyedAccessStoreMode store_mode) {
  if (store_mode >= STORE_NO_TRANSITION_IGNORE_OUT_OF_BOUNDS) {
    return store_mode;
  }
  if (store_mode >= STORE_AND_GROW_NO_TRANSITION) {
    return STORE_AND_GROW_NO_TRANSITION;
  }
  return STANDARD_STORE;
}


static inline bool IsGrowStoreMode(KeyedAccessStoreMode store_mode) {
  return store_mode >= STORE_AND_GROW_NO_TRANSITION &&
         store_mode <= STORE_AND_GROW_TRANSITION_TO_DOUBLE;
}


enum IcCheckType { ELEMENT, PROPERTY };






enum WriteBarrierMode {
  SKIP_WRITE_BARRIER,
  UPDATE_WEAK_WRITE_BARRIER,
  UPDATE_WRITE_BARRIER
};



enum StoreMode { ALLOW_IN_DESCRIPTOR, FORCE_FIELD };




enum PropertyNormalizationMode {
  CLEAR_INOBJECT_PROPERTIES,
  KEEP_INOBJECT_PROPERTIES
};







enum PrototypeOptimizationMode { REGULAR_PROTOTYPE, FAST_PROTOTYPE };



enum TransitionFlag {
  INSERT_TRANSITION,
  OMIT_TRANSITION
};





enum SimpleTransitionFlag {
  SIMPLE_PROPERTY_TRANSITION,
  PROPERTY_TRANSITION,
  SPECIAL_TRANSITION
};




enum DescriptorFlag {
  ALL_DESCRIPTORS,
  OWN_DESCRIPTORS
};
enum MarkingParity {
  NO_MARKING_PARITY,
  ODD_MARKING_PARITY,
  EVEN_MARKING_PARITY
};



typedef int ExtraICState;
static const ExtraICState kNoExtraICState = 0;


const int kVariableSizeSentinel = 0;



const int kStubMajorKeyBits = 7;
const int kStubMinorKeyBits = kSmiValueSize - kStubMajorKeyBits - 1;
const uint32_t kIsNotStringMask = 0x80;
const uint32_t kStringTag = 0x0;
const uint32_t kNotStringTag = 0x80;



const uint32_t kIsNotInternalizedMask = 0x40;
const uint32_t kNotInternalizedTag = 0x40;
const uint32_t kInternalizedTag = 0x0;



const uint32_t kStringEncodingMask = 0x4;
const uint32_t kTwoByteStringTag = 0x0;
const uint32_t kOneByteStringTag = 0x4;



const uint32_t kStringRepresentationMask = 0x03;
enum StringRepresentationTag {
  kSeqStringTag = 0x0,
  kConsStringTag = 0x1,
  kExternalStringTag = 0x2,
  kSlicedStringTag = 0x3
};
const uint32_t kIsIndirectStringMask = 0x1;
const uint32_t kIsIndirectStringTag = 0x1;
static_assert((kSeqStringTag & kIsIndirectStringMask) == 0, "(kSeqStringTag & kIsIndirectStringMask) == 0");
static_assert((kExternalStringTag & kIsIndirectStringMask) == 0, "(kExternalStringTag & kIsIndirectStringMask) == 0");
static_assert((kConsStringTag & kIsIndirectStringMask) == kIsIndirectStringTag, "(kConsStringTag & kIsIndirectStringMask) == kIsIndirectStringTag");

static_assert((kSlicedStringTag & kIsIndirectStringMask) == kIsIndirectStringTag, "(kSlicedStringTag & kIsIndirectStringMask) == kIsIndirectStringTag");




const uint32_t kSlicedNotConsMask = kSlicedStringTag & ~kConsStringTag;
static_assert(((kSlicedNotConsMask) != 0 && (((kSlicedNotConsMask) & ((kSlicedNotConsMask) - 1)) == 0)), "IS_POWER_OF_TWO(kSlicedNotConsMask)");



const uint32_t kOneByteDataHintMask = 0x08;
const uint32_t kOneByteDataHintTag = 0x08;



const uint32_t kShortExternalStringMask = 0x10;
const uint32_t kShortExternalStringTag = 0x10;
const uint32_t kShortcutTypeMask =
    kIsNotStringMask |
    kIsNotInternalizedMask |
    kStringRepresentationMask;
const uint32_t kShortcutTypeTag = kConsStringTag | kNotInternalizedTag;

static inline bool IsShortcutCandidate(int type) {
  return ((type & kShortcutTypeMask) == kShortcutTypeTag);
}

enum InstanceType {

  INTERNALIZED_STRING_TYPE = kTwoByteStringTag | kSeqStringTag |
                             kInternalizedTag,
  ONE_BYTE_INTERNALIZED_STRING_TYPE =
      kOneByteStringTag | kSeqStringTag | kInternalizedTag,
  EXTERNAL_INTERNALIZED_STRING_TYPE =
      kTwoByteStringTag | kExternalStringTag | kInternalizedTag,
  EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE =
      kOneByteStringTag | kExternalStringTag | kInternalizedTag,
  EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE =
      EXTERNAL_INTERNALIZED_STRING_TYPE | kOneByteDataHintTag |
      kInternalizedTag,
  SHORT_EXTERNAL_INTERNALIZED_STRING_TYPE = EXTERNAL_INTERNALIZED_STRING_TYPE |
                                            kShortExternalStringTag |
                                            kInternalizedTag,
  SHORT_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE =
      EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE | kShortExternalStringTag |
      kInternalizedTag,
  SHORT_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE =
      EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE |
      kShortExternalStringTag | kInternalizedTag,
  STRING_TYPE = INTERNALIZED_STRING_TYPE | kNotInternalizedTag,
  ONE_BYTE_STRING_TYPE =
      ONE_BYTE_INTERNALIZED_STRING_TYPE | kNotInternalizedTag,
  CONS_STRING_TYPE = kTwoByteStringTag | kConsStringTag | kNotInternalizedTag,
  CONS_ONE_BYTE_STRING_TYPE =
      kOneByteStringTag | kConsStringTag | kNotInternalizedTag,
  SLICED_STRING_TYPE =
      kTwoByteStringTag | kSlicedStringTag | kNotInternalizedTag,
  SLICED_ONE_BYTE_STRING_TYPE =
      kOneByteStringTag | kSlicedStringTag | kNotInternalizedTag,
  EXTERNAL_STRING_TYPE =
      EXTERNAL_INTERNALIZED_STRING_TYPE | kNotInternalizedTag,
  EXTERNAL_ONE_BYTE_STRING_TYPE =
      EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE | kNotInternalizedTag,
  EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE =
      EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE |
      kNotInternalizedTag,
  SHORT_EXTERNAL_STRING_TYPE =
      SHORT_EXTERNAL_INTERNALIZED_STRING_TYPE | kNotInternalizedTag,
  SHORT_EXTERNAL_ONE_BYTE_STRING_TYPE =
      SHORT_EXTERNAL_ONE_BYTE_INTERNALIZED_STRING_TYPE | kNotInternalizedTag,
  SHORT_EXTERNAL_STRING_WITH_ONE_BYTE_DATA_TYPE =
      SHORT_EXTERNAL_INTERNALIZED_STRING_WITH_ONE_BYTE_DATA_TYPE |
      kNotInternalizedTag,


  SYMBOL_TYPE = kNotStringTag,


  HEAP_NUMBER_TYPE,
  SIMD128_VALUE_TYPE,
  ODDBALL_TYPE,


  MAP_TYPE,
  CODE_TYPE,



  MUTABLE_HEAP_NUMBER_TYPE,
  FOREIGN_TYPE,
  BYTE_ARRAY_TYPE,
  BYTECODE_ARRAY_TYPE,
  FREE_SPACE_TYPE,
  FIXED_INT8_ARRAY_TYPE,
  FIXED_UINT8_ARRAY_TYPE,
  FIXED_INT16_ARRAY_TYPE,
  FIXED_UINT16_ARRAY_TYPE,
  FIXED_INT32_ARRAY_TYPE,
  FIXED_UINT32_ARRAY_TYPE,
  FIXED_FLOAT32_ARRAY_TYPE,
  FIXED_FLOAT64_ARRAY_TYPE,
  FIXED_UINT8_CLAMPED_ARRAY_TYPE,
  FIXED_DOUBLE_ARRAY_TYPE,
  FILLER_TYPE,


  ACCESSOR_INFO_TYPE,
  ACCESSOR_PAIR_TYPE,
  ACCESS_CHECK_INFO_TYPE,
  INTERCEPTOR_INFO_TYPE,
  CALL_HANDLER_INFO_TYPE,
  FUNCTION_TEMPLATE_INFO_TYPE,
  OBJECT_TEMPLATE_INFO_TYPE,
  SIGNATURE_INFO_TYPE,
  TYPE_SWITCH_INFO_TYPE,
  ALLOCATION_SITE_TYPE,
  ALLOCATION_MEMENTO_TYPE,
  SCRIPT_TYPE,
  CODE_CACHE_TYPE,
  POLYMORPHIC_CODE_CACHE_TYPE,
  TYPE_FEEDBACK_INFO_TYPE,
  ALIASED_ARGUMENTS_ENTRY_TYPE,
  BOX_TYPE,
  DEBUG_INFO_TYPE,
  BREAK_POINT_INFO_TYPE,
  FIXED_ARRAY_TYPE,
  SHARED_FUNCTION_INFO_TYPE,
  CELL_TYPE,
  WEAK_CELL_TYPE,
  TRANSITION_ARRAY_TYPE,
  PROPERTY_CELL_TYPE,
  PROTOTYPE_INFO_TYPE,
  SLOPPY_BLOCK_WITH_EVAL_CONTEXT_EXTENSION_TYPE,





  JS_PROXY_TYPE,
  JS_GLOBAL_OBJECT_TYPE,
  JS_GLOBAL_PROXY_TYPE,

  JS_SPECIAL_API_OBJECT_TYPE,
  JS_VALUE_TYPE,
  JS_MESSAGE_OBJECT_TYPE,
  JS_DATE_TYPE,
  JS_OBJECT_TYPE,
  JS_CONTEXT_EXTENSION_OBJECT_TYPE,
  JS_GENERATOR_OBJECT_TYPE,
  JS_MODULE_TYPE,
  JS_ARRAY_TYPE,
  JS_ARRAY_BUFFER_TYPE,
  JS_TYPED_ARRAY_TYPE,
  JS_DATA_VIEW_TYPE,
  JS_SET_TYPE,
  JS_MAP_TYPE,
  JS_SET_ITERATOR_TYPE,
  JS_MAP_ITERATOR_TYPE,
  JS_WEAK_MAP_TYPE,
  JS_WEAK_SET_TYPE,
  JS_PROMISE_TYPE,
  JS_REGEXP_TYPE,
  JS_BOUND_FUNCTION_TYPE,
  JS_FUNCTION_TYPE,


  FIRST_TYPE = 0x0,
  LAST_TYPE = JS_FUNCTION_TYPE,
  FIRST_NAME_TYPE = FIRST_TYPE,
  LAST_NAME_TYPE = SYMBOL_TYPE,
  FIRST_UNIQUE_NAME_TYPE = INTERNALIZED_STRING_TYPE,
  LAST_UNIQUE_NAME_TYPE = SYMBOL_TYPE,
  FIRST_NONSTRING_TYPE = SYMBOL_TYPE,
  FIRST_PRIMITIVE_TYPE = FIRST_NAME_TYPE,
  LAST_PRIMITIVE_TYPE = ODDBALL_TYPE,
  FIRST_FUNCTION_TYPE = JS_BOUND_FUNCTION_TYPE,
  LAST_FUNCTION_TYPE = JS_FUNCTION_TYPE,

  FIRST_FIXED_TYPED_ARRAY_TYPE = FIXED_INT8_ARRAY_TYPE,
  LAST_FIXED_TYPED_ARRAY_TYPE = FIXED_UINT8_CLAMPED_ARRAY_TYPE,

  LAST_DATA_TYPE = FILLER_TYPE,





  FIRST_JS_RECEIVER_TYPE = JS_PROXY_TYPE,
  LAST_JS_RECEIVER_TYPE = LAST_TYPE,

  FIRST_JS_OBJECT_TYPE = JS_GLOBAL_OBJECT_TYPE,
  LAST_JS_OBJECT_TYPE = LAST_TYPE,

  LAST_SPECIAL_RECEIVER_TYPE = JS_SPECIAL_API_OBJECT_TYPE,



  LAST_CUSTOM_ELEMENTS_RECEIVER = JS_VALUE_TYPE,
};

static_assert(JS_OBJECT_TYPE == Internals::kJSObjectType, "JS_OBJECT_TYPE == Internals::kJSObjectType");
static_assert(FIRST_NONSTRING_TYPE == Internals::kFirstNonstringType, "FIRST_NONSTRING_TYPE == Internals::kFirstNonstringType");
static_assert(ODDBALL_TYPE == Internals::kOddballType, "ODDBALL_TYPE == Internals::kOddballType");
static_assert(FOREIGN_TYPE == Internals::kForeignType, "FOREIGN_TYPE == Internals::kForeignType");


std::ostream& operator<<(std::ostream& os, InstanceType instance_type);
enum FixedArraySubInstanceType {

  FAST_ELEMENTS_SUB_TYPE, DICTIONARY_ELEMENTS_SUB_TYPE, FAST_PROPERTIES_SUB_TYPE, DICTIONARY_PROPERTIES_SUB_TYPE, MAP_CODE_CACHE_SUB_TYPE, SCOPE_INFO_SUB_TYPE, STRING_TABLE_SUB_TYPE, DESCRIPTOR_ARRAY_SUB_TYPE,

      LAST_FIXED_ARRAY_SUB_TYPE = DESCRIPTOR_ARRAY_SUB_TYPE
};



enum CompareResult {
  LESS = -1,
  EQUAL = 0,
  GREATER = 1,

  NOT_EQUAL = GREATER
};




enum class ComparisonResult {
  kLessThan,
  kEqual,
  kGreaterThan,
  kUndefined
};
class AccessorPair;
class AllocationSite;
class AllocationSiteCreationContext;
class AllocationSiteUsageContext;
class Cell;
class ConsString;
class ElementsAccessor;
class FixedArrayBase;
class FunctionLiteral;
class JSGlobalObject;
class KeyAccumulator;
class LayoutDescriptor;
class LiteralsArray;
class LookupIterator;
class FieldType;
class ObjectHashTable;
class ObjectVisitor;
class PropertyCell;
class PropertyDescriptor;
class SafepointEntry;
class SharedFunctionInfo;
class StringStream;
class TypeFeedbackInfo;
class TypeFeedbackVector;
class WeakCell;
class TransitionArray;



template <class C> inline bool Is(Object* obj);
enum class ElementTypes { kAll, kStringAndSymbol };







class Object {
 public:

  bool IsObject() const { return true; }


  inline bool IsSmi() const; inline bool IsLayoutDescriptor() const; inline bool IsHeapObject() const; inline bool IsPrimitive() const; inline bool IsNumber() const;
  inline bool IsHeapNumber() const; inline bool IsMutableHeapNumber() const; inline bool IsSimd128Value() const; inline bool IsFloat32x4() const; inline bool IsInt32x4() const; inline bool IsUint32x4() const; inline bool IsBool32x4() const; inline bool IsInt16x8() const; inline bool IsUint16x8() const; inline bool IsBool16x8() const; inline bool IsInt8x16() const; inline bool IsUint8x16() const; inline bool IsBool8x16() const; inline bool IsName() const; inline bool IsUniqueName() const; inline bool IsString() const; inline bool IsSeqString() const; inline bool IsExternalString() const; inline bool IsConsString() const; inline bool IsSlicedString() const; inline bool IsExternalTwoByteString() const; inline bool IsExternalOneByteString() const; inline bool IsSeqTwoByteString() const; inline bool IsSeqOneByteString() const; inline bool IsInternalizedString() const; inline bool IsSymbol() const; inline bool IsFixedTypedArrayBase() const; inline bool IsFixedUint8Array() const; inline bool IsFixedInt8Array() const; inline bool IsFixedUint16Array() const; inline bool IsFixedInt16Array() const; inline bool IsFixedUint32Array() const; inline bool IsFixedInt32Array() const; inline bool IsFixedFloat32Array() const; inline bool IsFixedFloat64Array() const; inline bool IsFixedUint8ClampedArray() const; inline bool IsByteArray() const; inline bool IsBytecodeArray() const; inline bool IsFreeSpace() const; inline bool IsJSReceiver() const; inline bool IsJSObject() const; inline bool IsJSContextExtensionObject() const; inline bool IsJSGeneratorObject() const; inline bool IsJSModule() const; inline bool IsMap() const; inline bool IsDescriptorArray() const; inline bool IsTransitionArray() const; inline bool IsLiteralsArray() const; inline bool IsTypeFeedbackMetadata() const; inline bool IsTypeFeedbackVector() const; inline bool IsDeoptimizationInputData() const; inline bool IsDeoptimizationOutputData() const; inline bool IsDependentCode() const; inline bool IsHandlerTable() const; inline bool IsFixedArray() const; inline bool IsFixedDoubleArray() const; inline bool IsWeakFixedArray() const; inline bool IsArrayList() const; inline bool IsContext() const; inline bool IsScriptContextTable() const; inline bool IsNativeContext() const; inline bool IsScopeInfo() const; inline bool IsJSBoundFunction() const; inline bool IsJSFunction() const; inline bool IsCode() const; inline bool IsAbstractCode() const; inline bool IsOddball() const; inline bool IsSharedFunctionInfo() const; inline bool IsJSValue() const; inline bool IsJSDate() const; inline bool IsJSMessageObject() const; inline bool IsStringWrapper() const; inline bool IsForeign() const; inline bool IsBoolean() const; inline bool IsJSArray() const; inline bool IsJSArrayBuffer() const; inline bool IsJSArrayBufferView() const; inline bool IsJSTypedArray() const; inline bool IsJSDataView() const; inline bool IsJSProxy() const; inline bool IsJSSet() const; inline bool IsJSMap() const; inline bool IsJSSetIterator() const; inline bool IsJSMapIterator() const; inline bool IsJSWeakCollection() const; inline bool IsJSWeakMap() const; inline bool IsJSWeakSet() const; inline bool IsJSRegExp() const; inline bool IsHashTable() const; inline bool IsDictionary() const; inline bool IsStringTable() const; inline bool IsStringSet() const; inline bool IsNormalizedMapCache() const; inline bool IsCompilationCacheTable() const; inline bool IsCodeCacheHashTable() const; inline bool IsPolymorphicCodeCacheHashTable() const; inline bool IsMapCache() const; inline bool IsJSGlobalObject() const; inline bool IsJSGlobalProxy() const; inline bool IsUndetectable() const; inline bool IsAccessCheckNeeded() const; inline bool IsCallable() const; inline bool IsFunction() const; inline bool IsConstructor() const; inline bool IsTemplateInfo() const; inline bool IsFiller() const; inline bool IsFixedArrayBase() const; inline bool IsExternal() const; inline bool IsStruct() const; inline bool IsCell() const; inline bool IsPropertyCell() const; inline bool IsWeakCell() const; inline bool IsObjectHashTable() const; inline bool IsWeakHashTable() const; inline bool IsOrderedHashTable() const;
  inline bool IsUndefined() const; inline bool IsNull() const; inline bool IsTheHole() const; inline bool IsException() const; inline bool IsUninitialized() const; inline bool IsTrue() const; inline bool IsFalse() const; inline bool IsArgumentsMarker() const; inline bool IsOptimizedOut() const;




  enum StoreFromKeyed {
    MAY_BE_STORE_FROM_KEYED,
    CERTAINLY_NOT_STORE_FROM_KEYED
  };

  enum ShouldThrow { THROW_ON_ERROR, DONT_THROW };
  inline bool IsBox() const; inline bool IsAccessorInfo() const; inline bool IsAccessorPair() const; inline bool IsAccessCheckInfo() const; inline bool IsInterceptorInfo() const; inline bool IsCallHandlerInfo() const; inline bool IsFunctionTemplateInfo() const; inline bool IsObjectTemplateInfo() const; inline bool IsScript() const; inline bool IsAllocationSite() const; inline bool IsAllocationMemento() const; inline bool IsCodeCache() const; inline bool IsPolymorphicCodeCache() const; inline bool IsTypeFeedbackInfo() const; inline bool IsAliasedArgumentsEntry() const; inline bool IsDebugInfo() const; inline bool IsBreakPointInfo() const; inline bool IsPrototypeInfo() const; inline bool IsSloppyBlockWithEvalContextExtension() const;



  __attribute__((warn_unused_result)) static Maybe<bool> IsArray(Handle<Object> object);

  inline bool IsNameDictionary() const;
  inline bool IsGlobalDictionary() const;
  inline bool IsSeededNumberDictionary() const;
  inline bool IsUnseededNumberDictionary() const;
  inline bool IsOrderedHashSet() const;
  inline bool IsOrderedHashMap() const;
  static bool IsPromise(Handle<Object> object);


  inline double Number() const;
  inline bool IsNaN() const;
  inline bool IsMinusZero() const;
  bool ToInt32(int32_t* value);
  inline bool ToUint32(uint32_t* value);

  inline Representation OptimalRepresentation();

  inline ElementsKind OptimalElementsKind();

  inline bool FitsRepresentation(Representation representation);




  inline bool KeyEquals(Object* other);

  inline bool FilterKey(PropertyFilter filter);

  Handle<FieldType> OptimalType(Isolate* isolate,
                                Representation representation);

  inline static Handle<Object> NewStorageFor(Isolate* isolate,
                                             Handle<Object> object,
                                             Representation representation);

  inline static Handle<Object> WrapForRead(Isolate* isolate,
                                           Handle<Object> object,
                                           Representation representation);



  inline bool HasValidElements();

  inline bool HasSpecificClassOf(String* name);

  bool BooleanValue();


  __attribute__((warn_unused_result)) static Maybe<ComparisonResult> Compare(Handle<Object> x,
                                                         Handle<Object> y);


  __attribute__((warn_unused_result)) static Maybe<bool> Equals(Handle<Object> x, Handle<Object> y);


  bool StrictEquals(Object* that);



  __attribute__((warn_unused_result)) static inline MaybeHandle<JSReceiver> ToObject(
      Isolate* isolate, Handle<Object> object);
  __attribute__((warn_unused_result)) static MaybeHandle<JSReceiver> ToObject(
      Isolate* isolate, Handle<Object> object, Handle<Context> context);


  __attribute__((warn_unused_result)) static inline MaybeHandle<Name> ToName(Isolate* isolate,
                                                         Handle<Object> input);


  __attribute__((warn_unused_result)) static inline MaybeHandle<Object> ToPrimitive(
      Handle<Object> input, ToPrimitiveHint hint = ToPrimitiveHint::kDefault);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> ToNumber(Handle<Object> input);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> ToInteger(Isolate* isolate,
                                                       Handle<Object> input);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> ToInt32(Isolate* isolate,
                                                     Handle<Object> input);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> ToUint32(Isolate* isolate,
                                                      Handle<Object> input);


  __attribute__((warn_unused_result)) static MaybeHandle<String> ToString(Isolate* isolate,
                                                      Handle<Object> input);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> ToLength(Isolate* isolate,
                                                      Handle<Object> input);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> GetMethod(
      Handle<JSReceiver> receiver, Handle<Name> name);


  __attribute__((warn_unused_result)) static MaybeHandle<FixedArray> CreateListFromArrayLike(
      Isolate* isolate, Handle<Object> object, ElementTypes element_types);


  static bool IsErrorObject(Isolate* isolate, Handle<Object> object);


  static Handle<String> TypeOf(Isolate* isolate, Handle<Object> object);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> Multiply(Isolate* isolate,
                                                      Handle<Object> lhs,
                                                      Handle<Object> rhs);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> Divide(Isolate* isolate,
                                                    Handle<Object> lhs,
                                                    Handle<Object> rhs);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> Modulus(Isolate* isolate,
                                                     Handle<Object> lhs,
                                                     Handle<Object> rhs);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> Add(Isolate* isolate,
                                                 Handle<Object> lhs,
                                                 Handle<Object> rhs);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> Subtract(Isolate* isolate,
                                                      Handle<Object> lhs,
                                                      Handle<Object> rhs);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> ShiftLeft(Isolate* isolate,
                                                       Handle<Object> lhs,
                                                       Handle<Object> rhs);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> ShiftRight(Isolate* isolate,
                                                        Handle<Object> lhs,
                                                        Handle<Object> rhs);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> ShiftRightLogical(
      Isolate* isolate, Handle<Object> lhs, Handle<Object> rhs);


  __attribute__((warn_unused_result)) static inline Maybe<bool> GreaterThan(Handle<Object> x,
                                                        Handle<Object> y);
  __attribute__((warn_unused_result)) static inline Maybe<bool> GreaterThanOrEqual(
      Handle<Object> x, Handle<Object> y);
  __attribute__((warn_unused_result)) static inline Maybe<bool> LessThan(Handle<Object> x,
                                                     Handle<Object> y);
  __attribute__((warn_unused_result)) static inline Maybe<bool> LessThanOrEqual(Handle<Object> x,
                                                            Handle<Object> y);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> BitwiseAnd(Isolate* isolate,
                                                        Handle<Object> lhs,
                                                        Handle<Object> rhs);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> BitwiseOr(Isolate* isolate,
                                                       Handle<Object> lhs,
                                                       Handle<Object> rhs);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> BitwiseXor(Isolate* isolate,
                                                        Handle<Object> lhs,
                                                        Handle<Object> rhs);

  __attribute__((warn_unused_result)) static MaybeHandle<Object> GetProperty(LookupIterator* it);
  __attribute__((warn_unused_result)) static Maybe<bool> SetProperty(LookupIterator* it,
                                                 Handle<Object> value,
                                                 LanguageMode language_mode,
                                                 StoreFromKeyed store_mode);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> SetProperty(
      Handle<Object> object, Handle<Name> name, Handle<Object> value,
      LanguageMode language_mode,
      StoreFromKeyed store_mode = MAY_BE_STORE_FROM_KEYED);

  __attribute__((warn_unused_result)) static Maybe<bool> SetSuperProperty(
      LookupIterator* it, Handle<Object> value, LanguageMode language_mode,
      StoreFromKeyed store_mode);

  __attribute__((warn_unused_result)) static MaybeHandle<Object> ReadAbsentProperty(
      LookupIterator* it);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> ReadAbsentProperty(
      Isolate* isolate, Handle<Object> receiver, Handle<Object> name);
  __attribute__((warn_unused_result)) static Maybe<bool> CannotCreateProperty(
      Isolate* isolate, Handle<Object> receiver, Handle<Object> name,
      Handle<Object> value, ShouldThrow should_throw);
  __attribute__((warn_unused_result)) static Maybe<bool> WriteToReadOnlyProperty(
      LookupIterator* it, Handle<Object> value, ShouldThrow should_throw);
  __attribute__((warn_unused_result)) static Maybe<bool> WriteToReadOnlyProperty(
      Isolate* isolate, Handle<Object> receiver, Handle<Object> name,
      Handle<Object> value, ShouldThrow should_throw);
  __attribute__((warn_unused_result)) static Maybe<bool> RedefineIncompatibleProperty(
      Isolate* isolate, Handle<Object> name, Handle<Object> value,
      ShouldThrow should_throw);
  __attribute__((warn_unused_result)) static Maybe<bool> SetDataProperty(LookupIterator* it,
                                                     Handle<Object> value);
  __attribute__((warn_unused_result)) static Maybe<bool> AddDataProperty(
      LookupIterator* it, Handle<Object> value, PropertyAttributes attributes,
      ShouldThrow should_throw, StoreFromKeyed store_mode);
  __attribute__((warn_unused_result)) static inline MaybeHandle<Object> GetPropertyOrElement(
      Handle<Object> object, Handle<Name> name);
  __attribute__((warn_unused_result)) static inline MaybeHandle<Object> GetPropertyOrElement(
      Handle<Object> receiver, Handle<Name> name, Handle<JSReceiver> holder);
  __attribute__((warn_unused_result)) static inline MaybeHandle<Object> GetProperty(
      Handle<Object> object, Handle<Name> name);

  __attribute__((warn_unused_result)) static MaybeHandle<Object> GetPropertyWithAccessor(
      LookupIterator* it);
  __attribute__((warn_unused_result)) static Maybe<bool> SetPropertyWithAccessor(
      LookupIterator* it, Handle<Object> value, ShouldThrow should_throw);

  __attribute__((warn_unused_result)) static MaybeHandle<Object> GetPropertyWithDefinedGetter(
      Handle<Object> receiver,
      Handle<JSReceiver> getter);
  __attribute__((warn_unused_result)) static Maybe<bool> SetPropertyWithDefinedSetter(
      Handle<Object> receiver, Handle<JSReceiver> setter, Handle<Object> value,
      ShouldThrow should_throw);

  __attribute__((warn_unused_result)) static inline MaybeHandle<Object> GetElement(
      Isolate* isolate, Handle<Object> object, uint32_t index);

  __attribute__((warn_unused_result)) static inline MaybeHandle<Object> SetElement(
      Isolate* isolate, Handle<Object> object, uint32_t index,
      Handle<Object> value, LanguageMode language_mode);



  Object* GetHash();




  Object* GetSimpleHash();




  static Handle<Smi> GetOrCreateHash(Isolate* isolate, Handle<Object> object);




  bool SameValue(Object* other);





  bool SameValueZero(Object* other);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> ArraySpeciesConstructor(
      Isolate* isolate, Handle<Object> original_array);



  inline bool ToArrayLength(uint32_t* index);




  inline bool ToArrayIndex(uint32_t* index);

  void ObjectVerify();


  static void VerifyPointer(Object* p);


  inline void VerifyApiCallResultType();


  __attribute__((warn_unused_result)) static MaybeHandle<String> ObjectProtoToString(
      Isolate* isolate, Handle<Object> object);


  void ShortPrint(FILE* out = ( *((__FILEP * const) (*(_Gtab(3))) ) ));


  void ShortPrint(StringStream* accumulator);

  void ShortPrint(std::ostream& os);

  inline static Object* cast(Object* object); inline static const Object* cast(const Object* object);


  static const int kHeaderSize = 0;



  void Print();


  void Print(std::ostream& os);





 private:
  friend class LookupIterator;
  friend class StringStream;


  Map* GetRootMap(Isolate* isolate);



  __attribute__((warn_unused_result)) static Maybe<bool> SetPropertyInternal(
      LookupIterator* it, Handle<Object> value, LanguageMode language_mode,
      StoreFromKeyed store_mode, bool* found);

  __attribute__((warn_unused_result)) static MaybeHandle<Name> ConvertToName(Isolate* isolate,
                                                         Handle<Object> input);

  Object() = delete; Object(const Object&) = delete; void operator=(const Object&) = delete;
};



bool Object::IsSmi() const { return ((reinterpret_cast<intptr_t>(this) & kSmiTagMask) == kSmiTag); }
bool Object::IsHeapObject() const { return Internals::HasHeapObjectTag(this); }


struct Brief {
  explicit Brief(const Object* const v) : value(v) {}
  const Object* value;
};


std::ostream& operator<<(std::ostream& os, const Brief& v);
class Smi: public Object {
 public:

  inline int value() const { return Internals::SmiValue(this); }


  static inline Smi* FromInt(int value) {
    do { if ((!(Smi::IsValid(value)))) { V8_Fatal(".././src/objects.h", 1418, "Check failed: %s.", "Smi::IsValid(value)"); } } while (0);
    return reinterpret_cast<Smi*>(Internals::IntToSmi(value));
  }

  static inline Smi* FromIntptr(intptr_t value) {
    do { if ((!(Smi::IsValid(value)))) { V8_Fatal(".././src/objects.h", 1423, "Check failed: %s.", "Smi::IsValid(value)"); } } while (0);
    int smi_shift_bits = kSmiTagSize + kSmiShiftSize;
    return reinterpret_cast<Smi*>((value << smi_shift_bits) | kSmiTag);
  }


  static inline bool IsValid(intptr_t value) {
    bool result = Internals::IsValidSmi(value);
    do { if (std::string* _msg = ::v8::base::CheckEQImpl( (result), (value >= kMinValue && value <= kMaxValue), "result" " " "==" " " "value >= kMinValue && value <= kMaxValue")) { V8_Fatal(".././src/objects.h", 1431, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    return result;
  }

  inline static Smi* cast(Object* object); inline static const Smi* cast(const Object* object);


  void SmiPrint(std::ostream& os) const;
  void SmiVerify();

  static const int kMinValue =
      (static_cast<unsigned int>(-1)) << (kSmiValueSize - 1);
  static const int kMaxValue = -(kMinValue + 1);

 private:
  Smi() = delete; Smi(const Smi&) = delete; void operator=(const Smi&) = delete;
};






class MapWord : public Embedded {
 public:



  static inline MapWord FromMap(const Map* map);


  inline Map* ToMap();
  inline bool IsForwardingAddress();


  static inline MapWord FromForwardingAddress(HeapObject* object);


  inline HeapObject* ToForwardingAddress();

  static inline MapWord FromRawValue(uintptr_t value) {
    return MapWord(value);
  }

  inline uintptr_t ToRawValue() {
    return value_;
  }

 private:

  friend class HeapObject;

  explicit MapWord(uintptr_t value) : value_(value) {}

  uintptr_t value_;
};




class HeapObject: public Object {
 public:


  inline Map* map() const;
  inline void set_map(Map* value);



  inline void set_map_no_write_barrier(Map* value);


  inline Map* synchronized_map();
  inline MapWord synchronized_map_word() const;


  inline void synchronized_set_map(Map* value);
  inline void synchronized_set_map_no_write_barrier(Map* value);
  inline void synchronized_set_map_word(MapWord map_word);



  inline MapWord map_word() const;
  inline void set_map_word(MapWord map_word);


  inline Heap* GetHeap() const;


  inline Isolate* GetIsolate() const;


  inline bool IsHeapNumber() const; inline bool IsMutableHeapNumber() const; inline bool IsSimd128Value() const; inline bool IsFloat32x4() const; inline bool IsInt32x4() const; inline bool IsUint32x4() const; inline bool IsBool32x4() const; inline bool IsInt16x8() const; inline bool IsUint16x8() const; inline bool IsBool16x8() const; inline bool IsInt8x16() const; inline bool IsUint8x16() const; inline bool IsBool8x16() const; inline bool IsName() const; inline bool IsUniqueName() const; inline bool IsString() const; inline bool IsSeqString() const; inline bool IsExternalString() const; inline bool IsConsString() const; inline bool IsSlicedString() const; inline bool IsExternalTwoByteString() const; inline bool IsExternalOneByteString() const; inline bool IsSeqTwoByteString() const; inline bool IsSeqOneByteString() const; inline bool IsInternalizedString() const; inline bool IsSymbol() const; inline bool IsFixedTypedArrayBase() const; inline bool IsFixedUint8Array() const; inline bool IsFixedInt8Array() const; inline bool IsFixedUint16Array() const; inline bool IsFixedInt16Array() const; inline bool IsFixedUint32Array() const; inline bool IsFixedInt32Array() const; inline bool IsFixedFloat32Array() const; inline bool IsFixedFloat64Array() const; inline bool IsFixedUint8ClampedArray() const; inline bool IsByteArray() const; inline bool IsBytecodeArray() const; inline bool IsFreeSpace() const; inline bool IsJSReceiver() const; inline bool IsJSObject() const; inline bool IsJSContextExtensionObject() const; inline bool IsJSGeneratorObject() const; inline bool IsJSModule() const; inline bool IsMap() const; inline bool IsDescriptorArray() const; inline bool IsTransitionArray() const; inline bool IsLiteralsArray() const; inline bool IsTypeFeedbackMetadata() const; inline bool IsTypeFeedbackVector() const; inline bool IsDeoptimizationInputData() const; inline bool IsDeoptimizationOutputData() const; inline bool IsDependentCode() const; inline bool IsHandlerTable() const; inline bool IsFixedArray() const; inline bool IsFixedDoubleArray() const; inline bool IsWeakFixedArray() const; inline bool IsArrayList() const; inline bool IsContext() const; inline bool IsScriptContextTable() const; inline bool IsNativeContext() const; inline bool IsScopeInfo() const; inline bool IsJSBoundFunction() const; inline bool IsJSFunction() const; inline bool IsCode() const; inline bool IsAbstractCode() const; inline bool IsOddball() const; inline bool IsSharedFunctionInfo() const; inline bool IsJSValue() const; inline bool IsJSDate() const; inline bool IsJSMessageObject() const; inline bool IsStringWrapper() const; inline bool IsForeign() const; inline bool IsBoolean() const; inline bool IsJSArray() const; inline bool IsJSArrayBuffer() const; inline bool IsJSArrayBufferView() const; inline bool IsJSTypedArray() const; inline bool IsJSDataView() const; inline bool IsJSProxy() const; inline bool IsJSSet() const; inline bool IsJSMap() const; inline bool IsJSSetIterator() const; inline bool IsJSMapIterator() const; inline bool IsJSWeakCollection() const; inline bool IsJSWeakMap() const; inline bool IsJSWeakSet() const; inline bool IsJSRegExp() const; inline bool IsHashTable() const; inline bool IsDictionary() const; inline bool IsStringTable() const; inline bool IsStringSet() const; inline bool IsNormalizedMapCache() const; inline bool IsCompilationCacheTable() const; inline bool IsCodeCacheHashTable() const; inline bool IsPolymorphicCodeCacheHashTable() const; inline bool IsMapCache() const; inline bool IsJSGlobalObject() const; inline bool IsJSGlobalProxy() const; inline bool IsUndetectable() const; inline bool IsAccessCheckNeeded() const; inline bool IsCallable() const; inline bool IsFunction() const; inline bool IsConstructor() const; inline bool IsTemplateInfo() const; inline bool IsFiller() const; inline bool IsFixedArrayBase() const; inline bool IsExternal() const; inline bool IsStruct() const; inline bool IsCell() const; inline bool IsPropertyCell() const; inline bool IsWeakCell() const; inline bool IsObjectHashTable() const; inline bool IsWeakHashTable() const; inline bool IsOrderedHashTable() const;
  inline bool IsUndefined() const; inline bool IsNull() const; inline bool IsTheHole() const; inline bool IsException() const; inline bool IsUninitialized() const; inline bool IsTrue() const; inline bool IsFalse() const; inline bool IsArgumentsMarker() const; inline bool IsOptimizedOut() const;



  inline bool IsBox() const; inline bool IsAccessorInfo() const; inline bool IsAccessorPair() const; inline bool IsAccessCheckInfo() const; inline bool IsInterceptorInfo() const; inline bool IsCallHandlerInfo() const; inline bool IsFunctionTemplateInfo() const; inline bool IsObjectTemplateInfo() const; inline bool IsScript() const; inline bool IsAllocationSite() const; inline bool IsAllocationMemento() const; inline bool IsCodeCache() const; inline bool IsPolymorphicCodeCache() const; inline bool IsTypeFeedbackInfo() const; inline bool IsAliasedArgumentsEntry() const; inline bool IsDebugInfo() const; inline bool IsBreakPointInfo() const; inline bool IsPrototypeInfo() const; inline bool IsSloppyBlockWithEvalContextExtension() const;



  static inline HeapObject* FromAddress(Address address) {
    do { if ((!((reinterpret_cast<intptr_t>(address) & ::v8::internal::kHeapObjectTagMask) == 0))) { V8_Fatal(".././src/objects.h", 1541, "Check failed: %s.", "(reinterpret_cast<intptr_t>(address) & ::v8::internal::kHeapObjectTagMask) == 0"); } } while (0);
    return reinterpret_cast<HeapObject*>(address + kHeapObjectTag);
  }


  inline Address address() {
    return reinterpret_cast<Address>(this) - kHeapObjectTag;
  }




  void Iterate(ObjectVisitor* v);

  template <typename ObjectVisitor>
  inline void IterateFast(ObjectVisitor* v);







  void IterateBody(ObjectVisitor* v);
  void IterateBody(InstanceType type, int object_size, ObjectVisitor* v);

  template <typename ObjectVisitor>
  inline void IterateBodyFast(ObjectVisitor* v);

  template <typename ObjectVisitor>
  inline void IterateBodyFast(InstanceType type, int object_size,
                              ObjectVisitor* v);




  bool IsValidSlot(int offset);


  inline int Size();




  inline int SizeFromMap(Map* map);





  static inline Object** RawField(HeapObject* obj, int offset);




  static void UpdateMapCodeCache(Handle<HeapObject> object,
                                 Handle<Name> name,
                                 Handle<Code> code);

  inline static HeapObject* cast(Object* object); inline static const HeapObject* cast(const Object* object);






  inline WriteBarrierMode GetWriteBarrierMode(
      const DisallowHeapAllocation& promise);


  void HeapObjectShortPrint(std::ostream& os);

  void PrintHeader(std::ostream& os, const char* id);

  void HeapObjectPrint(std::ostream& os);
  void HeapObjectVerify();

  inline void VerifyObjectField(int offset);
  inline void VerifySmiField(int offset);



  static void VerifyHeapPointer(Object* p);


  inline AllocationAlignment RequiredAlignment();



  static const int kMapOffset = Object::kHeaderSize;
  static const int kHeaderSize = kMapOffset + kPointerSize;

  static_assert(kMapOffset == Internals::kHeapObjectMapOffset, "kMapOffset == Internals::kHeapObjectMapOffset");

 private:
  HeapObject() = delete; HeapObject(const HeapObject&) = delete; void operator=(const HeapObject&) = delete;
};


template <int start_offset, int end_offset, int size>
class FixedBodyDescriptor;


template <int start_offset>
class FlexibleBodyDescriptor;




class HeapNumber: public HeapObject {
 public:

  inline double value() const;
  inline void set_value(double value);

  inline static HeapNumber* cast(Object* object); inline static const HeapNumber* cast(const Object* object);


  bool HeapNumberBooleanValue();

  void HeapNumberPrint(std::ostream& os);
  void HeapNumberVerify();

  inline int get_exponent();
  inline int get_sign();


  static const int kValueOffset = HeapObject::kHeaderSize;
  static const int kMantissaOffset = kValueOffset + 4;
  static const int kExponentOffset = kValueOffset;




  static const int kSize = kValueOffset + kDoubleSize;
  static const uint32_t kSignMask = 0x80000000u;
  static const uint32_t kExponentMask = 0x7ff00000u;
  static const uint32_t kMantissaMask = 0xfffffu;
  static const int kMantissaBits = 52;
  static const int kExponentBits = 11;
  static const int kExponentBias = 1023;
  static const int kExponentShift = 20;
  static const int kInfinityOrNanExponent =
      (kExponentMask >> kExponentShift) - kExponentBias;
  static const int kMantissaBitsInTopWord = 20;
  static const int kNonMantissaBitsInTopWord = 12;

 private:
  HeapNumber() = delete; HeapNumber(const HeapNumber&) = delete; void operator=(const HeapNumber&) = delete;
};



class Simd128Value : public HeapObject {
 public:
  inline static Simd128Value* cast(Object* object); inline static const Simd128Value* cast(const Object* object);

  void Simd128ValuePrint(std::ostream& os);
  void Simd128ValueVerify();

  static Handle<String> ToString(Handle<Simd128Value> input);


  inline bool Equals(Simd128Value* that);
  static inline bool Equals(Handle<Simd128Value> one, Handle<Simd128Value> two);


  bool BitwiseEquals(const Simd128Value* other) const;

  uint32_t Hash() const;

  void CopyBits(void* destination) const;


  static const int kValueOffset = HeapObject::kHeaderSize;
  static const int kSize = kValueOffset + kSimd128Size;

 private:
  Simd128Value() = delete; Simd128Value(const Simd128Value&) = delete; void operator=(const Simd128Value&) = delete;
};
class Float32x4 final : public Simd128Value { public: inline float get_lane(int lane) const; inline void set_lane(int lane, float value); inline static Float32x4* cast(Object* object); inline static const Float32x4* cast(const Object* object); void Float32x4Print(std::ostream& os); static Handle<String> ToString(Handle<Float32x4> input); inline bool Equals(Float32x4* that); private: Float32x4() = delete; Float32x4(const Float32x4&) = delete; void operator=(const Float32x4&) = delete; }; class Int32x4 final : public Simd128Value { public: inline int32_t get_lane(int lane) const; inline void set_lane(int lane, int32_t value); inline static Int32x4* cast(Object* object); inline static const Int32x4* cast(const Object* object); void Int32x4Print(std::ostream& os); static Handle<String> ToString(Handle<Int32x4> input); inline bool Equals(Int32x4* that); private: Int32x4() = delete; Int32x4(const Int32x4&) = delete; void operator=(const Int32x4&) = delete; }; class Uint32x4 final : public Simd128Value { public: inline uint32_t get_lane(int lane) const; inline void set_lane(int lane, uint32_t value); inline static Uint32x4* cast(Object* object); inline static const Uint32x4* cast(const Object* object); void Uint32x4Print(std::ostream& os); static Handle<String> ToString(Handle<Uint32x4> input); inline bool Equals(Uint32x4* that); private: Uint32x4() = delete; Uint32x4(const Uint32x4&) = delete; void operator=(const Uint32x4&) = delete; }; class Bool32x4 final : public Simd128Value { public: inline bool get_lane(int lane) const; inline void set_lane(int lane, bool value); inline static Bool32x4* cast(Object* object); inline static const Bool32x4* cast(const Object* object); void Bool32x4Print(std::ostream& os); static Handle<String> ToString(Handle<Bool32x4> input); inline bool Equals(Bool32x4* that); private: Bool32x4() = delete; Bool32x4(const Bool32x4&) = delete; void operator=(const Bool32x4&) = delete; }; class Int16x8 final : public Simd128Value { public: inline int16_t get_lane(int lane) const; inline void set_lane(int lane, int16_t value); inline static Int16x8* cast(Object* object); inline static const Int16x8* cast(const Object* object); void Int16x8Print(std::ostream& os); static Handle<String> ToString(Handle<Int16x8> input); inline bool Equals(Int16x8* that); private: Int16x8() = delete; Int16x8(const Int16x8&) = delete; void operator=(const Int16x8&) = delete; }; class Uint16x8 final : public Simd128Value { public: inline uint16_t get_lane(int lane) const; inline void set_lane(int lane, uint16_t value); inline static Uint16x8* cast(Object* object); inline static const Uint16x8* cast(const Object* object); void Uint16x8Print(std::ostream& os); static Handle<String> ToString(Handle<Uint16x8> input); inline bool Equals(Uint16x8* that); private: Uint16x8() = delete; Uint16x8(const Uint16x8&) = delete; void operator=(const Uint16x8&) = delete; }; class Bool16x8 final : public Simd128Value { public: inline bool get_lane(int lane) const; inline void set_lane(int lane, bool value); inline static Bool16x8* cast(Object* object); inline static const Bool16x8* cast(const Object* object); void Bool16x8Print(std::ostream& os); static Handle<String> ToString(Handle<Bool16x8> input); inline bool Equals(Bool16x8* that); private: Bool16x8() = delete; Bool16x8(const Bool16x8&) = delete; void operator=(const Bool16x8&) = delete; }; class Int8x16 final : public Simd128Value { public: inline int8_t get_lane(int lane) const; inline void set_lane(int lane, int8_t value); inline static Int8x16* cast(Object* object); inline static const Int8x16* cast(const Object* object); void Int8x16Print(std::ostream& os); static Handle<String> ToString(Handle<Int8x16> input); inline bool Equals(Int8x16* that); private: Int8x16() = delete; Int8x16(const Int8x16&) = delete; void operator=(const Int8x16&) = delete; }; class Uint8x16 final : public Simd128Value { public: inline uint8_t get_lane(int lane) const; inline void set_lane(int lane, uint8_t value); inline static Uint8x16* cast(Object* object); inline static const Uint8x16* cast(const Object* object); void Uint8x16Print(std::ostream& os); static Handle<String> ToString(Handle<Uint8x16> input); inline bool Equals(Uint8x16* that); private: Uint8x16() = delete; Uint8x16(const Uint8x16&) = delete; void operator=(const Uint8x16&) = delete; }; class Bool8x16 final : public Simd128Value { public: inline bool get_lane(int lane) const; inline void set_lane(int lane, bool value); inline static Bool8x16* cast(Object* object); inline static const Bool8x16* cast(const Object* object); void Bool8x16Print(std::ostream& os); static Handle<String> ToString(Handle<Bool8x16> input); inline bool Equals(Bool8x16* that); private: Bool8x16() = delete; Bool8x16(const Bool8x16&) = delete; void operator=(const Bool8x16&) = delete; };



enum EnsureElementsMode {
  DONT_ALLOW_DOUBLE_ELEMENTS,
  ALLOW_COPIED_DOUBLE_ELEMENTS,
  ALLOW_CONVERTED_DOUBLE_ELEMENTS
};



enum AccessorComponent {
  ACCESSOR_GETTER,
  ACCESSOR_SETTER
};


enum GetKeysConversion { KEEP_NUMBERS, CONVERT_TO_STRING };

enum KeyCollectionType { OWN_ONLY, INCLUDE_PROTOS };



class JSReceiver: public HeapObject {
 public:



  inline FixedArray* properties() const; inline void set_properties(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline void initialize_properties();
  inline bool HasFastProperties();

  inline NameDictionary* property_dictionary();


  static void DeleteNormalizedProperty(Handle<JSReceiver> object,
                                       Handle<Name> name, int entry);

  inline static JSReceiver* cast(Object* object); inline static const JSReceiver* cast(const Object* object);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> ToPrimitive(
      Handle<JSReceiver> receiver,
      ToPrimitiveHint hint = ToPrimitiveHint::kDefault);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> OrdinaryToPrimitive(
      Handle<JSReceiver> receiver, OrdinaryToPrimitiveHint hint);

  static MaybeHandle<Context> GetFunctionRealm(Handle<JSReceiver> receiver);


  static inline MaybeHandle<Object> GetPrototype(Isolate* isolate,
                                                 Handle<JSReceiver> receiver);

  __attribute__((warn_unused_result)) static Maybe<bool> HasInPrototypeChain(
      Isolate* isolate, Handle<JSReceiver> object, Handle<Object> proto);


  __attribute__((warn_unused_result)) static Maybe<bool> HasProperty(LookupIterator* it);
  __attribute__((warn_unused_result)) static inline Maybe<bool> HasProperty(
      Handle<JSReceiver> object, Handle<Name> name);
  __attribute__((warn_unused_result)) static inline Maybe<bool> HasElement(
      Handle<JSReceiver> object, uint32_t index);

  __attribute__((warn_unused_result)) static inline Maybe<bool> HasOwnProperty(
      Handle<JSReceiver> object, Handle<Name> name);

  __attribute__((warn_unused_result)) static inline MaybeHandle<Object> GetProperty(
      Isolate* isolate, Handle<JSReceiver> receiver, const char* key);
  __attribute__((warn_unused_result)) static inline MaybeHandle<Object> GetProperty(
      Handle<JSReceiver> receiver, Handle<Name> name);
  __attribute__((warn_unused_result)) static inline MaybeHandle<Object> GetElement(
      Isolate* isolate, Handle<JSReceiver> receiver, uint32_t index);


  __attribute__((warn_unused_result)) static Maybe<bool> DeletePropertyOrElement(
      Handle<JSReceiver> object, Handle<Name> name,
      LanguageMode language_mode = SLOPPY);
  __attribute__((warn_unused_result)) static Maybe<bool> DeleteProperty(
      Handle<JSReceiver> object, Handle<Name> name,
      LanguageMode language_mode = SLOPPY);
  __attribute__((warn_unused_result)) static Maybe<bool> DeleteProperty(LookupIterator* it,
                                                    LanguageMode language_mode);
  __attribute__((warn_unused_result)) static Maybe<bool> DeleteElement(
      Handle<JSReceiver> object, uint32_t index,
      LanguageMode language_mode = SLOPPY);

  __attribute__((warn_unused_result)) static Object* DefineProperty(Isolate* isolate,
                                                Handle<Object> object,
                                                Handle<Object> name,
                                                Handle<Object> attributes);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> DefineProperties(
      Isolate* isolate, Handle<Object> object, Handle<Object> properties);


  __attribute__((warn_unused_result)) static Maybe<bool> DefineOwnProperty(
      Isolate* isolate, Handle<JSReceiver> object, Handle<Object> key,
      PropertyDescriptor* desc, ShouldThrow should_throw);


  __attribute__((warn_unused_result)) static Maybe<bool> CreateDataProperty(
      LookupIterator* it, Handle<Object> value, ShouldThrow should_throw);


  __attribute__((warn_unused_result)) static Maybe<bool> OrdinaryDefineOwnProperty(
      Isolate* isolate, Handle<JSObject> object, Handle<Object> key,
      PropertyDescriptor* desc, ShouldThrow should_throw);
  __attribute__((warn_unused_result)) static Maybe<bool> OrdinaryDefineOwnProperty(
      LookupIterator* it, PropertyDescriptor* desc, ShouldThrow should_throw);

  __attribute__((warn_unused_result)) static Maybe<bool> IsCompatiblePropertyDescriptor(
      Isolate* isolate, bool extensible, PropertyDescriptor* desc,
      PropertyDescriptor* current, Handle<Name> property_name,
      ShouldThrow should_throw);



  __attribute__((warn_unused_result)) static Maybe<bool> ValidateAndApplyPropertyDescriptor(
      Isolate* isolate, LookupIterator* it, bool extensible,
      PropertyDescriptor* desc, PropertyDescriptor* current,
      ShouldThrow should_throw, Handle<Name> property_name = Handle<Name>());

  __attribute__((warn_unused_result)) static Maybe<bool> GetOwnPropertyDescriptor(
      Isolate* isolate, Handle<JSReceiver> object, Handle<Object> key,
      PropertyDescriptor* desc);
  __attribute__((warn_unused_result)) static Maybe<bool> GetOwnPropertyDescriptor(
      LookupIterator* it, PropertyDescriptor* desc);

  typedef PropertyAttributes IntegrityLevel;



  __attribute__((warn_unused_result)) static Maybe<bool> SetIntegrityLevel(
      Handle<JSReceiver> object, IntegrityLevel lvl, ShouldThrow should_throw);



  __attribute__((warn_unused_result)) static Maybe<bool> TestIntegrityLevel(
      Handle<JSReceiver> object, IntegrityLevel lvl);


  __attribute__((warn_unused_result)) static Maybe<bool> PreventExtensions(
      Handle<JSReceiver> object, ShouldThrow should_throw);

  __attribute__((warn_unused_result)) static Maybe<bool> IsExtensible(Handle<JSReceiver> object);


  bool IsSimpleEnum();


  String* class_name();


  __attribute__((warn_unused_result)) static MaybeHandle<String> BuiltinStringTag(
      Handle<JSReceiver> object);



  static Handle<String> GetConstructorName(Handle<JSReceiver> receiver);

  Context* GetCreationContext();

  __attribute__((warn_unused_result)) static inline Maybe<PropertyAttributes> GetPropertyAttributes(
      Handle<JSReceiver> object, Handle<Name> name);
  __attribute__((warn_unused_result)) static inline Maybe<PropertyAttributes>
  GetOwnPropertyAttributes(Handle<JSReceiver> object, Handle<Name> name);

  __attribute__((warn_unused_result)) static inline Maybe<PropertyAttributes> GetElementAttributes(
      Handle<JSReceiver> object, uint32_t index);
  __attribute__((warn_unused_result)) static inline Maybe<PropertyAttributes>
  GetOwnElementAttributes(Handle<JSReceiver> object, uint32_t index);

  __attribute__((warn_unused_result)) static Maybe<PropertyAttributes> GetPropertyAttributes(
      LookupIterator* it);


  __attribute__((warn_unused_result)) static Maybe<bool> SetPrototype(Handle<JSReceiver> object,
                                                  Handle<Object> value,
                                                  bool from_javascript,
                                                  ShouldThrow should_throw);

  inline static Handle<Object> GetDataProperty(Handle<JSReceiver> object,
                                               Handle<Name> name);
  static Handle<Object> GetDataProperty(LookupIterator* it);




  static inline Handle<Object> GetIdentityHash(Isolate* isolate,
                                               Handle<JSReceiver> object);



  inline static Handle<Smi> GetOrCreateIdentityHash(
      Handle<JSReceiver> object);


  __attribute__((warn_unused_result)) static MaybeHandle<FixedArray> OwnPropertyKeys(
      Handle<JSReceiver> object) {
    return GetKeys(object, OWN_ONLY, ALL_PROPERTIES, CONVERT_TO_STRING);
  }



  __attribute__((warn_unused_result)) static MaybeHandle<FixedArray> GetKeys(
      Handle<JSReceiver> object, KeyCollectionType type, PropertyFilter filter,
      GetKeysConversion keys_conversion = KEEP_NUMBERS,
      bool filter_proxy_keys_ = true);

  __attribute__((warn_unused_result)) static MaybeHandle<FixedArray> GetOwnValues(
      Handle<JSReceiver> object, PropertyFilter filter);

  __attribute__((warn_unused_result)) static MaybeHandle<FixedArray> GetOwnEntries(
      Handle<JSReceiver> object, PropertyFilter filter);


  static const int kPropertiesOffset = HeapObject::kHeaderSize;
  static const int kHeaderSize = HeapObject::kHeaderSize + kPointerSize;

 private:
  JSReceiver() = delete; JSReceiver(const JSReceiver&) = delete; void operator=(const JSReceiver&) = delete;
};






class JSObject: public JSReceiver {
 public:
  static __attribute__((warn_unused_result)) MaybeHandle<JSObject> New(
      Handle<JSFunction> constructor, Handle<JSReceiver> new_target,
      Handle<AllocationSite> site = Handle<AllocationSite>::null());


  inline GlobalDictionary* global_dictionary();

  static MaybeHandle<Context> GetFunctionRealm(Handle<JSObject> object);
  inline FixedArrayBase* elements() const; inline void set_elements(FixedArrayBase* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline void initialize_elements();
  static void ResetElements(Handle<JSObject> object);
  static inline void SetMapAndElements(Handle<JSObject> object,
                                       Handle<Map> map,
                                       Handle<FixedArrayBase> elements);
  inline ElementsKind GetElementsKind();
  ElementsAccessor* GetElementsAccessor();

  inline bool HasFastSmiElements();

  inline bool HasFastObjectElements();


  inline bool HasFastSmiOrObjectElements();

  inline bool HasFastElements();


  inline bool HasFastDoubleElements();


  inline bool HasFastHoleyElements();
  inline bool HasSloppyArgumentsElements();
  inline bool HasStringWrapperElements();
  inline bool HasDictionaryElements();

  inline bool HasFixedTypedArrayElements();

  inline bool HasFixedUint8ClampedElements();
  inline bool HasFixedArrayElements();
  inline bool HasFixedInt8Elements();
  inline bool HasFixedUint8Elements();
  inline bool HasFixedInt16Elements();
  inline bool HasFixedUint16Elements();
  inline bool HasFixedInt32Elements();
  inline bool HasFixedUint32Elements();
  inline bool HasFixedFloat32Elements();
  inline bool HasFixedFloat64Elements();

  inline bool HasFastArgumentsElements();
  inline bool HasSlowArgumentsElements();
  inline bool HasFastStringWrapperElements();
  inline bool HasSlowStringWrapperElements();
  bool HasEnumerableElements();

  inline SeededNumberDictionary* element_dictionary();


  static void EnsureWritableFastElements(Handle<JSObject> object);




  static Handle<Object> PrepareElementsForSort(Handle<JSObject> object,
                                               uint32_t limit);



  static Handle<Object> PrepareSlowElementsForSort(Handle<JSObject> object,
                                                   uint32_t limit);

  __attribute__((warn_unused_result)) static Maybe<bool> SetPropertyWithInterceptor(
      LookupIterator* it, ShouldThrow should_throw, Handle<Object> value);




  enum AccessorInfoHandling { FORCE_FIELD, DONT_FORCE_FIELD };

  __attribute__((warn_unused_result)) static MaybeHandle<Object> DefineOwnPropertyIgnoreAttributes(
      LookupIterator* it, Handle<Object> value, PropertyAttributes attributes,
      AccessorInfoHandling handling = DONT_FORCE_FIELD);

  __attribute__((warn_unused_result)) static Maybe<bool> DefineOwnPropertyIgnoreAttributes(
      LookupIterator* it, Handle<Object> value, PropertyAttributes attributes,
      ShouldThrow should_throw,
      AccessorInfoHandling handling = DONT_FORCE_FIELD);

  __attribute__((warn_unused_result)) static MaybeHandle<Object> SetOwnPropertyIgnoreAttributes(
      Handle<JSObject> object, Handle<Name> name, Handle<Object> value,
      PropertyAttributes attributes);

  __attribute__((warn_unused_result)) static MaybeHandle<Object> SetOwnElementIgnoreAttributes(
      Handle<JSObject> object, uint32_t index, Handle<Object> value,
      PropertyAttributes attributes);



  __attribute__((warn_unused_result)) static MaybeHandle<Object>
  DefinePropertyOrElementIgnoreAttributes(Handle<JSObject> object,
                                          Handle<Name> name,
                                          Handle<Object> value,
                                          PropertyAttributes attributes = NONE);



  __attribute__((warn_unused_result)) static Maybe<bool> CreateDataProperty(
      LookupIterator* it, Handle<Object> value,
      ShouldThrow should_throw = DONT_THROW);

  static void AddProperty(Handle<JSObject> object, Handle<Name> name,
                          Handle<Object> value, PropertyAttributes attributes);

  __attribute__((warn_unused_result)) static Maybe<bool> AddDataElement(
      Handle<JSObject> receiver, uint32_t index, Handle<Object> value,
      PropertyAttributes attributes, ShouldThrow should_throw);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> AddDataElement(
      Handle<JSObject> receiver, uint32_t index, Handle<Object> value,
      PropertyAttributes attributes);



  static void AllocateStorageForMap(Handle<JSObject> object, Handle<Map> map);



  static void MigrateInstance(Handle<JSObject> instance);



  static bool TryMigrateInstance(Handle<JSObject> instance);



  static void SetNormalizedProperty(Handle<JSObject> object, Handle<Name> name,
                                    Handle<Object> value,
                                    PropertyDetails details);
  static void SetDictionaryElement(Handle<JSObject> object, uint32_t index,
                                   Handle<Object> value,
                                   PropertyAttributes attributes);
  static void SetDictionaryArgumentsElement(Handle<JSObject> object,
                                            uint32_t index,
                                            Handle<Object> value,
                                            PropertyAttributes attributes);

  static void OptimizeAsPrototype(Handle<JSObject> object,
                                  PrototypeOptimizationMode mode);
  static void ReoptimizeIfPrototype(Handle<JSObject> object);
  static void LazyRegisterPrototypeUser(Handle<Map> user, Isolate* isolate);
  static void UpdatePrototypeUserRegistration(Handle<Map> old_map,
                                              Handle<Map> new_map,
                                              Isolate* isolate);
  static bool UnregisterPrototypeUser(Handle<Map> user, Isolate* isolate);
  static void InvalidatePrototypeChains(Map* map);


  class PrototypeRegistryCompactionCallback {
   public:
    static void Callback(Object* value, int old_index, int new_index);
  };


  inline InterceptorInfo* GetNamedInterceptor();
  inline InterceptorInfo* GetIndexedInterceptor();


  __attribute__((warn_unused_result)) static Maybe<PropertyAttributes>
  GetPropertyAttributesWithInterceptor(LookupIterator* it);
  __attribute__((warn_unused_result)) static Maybe<PropertyAttributes>
      GetPropertyAttributesWithFailedAccessCheck(LookupIterator* it);



  __attribute__((warn_unused_result)) static MaybeHandle<Object> GetAccessor(
      Handle<JSObject> object,
      Handle<Name> name,
      AccessorComponent component);



  static MaybeHandle<Object> DefineAccessor(Handle<JSObject> object,
                                            Handle<Name> name,
                                            Handle<Object> getter,
                                            Handle<Object> setter,
                                            PropertyAttributes attributes);
  static MaybeHandle<Object> DefineAccessor(LookupIterator* it,
                                            Handle<Object> getter,
                                            Handle<Object> setter,
                                            PropertyAttributes attributes);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> SetAccessor(
      Handle<JSObject> object,
      Handle<AccessorInfo> info);




  __attribute__((warn_unused_result)) static MaybeHandle<Object> GetPropertyWithInterceptor(
      LookupIterator* it, bool* done);
  static Handle<Object> SetHiddenProperty(Handle<JSObject> object,
                                          Handle<Name> key,
                                          Handle<Object> value);



  Object* GetHiddenProperty(Handle<Name> key);


  static void DeleteHiddenProperty(Handle<JSObject> object,
                                   Handle<Name> key);

  static bool HasHiddenProperties(Handle<JSObject> object);

  static void ValidateElements(Handle<JSObject> object);


  static inline void EnsureCanContainHeapObjectElements(Handle<JSObject> obj);


  static inline void EnsureCanContainElements(
      Handle<JSObject> object,
      Object** elements,
      uint32_t count,
      EnsureElementsMode mode);
  static inline void EnsureCanContainElements(
      Handle<JSObject> object,
      Handle<FixedArrayBase> elements,
      uint32_t length,
      EnsureElementsMode mode);
  static void EnsureCanContainElements(
      Handle<JSObject> object,
      Arguments* arguments,
      uint32_t first_arg,
      uint32_t arg_count,
      EnsureElementsMode mode);



  bool WouldConvertToSlowElements(uint32_t index);


  static uint32_t NewElementsCapacity(uint32_t old_capacity) {

    return old_capacity + (old_capacity >> 1) + 16;
  }


  static void UpdateAllocationSite(Handle<JSObject> object,
                                   ElementsKind to_kind);



  inline bool HasNamedInterceptor();
  inline bool HasIndexedInterceptor();


  __attribute__((warn_unused_result)) static Maybe<bool> HasRealNamedProperty(
      Handle<JSObject> object, Handle<Name> name);
  __attribute__((warn_unused_result)) static Maybe<bool> HasRealElementProperty(
      Handle<JSObject> object, uint32_t index);
  __attribute__((warn_unused_result)) static Maybe<bool> HasRealNamedCallbackProperty(
      Handle<JSObject> object, Handle<Name> name);



  static inline int GetHeaderSize(InstanceType instance_type);
  inline int GetHeaderSize();

  static inline int GetInternalFieldCount(Map* map);
  inline int GetInternalFieldCount();
  inline int GetInternalFieldOffset(int index);
  inline Object* GetInternalField(int index);
  inline void SetInternalField(int index, Object* value);
  inline void SetInternalField(int index, Smi* value);

  void CollectOwnPropertyNames(KeyAccumulator* keys,
                               PropertyFilter filter = ALL_PROPERTIES);




  int NumberOfOwnElements(PropertyFilter filter);



  int GetOwnElementKeys(FixedArray* storage, PropertyFilter filter);

  static void CollectOwnElementKeys(Handle<JSObject> object,
                                    KeyAccumulator* keys,
                                    PropertyFilter filter);

  static Handle<FixedArray> GetEnumPropertyKeys(Handle<JSObject> object);

  static Handle<FixedArray> GetFastEnumPropertyKeys(Isolate* isolate,
                                                    Handle<JSObject> object);



  static Handle<Map> GetElementsTransitionMap(Handle<JSObject> object,
                                              ElementsKind to_kind);
  static void TransitionElementsKind(Handle<JSObject> object,
                                     ElementsKind to_kind);




  static void MigrateToMap(Handle<JSObject> object, Handle<Map> new_map,
                           int expected_additional_properties = 0);





  static void NormalizeProperties(Handle<JSObject> object,
                                  PropertyNormalizationMode mode,
                                  int expected_additional_properties,
                                  const char* reason);



  static Handle<SeededNumberDictionary> NormalizeElements(
      Handle<JSObject> object);

  void RequireSlowElements(SeededNumberDictionary* dictionary);


  static void MigrateSlowToFast(Handle<JSObject> object,
                                int unused_property_fields, const char* reason);

  inline bool IsUnboxedDoubleField(FieldIndex index);


  static Handle<Object> FastPropertyAt(Handle<JSObject> object,
                                       Representation representation,
                                       FieldIndex index);
  inline Object* RawFastPropertyAt(FieldIndex index);
  inline double RawFastDoublePropertyAt(FieldIndex index);

  inline void FastPropertyAtPut(FieldIndex index, Object* value);
  inline void RawFastPropertyAtPut(FieldIndex index, Object* value);
  inline void RawFastDoublePropertyAtPut(FieldIndex index, double value);
  inline void WriteToField(int descriptor, PropertyDetails details,
                           Object* value);
  inline void WriteToField(int descriptor, Object* value);


  inline int GetInObjectPropertyOffset(int index);
  inline Object* InObjectPropertyAt(int index);
  inline Object* InObjectPropertyAtPut(int index,
                                       Object* value,
                                       WriteBarrierMode mode
                                       = UPDATE_WRITE_BARRIER);


  __attribute__((warn_unused_result)) static Maybe<bool> SetPrototype(Handle<JSObject> object,
                                                  Handle<Object> value,
                                                  bool from_javascript,
                                                  ShouldThrow should_throw);






  inline void InitializeBody(Map* map, int start_offset,
                             Object* pre_allocated_value, Object* filler_value);


  bool ReferencesObject(Object* obj);

  __attribute__((warn_unused_result)) static Maybe<bool> PreventExtensions(
      Handle<JSObject> object, ShouldThrow should_throw);

  static bool IsExtensible(Handle<JSObject> object);


  static void SetObserved(Handle<JSObject> object);


  enum DeepCopyHints { kNoHints = 0, kObjectIsShallow = 1 };

  __attribute__((warn_unused_result)) static MaybeHandle<JSObject> DeepCopy(
      Handle<JSObject> object,
      AllocationSiteUsageContext* site_context,
      DeepCopyHints hints = kNoHints);
  __attribute__((warn_unused_result)) static MaybeHandle<JSObject> DeepWalk(
      Handle<JSObject> object,
      AllocationSiteCreationContext* site_context);

  inline static JSObject* cast(Object* object); inline static const JSObject* cast(const Object* object);


  void JSObjectShortPrint(StringStream* accumulator);
  void JSObjectPrint(std::ostream& os);
  void JSObjectVerify();

  void PrintProperties(std::ostream& os);
  void PrintElements(std::ostream& os);


  void PrintTransitions(std::ostream& os);


  static void PrintElementsTransition(
      FILE* file, Handle<JSObject> object,
      ElementsKind from_kind, Handle<FixedArrayBase> from_elements,
      ElementsKind to_kind, Handle<FixedArrayBase> to_elements);

  void PrintInstanceMigration(FILE* file, Map* original_map, Map* new_map);



  class SpillInformation {
   public:
    void Clear();
    void Print();
    int number_of_objects_;
    int number_of_objects_with_fast_properties_;
    int number_of_objects_with_fast_elements_;
    int number_of_fast_used_fields_;
    int number_of_fast_unused_fields_;
    int number_of_slow_used_properties_;
    int number_of_slow_unused_properties_;
    int number_of_fast_used_elements_;
    int number_of_fast_unused_elements_;
    int number_of_slow_used_elements_;
    int number_of_slow_unused_elements_;
  };

  void IncrementSpillStatistics(SpillInformation* info);






  bool ElementsAreSafeToExamine();


  Object* SlowReverseLookup(Object* value);



  static const uint32_t kMaxElementCount = 0xffffffffu;






  static const uint32_t kMaxGap = 1024;



  static const int kMaxUncheckedFastElementsLength = 5000;



  static const int kMaxUncheckedOldFastElementsLength = 500;



  static const int kInitialGlobalObjectUnusedPropertiesCount = 4;

  static const int kMaxInstanceSize = 255 * kPointerSize;



  static const int kFieldsAdded = 3;


  static const int kElementsOffset = JSReceiver::kHeaderSize;
  static const int kHeaderSize = kElementsOffset + kPointerSize;

  static_assert(kHeaderSize == Internals::kJSObjectHeaderSize, "kHeaderSize == Internals::kJSObjectHeaderSize");

  typedef FlexibleBodyDescriptor<JSReceiver::kPropertiesOffset> BodyDescriptor;


  __attribute__((warn_unused_result)) static MaybeHandle<Object> EnqueueChangeRecord(
      Handle<JSObject> object, const char* type, Handle<Name> name,
      Handle<Object> old_value);


  int GetFastElementsUsage();

  static bool AllCanRead(LookupIterator* it);
  static bool AllCanWrite(LookupIterator* it);

 private:
  friend class JSReceiver;
  friend class Object;


  __attribute__((warn_unused_result)) static MaybeHandle<Object> GetPropertyWithFailedAccessCheck(
      LookupIterator* it);

  __attribute__((warn_unused_result)) static Maybe<bool> SetPropertyWithFailedAccessCheck(
      LookupIterator* it, Handle<Object> value, ShouldThrow should_throw);


  static void AddSlowProperty(Handle<JSObject> object,
                              Handle<Name> name,
                              Handle<Object> value,
                              PropertyAttributes attributes);

  __attribute__((warn_unused_result)) static Maybe<bool> DeletePropertyWithInterceptor(
      LookupIterator* it, ShouldThrow should_throw);

  bool ReferencesObjectFromElements(FixedArray* elements,
                                    ElementsKind kind,
                                    Object* object);



  __attribute__((warn_unused_result)) Object* GetHiddenPropertiesHashTable();



  static Handle<ObjectHashTable> GetOrCreateHiddenPropertiesHashtable(
      Handle<JSObject> object);



  static Handle<Object> SetHiddenPropertiesHashTable(
      Handle<JSObject> object,
      Handle<Object> value);

  static Handle<Object> GetIdentityHash(Isolate* isolate,
                                        Handle<JSObject> object);

  static Handle<Smi> GetOrCreateIdentityHash(Handle<JSObject> object);



  template <PropertyAttributes attrs>
  __attribute__((warn_unused_result)) static Maybe<bool> PreventExtensionsWithTransition(
      Handle<JSObject> object, ShouldThrow should_throw);

  __attribute__((warn_unused_result)) static Maybe<bool> SetPrototypeUnobserved(
      Handle<JSObject> object, Handle<Object> value, bool from_javascript,
      ShouldThrow should_throw);

  JSObject() = delete; JSObject(const JSObject&) = delete; void operator=(const JSObject&) = delete;
};






class JSAccessorPropertyDescriptor: public JSObject {
 public:

  static const int kGetOffset = JSObject::kHeaderSize;
  static const int kSetOffset = kGetOffset + kPointerSize;
  static const int kEnumerableOffset = kSetOffset + kPointerSize;
  static const int kConfigurableOffset = kEnumerableOffset + kPointerSize;
  static const int kSize = kConfigurableOffset + kPointerSize;

  static const int kGetIndex = 0;
  static const int kSetIndex = 1;
  static const int kEnumerableIndex = 2;
  static const int kConfigurableIndex = 3;

 private:
  JSAccessorPropertyDescriptor() = delete; JSAccessorPropertyDescriptor(const JSAccessorPropertyDescriptor&) = delete; void operator=(const JSAccessorPropertyDescriptor&) = delete;
};






class JSDataPropertyDescriptor: public JSObject {
 public:

  static const int kValueOffset = JSObject::kHeaderSize;
  static const int kWritableOffset = kValueOffset + kPointerSize;
  static const int kEnumerableOffset = kWritableOffset + kPointerSize;
  static const int kConfigurableOffset = kEnumerableOffset + kPointerSize;
  static const int kSize = kConfigurableOffset + kPointerSize;

  static const int kValueIndex = 0;
  static const int kWritableIndex = 1;
  static const int kEnumerableIndex = 2;
  static const int kConfigurableIndex = 3;

 private:
  JSDataPropertyDescriptor() = delete; JSDataPropertyDescriptor(const JSDataPropertyDescriptor&) = delete; void operator=(const JSDataPropertyDescriptor&) = delete;
};





class JSIteratorResult: public JSObject {
 public:

  static const int kValueOffset = JSObject::kHeaderSize;
  static const int kDoneOffset = kValueOffset + kPointerSize;
  static const int kSize = kDoneOffset + kPointerSize;

  static const int kValueIndex = 0;
  static const int kDoneIndex = 1;

 private:
  JSIteratorResult() = delete; JSIteratorResult(const JSIteratorResult&) = delete; void operator=(const JSIteratorResult&) = delete;
};



class JSArgumentsObject: public JSObject {
 public:

  static const int kLengthOffset = JSObject::kHeaderSize;
  static const int kHeaderSize = kLengthOffset + kPointerSize;

  static const int kLengthIndex = 0;

 private:
  JSArgumentsObject() = delete; JSArgumentsObject(const JSArgumentsObject&) = delete; void operator=(const JSArgumentsObject&) = delete;
};




class JSSloppyArgumentsObject: public JSArgumentsObject {
 public:

  static const int kCalleeOffset = JSArgumentsObject::kHeaderSize;
  static const int kSize = kCalleeOffset + kPointerSize;

  static const int kCalleeIndex = 1;

 private:
  JSSloppyArgumentsObject() = delete; JSSloppyArgumentsObject(const JSSloppyArgumentsObject&) = delete; void operator=(const JSSloppyArgumentsObject&) = delete;
};




class JSStrictArgumentsObject: public JSArgumentsObject {
 public:

  static const int kSize = JSArgumentsObject::kHeaderSize;

 private:
  JSStrictArgumentsObject() = delete; JSStrictArgumentsObject(const JSStrictArgumentsObject&) = delete; void operator=(const JSStrictArgumentsObject&) = delete;
};




class FixedArrayBase: public HeapObject {
 public:

  inline int length() const;
  inline void set_length(int value);


  inline int synchronized_length() const;
  inline void synchronized_set_length(int value);

  inline static FixedArrayBase* cast(Object* object); inline static const FixedArrayBase* cast(const Object* object);



  static const int kLengthOffset = HeapObject::kHeaderSize;
  static const int kHeaderSize = kLengthOffset + kPointerSize;
};


class FixedDoubleArray;
class IncrementalMarking;



class FixedArray: public FixedArrayBase {
 public:

  inline Object* get(int index) const;
  static inline Handle<Object> get(FixedArray* array, int index,
                                   Isolate* isolate);

  inline void set(int index, Object* value);
  inline bool is_the_hole(int index);


  inline void set(int index, Smi* value);

  inline void set(int index, Object* value, WriteBarrierMode mode);


  inline void set_undefined(int index);
  inline void set_null(int index);
  inline void set_the_hole(int index);

  inline Object** GetFirstElementAddress();
  inline bool ContainsOnlySmisOrHoles();


  inline Object** data_start();

  inline void FillWithHoles(int from, int to);


  void Shrink(int length);


  void CopyTo(int pos, FixedArray* dest, int dest_pos, int len);


  static int SizeFor(int length) { return kHeaderSize + length * kPointerSize; }


  static int OffsetOfElementAt(int index) { return SizeFor(index); }


  inline Object** RawFieldOfElementAt(int index);

  inline static FixedArray* cast(Object* object); inline static const FixedArray* cast(const Object* object);




  static const int kMaxSize = 128 * MB * kPointerSize;

  static const int kMaxLength = (kMaxSize - kHeaderSize) / kPointerSize;


  void FixedArrayPrint(std::ostream& os);
  void FixedArrayVerify();


  bool IsEqualTo(FixedArray* other);





  void SwapPairs(FixedArray* numbers, int i, int j);




  void SortPairs(FixedArray* numbers, uint32_t len);

  typedef FlexibleBodyDescriptor<kHeaderSize> BodyDescriptor;

 protected:


  static inline void NoWriteBarrierSet(FixedArray* array,
                                       int index,
                                       Object* value);

 private:
  static_assert(kHeaderSize == Internals::kFixedArrayHeaderSize, "kHeaderSize == Internals::kFixedArrayHeaderSize");

  FixedArray() = delete; FixedArray(const FixedArray&) = delete; void operator=(const FixedArray&) = delete;
};



class FixedDoubleArray: public FixedArrayBase {
 public:

  inline double get_scalar(int index);
  inline uint64_t get_representation(int index);
  static inline Handle<Object> get(FixedDoubleArray* array, int index,
                                   Isolate* isolate);
  inline void set(int index, double value);
  inline void set_the_hole(int index);


  inline bool is_the_hole(int index);


  inline static int SizeFor(int length) {
    return kHeaderSize + length * kDoubleSize;
  }


  inline double* data_start();

  inline void FillWithHoles(int from, int to);


  static int OffsetOfElementAt(int index) { return SizeFor(index); }

  inline static FixedDoubleArray* cast(Object* object); inline static const FixedDoubleArray* cast(const Object* object);




  static const int kMaxSize = 512 * MB;

  static const int kMaxLength = (kMaxSize - kHeaderSize) / kDoubleSize;


  void FixedDoubleArrayPrint(std::ostream& os);
  void FixedDoubleArrayVerify();

 private:
  FixedDoubleArray() = delete; FixedDoubleArray(const FixedDoubleArray&) = delete; void operator=(const FixedDoubleArray&) = delete;
};


class WeakFixedArray : public FixedArray {
 public:



  static Handle<WeakFixedArray> Add(Handle<Object> maybe_array,
                                    Handle<HeapObject> value,
                                    int* assigned_index = 0);


  bool Remove(Handle<HeapObject> value);

  class NullCallback {
   public:
    static void Callback(Object* value, int old_index, int new_index) {}
  };

  template <class CompactionCallback>
  void Compact();

  inline Object* Get(int index) const;
  inline void Clear(int index);
  inline int Length() const;

  inline bool IsEmptySlot(int index) const;
  static Object* Empty() { return Smi::FromInt(0); }

  class Iterator {
   public:
    explicit Iterator(Object* maybe_array) : list_(0) { Reset(maybe_array); }
    void Reset(Object* maybe_array);

    template <class T>
    inline T* Next();

   private:
    int index_;
    WeakFixedArray* list_;

    int last_used_index_;
    DisallowHeapAllocation no_gc_;

    Iterator(const Iterator&) = delete; void operator=(const Iterator&) = delete;
  };

  inline static WeakFixedArray* cast(Object* object); inline static const WeakFixedArray* cast(const Object* object);

 private:
  static const int kLastUsedIndexIndex = 0;
  static const int kFirstIndex = 1;

  static Handle<WeakFixedArray> Allocate(
      Isolate* isolate, int size, Handle<WeakFixedArray> initialize_from);

  static void Set(Handle<WeakFixedArray> array, int index,
                  Handle<HeapObject> value);
  inline void clear(int index);

  inline int last_used_index() const;
  inline void set_last_used_index(int index);


  void set(int index, Smi* value);
  void set(int index, Object* value);
  void set(int index, Object* value, WriteBarrierMode mode);
  WeakFixedArray() = delete; WeakFixedArray(const WeakFixedArray&) = delete; void operator=(const WeakFixedArray&) = delete;
};



class ArrayList : public FixedArray {
 public:
  enum AddMode {
    kNone,

    kReloadLengthAfterAllocation,
  };
  static Handle<ArrayList> Add(Handle<ArrayList> array, Handle<Object> obj,
                               AddMode mode = kNone);
  static Handle<ArrayList> Add(Handle<ArrayList> array, Handle<Object> obj1,
                               Handle<Object> obj2, AddMode = kNone);
  inline int Length();
  inline void SetLength(int length);
  inline Object* Get(int index);
  inline Object** Slot(int index);
  inline void Set(int index, Object* obj);
  inline void Clear(int index, Object* undefined);
  bool IsFull();
  inline static ArrayList* cast(Object* object); inline static const ArrayList* cast(const Object* object);

 private:
  static Handle<ArrayList> EnsureSpace(Handle<ArrayList> array, int length);
  static const int kLengthIndex = 0;
  static const int kFirstIndex = 1;
  ArrayList() = delete; ArrayList(const ArrayList&) = delete; void operator=(const ArrayList&) = delete;
};
class DescriptorArray: public FixedArray {
 public:



  inline bool IsEmpty();


  inline int number_of_descriptors();

  inline int number_of_descriptors_storage();

  inline int NumberOfSlackDescriptors();

  inline void SetNumberOfDescriptors(int number_of_descriptors);
  inline int number_of_entries();

  inline bool HasEnumCache();

  inline void CopyEnumCacheFrom(DescriptorArray* array);

  inline FixedArray* GetEnumCache();

  inline bool HasEnumIndicesCache();

  inline FixedArray* GetEnumIndicesCache();

  inline Object** GetEnumCacheSlot();

  void ClearEnumCache();



  static void SetEnumCache(Handle<DescriptorArray> descriptors,
                           Isolate* isolate, Handle<FixedArray> new_cache,
                           Handle<FixedArray> new_index_cache);


  inline Name* GetKey(int descriptor_number);
  inline Object** GetKeySlot(int descriptor_number);
  inline Object* GetValue(int descriptor_number);
  inline void SetValue(int descriptor_number, Object* value);
  inline Object** GetValueSlot(int descriptor_number);
  static inline int GetValueOffset(int descriptor_number);
  inline Object** GetDescriptorStartSlot(int descriptor_number);
  inline Object** GetDescriptorEndSlot(int descriptor_number);
  inline PropertyDetails GetDetails(int descriptor_number);
  inline PropertyType GetType(int descriptor_number);
  inline int GetFieldIndex(int descriptor_number);
  FieldType* GetFieldType(int descriptor_number);
  inline Object* GetConstant(int descriptor_number);
  inline Object* GetCallbacksObject(int descriptor_number);
  inline AccessorDescriptor* GetCallbacks(int descriptor_number);

  inline Name* GetSortedKey(int descriptor_number);
  inline int GetSortedKeyIndex(int descriptor_number);
  inline void SetSortedKey(int pointer, int descriptor_number);
  inline void SetRepresentation(int descriptor_number,
                                Representation representation);


  inline void Get(int descriptor_number, Descriptor* desc);
  inline void Set(int descriptor_number, Descriptor* desc);
  void Replace(int descriptor_number, Descriptor* descriptor);




  inline void Append(Descriptor* desc);

  static Handle<DescriptorArray> CopyUpTo(Handle<DescriptorArray> desc,
                                          int enumeration_index,
                                          int slack = 0);

  static Handle<DescriptorArray> CopyUpToAddAttributes(
      Handle<DescriptorArray> desc,
      int enumeration_index,
      PropertyAttributes attributes,
      int slack = 0);


  void Sort();


  inline int Search(Name* name, int number_of_own_descriptors);



  inline int SearchWithCache(Isolate* isolate, Name* name, Map* map);

  bool IsEqualUpTo(DescriptorArray* desc, int nof_descriptors);



  static Handle<DescriptorArray> Allocate(
      Isolate* isolate, int number_of_descriptors, int slack,
      PretenureFlag pretenure = NOT_TENURED);

  inline static DescriptorArray* cast(Object* object); inline static const DescriptorArray* cast(const Object* object);


  static const int kNotFound = -1;

  static const int kDescriptorLengthIndex = 0;
  static const int kEnumCacheIndex = 1;
  static const int kFirstIndex = 2;


  static const int kEnumCacheBridgeLength = 2;
  static const int kEnumCacheBridgeCacheIndex = 0;
  static const int kEnumCacheBridgeIndicesCacheIndex = 1;


  static const int kDescriptorLengthOffset = FixedArray::kHeaderSize;
  static const int kEnumCacheOffset = kDescriptorLengthOffset + kPointerSize;
  static const int kFirstOffset = kEnumCacheOffset + kPointerSize;


  static const int kEnumCacheBridgeCacheOffset = FixedArray::kHeaderSize;


  static const int kDescriptorKey = 0;
  static const int kDescriptorDetails = 1;
  static const int kDescriptorValue = 2;
  static const int kDescriptorSize = 3;



  void Print();


  void PrintDescriptors(std::ostream& os);




  bool IsSortedNoDuplicates(int valid_descriptors = -1);


  bool IsConsistentWithBackPointers(Map* current_map);


  bool IsEqualTo(DescriptorArray* other);




  static int LengthFor(int number_of_descriptors) {
    return ToKeyIndex(number_of_descriptors);
  }

  static int ToDetailsIndex(int descriptor_number) {
    return kFirstIndex + (descriptor_number * kDescriptorSize) +
           kDescriptorDetails;
  }


  static int ToKeyIndex(int descriptor_number) {
    return kFirstIndex + (descriptor_number * kDescriptorSize) + kDescriptorKey;
  }

 private:

  class Entry {
   public:
    inline explicit Entry(DescriptorArray* descs, int index) :
        descs_(descs), index_(index) { }

    inline PropertyType type();
    inline Object* GetCallbackObject();

   private:
    DescriptorArray* descs_;
    int index_;
  };

  static int ToValueIndex(int descriptor_number) {
    return kFirstIndex +
           (descriptor_number * kDescriptorSize) +
           kDescriptorValue;
  }



  void CopyFrom(int index, DescriptorArray* src);

  inline void SetDescriptor(int descriptor_number, Descriptor* desc);


  inline void SwapSortedKeys(int first, int second);

  DescriptorArray() = delete; DescriptorArray(const DescriptorArray&) = delete; void operator=(const DescriptorArray&) = delete;
};


enum SearchMode { ALL_ENTRIES, VALID_ENTRIES };

template <SearchMode search_mode, typename T>
inline int Search(T* array, Name* name, int valid_entries = 0,
                  int* out_insertion_index = 0);
template<typename Key>
class BaseShape {
 public:
  static const bool UsesSeed = false;
  static uint32_t Hash(Key key) { return 0; }
  static uint32_t SeededHash(Key key, uint32_t seed) {
    do { if ((!(UsesSeed))) { V8_Fatal(".././src/objects.h", 3176, "Check failed: %s.", "UsesSeed"); } } while (0);
    return Hash(key);
  }
  static uint32_t HashForObject(Key key, Object* object) { return 0; }
  static uint32_t SeededHashForObject(Key key, uint32_t seed, Object* object) {
    do { if ((!(UsesSeed))) { V8_Fatal(".././src/objects.h", 3181, "Check failed: %s.", "UsesSeed"); } } while (0);
    return HashForObject(key, object);
  }
};


class HashTableBase : public FixedArray {
 public:

  inline int NumberOfElements();


  inline int NumberOfDeletedElements();


  inline int Capacity();



  inline void ElementAdded();



  inline void ElementRemoved();
  inline void ElementsRemoved(int n);



  static inline int ComputeCapacity(int at_least_space_for);



  inline bool IsKey(Object* k);
  inline bool IsKey(Heap* heap, Object* k);


  inline static uint32_t GetProbeOffset(uint32_t n) {
    return (n + n * n) >> 1;
  }

  static const int kNumberOfElementsIndex = 0;
  static const int kNumberOfDeletedElementsIndex = 1;
  static const int kCapacityIndex = 2;
  static const int kPrefixStartIndex = 3;


  static const int kNotFound = -1;

 protected:

  inline void SetNumberOfElements(int nof);


  inline void SetNumberOfDeletedElements(int nod);


  static uint32_t GetProbe(uint32_t hash, uint32_t number, uint32_t size) {
    do { if ((!(base::bits::IsPowerOfTwo32(size)))) { V8_Fatal(".././src/objects.h", 3238, "Check failed: %s.", "base::bits::IsPowerOfTwo32(size)"); } } while (0);
    return (hash + GetProbeOffset(number)) & (size - 1);
  }

  inline static uint32_t FirstProbe(uint32_t hash, uint32_t size) {
    return hash & (size - 1);
  }

  inline static uint32_t NextProbe(
      uint32_t last, uint32_t number, uint32_t size) {
    return (last + number) & (size - 1);
  }
};


template <typename Derived, typename Shape, typename Key>
class HashTable : public HashTableBase {
 public:

  inline uint32_t Hash(Key key) {
    if (Shape::UsesSeed) {
      return Shape::SeededHash(key, GetHeap()->HashSeed());
    } else {
      return Shape::Hash(key);
    }
  }

  inline uint32_t HashForObject(Key key, Object* object) {
    if (Shape::UsesSeed) {
      return Shape::SeededHashForObject(key, GetHeap()->HashSeed(), object);
    } else {
      return Shape::HashForObject(key, object);
    }
  }


  __attribute__((warn_unused_result)) static Handle<Derived> New(
      Isolate* isolate, int at_least_space_for,
      MinimumCapacity capacity_option = USE_DEFAULT_MINIMUM_CAPACITY,
      PretenureFlag pretenure = NOT_TENURED);

  inline static HashTable* cast(Object* object); inline static const HashTable* cast(const Object* object);


  void IteratePrefix(ObjectVisitor* visitor);
  void IterateElements(ObjectVisitor* visitor);


  inline int FindEntry(Key key);
  inline int FindEntry(Isolate* isolate, Key key, int32_t hash);
  int FindEntry(Isolate* isolate, Key key);


  void Rehash(Key key);


  Object* KeyAt(int entry) { return get(EntryToIndex(entry)); }

  static const int kElementsStartIndex = kPrefixStartIndex + Shape::kPrefixSize;
  static const int kEntrySize = Shape::kEntrySize;
  static const int kElementsStartOffset =
      kHeaderSize + kElementsStartIndex * kPointerSize;
  static const int kCapacityOffset =
      kHeaderSize + kCapacityIndex * kPointerSize;


  static inline int EntryToIndex(int entry) {
    return (entry * kEntrySize) + kElementsStartIndex;
  }

 protected:
  friend class ObjectHashTable;



  uint32_t FindInsertionEntry(uint32_t hash);


  __attribute__((warn_unused_result)) static Handle<Derived> Shrink(Handle<Derived> table, Key key);


  __attribute__((warn_unused_result)) static Handle<Derived> EnsureCapacity(
      Handle<Derived> table,
      int n,
      Key key,
      PretenureFlag pretenure = NOT_TENURED);


  bool HasSufficientCapacity(int n);


  void SetCapacity(int capacity) {



    do { if ((!(capacity > 0))) { V8_Fatal(".././src/objects.h", 3333, "Check failed: %s.", "capacity > 0"); } } while (0);
    do { if ((!(capacity <= kMaxCapacity))) { V8_Fatal(".././src/objects.h", 3334, "Check failed: %s.", "capacity <= kMaxCapacity"); } } while (0);
    set(kCapacityIndex, Smi::FromInt(capacity));
  }




  static const int kMaxCapacity =
      (FixedArray::kMaxLength - kElementsStartOffset) / kEntrySize;

 private:



  uint32_t EntryForProbe(Key key, Object* k, int probe, uint32_t expected);

  void Swap(uint32_t entry1, uint32_t entry2, WriteBarrierMode mode);


  void Rehash(Handle<Derived> new_table, Key key);
};



class HashTableKey {
 public:

  virtual bool IsMatch(Object* other) = 0;

  virtual uint32_t Hash() = 0;

  virtual uint32_t HashForObject(Object* key) = 0;

  __attribute__((warn_unused_result)) virtual Handle<Object> AsHandle(Isolate* isolate) = 0;

  virtual ~HashTableKey() {}
};


class StringTableShape : public BaseShape<HashTableKey*> {
 public:
  static inline bool IsMatch(HashTableKey* key, Object* value) {
    return key->IsMatch(value);
  }

  static inline uint32_t Hash(HashTableKey* key) {
    return key->Hash();
  }

  static inline uint32_t HashForObject(HashTableKey* key, Object* object) {
    return key->HashForObject(object);
  }

  static inline Handle<Object> AsHandle(Isolate* isolate, HashTableKey* key);

  static const int kPrefixSize = 0;
  static const int kEntrySize = 1;
};

class SeqOneByteString;





class StringTable: public HashTable<StringTable,
                                    StringTableShape,
                                    HashTableKey*> {
 public:


  static Handle<String> LookupString(Isolate* isolate, Handle<String> key);
  static Handle<String> LookupKey(Isolate* isolate, HashTableKey* key);
  static String* LookupKeyIfExists(Isolate* isolate, HashTableKey* key);



  __attribute__((warn_unused_result)) static MaybeHandle<String> InternalizeStringIfExists(
      Isolate* isolate,
      Handle<String> string);



  __attribute__((warn_unused_result)) static MaybeHandle<String> LookupStringIfExists(
      Isolate* isolate,
      Handle<String> str);
  __attribute__((warn_unused_result)) static MaybeHandle<String> LookupTwoCharsStringIfExists(
      Isolate* isolate,
      uint16_t c1,
      uint16_t c2);

  static void EnsureCapacityForDeserialization(Isolate* isolate, int expected);

  inline static StringTable* cast(Object* object); inline static const StringTable* cast(const Object* object);

 private:
  template <bool seq_one_byte>
  friend class JsonParser;

  StringTable() = delete; StringTable(const StringTable&) = delete; void operator=(const StringTable&) = delete;
};

class StringSetShape : public BaseShape<String*> {
 public:
  static inline bool IsMatch(String* key, Object* value);
  static inline uint32_t Hash(String* key);
  static inline uint32_t HashForObject(String* key, Object* object);

  static const int kPrefixSize = 0;
  static const int kEntrySize = 1;
};

class StringSet : public HashTable<StringSet, StringSetShape, String*> {
 public:
  static Handle<StringSet> New(Isolate* isolate);
  static Handle<StringSet> Add(Handle<StringSet> blacklist,
                               Handle<String> name);
  bool Has(Handle<String> name);

  inline static StringSet* cast(Object* object); inline static const StringSet* cast(const Object* object);
};

template <typename Derived, typename Shape, typename Key>
class Dictionary: public HashTable<Derived, Shape, Key> {
  typedef HashTable<Derived, Shape, Key> DerivedHashTable;

 public:

  Object* ValueAt(int entry) {
    return this->get(Derived::EntryToIndex(entry) + 1);
  }


  void ValueAtPut(int entry, Object* value) {
    this->set(Derived::EntryToIndex(entry) + 1, value);
  }


  PropertyDetails DetailsAt(int entry) {
    return Shape::DetailsAt(static_cast<Derived*>(this), entry);
  }


  void DetailsAtPut(int entry, PropertyDetails value) {
    Shape::DetailsAtPut(static_cast<Derived*>(this), entry, value);
  }


  bool IsDeleted(int entry) {
    return Shape::IsDeleted(static_cast<Derived*>(this), entry);
  }


  static Handle<Object> DeleteProperty(Handle<Derived> dictionary, int entry);


  __attribute__((warn_unused_result)) static inline Handle<Derived> Shrink(
      Handle<Derived> dictionary,
      Key key) {
    return DerivedHashTable::Shrink(dictionary, key);
  }



  void CopyValuesTo(FixedArray* elements);




  int NumberOfElementsFilterAttributes(PropertyFilter filter);



  int NumberOfEnumElements() {
    return NumberOfElementsFilterAttributes(ENUMERABLE_STRINGS);
  }

  enum SortMode { UNSORTED, SORTED };




  int CopyKeysTo(FixedArray* storage, int index, PropertyFilter filter,
                 SortMode sort_mode);


  static void CollectKeysTo(Handle<Dictionary<Derived, Shape, Key> > dictionary,
                            KeyAccumulator* keys, PropertyFilter filter);


  void CopyEnumKeysTo(FixedArray* storage);


  void SetNextEnumerationIndex(int index) {
    do { if ((!(index != 0))) { V8_Fatal(".././src/objects.h", 3528, "Check failed: %s.", "index != 0"); } } while (0);
    this->set(kNextEnumerationIndexIndex, Smi::FromInt(index));
  }

  int NextEnumerationIndex() {
    return Smi::cast(this->get(kNextEnumerationIndexIndex))->value();
  }


  __attribute__((warn_unused_result)) static Handle<Derived> New(
      Isolate* isolate,
      int at_least_space_for,
      PretenureFlag pretenure = NOT_TENURED);


  void SetRequiresCopyOnCapacityChange();


  static Handle<Derived> EnsureCapacity(Handle<Derived> obj, int n, Key key);


  void Print(std::ostream& os);


  Object* SlowReverseLookup(Object* value);


  inline void SetEntry(int entry,
                       Handle<Object> key,
                       Handle<Object> value);
  inline void SetEntry(int entry,
                       Handle<Object> key,
                       Handle<Object> value,
                       PropertyDetails details);

  __attribute__((warn_unused_result)) static Handle<Derived> Add(
      Handle<Derived> dictionary,
      Key key,
      Handle<Object> value,
      PropertyDetails details);



  static Handle<FixedArray> BuildIterationIndicesArray(
      Handle<Derived> dictionary);

 protected:

  __attribute__((warn_unused_result)) static Handle<Derived> AtPut(
      Handle<Derived> dictionary,
      Key key,
      Handle<Object> value);


  static void AddEntry(
      Handle<Derived> dictionary,
      Key key,
      Handle<Object> value,
      PropertyDetails details,
      uint32_t hash);



  static Handle<FixedArray> GenerateNewEnumerationIndices(
      Handle<Derived> dictionary);
  static const int kMaxNumberKeyIndex = DerivedHashTable::kPrefixStartIndex;
  static const int kNextEnumerationIndexIndex = kMaxNumberKeyIndex + 1;
};


template <typename Derived, typename Shape>
class NameDictionaryBase : public Dictionary<Derived, Shape, Handle<Name> > {
  typedef Dictionary<Derived, Shape, Handle<Name> > DerivedDictionary;

 public:


  int FindEntry(Handle<Name> key);
};


template <typename Key>
class BaseDictionaryShape : public BaseShape<Key> {
 public:
  template <typename Dictionary>
  static inline PropertyDetails DetailsAt(Dictionary* dict, int entry) {
    static_assert(Dictionary::kEntrySize == 3, "Dictionary::kEntrySize == 3");
    do { if ((!(entry >= 0))) { V8_Fatal(".././src/objects.h", 3615, "Check failed: %s.", "entry >= 0"); } } while (0);
    return PropertyDetails(
        Smi::cast(dict->get(Dictionary::EntryToIndex(entry) + 2)));
  }

  template <typename Dictionary>
  static inline void DetailsAtPut(Dictionary* dict, int entry,
                                  PropertyDetails value) {
    static_assert(Dictionary::kEntrySize == 3, "Dictionary::kEntrySize == 3");
    dict->set(Dictionary::EntryToIndex(entry) + 2, value.AsSmi());
  }

  template <typename Dictionary>
  static bool IsDeleted(Dictionary* dict, int entry) {
    return false;
  }

  template <typename Dictionary>
  static inline void SetEntry(Dictionary* dict, int entry, Handle<Object> key,
                              Handle<Object> value, PropertyDetails details);
};


class NameDictionaryShape : public BaseDictionaryShape<Handle<Name> > {
 public:
  static inline bool IsMatch(Handle<Name> key, Object* other);
  static inline uint32_t Hash(Handle<Name> key);
  static inline uint32_t HashForObject(Handle<Name> key, Object* object);
  static inline Handle<Object> AsHandle(Isolate* isolate, Handle<Name> key);
  static const int kPrefixSize = 2;
  static const int kEntrySize = 3;
  static const bool kIsEnumerable = true;
};


class NameDictionary
    : public NameDictionaryBase<NameDictionary, NameDictionaryShape> {
  typedef NameDictionaryBase<NameDictionary, NameDictionaryShape>
      DerivedDictionary;

 public:
  inline static NameDictionary* cast(Object* object); inline static const NameDictionary* cast(const Object* object);

  inline static Handle<FixedArray> DoGenerateNewEnumerationIndices(
      Handle<NameDictionary> dictionary);
};


class GlobalDictionaryShape : public NameDictionaryShape {
 public:
  static const int kEntrySize = 2;

  template <typename Dictionary>
  static inline PropertyDetails DetailsAt(Dictionary* dict, int entry);

  template <typename Dictionary>
  static inline void DetailsAtPut(Dictionary* dict, int entry,
                                  PropertyDetails value);

  template <typename Dictionary>
  static bool IsDeleted(Dictionary* dict, int entry);

  template <typename Dictionary>
  static inline void SetEntry(Dictionary* dict, int entry, Handle<Object> key,
                              Handle<Object> value, PropertyDetails details);
};


class GlobalDictionary
    : public NameDictionaryBase<GlobalDictionary, GlobalDictionaryShape> {
 public:
  inline static GlobalDictionary* cast(Object* object); inline static const GlobalDictionary* cast(const Object* object);
};


class NumberDictionaryShape : public BaseDictionaryShape<uint32_t> {
 public:
  static inline bool IsMatch(uint32_t key, Object* other);
  static inline Handle<Object> AsHandle(Isolate* isolate, uint32_t key);
  static const int kEntrySize = 3;
  static const bool kIsEnumerable = false;
};


class SeededNumberDictionaryShape : public NumberDictionaryShape {
 public:
  static const bool UsesSeed = true;
  static const int kPrefixSize = 2;

  static inline uint32_t SeededHash(uint32_t key, uint32_t seed);
  static inline uint32_t SeededHashForObject(uint32_t key,
                                             uint32_t seed,
                                             Object* object);
};


class UnseededNumberDictionaryShape : public NumberDictionaryShape {
 public:
  static const int kPrefixSize = 0;

  static inline uint32_t Hash(uint32_t key);
  static inline uint32_t HashForObject(uint32_t key, Object* object);
};


class SeededNumberDictionary
    : public Dictionary<SeededNumberDictionary,
                        SeededNumberDictionaryShape,
                        uint32_t> {
 public:
  inline static SeededNumberDictionary* cast(Object* object); inline static const SeededNumberDictionary* cast(const Object* object);


  __attribute__((warn_unused_result)) static Handle<SeededNumberDictionary> AtNumberPut(
      Handle<SeededNumberDictionary> dictionary, uint32_t key,
      Handle<Object> value, bool used_as_prototype);
  __attribute__((warn_unused_result)) static Handle<SeededNumberDictionary> AddNumberEntry(
      Handle<SeededNumberDictionary> dictionary, uint32_t key,
      Handle<Object> value, PropertyDetails details, bool used_as_prototype);



  __attribute__((warn_unused_result)) static Handle<SeededNumberDictionary> Set(
      Handle<SeededNumberDictionary> dictionary, uint32_t key,
      Handle<Object> value, PropertyDetails details, bool used_as_prototype);

  void UpdateMaxNumberKey(uint32_t key, bool used_as_prototype);



  bool HasComplexElements();






  inline bool requires_slow_elements();
  inline void set_requires_slow_elements();




  inline uint32_t max_number_key();


  static const int kRequiresSlowElementsMask = 1;
  static const int kRequiresSlowElementsTagSize = 1;
  static const uint32_t kRequiresSlowElementsLimit = (1 << 29) - 1;
};


class UnseededNumberDictionary
    : public Dictionary<UnseededNumberDictionary,
                        UnseededNumberDictionaryShape,
                        uint32_t> {
 public:
  inline static UnseededNumberDictionary* cast(Object* object); inline static const UnseededNumberDictionary* cast(const Object* object);


  __attribute__((warn_unused_result)) static Handle<UnseededNumberDictionary> AtNumberPut(
      Handle<UnseededNumberDictionary> dictionary,
      uint32_t key,
      Handle<Object> value);
  __attribute__((warn_unused_result)) static Handle<UnseededNumberDictionary> AddNumberEntry(
      Handle<UnseededNumberDictionary> dictionary,
      uint32_t key,
      Handle<Object> value);



  __attribute__((warn_unused_result)) static Handle<UnseededNumberDictionary> Set(
      Handle<UnseededNumberDictionary> dictionary,
      uint32_t key,
      Handle<Object> value);
};


class ObjectHashTableShape : public BaseShape<Handle<Object> > {
 public:
  static inline bool IsMatch(Handle<Object> key, Object* other);
  static inline uint32_t Hash(Handle<Object> key);
  static inline uint32_t HashForObject(Handle<Object> key, Object* object);
  static inline Handle<Object> AsHandle(Isolate* isolate, Handle<Object> key);
  static const int kPrefixSize = 0;
  static const int kEntrySize = 2;
};




class ObjectHashTable: public HashTable<ObjectHashTable,
                                        ObjectHashTableShape,
                                        Handle<Object> > {
  typedef HashTable<
      ObjectHashTable, ObjectHashTableShape, Handle<Object> > DerivedHashTable;
 public:
  inline static ObjectHashTable* cast(Object* object); inline static const ObjectHashTable* cast(const Object* object);


  __attribute__((warn_unused_result)) static inline Handle<ObjectHashTable> Shrink(
      Handle<ObjectHashTable> table,
      Handle<Object> key);



  Object* Lookup(Handle<Object> key);
  Object* Lookup(Handle<Object> key, int32_t hash);
  Object* Lookup(Isolate* isolate, Handle<Object> key, int32_t hash);


  static Handle<ObjectHashTable> Put(Handle<ObjectHashTable> table,
                                     Handle<Object> key,
                                     Handle<Object> value);
  static Handle<ObjectHashTable> Put(Handle<ObjectHashTable> table,
                                     Handle<Object> key, Handle<Object> value,
                                     int32_t hash);


  static Handle<ObjectHashTable> Remove(Handle<ObjectHashTable> table,
                                        Handle<Object> key,
                                        bool* was_present);
  static Handle<ObjectHashTable> Remove(Handle<ObjectHashTable> table,
                                        Handle<Object> key, bool* was_present,
                                        int32_t hash);

 protected:
  friend class MarkCompactCollector;

  void AddEntry(int entry, Object* key, Object* value);
  void RemoveEntry(int entry);


  static inline int EntryToValueIndex(int entry) {
    return EntryToIndex(entry) + 1;
  }
};
template<class Derived, class Iterator, int entrysize>
class OrderedHashTable: public FixedArray {
 public:

  static Handle<Derived> Allocate(
      Isolate* isolate, int capacity, PretenureFlag pretenure = NOT_TENURED);



  static Handle<Derived> EnsureGrowable(Handle<Derived> table);



  static Handle<Derived> Shrink(Handle<Derived> table);



  static Handle<Derived> Clear(Handle<Derived> table);


  static bool HasKey(Handle<Derived> table, Handle<Object> key);

  int NumberOfElements() {
    return Smi::cast(get(kNumberOfElementsIndex))->value();
  }

  int NumberOfDeletedElements() {
    return Smi::cast(get(kNumberOfDeletedElementsIndex))->value();
  }

  int UsedCapacity() { return NumberOfElements() + NumberOfDeletedElements(); }

  int NumberOfBuckets() {
    return Smi::cast(get(kNumberOfBucketsIndex))->value();
  }


  int EntryToIndex(int entry) {
    return kHashTableStartIndex + NumberOfBuckets() + (entry * kEntrySize);
  }

  int HashToBucket(int hash) { return hash & (NumberOfBuckets() - 1); }

  int HashToEntry(int hash) {
    int bucket = HashToBucket(hash);
    Object* entry = this->get(kHashTableStartIndex + bucket);
    return Smi::cast(entry)->value();
  }

  int KeyToFirstEntry(Object* key) {
    Object* hash = key->GetHash();

    if (hash->IsUndefined()) return kNotFound;
    return HashToEntry(Smi::cast(hash)->value());
  }

  int NextChainEntry(int entry) {
    Object* next_entry = get(EntryToIndex(entry) + kChainOffset);
    return Smi::cast(next_entry)->value();
  }

  Object* KeyAt(int entry) { return get(EntryToIndex(entry)); }

  bool IsObsolete() {
    return !get(kNextTableIndex)->IsSmi();
  }


  Derived* NextTable() {
    return Derived::cast(get(kNextTableIndex));
  }


  int RemovedIndexAt(int index) {
    return Smi::cast(get(kRemovedHolesIndex + index))->value();
  }

  static const int kNotFound = -1;
  static const int kMinCapacity = 4;

  static const int kNumberOfBucketsIndex = 0;
  static const int kNumberOfElementsIndex = kNumberOfBucketsIndex + 1;
  static const int kNumberOfDeletedElementsIndex = kNumberOfElementsIndex + 1;
  static const int kHashTableStartIndex = kNumberOfDeletedElementsIndex + 1;
  static const int kNextTableIndex = kNumberOfElementsIndex;

  static const int kNumberOfBucketsOffset =
      kHeaderSize + kNumberOfBucketsIndex * kPointerSize;
  static const int kNumberOfElementsOffset =
      kHeaderSize + kNumberOfElementsIndex * kPointerSize;
  static const int kNumberOfDeletedElementsOffset =
      kHeaderSize + kNumberOfDeletedElementsIndex * kPointerSize;
  static const int kHashTableStartOffset =
      kHeaderSize + kHashTableStartIndex * kPointerSize;
  static const int kNextTableOffset =
      kHeaderSize + kNextTableIndex * kPointerSize;

  static const int kEntrySize = entrysize + 1;
  static const int kChainOffset = entrysize;

  static const int kLoadFactor = 2;




  static const int kClearedTableSentinel = -1;

 protected:
  static Handle<Derived> Rehash(Handle<Derived> table, int new_capacity);

  void SetNumberOfBuckets(int num) {
    set(kNumberOfBucketsIndex, Smi::FromInt(num));
  }

  void SetNumberOfElements(int num) {
    set(kNumberOfElementsIndex, Smi::FromInt(num));
  }

  void SetNumberOfDeletedElements(int num) {
    set(kNumberOfDeletedElementsIndex, Smi::FromInt(num));
  }

  int Capacity() {
    return NumberOfBuckets() * kLoadFactor;
  }

  void SetNextTable(Derived* next_table) {
    set(kNextTableIndex, next_table);
  }

  void SetRemovedIndexAt(int index, int removed_index) {
    return set(kRemovedHolesIndex + index, Smi::FromInt(removed_index));
  }

  static const int kRemovedHolesIndex = kHashTableStartIndex;

  static const int kMaxCapacity =
      (FixedArray::kMaxLength - kHashTableStartIndex)
      / (1 + (kEntrySize * kLoadFactor));
};


class JSSetIterator;


class OrderedHashSet: public OrderedHashTable<
    OrderedHashSet, JSSetIterator, 1> {
 public:
  inline static OrderedHashSet* cast(Object* object); inline static const OrderedHashSet* cast(const Object* object);

  static Handle<OrderedHashSet> Add(Handle<OrderedHashSet> table,
                                    Handle<Object> value);
};


class JSMapIterator;


class OrderedHashMap
    : public OrderedHashTable<OrderedHashMap, JSMapIterator, 2> {
 public:
  inline static OrderedHashMap* cast(Object* object); inline static const OrderedHashMap* cast(const Object* object);

  inline Object* ValueAt(int entry);

  static const int kValueOffset = 1;
};


template <int entrysize>
class WeakHashTableShape : public BaseShape<Handle<Object> > {
 public:
  static inline bool IsMatch(Handle<Object> key, Object* other);
  static inline uint32_t Hash(Handle<Object> key);
  static inline uint32_t HashForObject(Handle<Object> key, Object* object);
  static inline Handle<Object> AsHandle(Isolate* isolate, Handle<Object> key);
  static const int kPrefixSize = 0;
  static const int kEntrySize = entrysize;
};





class WeakHashTable: public HashTable<WeakHashTable,
                                      WeakHashTableShape<2>,
                                      Handle<Object> > {
  typedef HashTable<
      WeakHashTable, WeakHashTableShape<2>, Handle<Object> > DerivedHashTable;
 public:
  inline static WeakHashTable* cast(Object* object); inline static const WeakHashTable* cast(const Object* object);



  Object* Lookup(Handle<HeapObject> key);



  __attribute__((warn_unused_result)) static Handle<WeakHashTable> Put(Handle<WeakHashTable> table,
                                                   Handle<HeapObject> key,
                                                   Handle<HeapObject> value);

  static Handle<FixedArray> GetValues(Handle<WeakHashTable> table);

 private:
  friend class MarkCompactCollector;

  void AddEntry(int entry, Handle<WeakCell> key, Handle<HeapObject> value);


  static inline int EntryToValueIndex(int entry) {
    return EntryToIndex(entry) + 1;
  }
};
class ScopeInfo : public FixedArray {
 public:
  inline static ScopeInfo* cast(Object* object); inline static const ScopeInfo* cast(const Object* object);


  ScopeType scope_type();


  bool CallsEval();


  LanguageMode language_mode();


  bool is_declaration_scope();


  bool CallsSloppyEval() { return CallsEval() && is_sloppy(language_mode()); }



  int LocalCount();





  int StackSlotCount();
  int ContextLength();


  bool HasReceiver();



  bool HasAllocatedReceiver();


  bool HasNewTarget();


  bool HasFunctionName();


  bool HasHeapAllocatedLocals();


  bool HasContext();


  inline bool IsAsmModule();


  inline bool IsAsmFunction();

  inline bool HasSimpleParameters();


  String* FunctionName();


  String* ParameterName(int var);


  String* LocalName(int var);


  String* StackLocalName(int var);


  int StackLocalIndex(int var);


  String* ContextLocalName(int var);


  VariableMode ContextLocalMode(int var);


  InitializationFlag ContextLocalInitFlag(int var);


  MaybeAssignedFlag ContextLocalMaybeAssignedFlag(int var);



  bool LocalIsSynthetic(int var);





  int StackSlotIndex(String* name);






  static int ContextSlotIndex(Handle<ScopeInfo> scope_info, Handle<String> name,
                              VariableMode* mode, InitializationFlag* init_flag,
                              MaybeAssignedFlag* maybe_assigned_flag);






  static int ContextGlobalSlotIndex(Handle<ScopeInfo> scope_info,
                                    Handle<String> name, VariableMode* mode,
                                    InitializationFlag* init_flag,
                                    MaybeAssignedFlag* maybe_assigned_flag);


  String* ContextSlotName(int slot_index);




  int ParameterIndex(String* name);





  int FunctionContextSlotIndex(String* name, VariableMode* mode);




  int ReceiverContextSlotIndex();

  FunctionKind function_kind();

  static Handle<ScopeInfo> Create(Isolate* isolate, Zone* zone, Scope* scope);
  static Handle<ScopeInfo> CreateGlobalThisBinding(Isolate* isolate);


  static ScopeInfo* Empty(Isolate* isolate);


  void Print();
  inline void SetFlags(int value); inline int Flags(); inline void SetParameterCount(int value); inline int ParameterCount(); inline void SetStackLocalCount(int value); inline int StackLocalCount(); inline void SetContextLocalCount(int value); inline int ContextLocalCount(); inline void SetContextGlobalCount(int value); inline int ContextGlobalCount();


  enum {

    kFlags, kParameterCount, kStackLocalCount, kContextLocalCount, kContextGlobalCount,

    kVariablePartIndex
  };

 private:
  int ParameterEntriesIndex();
  int StackLocalFirstSlotIndex();
  int StackLocalEntriesIndex();
  int ContextLocalNameEntriesIndex();
  int ContextGlobalNameEntriesIndex();
  int ContextLocalInfoEntriesIndex();
  int ContextGlobalInfoEntriesIndex();
  int ReceiverEntryIndex();
  int FunctionNameEntryIndex();

  int Lookup(Handle<String> name, int start, int end, VariableMode* mode,
             VariableLocation* location, InitializationFlag* init_flag,
             MaybeAssignedFlag* maybe_assigned_flag);



  enum VariableAllocationInfo { NONE, STACK, CONTEXT, UNUSED };


  class ScopeTypeField : public BitField<ScopeType, 0, 4> {};
  class CallsEvalField : public BitField<bool, ScopeTypeField::kNext, 1> {};
  static_assert(LANGUAGE_END == 3, "LANGUAGE_END == 3");
  class LanguageModeField
      : public BitField<LanguageMode, CallsEvalField::kNext, 2> {};
  class DeclarationScopeField
      : public BitField<bool, LanguageModeField::kNext, 1> {};
  class ReceiverVariableField
      : public BitField<VariableAllocationInfo, DeclarationScopeField::kNext,
                        2> {};
  class HasNewTargetField
      : public BitField<bool, ReceiverVariableField::kNext, 1> {};
  class FunctionVariableField
      : public BitField<VariableAllocationInfo, HasNewTargetField::kNext, 2> {};
  class FunctionVariableMode
      : public BitField<VariableMode, FunctionVariableField::kNext, 3> {};
  class AsmModuleField : public BitField<bool, FunctionVariableMode::kNext, 1> {
  };
  class AsmFunctionField : public BitField<bool, AsmModuleField::kNext, 1> {};
  class HasSimpleParametersField
      : public BitField<bool, AsmFunctionField::kNext, 1> {};
  class FunctionKindField
      : public BitField<FunctionKind, HasSimpleParametersField::kNext, 8> {};



  class ContextLocalMode: public BitField<VariableMode, 0, 3> {};
  class ContextLocalInitFlag: public BitField<InitializationFlag, 3, 1> {};
  class ContextLocalMaybeAssignedFlag
      : public BitField<MaybeAssignedFlag, 4, 1> {};

  friend class ScopeIterator;
};





class NormalizedMapCache: public FixedArray {
 public:
  static Handle<NormalizedMapCache> New(Isolate* isolate);

  __attribute__((warn_unused_result)) MaybeHandle<Map> Get(Handle<Map> fast_map,
                                       PropertyNormalizationMode mode);
  void Set(Handle<Map> fast_map, Handle<Map> normalized_map);

  void Clear();

  inline static NormalizedMapCache* cast(Object* object); inline static const NormalizedMapCache* cast(const Object* object);

  static inline bool IsNormalizedMapCache(const HeapObject* obj);

  void NormalizedMapCacheVerify();
 private:
  static const int kEntries = 64;

  static inline int GetIndex(Handle<Map> map);


  Object* get(int index);
  void set(int index, Object* value);
};




class ByteArray: public FixedArrayBase {
 public:
  inline int Size();


  inline byte get(int index);
  inline void set(int index, byte value);


  inline int get_int(int index);

  static int SizeFor(int length) {
    return (((kHeaderSize + length) + kObjectAlignmentMask) & ~kObjectAlignmentMask);
  }




  static int LengthFor(int size_in_bytes) {
    do { if ((!(IsAligned(size_in_bytes, kPointerSize)))) { V8_Fatal(".././src/objects.h", 4432, "Check failed: %s.", "IsAligned(size_in_bytes, kPointerSize)"); } } while (0);
    do { if ((!(size_in_bytes >= kHeaderSize))) { V8_Fatal(".././src/objects.h", 4433, "Check failed: %s.", "size_in_bytes >= kHeaderSize"); } } while (0);
    return size_in_bytes - kHeaderSize;
  }


  inline Address GetDataStartAddress();


  static inline ByteArray* FromDataStartAddress(Address address);

  inline static ByteArray* cast(Object* object); inline static const ByteArray* cast(const Object* object);


  inline int ByteArraySize();
  void ByteArrayPrint(std::ostream& os);
  void ByteArrayVerify();


  static const int kAlignedSize = (((kHeaderSize) + kObjectAlignmentMask) & ~kObjectAlignmentMask);


  static const int kMaxSize = 512 * MB;

  static const int kMaxLength = kMaxSize - kHeaderSize;

 private:
  ByteArray() = delete; ByteArray(const ByteArray&) = delete; void operator=(const ByteArray&) = delete;
};



class BytecodeArray : public FixedArrayBase {
 public:
  static int SizeFor(int length) {
    return (((kHeaderSize + length) + kObjectAlignmentMask) & ~kObjectAlignmentMask);
  }


  inline byte get(int index);
  inline void set(int index, byte value);


  inline Address GetFirstBytecodeAddress();


  inline int frame_size() const;
  inline void set_frame_size(int frame_size);


  inline int register_count() const;


  inline int parameter_count() const;
  inline void set_parameter_count(int number_of_parameters);


  inline int interrupt_budget() const;
  inline void set_interrupt_budget(int interrupt_budget);


  inline FixedArray* constant_pool() const; inline void set_constant_pool(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline FixedArray* handler_table() const; inline void set_handler_table(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline ByteArray* source_position_table() const; inline void set_source_position_table(ByteArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static BytecodeArray* cast(Object* object); inline static const BytecodeArray* cast(const Object* object);


  inline int BytecodeArraySize();

  inline int instruction_size();

  int SourcePosition(int offset);
  int SourceStatementPosition(int offset);

  void BytecodeArrayPrint(std::ostream& os);
  void BytecodeArrayVerify();

  void Disassemble(std::ostream& os);

  void CopyBytecodesTo(BytecodeArray* to);


  static const int kConstantPoolOffset = FixedArrayBase::kHeaderSize;
  static const int kHandlerTableOffset = kConstantPoolOffset + kPointerSize;
  static const int kSourcePositionTableOffset =
      kHandlerTableOffset + kPointerSize;
  static const int kFrameSizeOffset = kSourcePositionTableOffset + kPointerSize;
  static const int kParameterSizeOffset = kFrameSizeOffset + kIntSize;
  static const int kInterruptBudgetOffset = kParameterSizeOffset + kIntSize;
  static const int kHeaderSize = kInterruptBudgetOffset + kIntSize;


  static const int kMaxSize = 512 * MB;

  static const int kMaxLength = kMaxSize - kHeaderSize;

  class BodyDescriptor;

 private:
  BytecodeArray() = delete; BytecodeArray(const BytecodeArray&) = delete; void operator=(const BytecodeArray&) = delete;
};







class FreeSpace: public HeapObject {
 public:

  inline int size() const;
  inline void set_size(int value);

  inline int nobarrier_size() const;
  inline void nobarrier_set_size(int value);

  inline int Size();


  inline FreeSpace* next();
  inline void set_next(FreeSpace* next);

  inline static FreeSpace* cast(HeapObject* obj);


  void FreeSpacePrint(std::ostream& os);
  void FreeSpaceVerify();



  static const int kSizeOffset = HeapObject::kHeaderSize;
  static const int kNextOffset = (((kSizeOffset + kPointerSize) + kPointerAlignmentMask) & ~kPointerAlignmentMask);

 private:
  FreeSpace() = delete; FreeSpace(const FreeSpace&) = delete; void operator=(const FreeSpace&) = delete;
};
class FixedTypedArrayBase: public FixedArrayBase {
 public:

  inline Object* base_pointer() const; inline void set_base_pointer(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);




  inline void* external_pointer() const; inline void set_external_pointer(void* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline static FixedTypedArrayBase* cast(Object* object); inline static const FixedTypedArrayBase* cast(const Object* object);

  static const int kBasePointerOffset = FixedArrayBase::kHeaderSize;
  static const int kExternalPointerOffset = kBasePointerOffset + kPointerSize;
  static const int kHeaderSize =
      (((kExternalPointerOffset + kPointerSize) + kDoubleAlignmentMask) & ~kDoubleAlignmentMask);

  static const int kDataOffset = kHeaderSize;

  class BodyDescriptor;

  inline int size();

  static inline int TypedArraySize(InstanceType type, int length);
  inline int TypedArraySize(InstanceType type);


  inline void* DataPtr();

  inline int DataSize();

 private:
  static inline int ElementSize(InstanceType type);

  inline int DataSize(InstanceType type);

  FixedTypedArrayBase() = delete; FixedTypedArrayBase(const FixedTypedArrayBase&) = delete; void operator=(const FixedTypedArrayBase&) = delete;
};


template <class Traits>
class FixedTypedArray: public FixedTypedArrayBase {
 public:
  typedef typename Traits::ElementType ElementType;
  static const InstanceType kInstanceType = Traits::kInstanceType;

  inline static FixedTypedArray<Traits>* cast(Object* object); inline static const FixedTypedArray<Traits>* cast(const Object* object);

  inline ElementType get_scalar(int index);
  static inline Handle<Object> get(FixedTypedArray* array, int index);
  inline void set(int index, ElementType value);

  static inline ElementType from_int(int value);
  static inline ElementType from_double(double value);



  inline void SetValue(uint32_t index, Object* value);

  void FixedTypedArrayPrint(std::ostream& os);
  void FixedTypedArrayVerify();

 private:
  FixedTypedArray() = delete; FixedTypedArray(const FixedTypedArray&) = delete; void operator=(const FixedTypedArray&) = delete;
};
class Uint8ArrayTraits { public: typedef uint8_t ElementType; static const InstanceType kInstanceType = FIXED_UINT8_ARRAY_TYPE; static const char* Designator() { return u8"uint8" u8" array"; } static inline Handle<Object> ToHandle(Isolate* isolate, uint8_t scalar); static inline uint8_t defaultValue(); }; typedef FixedTypedArray<Uint8ArrayTraits> FixedUint8Array; class Int8ArrayTraits { public: typedef int8_t ElementType; static const InstanceType kInstanceType = FIXED_INT8_ARRAY_TYPE; static const char* Designator() { return u8"int8" u8" array"; } static inline Handle<Object> ToHandle(Isolate* isolate, int8_t scalar); static inline int8_t defaultValue(); }; typedef FixedTypedArray<Int8ArrayTraits> FixedInt8Array; class Uint16ArrayTraits { public: typedef uint16_t ElementType; static const InstanceType kInstanceType = FIXED_UINT16_ARRAY_TYPE; static const char* Designator() { return u8"uint16" u8" array"; } static inline Handle<Object> ToHandle(Isolate* isolate, uint16_t scalar); static inline uint16_t defaultValue(); }; typedef FixedTypedArray<Uint16ArrayTraits> FixedUint16Array; class Int16ArrayTraits { public: typedef int16_t ElementType; static const InstanceType kInstanceType = FIXED_INT16_ARRAY_TYPE; static const char* Designator() { return u8"int16" u8" array"; } static inline Handle<Object> ToHandle(Isolate* isolate, int16_t scalar); static inline int16_t defaultValue(); }; typedef FixedTypedArray<Int16ArrayTraits> FixedInt16Array; class Uint32ArrayTraits { public: typedef uint32_t ElementType; static const InstanceType kInstanceType = FIXED_UINT32_ARRAY_TYPE; static const char* Designator() { return u8"uint32" u8" array"; } static inline Handle<Object> ToHandle(Isolate* isolate, uint32_t scalar); static inline uint32_t defaultValue(); }; typedef FixedTypedArray<Uint32ArrayTraits> FixedUint32Array; class Int32ArrayTraits { public: typedef int32_t ElementType; static const InstanceType kInstanceType = FIXED_INT32_ARRAY_TYPE; static const char* Designator() { return u8"int32" u8" array"; } static inline Handle<Object> ToHandle(Isolate* isolate, int32_t scalar); static inline int32_t defaultValue(); }; typedef FixedTypedArray<Int32ArrayTraits> FixedInt32Array; class Float32ArrayTraits { public: typedef float ElementType; static const InstanceType kInstanceType = FIXED_FLOAT32_ARRAY_TYPE; static const char* Designator() { return u8"float32" u8" array"; } static inline Handle<Object> ToHandle(Isolate* isolate, float scalar); static inline float defaultValue(); }; typedef FixedTypedArray<Float32ArrayTraits> FixedFloat32Array; class Float64ArrayTraits { public: typedef double ElementType; static const InstanceType kInstanceType = FIXED_FLOAT64_ARRAY_TYPE; static const char* Designator() { return u8"float64" u8" array"; } static inline Handle<Object> ToHandle(Isolate* isolate, double scalar); static inline double defaultValue(); }; typedef FixedTypedArray<Float64ArrayTraits> FixedFloat64Array; class Uint8ClampedArrayTraits { public: typedef uint8_t ElementType; static const InstanceType kInstanceType = FIXED_UINT8_CLAMPED_ARRAY_TYPE; static const char* Designator() { return u8"uint8_clamped" u8" array"; } static inline Handle<Object> ToHandle(Isolate* isolate, uint8_t scalar); static inline uint8_t defaultValue(); }; typedef FixedTypedArray<Uint8ClampedArrayTraits> FixedUint8ClampedArray;
class DeoptimizationInputData: public FixedArray {
 public:

  static const int kTranslationByteArrayIndex = 0;
  static const int kInlinedFunctionCountIndex = 1;
  static const int kLiteralArrayIndex = 2;
  static const int kOsrAstIdIndex = 3;
  static const int kOsrPcOffsetIndex = 4;
  static const int kOptimizationIdIndex = 5;
  static const int kSharedFunctionInfoIndex = 6;
  static const int kWeakCellCacheIndex = 7;
  static const int kFirstDeoptEntryIndex = 8;


  static const int kAstIdRawOffset = 0;
  static const int kTranslationIndexOffset = 1;
  static const int kArgumentsStackHeightOffset = 2;
  static const int kPcOffset = 3;
  static const int kDeoptEntrySize = 4;






  inline ByteArray* TranslationByteArray(); inline void SetTranslationByteArray(ByteArray* value);
  inline Smi* InlinedFunctionCount(); inline void SetInlinedFunctionCount(Smi* value);
  inline FixedArray* LiteralArray(); inline void SetLiteralArray(FixedArray* value);
  inline Smi* OsrAstId(); inline void SetOsrAstId(Smi* value);
  inline Smi* OsrPcOffset(); inline void SetOsrPcOffset(Smi* value);
  inline Smi* OptimizationId(); inline void SetOptimizationId(Smi* value);
  inline Object* SharedFunctionInfo(); inline void SetSharedFunctionInfo(Object* value);
  inline Object* WeakCellCache(); inline void SetWeakCellCache(Object* value);
  inline Smi* AstIdRaw(int i); inline void SetAstIdRaw(int i, Smi* value);
  inline Smi* TranslationIndex(int i); inline void SetTranslationIndex(int i, Smi* value);
  inline Smi* ArgumentsStackHeight(int i); inline void SetArgumentsStackHeight(int i, Smi* value);
  inline Smi* Pc(int i); inline void SetPc(int i, Smi* value);



  inline BailoutId AstId(int i);

  inline void SetAstId(int i, BailoutId value);

  inline int DeoptCount();


  static Handle<DeoptimizationInputData> New(Isolate* isolate,
                                             int deopt_entry_count,
                                             PretenureFlag pretenure);

  inline static DeoptimizationInputData* cast(Object* object); inline static const DeoptimizationInputData* cast(const Object* object);


  void DeoptimizationInputDataPrint(std::ostream& os);


 private:
  static int IndexForEntry(int i) {
    return kFirstDeoptEntryIndex + (i * kDeoptEntrySize);
  }


  static int LengthFor(int entry_count) { return IndexForEntry(entry_count); }
};







class DeoptimizationOutputData: public FixedArray {
 public:
  inline int DeoptPoints();

  inline BailoutId AstId(int index);

  inline void SetAstId(int index, BailoutId id);

  inline Smi* PcAndState(int index);
  inline void SetPcAndState(int index, Smi* offset);

  static int LengthOfFixedArray(int deopt_points) {
    return deopt_points * 2;
  }


  static Handle<DeoptimizationOutputData> New(Isolate* isolate,
                                              int number_of_deopt_points,
                                              PretenureFlag pretenure);

  inline static DeoptimizationOutputData* cast(Object* object); inline static const DeoptimizationOutputData* cast(const Object* object);


  void DeoptimizationOutputDataPrint(std::ostream& os);

};




class LiteralsArray : public FixedArray {
 public:
  static const int kVectorIndex = 0;
  static const int kFirstLiteralIndex = 1;
  static const int kOffsetToFirstLiteral =
      FixedArray::kHeaderSize + kPointerSize;

  static int OffsetOfLiteralAt(int index) {
    return SizeFor(index + kFirstLiteralIndex);
  }

  inline TypeFeedbackVector* feedback_vector() const;
  inline void set_feedback_vector(TypeFeedbackVector* vector);
  inline Object* literal(int literal_index) const;
  inline void set_literal(int literal_index, Object* literal);
  inline int literals_count() const;

  static Handle<LiteralsArray> New(Isolate* isolate,
                                   Handle<TypeFeedbackVector> vector,
                                   int number_of_literals,
                                   PretenureFlag pretenure);

  inline static LiteralsArray* cast(Object* object); inline static const LiteralsArray* cast(const Object* object);

 private:
  inline Object* get(int index) const;
  inline void set(int index, Object* value);
  inline void set(int index, Smi* value);
  inline void set(int index, Object* value, WriteBarrierMode mode);
};
class HandlerTable : public FixedArray {
 public:



  enum CatchPrediction { UNCAUGHT, CAUGHT };


  inline int GetRangeStart(int index) const;
  inline int GetRangeEnd(int index) const;
  inline int GetRangeHandler(int index) const;
  inline int GetRangeData(int index) const;


  inline void SetRangeStart(int index, int value);
  inline void SetRangeEnd(int index, int value);
  inline void SetRangeHandler(int index, int offset, CatchPrediction pred);
  inline void SetRangeData(int index, int value);


  inline void SetReturnOffset(int index, int value);
  inline void SetReturnHandler(int index, int offset, CatchPrediction pred);


  int LookupRange(int pc_offset, int* data, CatchPrediction* prediction);


  int LookupReturn(int pc_offset, CatchPrediction* prediction);


  inline CatchPrediction GetRangePrediction(int index) const;


  inline int NumberOfRangeEntries() const;


  static int LengthForRange(int entries) { return entries * kRangeEntrySize; }
  static int LengthForReturn(int entries) { return entries * kReturnEntrySize; }

  inline static HandlerTable* cast(Object* object); inline static const HandlerTable* cast(const Object* object);


  void HandlerTableRangePrint(std::ostream& os);
  void HandlerTableReturnPrint(std::ostream& os);


 private:

  static const int kRangeStartIndex = 0;
  static const int kRangeEndIndex = 1;
  static const int kRangeHandlerIndex = 2;
  static const int kRangeDataIndex = 3;
  static const int kRangeEntrySize = 4;


  static const int kReturnOffsetIndex = 0;
  static const int kReturnHandlerIndex = 1;
  static const int kReturnEntrySize = 2;


  class HandlerPredictionField : public BitField<CatchPrediction, 0, 1> {};
  class HandlerOffsetField : public BitField<int, 1, 30> {};
};



class Code: public HeapObject {
 public:


  typedef uint32_t Flags;
  enum Kind {

    FUNCTION, OPTIMIZED_FUNCTION, BYTECODE_HANDLER, STUB, HANDLER, BUILTIN, REGEXP, WASM_FUNCTION, WASM_TO_JS_FUNCTION, JS_TO_WASM_FUNCTION, LOAD_IC, KEYED_LOAD_IC, CALL_IC, STORE_IC, KEYED_STORE_IC, BINARY_OP_IC, COMPARE_IC, TO_BOOLEAN_IC,

    NUMBER_OF_KINDS
  };



  static_assert(NUMBER_OF_KINDS <= 32, "NUMBER_OF_KINDS <= 32");

  static const char* Kind2String(Kind kind);


  enum StubType {
    NORMAL,
    FAST
  };

  static const int kPrologueOffsetNotSet = -1;



  static const char* ICState2String(InlineCacheState state);
  static const char* StubType2String(StubType type);
  static void PrintExtraICState(std::ostream& os,
                                Kind kind, ExtraICState extra);
  void Disassemble(const char* name, std::ostream& os);



  inline int instruction_size() const;
  inline void set_instruction_size(int value);


  inline ByteArray* relocation_info() const; inline void set_relocation_info(ByteArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  void InvalidateRelocation();
  void InvalidateEmbeddedObjects();


  inline FixedArray* handler_table() const; inline void set_handler_table(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline FixedArray* deoptimization_data() const; inline void set_deoptimization_data(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);





  inline Object* raw_type_feedback_info() const; inline void set_raw_type_feedback_info(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* type_feedback_info();
  inline void set_type_feedback_info(
      Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline uint32_t stub_key();
  inline void set_stub_key(uint32_t key);



  inline Object* next_code_link() const; inline void set_next_code_link(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);




  inline Object* gc_metadata() const; inline void set_gc_metadata(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline void set_ic_age(int count);
  inline int ic_age() const;



  inline int prologue_offset() const;
  inline void set_prologue_offset(int offset);



  inline int constant_pool_offset() const;
  inline void set_constant_pool_offset(int offset);


  inline ByteArray* unchecked_relocation_info();

  inline int relocation_size();


  inline Flags flags();
  inline void set_flags(Flags flags);


  inline Kind kind();
  inline InlineCacheState ic_state();
  inline ExtraICState extra_ic_state();

  inline StubType type();


  inline bool is_inline_cache_stub();
  inline bool is_debug_stub();
  inline bool is_handler();
  inline bool is_load_stub();
  inline bool is_keyed_load_stub();
  inline bool is_store_stub();
  inline bool is_keyed_store_stub();
  inline bool is_call_stub();
  inline bool is_binary_op_stub();
  inline bool is_compare_ic_stub();
  inline bool is_to_boolean_ic_stub();
  inline bool is_keyed_stub();
  inline bool is_optimized_code();
  inline bool is_wasm_code();
  inline bool embeds_maps_weakly();

  inline bool IsCodeStubOrIC();
  inline bool IsJavaScriptCode();

  inline void set_raw_kind_specific_flags1(int value);
  inline void set_raw_kind_specific_flags2(int value);


  inline bool is_interpreter_entry_trampoline();
  inline bool is_interpreter_enter_bytecode_dispatch();




  inline bool is_crankshafted();
  inline bool is_hydrogen_stub();
  inline void set_is_crankshafted(bool value);



  inline bool is_turbofanned();
  inline void set_is_turbofanned(bool value);



  inline bool can_have_weak_objects();
  inline void set_can_have_weak_objects(bool value);



  inline bool has_deoptimization_support();
  inline void set_has_deoptimization_support(bool value);



  inline bool has_debug_break_slots();
  inline void set_has_debug_break_slots(bool value);




  inline bool has_reloc_info_for_serialization();
  inline void set_has_reloc_info_for_serialization(bool value);





  inline void set_allow_osr_at_loop_nesting_level(int level);
  inline int allow_osr_at_loop_nesting_level();



  inline int profiler_ticks();
  inline void set_profiler_ticks(int ticks);






  inline int builtin_index();
  inline void set_builtin_index(int id);



  inline unsigned stack_slots();
  inline void set_stack_slots(unsigned slots);



  inline unsigned safepoint_table_offset();
  inline void set_safepoint_table_offset(unsigned offset);



  inline unsigned back_edge_table_offset();
  inline void set_back_edge_table_offset(unsigned offset);

  inline bool back_edges_patched_for_osr();


  inline uint16_t to_boolean_state();



  inline bool marked_for_deoptimization();
  inline void set_marked_for_deoptimization(bool flag);


  inline Address constant_pool();


  SafepointEntry GetSafepointEntry(Address pc);


  Object* FindNthObject(int n, Map* match_map);


  AllocationSite* FindFirstAllocationSite();


  Map* FindFirstMap();
  void FindAllMaps(MapHandleList* maps);


  Code* FindFirstHandler();



  bool FindHandlers(CodeHandleList* code_list, int length = -1);


  MaybeHandle<Code> FindHandlerForMap(Map* map);


  Name* FindFirstName();

  class FindAndReplacePattern;






  void FindAndReplace(const FindAndReplacePattern& pattern);
  inline void WipeOutHeader();


  static inline Flags ComputeFlags(
      Kind kind, InlineCacheState ic_state = UNINITIALIZED,
      ExtraICState extra_ic_state = kNoExtraICState, StubType type = NORMAL,
      CacheHolderFlag holder = kCacheOnReceiver);

  static inline Flags ComputeMonomorphicFlags(
      Kind kind, ExtraICState extra_ic_state = kNoExtraICState,
      CacheHolderFlag holder = kCacheOnReceiver, StubType type = NORMAL);

  static inline Flags ComputeHandlerFlags(
      Kind handler_kind, StubType type = NORMAL,
      CacheHolderFlag holder = kCacheOnReceiver);

  static inline InlineCacheState ExtractICStateFromFlags(Flags flags);
  static inline StubType ExtractTypeFromFlags(Flags flags);
  static inline CacheHolderFlag ExtractCacheHolderFromFlags(Flags flags);
  static inline Kind ExtractKindFromFlags(Flags flags);
  static inline ExtraICState ExtractExtraICStateFromFlags(Flags flags);

  static inline Flags RemoveTypeFromFlags(Flags flags);
  static inline Flags RemoveTypeAndHolderFromFlags(Flags flags);


  static inline Code* GetCodeFromTargetAddress(Address address);


  static inline Object* GetObjectFromEntryAddress(Address location_of_address);


  inline byte* instruction_start();


  inline byte* instruction_end();


  inline int body_size();


  inline byte* relocation_start();


  inline byte* entry();


  inline bool contains(byte* pc);



  void Relocate(intptr_t delta);


  void CopyFrom(const CodeDesc& desc);


  static int SizeFor(int body_size) {
    do { if ((!((body_size & ::v8::internal::kHeapObjectTagMask) == 0))) { V8_Fatal(".././src/objects.h", 5235, "Check failed: %s.", "(body_size & ::v8::internal::kHeapObjectTagMask) == 0"); } } while (0);
    return RoundUp(kHeaderSize + body_size, kCodeAlignment);
  }



  inline int ExecutableSize();


  int SourcePosition(int code_offset);
  int SourceStatementPosition(int code_offset);

  inline static Code* cast(Object* object); inline static const Code* cast(const Object* object);


  inline int CodeSize();

  void CodePrint(std::ostream& os);
  void CodeVerify();

  void ClearInlineCaches();
  void ClearInlineCaches(Kind kind);

  BailoutId TranslatePcOffsetToAstId(uint32_t pc_offset);
  uint32_t TranslateAstIdToPcOffset(BailoutId ast_id);


  enum Age {
    kToBeExecutedOnceCodeAge = -3,
    kNotExecutedCodeAge = -2,
    kExecutedOnceCodeAge = -1,
    kNoAgeCodeAge = 0,
    kQuadragenarianCodeAge, kQuinquagenarianCodeAge, kSexagenarianCodeAge, kSeptuagenarianCodeAge, kOctogenarianCodeAge,
    kAfterLastCodeAge,
    kFirstCodeAge = kToBeExecutedOnceCodeAge,
    kLastCodeAge = kAfterLastCodeAge - 1,
    kCodeAgeCount = kAfterLastCodeAge - kFirstCodeAge - 1,
    kIsOldCodeAge = kSexagenarianCodeAge,
    kPreAgedCodeAge = kIsOldCodeAge - 1
  };






  static void MakeCodeAgeSequenceYoung(byte* sequence, Isolate* isolate);
  static void MarkCodeAsExecuted(byte* sequence, Isolate* isolate);
  void MakeYoung(Isolate* isolate);
  void PreAge(Isolate* isolate);
  void MarkToBeExecutedOnce(Isolate* isolate);
  void MakeOlder(MarkingParity);
  static bool IsYoungSequence(Isolate* isolate, byte* sequence);
  bool IsOld();
  Age GetAge();
  static inline Code* GetPreAgedCodeAgeStub(Isolate* isolate) {
    return GetCodeAgeStub(isolate, kNotExecutedCodeAge, NO_MARKING_PARITY);
  }

  void PrintDeoptLocation(FILE* out, Address pc);
  bool CanDeoptAt(Address pc);


  void VerifyEmbeddedObjectsDependency();



  enum VerifyMode { kNoContextSpecificPointers, kNoContextRetainingPointers };
  void VerifyEmbeddedObjects(VerifyMode mode = kNoContextRetainingPointers);
  static void VerifyRecompiledCode(Code* old_code, Code* new_code);


  inline bool CanContainWeakObjects();

  inline bool IsWeakObject(Object* object);

  static inline bool IsWeakObjectInOptimizedCode(Object* object);

  static Handle<WeakCell> WeakCellFor(Handle<Code> code);
  WeakCell* CachedWeakCell();



  static const int kMaxLoopNestingMarker = 6;

  static const int kConstantPoolSize =
      FLAG_enable_embedded_constant_pool ? kIntSize : 0;


  static const int kRelocationInfoOffset = HeapObject::kHeaderSize;
  static const int kHandlerTableOffset = kRelocationInfoOffset + kPointerSize;
  static const int kDeoptimizationDataOffset =
      kHandlerTableOffset + kPointerSize;

  static const int kTypeFeedbackInfoOffset =
      kDeoptimizationDataOffset + kPointerSize;
  static const int kNextCodeLinkOffset = kTypeFeedbackInfoOffset + kPointerSize;
  static const int kGCMetadataOffset = kNextCodeLinkOffset + kPointerSize;
  static const int kInstructionSizeOffset = kGCMetadataOffset + kPointerSize;
  static const int kICAgeOffset = kInstructionSizeOffset + kIntSize;
  static const int kFlagsOffset = kICAgeOffset + kIntSize;
  static const int kKindSpecificFlags1Offset = kFlagsOffset + kIntSize;
  static const int kKindSpecificFlags2Offset =
      kKindSpecificFlags1Offset + kIntSize;

  static const int kPrologueOffset = kKindSpecificFlags2Offset + kIntSize;
  static const int kConstantPoolOffset = kPrologueOffset + kIntSize;
  static const int kBuiltinIndexOffset =
      kConstantPoolOffset + kConstantPoolSize;
  static const int kHeaderPaddingStart = kBuiltinIndexOffset + kIntSize;



  static const int kHeaderSize =
      (kHeaderPaddingStart + kCodeAlignmentMask) & ~kCodeAlignmentMask;

  class BodyDescriptor;


  static const int kFullCodeFlags = kKindSpecificFlags1Offset;
  class FullCodeFlagsHasDeoptimizationSupportField:
      public BitField<bool, 0, 1> {};
  class FullCodeFlagsHasDebugBreakSlotsField: public BitField<bool, 1, 1> {};
  class FullCodeFlagsHasRelocInfoForSerialization
      : public BitField<bool, 2, 1> {};

  class ProfilerTicksField : public BitField<int, 4, 28> {};


  class ICStateField : public BitField<InlineCacheState, 0, 3> {};
  class TypeField : public BitField<StubType, 3, 1> {};
  class CacheHolderField : public BitField<CacheHolderFlag, 4, 2> {};
  class KindField : public BitField<Kind, 6, 5> {};
  class ExtraICStateField
      : public BitField<ExtraICState, 11, PlatformSmiTagging::kSmiValueSize -
                                              11 + 1> {};


  static const int kStackSlotsFirstBit = 0;
  static const int kStackSlotsBitCount = 24;
  static const int kMarkedForDeoptimizationBit =
      kStackSlotsFirstBit + kStackSlotsBitCount;
  static const int kIsTurbofannedBit = kMarkedForDeoptimizationBit + 1;
  static const int kCanHaveWeakObjects = kIsTurbofannedBit + 1;

  static_assert(kStackSlotsFirstBit + kStackSlotsBitCount <= 32, "kStackSlotsFirstBit + kStackSlotsBitCount <= 32");
  static_assert(kCanHaveWeakObjects + 1 <= 32, "kCanHaveWeakObjects + 1 <= 32");

  class StackSlotsField: public BitField<int,
      kStackSlotsFirstBit, kStackSlotsBitCount> {};
  class MarkedForDeoptimizationField
      : public BitField<bool, kMarkedForDeoptimizationBit, 1> {};
  class IsTurbofannedField : public BitField<bool, kIsTurbofannedBit, 1> {
  };
  class CanHaveWeakObjectsField
      : public BitField<bool, kCanHaveWeakObjects, 1> {};


  static const int kIsCrankshaftedBit = 0;
  class IsCrankshaftedField: public BitField<bool,
      kIsCrankshaftedBit, 1> {};


  static const int kSafepointTableOffsetFirstBit = kIsCrankshaftedBit + 1;
  static const int kSafepointTableOffsetBitCount = 30;

  static_assert(kSafepointTableOffsetFirstBit + kSafepointTableOffsetBitCount <= 32, "kSafepointTableOffsetFirstBit + kSafepointTableOffsetBitCount <= 32");

  static_assert(1 + kSafepointTableOffsetBitCount <= 32, "1 + kSafepointTableOffsetBitCount <= 32");

  class SafepointTableOffsetField: public BitField<int,
      kSafepointTableOffsetFirstBit,
      kSafepointTableOffsetBitCount> {};


  class BackEdgeTableOffsetField: public BitField<int,
      kIsCrankshaftedBit + 1, 27> {};
  class AllowOSRAtLoopNestingLevelField: public BitField<int,
      kIsCrankshaftedBit + 1 + 27, 4> {};
  static_assert(AllowOSRAtLoopNestingLevelField::kMax >= kMaxLoopNestingMarker, "AllowOSRAtLoopNestingLevelField::kMax >= kMaxLoopNestingMarker");

  static const int kArgumentsBits = 16;
  static const int kMaxArguments = (1 << kArgumentsBits) - 1;


  static const int kFlagsNotUsedInLookup =
      TypeField::kMask | CacheHolderField::kMask;

 private:
  friend class RelocIterator;
  friend class Deoptimizer;

  void ClearInlineCaches(Kind* kind);


  byte* FindCodeAgeSequence();
  static void GetCodeAgeAndParity(Code* code, Age* age,
                                  MarkingParity* parity);
  static void GetCodeAgeAndParity(Isolate* isolate, byte* sequence, Age* age,
                                  MarkingParity* parity);
  static Code* GetCodeAgeStub(Isolate* isolate, Age age, MarkingParity parity);


  static void PatchPlatformCodeAge(Isolate* isolate,
                                   byte* sequence, Age age,
                                   MarkingParity parity);

  Code() = delete; Code(const Code&) = delete; void operator=(const Code&) = delete;
};

class AbstractCode : public HeapObject {
 public:

  enum Kind {

    FUNCTION, OPTIMIZED_FUNCTION, BYTECODE_HANDLER, STUB, HANDLER, BUILTIN, REGEXP, WASM_FUNCTION, WASM_TO_JS_FUNCTION, JS_TO_WASM_FUNCTION, LOAD_IC, KEYED_LOAD_IC, CALL_IC, STORE_IC, KEYED_STORE_IC, BINARY_OP_IC, COMPARE_IC, TO_BOOLEAN_IC,

        INTERPRETED_FUNCTION,
  };

  int SourcePosition(int offset);
  int SourceStatementPosition(int offset);


  inline Address instruction_start();


  inline Address instruction_end();


  inline int instruction_size();


  inline bool contains(byte* pc);


  inline Kind kind();



  inline int ExecutableSize();

  inline static AbstractCode* cast(Object* object); inline static const AbstractCode* cast(const Object* object);
  inline Code* GetCode();
  inline BytecodeArray* GetBytecodeArray();
};
class DependentCode: public FixedArray {
 public:
  enum DependencyGroup {


    kWeakCodeGroup,


    kTransitionGroup,




    kPrototypeCheckGroup,


    kPropertyCellChangedGroup,


    kFieldTypeGroup,


    kInitialMapChangedGroup,


    kAllocationSiteTenuringChangedGroup,


    kAllocationSiteTransitionChangedGroup
  };

  static const int kGroupCount = kAllocationSiteTransitionChangedGroup + 1;

  bool Contains(DependencyGroup group, WeakCell* code_cell);
  bool IsEmpty(DependencyGroup group);

  static Handle<DependentCode> InsertCompilationDependencies(
      Handle<DependentCode> entries, DependencyGroup group,
      Handle<Foreign> info);

  static Handle<DependentCode> InsertWeakCode(Handle<DependentCode> entries,
                                              DependencyGroup group,
                                              Handle<WeakCell> code_cell);

  void UpdateToFinishedCode(DependencyGroup group, Foreign* info,
                            WeakCell* code_cell);

  void RemoveCompilationDependencies(DependentCode::DependencyGroup group,
                                     Foreign* info);

  void DeoptimizeDependentCodeGroup(Isolate* isolate,
                                    DependentCode::DependencyGroup group);

  bool MarkCodeForDeoptimization(Isolate* isolate,
                                 DependentCode::DependencyGroup group);



  inline DependentCode* next_link();
  inline void set_next_link(DependentCode* next);
  inline int count();
  inline void set_count(int value);
  inline DependencyGroup group();
  inline void set_group(DependencyGroup group);
  inline Object* object_at(int i);
  inline void set_object_at(int i, Object* object);
  inline void clear_at(int i);
  inline void copy(int from, int to);
  inline static DependentCode* cast(Object* object); inline static const DependentCode* cast(const Object* object);

  static const char* DependencyGroupName(DependencyGroup group);
  static void SetMarkedForDeoptimization(Code* code, DependencyGroup group);

 private:
  static Handle<DependentCode> Insert(Handle<DependentCode> entries,
                                      DependencyGroup group,
                                      Handle<Object> object);
  static Handle<DependentCode> New(DependencyGroup group, Handle<Object> object,
                                   Handle<DependentCode> next);
  static Handle<DependentCode> EnsureSpace(Handle<DependentCode> entries);


  bool Compact();
  static int Grow(int number_of_entries) {
    if (number_of_entries < 5) return number_of_entries + 1;
    return number_of_entries * 5 / 4;
  }
  inline int flags();
  inline void set_flags(int flags);
  class GroupField : public BitField<int, 0, 3> {};
  class CountField : public BitField<int, 3, 27> {};
  static_assert(kGroupCount <= GroupField::kMax + 1, "kGroupCount <= GroupField::kMax + 1");
  static const int kNextLinkIndex = 0;
  static const int kFlagsIndex = 1;
  static const int kCodesStartIndex = 2;
};


class PrototypeInfo;






class Map: public HeapObject {
 public:



  inline int instance_size();
  inline void set_instance_size(int value);


  inline void clear_unused();




  inline int inobject_properties_or_constructor_function_index();
  inline void set_inobject_properties_or_constructor_function_index(int value);

  inline int GetInObjectProperties();
  inline void SetInObjectProperties(int value);



  static const int kNoConstructorFunctionIndex = 0;
  inline int GetConstructorFunctionIndex();
  inline void SetConstructorFunctionIndex(int value);
  static MaybeHandle<JSFunction> GetConstructorFunction(
      Handle<Map> map, Handle<Context> native_context);


  inline InterceptorInfo* GetNamedInterceptor();
  inline InterceptorInfo* GetIndexedInterceptor();


  inline InstanceType instance_type();
  inline void set_instance_type(InstanceType value);



  inline int unused_property_fields();
  inline void set_unused_property_fields(int value);


  inline byte bit_field() const;
  inline void set_bit_field(byte value);


  inline byte bit_field2() const;
  inline void set_bit_field2(byte value);


  inline uint32_t bit_field3() const;
  inline void set_bit_field3(uint32_t bits);

  class EnumLengthBits: public BitField<int,
      0, kDescriptorIndexBitCount> {};
  class NumberOfOwnDescriptorsBits: public BitField<int,
      kDescriptorIndexBitCount, kDescriptorIndexBitCount> {};
  static_assert(kDescriptorIndexBitCount + kDescriptorIndexBitCount == 20, "kDescriptorIndexBitCount + kDescriptorIndexBitCount == 20");
  class DictionaryMap : public BitField<bool, 20, 1> {};
  class OwnsDescriptors : public BitField<bool, 21, 1> {};
  class HasHiddenPrototype : public BitField<bool, 22, 1> {};
  class Deprecated : public BitField<bool, 23, 1> {};
  class IsUnstable : public BitField<bool, 24, 1> {};
  class IsMigrationTarget : public BitField<bool, 25, 1> {};

  class NewTargetIsBase : public BitField<bool, 27, 1> {};
  class ConstructionCounter : public BitField<int, 29, 3> {};
  static const int kSlackTrackingCounterStart = 7;
  static const int kSlackTrackingCounterEnd = 1;
  static const int kNoSlackTracking = 0;
  static_assert(kSlackTrackingCounterStart <= ConstructionCounter::kMax, "kSlackTrackingCounterStart <= ConstructionCounter::kMax");
  static const int kGenerousAllocationCount =
      kSlackTrackingCounterStart - kSlackTrackingCounterEnd + 1;


  void StartInobjectSlackTracking();



  inline bool IsInobjectSlackTrackingInProgress();


  inline void InobjectSlackTrackingStep();



  void CompleteInobjectSlackTracking();






  inline void set_non_instance_prototype(bool value);
  inline bool has_non_instance_prototype();



  inline void set_is_constructor(bool value);
  inline bool is_constructor() const;


  inline void set_has_hidden_prototype(bool value);
  inline bool has_hidden_prototype() const;


  inline void set_has_named_interceptor();
  inline bool has_named_interceptor();


  inline void set_has_indexed_interceptor();
  inline bool has_indexed_interceptor();







  inline void set_is_undetectable();
  inline bool is_undetectable();


  inline void set_is_observed();
  inline bool is_observed();



  inline void set_is_callable();
  inline bool is_callable() const;

  inline void set_new_target_is_base(bool value);
  inline bool new_target_is_base();
  inline void set_is_extensible(bool value);
  inline bool is_extensible();
  inline void set_is_prototype_map(bool value);
  inline bool is_prototype_map() const;

  inline void set_elements_kind(ElementsKind elements_kind);
  inline ElementsKind elements_kind();


  inline bool has_fast_smi_elements();


  inline bool has_fast_object_elements();
  inline bool has_fast_smi_or_object_elements();
  inline bool has_fast_double_elements();
  inline bool has_fast_elements();
  inline bool has_sloppy_arguments_elements();
  inline bool has_fast_string_wrapper_elements();
  inline bool has_fixed_typed_array_elements();
  inline bool has_dictionary_elements();

  static bool IsValidElementsTransition(ElementsKind from_kind,
                                        ElementsKind to_kind);



  bool DictionaryElementsInPrototypeChainOnly();

  inline Map* ElementsTransitionMap();

  inline FixedArrayBase* GetInitialElements();




  inline Object* raw_transitions() const; inline void set_raw_transitions(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* prototype_info() const; inline void set_prototype_info(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  static Handle<PrototypeInfo> GetOrCreatePrototypeInfo(
      Handle<JSObject> prototype, Isolate* isolate);
  static Handle<PrototypeInfo> GetOrCreatePrototypeInfo(
      Handle<Map> prototype_map, Isolate* isolate);





  static Handle<Cell> GetOrCreatePrototypeChainValidityCell(Handle<Map> map,
                                                            Isolate* isolate);
  static const int kPrototypeChainValid = 0;
  static const int kPrototypeChainInvalid = 1;

  Map* FindRootMap();
  Map* FindFieldOwner(int descriptor);

  inline int GetInObjectPropertyOffset(int index);

  int NumberOfFields();


  bool InstancesNeedRewriting(Map* target, int target_number_of_fields,
                              int target_inobject, int target_unused,
                              int* old_number_of_fields);

  static Handle<Map> GeneralizeAllFieldRepresentations(Handle<Map> map);
  __attribute__((warn_unused_result)) static Handle<FieldType> GeneralizeFieldType(
      Representation rep1, Handle<FieldType> type1, Representation rep2,
      Handle<FieldType> type2, Isolate* isolate);
  static void GeneralizeFieldType(Handle<Map> map, int modify_index,
                                  Representation new_representation,
                                  Handle<FieldType> new_field_type);
  static Handle<Map> ReconfigureProperty(Handle<Map> map, int modify_index,
                                         PropertyKind new_kind,
                                         PropertyAttributes new_attributes,
                                         Representation new_representation,
                                         Handle<FieldType> new_field_type,
                                         StoreMode store_mode);
  static Handle<Map> CopyGeneralizeAllRepresentations(
      Handle<Map> map, int modify_index, StoreMode store_mode,
      PropertyKind kind, PropertyAttributes attributes, const char* reason);

  static Handle<Map> PrepareForDataProperty(Handle<Map> old_map,
                                            int descriptor_number,
                                            Handle<Object> value);

  static Handle<Map> Normalize(Handle<Map> map, PropertyNormalizationMode mode,
                               const char* reason);





  inline void set_dictionary_map(bool value);
  inline bool is_dictionary_map();



  inline void set_is_access_check_needed(bool access_check_needed);
  inline bool is_access_check_needed();


  inline bool has_code_cache();


  inline Object* prototype() const; inline void set_prototype(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  static void SetPrototype(
      Handle<Map> map, Handle<Object> prototype,
      PrototypeOptimizationMode proto_mode = FAST_PROTOTYPE);





  inline Object* constructor_or_backpointer() const; inline void set_constructor_or_backpointer(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* GetConstructor() const;
  inline void SetConstructor(Object* constructor,
                             WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* GetBackPointer();
  inline void SetBackPointer(Object* value,
                             WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline DescriptorArray* instance_descriptors() const; inline void set_instance_descriptors(DescriptorArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline LayoutDescriptor* layout_descriptor() const; inline void set_layout_descriptor(LayoutDescriptor* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline LayoutDescriptor* layout_descriptor_gc_safe();
  inline bool HasFastPointerLayout() const;




  inline LayoutDescriptor* GetLayoutDescriptor();

  inline void UpdateDescriptors(DescriptorArray* descriptors,
                                LayoutDescriptor* layout_descriptor);
  inline void InitializeDescriptors(DescriptorArray* descriptors,
                                    LayoutDescriptor* layout_descriptor);


  inline Object* code_cache() const; inline void set_code_cache(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline DependentCode* dependent_code() const; inline void set_dependent_code(DependentCode* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* weak_cell_cache() const; inline void set_weak_cell_cache(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline PropertyDetails GetLastDescriptorDetails();

  inline int LastAdded();

  inline int NumberOfOwnDescriptors();
  inline void SetNumberOfOwnDescriptors(int number);

  inline Cell* RetrieveDescriptorsPointer();




  bool OnlyHasSimpleProperties();
  inline int EnumLength();
  inline void SetEnumLength(int length);

  inline bool owns_descriptors();
  inline void set_owns_descriptors(bool owns_descriptors);
  inline void mark_unstable();
  inline bool is_stable();
  inline void set_migration_target(bool value);
  inline bool is_migration_target();
  inline void set_construction_counter(int value);
  inline int construction_counter();
  inline void deprecate();
  inline bool is_deprecated();
  inline bool CanBeDeprecated();





  static MaybeHandle<Map> TryUpdate(Handle<Map> map) __attribute__((warn_unused_result));




  static Handle<Map> Update(Handle<Map> map);

  static inline Handle<Map> CopyInitialMap(Handle<Map> map);
  static Handle<Map> CopyInitialMap(Handle<Map> map, int instance_size,
                                    int in_object_properties,
                                    int unused_property_fields);
  static Handle<Map> CopyDropDescriptors(Handle<Map> map);
  static Handle<Map> CopyInsertDescriptor(Handle<Map> map,
                                          Descriptor* descriptor,
                                          TransitionFlag flag);

  __attribute__((warn_unused_result)) static MaybeHandle<Map> CopyWithField(
      Handle<Map> map, Handle<Name> name, Handle<FieldType> type,
      PropertyAttributes attributes, Representation representation,
      TransitionFlag flag);

  __attribute__((warn_unused_result)) static MaybeHandle<Map> CopyWithConstant(
      Handle<Map> map,
      Handle<Name> name,
      Handle<Object> constant,
      PropertyAttributes attributes,
      TransitionFlag flag);



  static Handle<Map> TransitionElementsTo(Handle<Map> map,
                                          ElementsKind to_kind);

  static Handle<Map> AsElementsKind(Handle<Map> map, ElementsKind kind);

  static Handle<Map> CopyAsElementsKind(Handle<Map> map,
                                        ElementsKind kind,
                                        TransitionFlag flag);

  static Handle<Map> AsLanguageMode(Handle<Map> initial_map,
                                    LanguageMode language_mode,
                                    FunctionKind kind);


  static Handle<Map> CopyForObserved(Handle<Map> map);

  static Handle<Map> CopyForPreventExtensions(Handle<Map> map,
                                              PropertyAttributes attrs_to_add,
                                              Handle<Symbol> transition_marker,
                                              const char* reason);

  static Handle<Map> FixProxy(Handle<Map> map, InstanceType type, int size);





  inline bool TooManyFastProperties(StoreFromKeyed store_mode);
  static Handle<Map> TransitionToDataProperty(Handle<Map> map,
                                              Handle<Name> name,
                                              Handle<Object> value,
                                              PropertyAttributes attributes,
                                              StoreFromKeyed store_mode);
  static Handle<Map> TransitionToAccessorProperty(
      Handle<Map> map, Handle<Name> name, int descriptor,
      AccessorComponent component, Handle<Object> accessor,
      PropertyAttributes attributes);
  static Handle<Map> ReconfigureExistingProperty(Handle<Map> map,
                                                 int descriptor,
                                                 PropertyKind kind,
                                                 PropertyAttributes attributes);

  inline void AppendDescriptor(Descriptor* desc);




  static Handle<Map> CopyForTransition(Handle<Map> map, const char* reason);



  static Handle<Map> Copy(Handle<Map> map, const char* reason);
  static Handle<Map> Create(Isolate* isolate, int inobject_properties);


  int NextFreePropertyIndex();



  int NumberOfDescribedProperties(DescriptorFlag which = OWN_DESCRIPTORS,
                                  PropertyFilter filter = ALL_PROPERTIES);

  inline static Map* cast(Object* object); inline static const Map* cast(const Object* object);




  inline void ClearCodeCache(Heap* heap);


  static void UpdateCodeCache(Handle<Map> map,
                              Handle<Name> name,
                              Handle<Code> code);



  static void AppendCallbackDescriptors(Handle<Map> map,
                                        Handle<Object> descriptors);

  static inline int SlackForArraySize(int old_size, int size_limit);

  static void EnsureDescriptorSlack(Handle<Map> map, int slack);


  Object* FindInCodeCache(Name* name, Code::Flags flags);



  int IndexInCodeCache(Object* name, Code* code);


  void RemoveFromCodeCache(Name* name, Code* code, int index);


  int Hash();





  Map* LookupElementsTransitionMap(ElementsKind elements_kind);




  static Handle<Map> FindTransitionedMap(Handle<Map> map,
                                         MapHandleList* candidates);

  inline bool CanTransition();

  inline bool IsBooleanMap();
  inline bool IsPrimitiveMap();
  inline bool IsJSReceiverMap();
  inline bool IsJSObjectMap();
  inline bool IsJSArrayMap();
  inline bool IsJSFunctionMap();
  inline bool IsStringMap();
  inline bool IsJSProxyMap();
  inline bool IsJSGlobalProxyMap();
  inline bool IsJSGlobalObjectMap();
  inline bool IsJSTypedArrayMap();
  inline bool IsJSDataViewMap();

  inline bool CanOmitMapChecks();

  static void AddDependentCode(Handle<Map> map,
                               DependentCode::DependencyGroup group,
                               Handle<Code> code);

  bool IsMapInArrayPrototypeChain();

  static Handle<WeakCell> WeakCellForMap(Handle<Map> map);


  void MapPrint(std::ostream& os);
  void MapVerify();


  void DictionaryMapVerify();
  void VerifyOmittedMapChecks();


  inline int visitor_id();
  inline void set_visitor_id(int visitor_id);

  static Handle<Map> TransitionToPrototype(Handle<Map> map,
                                           Handle<Object> prototype,
                                           PrototypeOptimizationMode mode);

  static const int kMaxPreAllocatedPropertyFields = 255;


  static const int kInstanceSizesOffset = HeapObject::kHeaderSize;
  static const int kInstanceAttributesOffset = kInstanceSizesOffset + kIntSize;
  static const int kBitField3Offset = kInstanceAttributesOffset + kIntSize;
  static const int kPrototypeOffset = kBitField3Offset + kPointerSize;
  static const int kConstructorOrBackPointerOffset =
      kPrototypeOffset + kPointerSize;




  static const int kTransitionsOrPrototypeInfoOffset =
      kConstructorOrBackPointerOffset + kPointerSize;
  static const int kDescriptorsOffset =
      kTransitionsOrPrototypeInfoOffset + kPointerSize;

  static const int kLayoutDecriptorOffset = kDescriptorsOffset + kPointerSize;
  static const int kCodeCacheOffset = kLayoutDecriptorOffset + kPointerSize;




  static const int kDependentCodeOffset = kCodeCacheOffset + kPointerSize;
  static const int kWeakCellCacheOffset = kDependentCodeOffset + kPointerSize;
  static const int kSize = kWeakCellCacheOffset + kPointerSize;



  static const int kPointerFieldsBeginOffset = Map::kPrototypeOffset;
  static const int kPointerFieldsEndOffset = kSize;


  static const int kInstanceSizeOffset = kInstanceSizesOffset + 0;
  static const int kInObjectPropertiesOrConstructorFunctionIndexByte = 1;
  static const int kInObjectPropertiesOrConstructorFunctionIndexOffset =
      kInstanceSizesOffset + kInObjectPropertiesOrConstructorFunctionIndexByte;

  static const int kUnusedByte = 2;
  static const int kUnusedOffset = kInstanceSizesOffset + kUnusedByte;
  static const int kVisitorIdByte = 3;
  static const int kVisitorIdOffset = kInstanceSizesOffset + kVisitorIdByte;
  static const int kBitFieldOffset = kInstanceAttributesOffset + 0;
  static const int kInstanceTypeOffset = kInstanceAttributesOffset + 1;

  static const int kInstanceTypeAndBitFieldOffset =
      kInstanceAttributesOffset + 0;
  static const int kBitField2Offset = kInstanceAttributesOffset + 2;
  static const int kUnusedPropertyFieldsByte = 3;
  static const int kUnusedPropertyFieldsOffset = kInstanceAttributesOffset + 3;

  static_assert(kInstanceTypeAndBitFieldOffset == Internals::kMapInstanceTypeAndBitFieldOffset, "kInstanceTypeAndBitFieldOffset == Internals::kMapInstanceTypeAndBitFieldOffset");



  static const int kHasNonInstancePrototype = 0;
  static const int kIsCallable = 1;
  static const int kHasNamedInterceptor = 2;
  static const int kHasIndexedInterceptor = 3;
  static const int kIsUndetectable = 4;
  static const int kIsObserved = 5;
  static const int kIsAccessCheckNeeded = 6;
  static const int kIsConstructor = 7;


  static const int kIsExtensible = 0;

  class IsPrototypeMapBits : public BitField<bool, 2, 1> {};
  class ElementsKindBits: public BitField<ElementsKind, 3, 5> {};


  static const int8_t kMaximumBitField2FastElementValue = static_cast<int8_t>(
      (FAST_ELEMENTS + 1) << Map::ElementsKindBits::kShift) - 1;
  static const int8_t kMaximumBitField2FastSmiElementValue =
      static_cast<int8_t>((FAST_SMI_ELEMENTS + 1) <<
                          Map::ElementsKindBits::kShift) - 1;
  static const int8_t kMaximumBitField2FastHoleyElementValue =
      static_cast<int8_t>((FAST_HOLEY_ELEMENTS + 1) <<
                          Map::ElementsKindBits::kShift) - 1;
  static const int8_t kMaximumBitField2FastHoleySmiElementValue =
      static_cast<int8_t>((FAST_HOLEY_SMI_ELEMENTS + 1) <<
                          Map::ElementsKindBits::kShift) - 1;

  typedef FixedBodyDescriptor<kPointerFieldsBeginOffset,
                              kPointerFieldsEndOffset,
                              kSize> BodyDescriptor;





  bool EquivalentToForNormalization(Map* other, PropertyNormalizationMode mode);


  inline bool IsUnboxedDoubleField(FieldIndex index);


  static void TraceTransition(const char* what, Map* from, Map* to, Name* name);
  static void TraceAllTransitions(Map* map);


  static inline Handle<Map> AddMissingTransitionsForTesting(
      Handle<Map> split_map, Handle<DescriptorArray> descriptors,
      Handle<LayoutDescriptor> full_layout_descriptor);

 private:
  static void ConnectTransition(Handle<Map> parent, Handle<Map> child,
                                Handle<Name> name, SimpleTransitionFlag flag);

  bool EquivalentToForTransition(Map* other);
  static Handle<Map> RawCopy(Handle<Map> map, int instance_size);
  static Handle<Map> ShareDescriptor(Handle<Map> map,
                                     Handle<DescriptorArray> descriptors,
                                     Descriptor* descriptor);
  static Handle<Map> AddMissingTransitions(
      Handle<Map> map, Handle<DescriptorArray> descriptors,
      Handle<LayoutDescriptor> full_layout_descriptor);
  static void InstallDescriptors(
      Handle<Map> parent_map, Handle<Map> child_map, int new_descriptor,
      Handle<DescriptorArray> descriptors,
      Handle<LayoutDescriptor> full_layout_descriptor);
  static Handle<Map> CopyAddDescriptor(Handle<Map> map,
                                       Descriptor* descriptor,
                                       TransitionFlag flag);
  static Handle<Map> CopyReplaceDescriptors(
      Handle<Map> map, Handle<DescriptorArray> descriptors,
      Handle<LayoutDescriptor> layout_descriptor, TransitionFlag flag,
      MaybeHandle<Name> maybe_name, const char* reason,
      SimpleTransitionFlag simple_flag);

  static Handle<Map> CopyReplaceDescriptor(Handle<Map> map,
                                           Handle<DescriptorArray> descriptors,
                                           Descriptor* descriptor,
                                           int index,
                                           TransitionFlag flag);
  static __attribute__((warn_unused_result)) MaybeHandle<Map> TryReconfigureExistingProperty(
      Handle<Map> map, int descriptor, PropertyKind kind,
      PropertyAttributes attributes, const char** reason);

  static Handle<Map> CopyNormalized(Handle<Map> map,
                                    PropertyNormalizationMode mode);




  inline void NotifyLeafMapLayoutChange();

  void DeprecateTransitionTree();

  void ReplaceDescriptors(DescriptorArray* new_descriptors,
                          LayoutDescriptor* new_layout_descriptor);


  Map* FindLastMatchMap(int verbatim, int length, DescriptorArray* descriptors);




  void UpdateFieldType(int descriptor_number, Handle<Name> name,
                       Representation new_representation,
                       Handle<Object> new_wrapped_type);

  void PrintReconfiguration(FILE* file, int modify_index, PropertyKind kind,
                            PropertyAttributes attributes);
  void PrintGeneralization(FILE* file, const char* reason, int modify_index,
                           int split, int descriptors, bool constant_to_field,
                           Representation old_representation,
                           Representation new_representation,
                           MaybeHandle<FieldType> old_field_type,
                           MaybeHandle<Object> old_value,
                           MaybeHandle<FieldType> new_field_type,
                           MaybeHandle<Object> new_value);

  static const int kFastPropertiesSoftLimit = 12;
  static const int kMaxFastProperties = 128;

  Map() = delete; Map(const Map&) = delete; void operator=(const Map&) = delete;
};





class Struct: public HeapObject {
 public:
  inline void InitializeBody(int object_size);
  inline static Struct* cast(Object* object); inline static const Struct* cast(const Object* object);
};



class Box : public Struct {
 public:

  inline Object* value() const; inline void set_value(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static Box* cast(Object* object); inline static const Box* cast(const Object* object);


  void BoxPrint(std::ostream& os);
  void BoxVerify();

  static const int kValueOffset = HeapObject::kHeaderSize;
  static const int kSize = kValueOffset + kPointerSize;

 private:
  Box() = delete; Box(const Box&) = delete; void operator=(const Box&) = delete;
};



class PrototypeInfo : public Struct {
 public:
  static const int UNREGISTERED = -1;



  inline Object* prototype_users() const; inline void set_prototype_users(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline int registry_slot() const;
  inline void set_registry_slot(int slot);






  inline Object* validity_cell() const; inline void set_validity_cell(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static PrototypeInfo* cast(Object* object); inline static const PrototypeInfo* cast(const Object* object);


  void PrototypeInfoPrint(std::ostream& os);
  void PrototypeInfoVerify();

  static const int kPrototypeUsersOffset = HeapObject::kHeaderSize;
  static const int kRegistrySlotOffset = kPrototypeUsersOffset + kPointerSize;
  static const int kValidityCellOffset = kRegistrySlotOffset + kPointerSize;
  static const int kConstructorNameOffset = kValidityCellOffset + kPointerSize;
  static const int kSize = kConstructorNameOffset + kPointerSize;

 private:
  PrototypeInfo() = delete; PrototypeInfo(const PrototypeInfo&) = delete; void operator=(const PrototypeInfo&) = delete;
};






class SloppyBlockWithEvalContextExtension : public Struct {
 public:

  inline ScopeInfo* scope_info() const; inline void set_scope_info(ScopeInfo* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline JSObject* extension() const; inline void set_extension(JSObject* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static SloppyBlockWithEvalContextExtension* cast(Object* object); inline static const SloppyBlockWithEvalContextExtension* cast(const Object* object);


  void SloppyBlockWithEvalContextExtensionPrint(std::ostream& os);
  void SloppyBlockWithEvalContextExtensionVerify();

  static const int kScopeInfoOffset = HeapObject::kHeaderSize;
  static const int kExtensionOffset = kScopeInfoOffset + kPointerSize;
  static const int kSize = kExtensionOffset + kPointerSize;

 private:
  SloppyBlockWithEvalContextExtension() = delete; SloppyBlockWithEvalContextExtension(const SloppyBlockWithEvalContextExtension&) = delete; void operator=(const SloppyBlockWithEvalContextExtension&) = delete;
};



class Script: public Struct {
 public:

  enum Type {
    TYPE_NATIVE = 0,
    TYPE_EXTENSION = 1,
    TYPE_NORMAL = 2
  };


  enum CompilationType {
    COMPILATION_TYPE_HOST = 0,
    COMPILATION_TYPE_EVAL = 1
  };


  enum CompilationState {
    COMPILATION_STATE_INITIAL = 0,
    COMPILATION_STATE_COMPILED = 1
  };


  inline Object* source() const; inline void set_source(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* name() const; inline void set_name(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline int id() const; inline void set_id(int value);


  inline int line_offset() const; inline void set_line_offset(int value);



  inline int column_offset() const; inline void set_column_offset(int value);


  inline Object* context_data() const; inline void set_context_data(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline HeapObject* wrapper() const; inline void set_wrapper(HeapObject* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline int type() const; inline void set_type(int value);


  inline Object* line_ends() const; inline void set_line_ends(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline Object* eval_from_shared() const; inline void set_eval_from_shared(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline int eval_from_instructions_offset() const; inline void set_eval_from_instructions_offset(int value);



  inline Object* shared_function_infos() const; inline void set_shared_function_infos(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline int flags() const; inline void set_flags(int value);


  inline Object* source_url() const; inline void set_source_url(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* source_mapping_url() const; inline void set_source_mapping_url(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline CompilationType compilation_type();
  inline void set_compilation_type(CompilationType type);



  inline CompilationState compilation_state();
  inline void set_compilation_state(CompilationState state);



  inline bool hide_source();
  inline void set_hide_source(bool value);




  inline v8::ScriptOriginOptions origin_options();
  inline void set_origin_options(ScriptOriginOptions origin_options);

  inline static Script* cast(Object* object); inline static const Script* cast(const Object* object);



  inline bool HasValidSource();


  static int GetColumnNumber(Handle<Script> script, int code_offset);



  static int GetLineNumber(Handle<Script> script, int code_offset);
  int GetLineNumber(int code_pos);

  static Handle<Object> GetNameOrSourceURL(Handle<Script> script);


  static void InitLineEnds(Handle<Script> script);


  static Handle<JSObject> GetWrapper(Handle<Script> script);



  MaybeHandle<SharedFunctionInfo> FindSharedFunctionInfo(FunctionLiteral* fun);


  class Iterator {
   public:
    explicit Iterator(Isolate* isolate);
    Script* Next();

   private:
    WeakFixedArray::Iterator iterator_;
    Iterator(const Iterator&) = delete; void operator=(const Iterator&) = delete;
  };


  void ScriptPrint(std::ostream& os);
  void ScriptVerify();

  static const int kSourceOffset = HeapObject::kHeaderSize;
  static const int kNameOffset = kSourceOffset + kPointerSize;
  static const int kLineOffsetOffset = kNameOffset + kPointerSize;
  static const int kColumnOffsetOffset = kLineOffsetOffset + kPointerSize;
  static const int kContextOffset = kColumnOffsetOffset + kPointerSize;
  static const int kWrapperOffset = kContextOffset + kPointerSize;
  static const int kTypeOffset = kWrapperOffset + kPointerSize;
  static const int kLineEndsOffset = kTypeOffset + kPointerSize;
  static const int kIdOffset = kLineEndsOffset + kPointerSize;
  static const int kEvalFromSharedOffset = kIdOffset + kPointerSize;
  static const int kEvalFrominstructionsOffsetOffset =
      kEvalFromSharedOffset + kPointerSize;
  static const int kSharedFunctionInfosOffset =
      kEvalFrominstructionsOffsetOffset + kPointerSize;
  static const int kFlagsOffset = kSharedFunctionInfosOffset + kPointerSize;
  static const int kSourceUrlOffset = kFlagsOffset + kPointerSize;
  static const int kSourceMappingUrlOffset = kSourceUrlOffset + kPointerSize;
  static const int kSize = kSourceMappingUrlOffset + kPointerSize;

 private:
  int GetLineNumberWithArray(int code_pos);


  static const int kCompilationTypeBit = 0;
  static const int kCompilationStateBit = 1;
  static const int kHideSourceBit = 2;
  static const int kOriginOptionsShift = 3;
  static const int kOriginOptionsSize = 3;
  static const int kOriginOptionsMask = ((1 << kOriginOptionsSize) - 1)
                                        << kOriginOptionsShift;

  Script() = delete; Script(const Script&) = delete; void operator=(const Script&) = delete;
};
enum BuiltinFunctionId {
  kArrayCode,
  kGeneratorObjectNext,
  kGeneratorObjectReturn,
  kGeneratorObjectThrow,


  kArrayIndexOf, kArrayLastIndexOf, kArrayPush, kArrayPop, kArrayShift, kFunctionApply, kFunctionCall, kObjectHasOwnProperty, kStringCharCodeAt, kStringCharAt, kStringConcat, kStringToLowerCase, kStringToUpperCase, kStringFromCharCode, kMathRandom, kMathFloor, kMathRound, kMathCeil, kMathAbs, kMathLog, kMathExp, kMathSqrt, kMathPow, kMathMax, kMathMin, kMathCos, kMathSin, kMathTan, kMathAcos, kMathAsin, kMathAtan, kMathAtan2, kMathImul, kMathClz32, kMathFround, kMathTrunc,
      kAtomicsLoad, kAtomicsStore,



  kMathPowHalf
};




struct CodeAndLiterals {
  Code* code;
  LiteralsArray* literals;
};




class SharedFunctionInfo: public HeapObject {
 public:

  inline Object* name() const; inline void set_name(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Code* code() const; inline void set_code(Code* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline AbstractCode* abstract_code();

  inline void ReplaceCode(Code* code);



  inline FixedArray* optimized_code_map() const; inline void set_optimized_code_map(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);





  CodeAndLiterals SearchOptimizedCodeMap(Context* native_context,
                                         BailoutId osr_ast_id);


  void ClearOptimizedCodeMap();




  inline bool OptimizedCodeMapIsCleared() const;




  void EvictFromOptimizedCodeMap(Code* optimized_code, const char* reason);


  void TrimOptimizedCodeMap(int shrink_by);


  static void AddSharedCodeToOptimizedCodeMap(Handle<SharedFunctionInfo> shared,
                                              Handle<Code> code);



  static void AddToOptimizedCodeMap(Handle<SharedFunctionInfo> shared,
                                    Handle<Context> native_context,
                                    MaybeHandle<Code> code,
                                    Handle<LiteralsArray> literals,
                                    BailoutId osr_ast_id);



  static void SetScript(Handle<SharedFunctionInfo> shared,
                        Handle<Object> script_object);


  static const int kSharedCodeIndex = 0;
  static const int kEntriesStart = 1;
  static const int kContextOffset = 0;
  static const int kCachedCodeOffset = 1;
  static const int kLiteralsOffset = 2;
  static const int kOsrAstIdOffset = 3;
  static const int kEntryLength = 4;
  static const int kInitialLength = kEntriesStart + kEntryLength;

  static const int kNotFound = -1;


  inline ScopeInfo* scope_info() const; inline void set_scope_info(ScopeInfo* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Code* construct_stub() const; inline void set_construct_stub(Code* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline bool is_compiled();



  inline int length() const;
  inline void set_length(int value);




  inline int internal_formal_parameter_count() const;
  inline void set_internal_formal_parameter_count(int value);



  inline void DontAdaptArguments();


  inline int expected_nof_properties() const;
  inline void set_expected_nof_properties(int value);




  inline TypeFeedbackVector* feedback_vector() const; inline void set_feedback_vector(TypeFeedbackVector* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  void ClearTypeFeedbackInfo();


  void ClearTypeFeedbackInfoAtGCTime();




  inline int unique_id() const;
  inline void set_unique_id(int value);



  inline Object* instance_class_name() const; inline void set_instance_class_name(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);





  inline Object* function_data() const; inline void set_function_data(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline bool IsApiFunction();
  inline FunctionTemplateInfo* get_api_func_data();
  inline void set_api_func_data(FunctionTemplateInfo* data);
  inline bool HasBytecodeArray();
  inline BytecodeArray* bytecode_array();
  inline void set_bytecode_array(BytecodeArray* bytecode);
  inline void ClearBytecodeArray();
  inline Object* function_identifier() const; inline void set_function_identifier(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline bool HasBuiltinFunctionId();
  inline BuiltinFunctionId builtin_function_id();
  inline void set_builtin_function_id(BuiltinFunctionId id);
  inline bool HasInferredName();
  inline String* inferred_name();
  inline void set_inferred_name(String* inferred_name);


  inline Object* script() const; inline void set_script(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline int num_literals() const;
  inline void set_num_literals(int value);






  inline int start_position_and_type() const;
  inline void set_start_position_and_type(int value);


  inline bool HasDebugInfo();
  inline DebugInfo* GetDebugInfo();


  inline bool HasDebugCode();


  inline Object* debug_info() const; inline void set_debug_info(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  String* DebugName();


  bool PassesFilter(const char* raw_filter);


  inline int function_token_position() const;
  inline void set_function_token_position(int function_token_position);


  inline int start_position() const;
  inline void set_start_position(int start_position);


  inline int end_position() const;
  inline void set_end_position(int end_position);


  inline bool is_named_expression() const; inline void set_is_named_expression(bool value);


  inline bool is_toplevel() const; inline void set_is_toplevel(bool value);



  inline int compiler_hints() const;
  inline void set_compiler_hints(int value);

  inline int ast_node_count() const;
  inline void set_ast_node_count(int count);

  inline int profiler_ticks() const;
  inline void set_profiler_ticks(int ticks);



  inline int ic_age();
  inline void set_ic_age(int age);




  inline bool allows_lazy_compilation() const; inline void set_allows_lazy_compilation(bool value);





  inline bool allows_lazy_compilation_without_context() const; inline void set_allows_lazy_compilation_without_context(bool value);





  inline bool optimization_disabled() const; inline void set_optimization_disabled(bool value);


  inline LanguageMode language_mode();
  inline void set_language_mode(LanguageMode language_mode);


  inline bool uses_arguments() const; inline void set_uses_arguments(bool value);




  inline bool needs_home_object() const; inline void set_needs_home_object(bool value);


  inline bool has_duplicate_parameters() const; inline void set_has_duplicate_parameters(bool value);





  inline bool native() const; inline void set_native(bool value);


  inline bool force_inline() const; inline void set_force_inline(bool value);





  inline bool name_should_print_as_anonymous() const; inline void set_name_should_print_as_anonymous(bool value);




  inline bool is_anonymous_expression() const; inline void set_is_anonymous_expression(bool value);


  inline bool is_function() const; inline void set_is_function(bool value);


  inline bool dont_crankshaft() const; inline void set_dont_crankshaft(bool value);


  inline bool dont_flush() const; inline void set_dont_flush(bool value);


  inline bool is_generator() const; inline void set_is_generator(bool value);


  inline bool is_arrow() const; inline void set_is_arrow(bool value);


  inline bool is_concise_method() const; inline void set_is_concise_method(bool value);


  inline bool is_getter_function() const; inline void set_is_getter_function(bool value);


  inline bool is_setter_function() const; inline void set_is_setter_function(bool value);


  inline bool is_default_constructor() const; inline void set_is_default_constructor(bool value);


  inline bool asm_function() const; inline void set_asm_function(bool value);


  inline bool deserialized() const; inline void set_deserialized(bool value);


  inline bool never_compiled() const; inline void set_never_compiled(bool value);


  inline bool is_declaration() const; inline void set_is_declaration(bool value);

  inline FunctionKind kind();
  inline void set_kind(FunctionKind kind);



  inline bool has_deoptimization_support();


  void EnableDeoptimizationSupport(Code* recompiled);



  void DisableOptimization(BailoutReason reason);

  inline BailoutReason disable_optimization_reason();




  bool VerifyBailoutId(BailoutId id);


  bool HasSourceCode() const;
  Handle<Object> GetSourceCode();


  inline int opt_count();
  inline void set_opt_count(int opt_count);


  inline void set_deopt_count(int value);
  inline int deopt_count();
  inline void increment_deopt_count();



  inline void set_opt_reenable_tries(int value);
  inline int opt_reenable_tries();

  inline void TryReenableOptimization();


  inline void set_counters(int value);
  inline int counters() const;


  inline void set_opt_count_and_bailout_reason(int value);
  inline int opt_count_and_bailout_reason() const;

  inline void set_disable_optimization_reason(BailoutReason reason);


  inline bool IsSubjectToDebugging();


  inline bool IsBuiltin();


  bool IsInlineable();


  int SourceSize();




  inline bool has_simple_parameters();


  static void InitFromFunctionLiteral(Handle<SharedFunctionInfo> shared_info,
                                      FunctionLiteral* lit);


  void SharedFunctionInfoPrint(std::ostream& os);
  void SharedFunctionInfoVerify();

  void ResetForNewContext(int new_ic_age);


  class Iterator {
   public:
    explicit Iterator(Isolate* isolate);
    SharedFunctionInfo* Next();

   private:
    bool NextScript();

    Script::Iterator script_iterator_;
    WeakFixedArray::Iterator sfi_iterator_;
    DisallowHeapAllocation no_gc_;
    Iterator(const Iterator&) = delete; void operator=(const Iterator&) = delete;
  };

  inline static SharedFunctionInfo* cast(Object* object); inline static const SharedFunctionInfo* cast(const Object* object);


  static const int kDontAdaptArgumentsSentinel = -1;



  static const int kNameOffset = HeapObject::kHeaderSize;
  static const int kCodeOffset = kNameOffset + kPointerSize;
  static const int kOptimizedCodeMapOffset = kCodeOffset + kPointerSize;
  static const int kScopeInfoOffset = kOptimizedCodeMapOffset + kPointerSize;
  static const int kConstructStubOffset = kScopeInfoOffset + kPointerSize;
  static const int kInstanceClassNameOffset =
      kConstructStubOffset + kPointerSize;
  static const int kFunctionDataOffset =
      kInstanceClassNameOffset + kPointerSize;
  static const int kScriptOffset = kFunctionDataOffset + kPointerSize;
  static const int kDebugInfoOffset = kScriptOffset + kPointerSize;
  static const int kFunctionIdentifierOffset = kDebugInfoOffset + kPointerSize;
  static const int kFeedbackVectorOffset =
      kFunctionIdentifierOffset + kPointerSize;

  static const int kUniqueIdOffset = kFeedbackVectorOffset + kPointerSize;
  static const int kLastPointerFieldOffset = kUniqueIdOffset;
  static const int kFormalParameterCountOffset =
      kLastPointerFieldOffset + kPointerSize;
  static const int kLengthOffset = kFormalParameterCountOffset + kIntSize;

  static const int kNumLiteralsOffset = kLengthOffset + kIntSize;
  static const int kExpectedNofPropertiesOffset = kNumLiteralsOffset + kIntSize;

  static const int kStartPositionAndTypeOffset =
      kExpectedNofPropertiesOffset + kIntSize;
  static const int kEndPositionOffset = kStartPositionAndTypeOffset + kIntSize;

  static const int kCompilerHintsOffset = kEndPositionOffset + kIntSize;
  static const int kFunctionTokenPositionOffset =
      kCompilerHintsOffset + kIntSize;

  static const int kCountersOffset = kFunctionTokenPositionOffset + kIntSize;
  static const int kOptCountAndBailoutReasonOffset = kCountersOffset + kIntSize;

  static const int kProfilerTicksOffset =
      kOptCountAndBailoutReasonOffset + kIntSize;
  static const int kAstNodeCountOffset = kProfilerTicksOffset + kIntSize;


  static const int kSize = kAstNodeCountOffset + kIntSize;







  static const int kAlignedSize = (((kSize) + kPointerAlignmentMask) & ~kPointerAlignmentMask);

  typedef FixedBodyDescriptor<kNameOffset,
                              kLastPointerFieldOffset + kPointerSize,
                              kSize> BodyDescriptor;




  static const int kIsNamedExpressionBit = 0;
  static const int kIsTopLevelBit = 1;
  static const int kStartPositionShift = 2;
  static const int kStartPositionMask = ~((1 << kStartPositionShift) - 1);


  enum CompilerHints {

    kAllowLazyCompilation,
    kAllowLazyCompilationWithoutContext,
    kOptimizationDisabled,
    kNeverCompiled,
    kNative,
    kStrictModeFunction,
    kUsesArguments,
    kNeedsHomeObject,

    kHasDuplicateParameters,
    kForceInline,
    kIsAsmFunction,
    kIsAnonymousExpression,
    kNameShouldPrintAsAnonymous,
    kIsFunction,
    kDontCrankshaft,
    kDontFlush,

    kFunctionKind,
    kIsArrow = kFunctionKind,
    kIsGenerator,
    kIsConciseMethod,
    kIsDefaultConstructor,
    kIsSubclassConstructor,
    kIsBaseConstructor,
    kIsGetterFunction,
    kIsSetterFunction,

    kDeserialized,
    kIsDeclaration,
    kCompilerHintsCount,
  };

  static_assert(LANGUAGE_END == 3, "LANGUAGE_END == 3");

  static_assert((kFunctionKind % kBitsPerByte) == 0, "(kFunctionKind % kBitsPerByte) == 0");




  static_assert(FunctionKind::kArrowFunction == 1 << (kIsArrow - kFunctionKind), "FunctionKind::kArrowFunction == 1 << (kIsArrow - kFunctionKind)");
  static_assert(FunctionKind::kGeneratorFunction == 1 << (kIsGenerator - kFunctionKind), "FunctionKind::kGeneratorFunction == 1 << (kIsGenerator - kFunctionKind)");
  static_assert(FunctionKind::kConciseMethod == 1 << (kIsConciseMethod - kFunctionKind), "FunctionKind::kConciseMethod == 1 << (kIsConciseMethod - kFunctionKind)");
  static_assert(FunctionKind::kDefaultConstructor == 1 << (kIsDefaultConstructor - kFunctionKind), "FunctionKind::kDefaultConstructor == 1 << (kIsDefaultConstructor - kFunctionKind)");
  static_assert(FunctionKind::kSubclassConstructor == 1 << (kIsSubclassConstructor - kFunctionKind), "FunctionKind::kSubclassConstructor == 1 << (kIsSubclassConstructor - kFunctionKind)");
  static_assert(FunctionKind::kBaseConstructor == 1 << (kIsBaseConstructor - kFunctionKind), "FunctionKind::kBaseConstructor == 1 << (kIsBaseConstructor - kFunctionKind)");
  static_assert(FunctionKind::kGetterFunction == 1 << (kIsGetterFunction - kFunctionKind), "FunctionKind::kGetterFunction == 1 << (kIsGetterFunction - kFunctionKind)");
  static_assert(FunctionKind::kSetterFunction == 1 << (kIsSetterFunction - kFunctionKind), "FunctionKind::kSetterFunction == 1 << (kIsSetterFunction - kFunctionKind)");


  class FunctionKindBits : public BitField<FunctionKind, kIsArrow, 8> {};

  class DeoptCountBits : public BitField<int, 0, 4> {};
  class OptReenableTriesBits : public BitField<int, 4, 18> {};
  class ICAgeBits : public BitField<int, 22, 8> {};

  class OptCountBits : public BitField<int, 0, 22> {};
  class DisabledOptimizationReasonBits : public BitField<int, 22, 8> {};

 private:






  static const int kCompilerHintsSmiTagSize = 0;
  static const int kCompilerHintsSize = kIntSize;


  static_assert(SharedFunctionInfo::kCompilerHintsCount <= SharedFunctionInfo::kCompilerHintsSize * kBitsPerByte, "SharedFunctionInfo::kCompilerHintsCount <= SharedFunctionInfo::kCompilerHintsSize * kBitsPerByte");


 public:


  static const int kStrictModeBit =
      kStrictModeFunction + kCompilerHintsSmiTagSize;
  static const int kNativeBit = kNative + kCompilerHintsSmiTagSize;

  static const int kClassConstructorBits =
      FunctionKind::kClassConstructor
      << (kFunctionKind + kCompilerHintsSmiTagSize);




  static const int kStrictModeBitWithinByte = kStrictModeBit % kBitsPerByte;
  static const int kNativeBitWithinByte = kNativeBit % kBitsPerByte;

  static const int kClassConstructorBitsWithinByte =
      FunctionKind::kClassConstructor << kCompilerHintsSmiTagSize;
  static_assert(kClassConstructorBitsWithinByte < (1 << kBitsPerByte), "kClassConstructorBitsWithinByte < (1 << kBitsPerByte)");
  static const int kStrictModeByteOffset = kCompilerHintsOffset + (kCompilerHintsSize - 1) - ((kStrictModeFunction + kCompilerHintsSmiTagSize) / kBitsPerByte);
  static const int kNativeByteOffset = kCompilerHintsOffset + (kCompilerHintsSize - 1) - ((kNative + kCompilerHintsSmiTagSize) / kBitsPerByte);
  static const int kFunctionKindByteOffset = kCompilerHintsOffset + (kCompilerHintsSize - 1) - ((kFunctionKind + kCompilerHintsSmiTagSize) / kBitsPerByte);


 private:



  int SearchOptimizedCodeMapEntry(Context* native_context,
                                  BailoutId osr_ast_id);

  SharedFunctionInfo() = delete; SharedFunctionInfo(const SharedFunctionInfo&) = delete; void operator=(const SharedFunctionInfo&) = delete;
};



struct SourceCodeOf {
  explicit SourceCodeOf(SharedFunctionInfo* v, int max = -1)
      : value(v), max_length(max) {}
  const SharedFunctionInfo* value;
  int max_length;
};


std::ostream& operator<<(std::ostream& os, const SourceCodeOf& v);


class JSGeneratorObject: public JSObject {
 public:

  inline JSFunction* function() const; inline void set_function(JSFunction* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Context* context() const; inline void set_context(Context* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* receiver() const; inline void set_receiver(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* input() const; inline void set_input(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);






  inline int continuation() const;
  inline void set_continuation(int continuation);
  inline bool is_closed();
  inline bool is_executing();
  inline bool is_suspended();


  inline FixedArray* operand_stack() const; inline void set_operand_stack(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static JSGeneratorObject* cast(Object* object); inline static const JSGeneratorObject* cast(const Object* object);


  void JSGeneratorObjectPrint(std::ostream& os);
  void JSGeneratorObjectVerify();


  static const int kGeneratorExecuting = -1;
  static const int kGeneratorClosed = 0;


  static const int kFunctionOffset = JSObject::kHeaderSize;
  static const int kContextOffset = kFunctionOffset + kPointerSize;
  static const int kReceiverOffset = kContextOffset + kPointerSize;
  static const int kInputOffset = kReceiverOffset + kPointerSize;
  static const int kContinuationOffset = kInputOffset + kPointerSize;
  static const int kOperandStackOffset = kContinuationOffset + kPointerSize;
  static const int kSize = kOperandStackOffset + kPointerSize;


  enum ResumeMode { NEXT, RETURN, THROW };

 private:
  JSGeneratorObject() = delete; JSGeneratorObject(const JSGeneratorObject&) = delete; void operator=(const JSGeneratorObject&) = delete;
};



class JSModule: public JSObject {
 public:

  inline Object* context() const; inline void set_context(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline ScopeInfo* scope_info() const; inline void set_scope_info(ScopeInfo* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static JSModule* cast(Object* object); inline static const JSModule* cast(const Object* object);


  void JSModulePrint(std::ostream& os);
  void JSModuleVerify();


  static const int kContextOffset = JSObject::kHeaderSize;
  static const int kScopeInfoOffset = kContextOffset + kPointerSize;
  static const int kSize = kScopeInfoOffset + kPointerSize;

 private:
  JSModule() = delete; JSModule(const JSModule&) = delete; void operator=(const JSModule&) = delete;
};



class JSBoundFunction : public JSObject {
 public:

  inline Object* length() const; inline void set_length(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* name() const; inline void set_name(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline JSReceiver* bound_target_function() const; inline void set_bound_target_function(JSReceiver* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline Object* bound_this() const; inline void set_bound_this(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline FixedArray* bound_arguments() const; inline void set_bound_arguments(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  static MaybeHandle<Context> GetFunctionRealm(
      Handle<JSBoundFunction> function);

  inline static JSBoundFunction* cast(Object* object); inline static const JSBoundFunction* cast(const Object* object);


  void JSBoundFunctionPrint(std::ostream& os);
  void JSBoundFunctionVerify();



  static Handle<String> ToString(Handle<JSBoundFunction> function);


  static const int kBoundTargetFunctionOffset = JSObject::kHeaderSize;
  static const int kBoundThisOffset = kBoundTargetFunctionOffset + kPointerSize;
  static const int kBoundArgumentsOffset = kBoundThisOffset + kPointerSize;
  static const int kLengthOffset = kBoundArgumentsOffset + kPointerSize;
  static const int kNameOffset = kLengthOffset + kPointerSize;
  static const int kSize = kNameOffset + kPointerSize;


  static const int kLengthIndex = 0;
  static const int kNameIndex = 1;

 private:
  JSBoundFunction() = delete; JSBoundFunction(const JSBoundFunction&) = delete; void operator=(const JSBoundFunction&) = delete;
};



class JSFunction: public JSObject {
 public:

  inline Object* prototype_or_initial_map() const; inline void set_prototype_or_initial_map(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline SharedFunctionInfo* shared() const; inline void set_shared(SharedFunctionInfo* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Context* context();
  inline void set_context(Object* context);
  inline JSObject* global_proxy();
  inline Context* native_context();

  static Handle<Context> GetFunctionRealm(Handle<JSFunction> function);





  inline Code* code();
  inline void set_code(Code* code);
  inline void set_code_no_write_barrier(Code* code);
  inline void ReplaceCode(Code* code);



  inline AbstractCode* abstract_code();


  bool Inlines(SharedFunctionInfo* candidate);


  inline bool IsOptimized();



  void MarkForOptimization();
  void AttemptConcurrentOptimization();



  inline bool IsMarkedForOptimization();
  inline bool IsMarkedForConcurrentOptimization();


  inline bool IsInOptimizationQueue();


  inline void CompleteInobjectSlackTrackingIfActive();
  inline LiteralsArray* literals() const; inline void set_literals(LiteralsArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Map* initial_map();
  static void SetInitialMap(Handle<JSFunction> function, Handle<Map> map,
                            Handle<Object> prototype);
  inline bool has_initial_map();
  static void EnsureHasInitialMap(Handle<JSFunction> function);




  static __attribute__((warn_unused_result)) MaybeHandle<Map> GetDerivedMap(
      Isolate* isolate, Handle<JSFunction> constructor,
      Handle<JSReceiver> new_target);





  inline bool has_prototype();
  inline bool has_instance_prototype();
  inline Object* prototype();
  inline Object* instance_prototype();
  static void SetPrototype(Handle<JSFunction> function,
                           Handle<Object> value);
  static void SetInstancePrototype(Handle<JSFunction> function,
                                   Handle<Object> value);



  bool RemovePrototype();


  inline bool is_compiled();





  inline Object* next_function_link() const; inline void set_next_function_link(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  void PrintName(FILE* out = ( *((__FILEP * const) (*(_Gtab(3))) ) ));

  inline static JSFunction* cast(Object* object); inline static const JSFunction* cast(const Object* object);


  void CalculateInstanceSize(InstanceType instance_type,
                             int requested_internal_fields, int* instance_size,
                             int* in_object_properties);
  void CalculateInstanceSizeForDerivedClass(InstanceType instance_type,
                                            int requested_internal_fields,
                                            int* instance_size,
                                            int* in_object_properties);
  static void CalculateInstanceSizeHelper(InstanceType instance_type,
                                          int requested_internal_fields,
                                          int requested_in_object_properties,
                                          int* instance_size,
                                          int* in_object_properties);


  enum BodyVisitingPolicy {
    kVisitCodeEntry = 1 << 0,
    kVisitNextFunction = 1 << 1,

    kSkipCodeEntryAndNextFunction = 0,
    kVisitCodeEntryAndNextFunction = kVisitCodeEntry | kVisitNextFunction
  };

  template <BodyVisitingPolicy>
  class BodyDescriptorImpl;


  typedef BodyDescriptorImpl<kVisitCodeEntryAndNextFunction> BodyDescriptor;


  typedef BodyDescriptorImpl<kVisitCodeEntry> BodyDescriptorStrongCode;
  typedef BodyDescriptorImpl<kSkipCodeEntryAndNextFunction>
      BodyDescriptorWeakCode;


  void JSFunctionPrint(std::ostream& os);
  void JSFunctionVerify();


  inline int NumberOfLiterals();



  static Handle<String> GetName(Handle<JSFunction> function);




  static void SetName(Handle<JSFunction> function, Handle<Name> name,
                      Handle<String> prefix);




  static Handle<String> GetDebugName(Handle<JSFunction> function);



  static Handle<String> ToString(Handle<JSFunction> function);



  static const int kPrototypeOrInitialMapOffset = JSObject::kHeaderSize;
  static const int kSharedFunctionInfoOffset =
      kPrototypeOrInitialMapOffset + kPointerSize;
  static const int kContextOffset = kSharedFunctionInfoOffset + kPointerSize;
  static const int kLiteralsOffset = kContextOffset + kPointerSize;
  static const int kNonWeakFieldsEndOffset = kLiteralsOffset + kPointerSize;
  static const int kCodeEntryOffset = kNonWeakFieldsEndOffset;
  static const int kNextFunctionLinkOffset = kCodeEntryOffset + kPointerSize;
  static const int kSize = kNextFunctionLinkOffset + kPointerSize;

 private:
  JSFunction() = delete; JSFunction(const JSFunction&) = delete; void operator=(const JSFunction&) = delete;
};
class JSGlobalProxy : public JSObject {
 public:


  inline Object* native_context() const; inline void set_native_context(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* hash() const; inline void set_hash(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static JSGlobalProxy* cast(Object* object); inline static const JSGlobalProxy* cast(const Object* object);

  inline bool IsDetachedFrom(JSGlobalObject* global) const;


  void JSGlobalProxyPrint(std::ostream& os);
  void JSGlobalProxyVerify();


  static const int kNativeContextOffset = JSObject::kHeaderSize;
  static const int kHashOffset = kNativeContextOffset + kPointerSize;
  static const int kSize = kHashOffset + kPointerSize;

 private:
  JSGlobalProxy() = delete; JSGlobalProxy(const JSGlobalProxy&) = delete; void operator=(const JSGlobalProxy&) = delete;
};



class JSGlobalObject : public JSObject {
 public:

  inline Context* native_context() const; inline void set_native_context(Context* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline JSObject* global_proxy() const; inline void set_global_proxy(JSObject* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  static void InvalidatePropertyCell(Handle<JSGlobalObject> object,
                                     Handle<Name> name);

  static Handle<PropertyCell> EnsurePropertyCell(Handle<JSGlobalObject> global,
                                                 Handle<Name> name);

  inline static JSGlobalObject* cast(Object* object); inline static const JSGlobalObject* cast(const Object* object);

  inline bool IsDetached();


  void JSGlobalObjectPrint(std::ostream& os);
  void JSGlobalObjectVerify();


  static const int kNativeContextOffset = JSObject::kHeaderSize;
  static const int kGlobalProxyOffset = kNativeContextOffset + kPointerSize;
  static const int kHeaderSize = kGlobalProxyOffset + kPointerSize;
  static const int kSize = kHeaderSize;

 private:
  JSGlobalObject() = delete; JSGlobalObject(const JSGlobalObject&) = delete; void operator=(const JSGlobalObject&) = delete;
};



class JSValue: public JSObject {
 public:

  inline Object* value() const; inline void set_value(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static JSValue* cast(Object* object); inline static const JSValue* cast(const Object* object);


  void JSValuePrint(std::ostream& os);
  void JSValueVerify();


  static const int kValueOffset = JSObject::kHeaderSize;
  static const int kSize = kValueOffset + kPointerSize;

 private:
  JSValue() = delete; JSValue(const JSValue&) = delete; void operator=(const JSValue&) = delete;
};


class DateCache;


class JSDate: public JSObject {
 public:
  static __attribute__((warn_unused_result)) MaybeHandle<JSDate> New(Handle<JSFunction> constructor,
                                                 Handle<JSReceiver> new_target,
                                                 double tv);



  inline Object* value() const; inline void set_value(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline Object* year() const; inline void set_year(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline Object* month() const; inline void set_month(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline Object* day() const; inline void set_day(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline Object* weekday() const; inline void set_weekday(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline Object* hour() const; inline void set_hour(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline Object* min() const; inline void set_min(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline Object* sec() const; inline void set_sec(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* cache_stamp() const; inline void set_cache_stamp(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static JSDate* cast(Object* object); inline static const JSDate* cast(const Object* object);


  static double CurrentTimeValue(Isolate* isolate);



  static Object* GetField(Object* date, Smi* index);

  static Handle<Object> SetValue(Handle<JSDate> date, double v);

  void SetValue(Object* value, bool is_value_nan);


  static __attribute__((warn_unused_result)) MaybeHandle<Object> ToPrimitive(
      Handle<JSReceiver> receiver, Handle<Object> hint);


  void JSDatePrint(std::ostream& os);
  void JSDateVerify();



  enum FieldIndex {
    kDateValue,
    kYear,
    kMonth,
    kDay,
    kWeekday,
    kHour,
    kMinute,
    kSecond,
    kFirstUncachedField,
    kMillisecond = kFirstUncachedField,
    kDays,
    kTimeInDay,
    kFirstUTCField,
    kYearUTC = kFirstUTCField,
    kMonthUTC,
    kDayUTC,
    kWeekdayUTC,
    kHourUTC,
    kMinuteUTC,
    kSecondUTC,
    kMillisecondUTC,
    kDaysUTC,
    kTimeInDayUTC,
    kTimezoneOffset
  };


  static const int kValueOffset = JSObject::kHeaderSize;
  static const int kYearOffset = kValueOffset + kPointerSize;
  static const int kMonthOffset = kYearOffset + kPointerSize;
  static const int kDayOffset = kMonthOffset + kPointerSize;
  static const int kWeekdayOffset = kDayOffset + kPointerSize;
  static const int kHourOffset = kWeekdayOffset + kPointerSize;
  static const int kMinOffset = kHourOffset + kPointerSize;
  static const int kSecOffset = kMinOffset + kPointerSize;
  static const int kCacheStampOffset = kSecOffset + kPointerSize;
  static const int kSize = kCacheStampOffset + kPointerSize;

 private:
  inline Object* DoGetField(FieldIndex index);

  Object* GetUTCField(FieldIndex index, double value, DateCache* date_cache);


  inline void SetCachedFields(int64_t local_time_ms, DateCache* date_cache);


  JSDate() = delete; JSDate(const JSDate&) = delete; void operator=(const JSDate&) = delete;
};
class JSMessageObject: public JSObject {
 public:

  inline int type() const;
  inline void set_type(int value);


  inline Object* argument() const; inline void set_argument(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* script() const; inline void set_script(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* stack_frames() const; inline void set_stack_frames(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline int start_position() const;
  inline void set_start_position(int value);


  inline int end_position() const;
  inline void set_end_position(int value);

  inline static JSMessageObject* cast(Object* object); inline static const JSMessageObject* cast(const Object* object);


  void JSMessageObjectPrint(std::ostream& os);
  void JSMessageObjectVerify();


  static const int kTypeOffset = JSObject::kHeaderSize;
  static const int kArgumentsOffset = kTypeOffset + kPointerSize;
  static const int kScriptOffset = kArgumentsOffset + kPointerSize;
  static const int kStackFramesOffset = kScriptOffset + kPointerSize;
  static const int kStartPositionOffset = kStackFramesOffset + kPointerSize;
  static const int kEndPositionOffset = kStartPositionOffset + kPointerSize;
  static const int kSize = kEndPositionOffset + kPointerSize;

  typedef FixedBodyDescriptor<HeapObject::kMapOffset,
                              kStackFramesOffset + kPointerSize,
                              kSize> BodyDescriptor;
};
class JSRegExp: public JSObject {
 public:





  enum Type { NOT_COMPILED, ATOM, IRREGEXP };
  enum Flag {
    kNone = 0,
    kGlobal = 1 << 0,
    kIgnoreCase = 1 << 1,
    kMultiline = 1 << 2,
    kSticky = 1 << 3,
    kUnicode = 1 << 4,
  };
  typedef base::Flags<Flag> Flags;

  inline Object* data() const; inline void set_data(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* flags() const; inline void set_flags(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* source() const; inline void set_source(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  static MaybeHandle<JSRegExp> New(Handle<String> source, Flags flags);
  static MaybeHandle<JSRegExp> New(Handle<String> source, Handle<String> flags);
  static Handle<JSRegExp> Copy(Handle<JSRegExp> regexp);

  static MaybeHandle<JSRegExp> Initialize(Handle<JSRegExp> regexp,
                                          Handle<String> source, Flags flags);
  static MaybeHandle<JSRegExp> Initialize(Handle<JSRegExp> regexp,
                                          Handle<String> source,
                                          Handle<String> flags_string);

  inline Type TypeTag();
  inline int CaptureCount();
  inline Flags GetFlags();
  inline String* Pattern();
  inline Object* DataAt(int index);

  inline void SetDataAt(int index, Object* value);

  static int code_index(bool is_latin1) {
    if (is_latin1) {
      return kIrregexpLatin1CodeIndex;
    } else {
      return kIrregexpUC16CodeIndex;
    }
  }

  static int saved_code_index(bool is_latin1) {
    if (is_latin1) {
      return kIrregexpLatin1CodeSavedIndex;
    } else {
      return kIrregexpUC16CodeSavedIndex;
    }
  }

  inline static JSRegExp* cast(Object* object); inline static const JSRegExp* cast(const Object* object);


  void JSRegExpPrint(std::ostream& os);
  void JSRegExpVerify();

  static const int kDataOffset = JSObject::kHeaderSize;
  static const int kSourceOffset = kDataOffset + kPointerSize;
  static const int kFlagsOffset = kSourceOffset + kPointerSize;
  static const int kSize = kFlagsOffset + kPointerSize;


  static const int kTagIndex = 0;
  static const int kSourceIndex = kTagIndex + 1;
  static const int kFlagsIndex = kSourceIndex + 1;
  static const int kDataIndex = kFlagsIndex + 1;



  static const int kAtomPatternIndex = kDataIndex;

  static const int kAtomDataSize = kAtomPatternIndex + 1;




  static const int kIrregexpLatin1CodeIndex = kDataIndex;



  static const int kIrregexpUC16CodeIndex = kDataIndex + 1;



  static const int kIrregexpLatin1CodeSavedIndex = kDataIndex + 2;


  static const int kIrregexpUC16CodeSavedIndex = kDataIndex + 3;



  static const int kIrregexpMaxRegisterCountIndex = kDataIndex + 4;

  static const int kIrregexpCaptureCountIndex = kDataIndex + 5;

  static const int kIrregexpDataSize = kIrregexpCaptureCountIndex + 1;


  static const int kDataTagOffset =
      FixedArray::kHeaderSize + kTagIndex * kPointerSize;
  static const int kDataOneByteCodeOffset =
      FixedArray::kHeaderSize + kIrregexpLatin1CodeIndex * kPointerSize;
  static const int kDataUC16CodeOffset =
      FixedArray::kHeaderSize + kIrregexpUC16CodeIndex * kPointerSize;
  static const int kIrregexpCaptureCountOffset =
      FixedArray::kHeaderSize + kIrregexpCaptureCountIndex * kPointerSize;


  static const int kLastIndexFieldIndex = 0;
  static const int kInObjectFieldCount = 1;


  static const int kUninitializedValue = -1;



  static const int kCompilationErrorValue = -2;




  static const int kCodeAgeMask = 0xff;
};

inline JSRegExp::Flags operator&( JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::flag_type rhs)__attribute__((unused)) __attribute__((warn_unused_result)); inline JSRegExp::Flags operator&(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::flag_type rhs) { return JSRegExp::Flags(lhs) & rhs; } inline JSRegExp::Flags operator&(JSRegExp::Flags::flag_type lhs, const JSRegExp::Flags& rhs)__attribute__((unused)) __attribute__((warn_unused_result)); inline JSRegExp::Flags operator&(JSRegExp::Flags::flag_type lhs, const JSRegExp::Flags& rhs) { return rhs & lhs; } inline void operator&(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::mask_type rhs)__attribute__((unused)); inline void operator&(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::mask_type rhs) {} inline JSRegExp::Flags operator|(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::flag_type rhs) __attribute__((unused)) __attribute__((warn_unused_result)); inline JSRegExp::Flags operator|(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::flag_type rhs) { return JSRegExp::Flags(lhs) | rhs; } inline JSRegExp::Flags operator|(JSRegExp::Flags::flag_type lhs, const JSRegExp::Flags& rhs) __attribute__((unused)) __attribute__((warn_unused_result)); inline JSRegExp::Flags operator|(JSRegExp::Flags::flag_type lhs, const JSRegExp::Flags& rhs) { return rhs | lhs; } inline void operator|(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::mask_type rhs) __attribute__((unused)); inline void operator|(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::mask_type rhs) {} inline JSRegExp::Flags operator^(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::flag_type rhs) __attribute__((unused)) __attribute__((warn_unused_result)); inline JSRegExp::Flags operator^(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::flag_type rhs) { return JSRegExp::Flags(lhs) ^ rhs; } inline JSRegExp::Flags operator^(JSRegExp::Flags::flag_type lhs, const JSRegExp::Flags& rhs) __attribute__((unused)) __attribute__((warn_unused_result)); inline JSRegExp::Flags operator^(JSRegExp::Flags::flag_type lhs, const JSRegExp::Flags& rhs) { return rhs ^ lhs; } inline void operator^(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::mask_type rhs) __attribute__((unused)); inline void operator^(JSRegExp::Flags::flag_type lhs, JSRegExp::Flags::mask_type rhs) { } inline JSRegExp::Flags operator~(JSRegExp::Flags::flag_type val)__attribute__((unused)); inline JSRegExp::Flags operator~(JSRegExp::Flags::flag_type val) { return ~JSRegExp::Flags(val); }


class CompilationCacheShape : public BaseShape<HashTableKey*> {
 public:
  static inline bool IsMatch(HashTableKey* key, Object* value) {
    return key->IsMatch(value);
  }

  static inline uint32_t Hash(HashTableKey* key) {
    return key->Hash();
  }

  static inline uint32_t HashForObject(HashTableKey* key, Object* object) {
    return key->HashForObject(object);
  }

  static inline Handle<Object> AsHandle(Isolate* isolate, HashTableKey* key);

  static const int kPrefixSize = 0;
  static const int kEntrySize = 2;
};
class CompilationCacheTable: public HashTable<CompilationCacheTable,
                                              CompilationCacheShape,
                                              HashTableKey*> {
 public:

  Handle<Object> Lookup(
      Handle<String> src, Handle<Context> context, LanguageMode language_mode);
  Handle<Object> LookupEval(
      Handle<String> src, Handle<SharedFunctionInfo> shared,
      LanguageMode language_mode, int scope_position);
  Handle<Object> LookupRegExp(Handle<String> source, JSRegExp::Flags flags);
  static Handle<CompilationCacheTable> Put(
      Handle<CompilationCacheTable> cache, Handle<String> src,
      Handle<Context> context, LanguageMode language_mode,
      Handle<Object> value);
  static Handle<CompilationCacheTable> PutEval(
      Handle<CompilationCacheTable> cache, Handle<String> src,
      Handle<SharedFunctionInfo> context, Handle<SharedFunctionInfo> value,
      int scope_position);
  static Handle<CompilationCacheTable> PutRegExp(
      Handle<CompilationCacheTable> cache, Handle<String> src,
      JSRegExp::Flags flags, Handle<FixedArray> value);
  void Remove(Object* value);
  void Age();
  static const int kHashGenerations = 10;

  inline static CompilationCacheTable* cast(Object* object); inline static const CompilationCacheTable* cast(const Object* object);

 private:
  CompilationCacheTable() = delete; CompilationCacheTable(const CompilationCacheTable&) = delete; void operator=(const CompilationCacheTable&) = delete;
};


class CodeCache: public Struct {
 public:
  inline FixedArray* default_cache() const; inline void set_default_cache(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* normal_type_cache() const; inline void set_normal_type_cache(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  static void Update(
      Handle<CodeCache> cache, Handle<Name> name, Handle<Code> code);



  Object* Lookup(Name* name, Code::Flags flags);





  int GetIndex(Object* name, Code* code);


  void RemoveByIndex(Object* name, Code* code, int index);

  inline static CodeCache* cast(Object* object); inline static const CodeCache* cast(const Object* object);


  void CodeCachePrint(std::ostream& os);
  void CodeCacheVerify();

  static const int kDefaultCacheOffset = HeapObject::kHeaderSize;
  static const int kNormalTypeCacheOffset =
      kDefaultCacheOffset + kPointerSize;
  static const int kSize = kNormalTypeCacheOffset + kPointerSize;

 private:
  static void UpdateDefaultCache(
      Handle<CodeCache> code_cache, Handle<Name> name, Handle<Code> code);
  static void UpdateNormalTypeCache(
      Handle<CodeCache> code_cache, Handle<Name> name, Handle<Code> code);
  Object* LookupDefaultCache(Name* name, Code::Flags flags);
  Object* LookupNormalTypeCache(Name* name, Code::Flags flags);



  static const int kCodeCacheEntrySize = 2;
  static const int kCodeCacheEntryNameOffset = 0;
  static const int kCodeCacheEntryCodeOffset = 1;

  CodeCache() = delete; CodeCache(const CodeCache&) = delete; void operator=(const CodeCache&) = delete;
};


class CodeCacheHashTableShape : public BaseShape<HashTableKey*> {
 public:
  static inline bool IsMatch(HashTableKey* key, Object* value) {
    return key->IsMatch(value);
  }

  static inline uint32_t Hash(HashTableKey* key) {
    return key->Hash();
  }

  static inline uint32_t HashForObject(HashTableKey* key, Object* object) {
    return key->HashForObject(object);
  }

  static inline Handle<Object> AsHandle(Isolate* isolate, HashTableKey* key);

  static const int kPrefixSize = 0;
  static const int kEntrySize = 2;
};


class CodeCacheHashTable: public HashTable<CodeCacheHashTable,
                                           CodeCacheHashTableShape,
                                           HashTableKey*> {
 public:
  Object* Lookup(Name* name, Code::Flags flags);
  static Handle<CodeCacheHashTable> Put(
      Handle<CodeCacheHashTable> table,
      Handle<Name> name,
      Handle<Code> code);

  int GetIndex(Name* name, Code::Flags flags);
  void RemoveByIndex(int index);

  inline static CodeCacheHashTable* cast(Object* object); inline static const CodeCacheHashTable* cast(const Object* object);


  static const int kInitialSize = 64;

 private:
  CodeCacheHashTable() = delete; CodeCacheHashTable(const CodeCacheHashTable&) = delete; void operator=(const CodeCacheHashTable&) = delete;
};


class PolymorphicCodeCache: public Struct {
 public:
  inline Object* cache() const; inline void set_cache(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  static void Update(Handle<PolymorphicCodeCache> cache,
                     MapHandleList* maps,
                     Code::Flags flags,
                     Handle<Code> code);



  Handle<Object> Lookup(MapHandleList* maps, Code::Flags flags);

  inline static PolymorphicCodeCache* cast(Object* object); inline static const PolymorphicCodeCache* cast(const Object* object);


  void PolymorphicCodeCachePrint(std::ostream& os);
  void PolymorphicCodeCacheVerify();

  static const int kCacheOffset = HeapObject::kHeaderSize;
  static const int kSize = kCacheOffset + kPointerSize;

 private:
  PolymorphicCodeCache() = delete; PolymorphicCodeCache(const PolymorphicCodeCache&) = delete; void operator=(const PolymorphicCodeCache&) = delete;
};


class PolymorphicCodeCacheHashTable
    : public HashTable<PolymorphicCodeCacheHashTable,
                       CodeCacheHashTableShape,
                       HashTableKey*> {
 public:
  Object* Lookup(MapHandleList* maps, int code_kind);

  static Handle<PolymorphicCodeCacheHashTable> Put(
      Handle<PolymorphicCodeCacheHashTable> hash_table,
      MapHandleList* maps,
      int code_kind,
      Handle<Code> code);

  inline static PolymorphicCodeCacheHashTable* cast(Object* object); inline static const PolymorphicCodeCacheHashTable* cast(const Object* object);

  static const int kInitialSize = 64;
 private:
  PolymorphicCodeCacheHashTable() = delete; PolymorphicCodeCacheHashTable(const PolymorphicCodeCacheHashTable&) = delete; void operator=(const PolymorphicCodeCacheHashTable&) = delete;
};


class TypeFeedbackInfo: public Struct {
 public:
  inline int ic_total_count();
  inline void set_ic_total_count(int count);

  inline int ic_with_type_info_count();
  inline void change_ic_with_type_info_count(int delta);

  inline int ic_generic_count();
  inline void change_ic_generic_count(int delta);

  inline void initialize_storage();

  inline void change_own_type_change_checksum();
  inline int own_type_change_checksum();

  inline void set_inlined_type_change_checksum(int checksum);
  inline bool matches_inlined_type_change_checksum(int checksum);

  inline static TypeFeedbackInfo* cast(Object* object); inline static const TypeFeedbackInfo* cast(const Object* object);


  void TypeFeedbackInfoPrint(std::ostream& os);
  void TypeFeedbackInfoVerify();

  static const int kStorage1Offset = HeapObject::kHeaderSize;
  static const int kStorage2Offset = kStorage1Offset + kPointerSize;
  static const int kStorage3Offset = kStorage2Offset + kPointerSize;
  static const int kSize = kStorage3Offset + kPointerSize;

 private:
  static const int kTypeChangeChecksumBits = 7;

  class ICTotalCountField: public BitField<int, 0,
      kSmiValueSize - kTypeChangeChecksumBits> {};
  class OwnTypeChangeChecksum: public BitField<int,
      kSmiValueSize - kTypeChangeChecksumBits,
      kTypeChangeChecksumBits> {};
  class ICsWithTypeInfoCountField: public BitField<int, 0,
      kSmiValueSize - kTypeChangeChecksumBits> {};
  class InlinedTypeChangeChecksum: public BitField<int,
      kSmiValueSize - kTypeChangeChecksumBits,
      kTypeChangeChecksumBits> {};

  TypeFeedbackInfo() = delete; TypeFeedbackInfo(const TypeFeedbackInfo&) = delete; void operator=(const TypeFeedbackInfo&) = delete;
};


enum AllocationSiteMode {
  DONT_TRACK_ALLOCATION_SITE,
  TRACK_ALLOCATION_SITE,
  LAST_ALLOCATION_SITE_MODE = TRACK_ALLOCATION_SITE
};


class AllocationSite: public Struct {
 public:
  static const uint32_t kMaximumArrayBytesToPretransition = 8 * 1024;
  static const double kPretenureRatio;
  static const int kPretenureMinimumCreated = 100;


  enum PretenureDecision {
    kUndecided = 0,
    kDontTenure = 1,
    kMaybeTenure = 2,
    kTenure = 3,
    kZombie = 4,
    kLastPretenureDecisionValue = kZombie
  };

  const char* PretenureDecisionName(PretenureDecision decision);

  inline Object* transition_info() const; inline void set_transition_info(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline Object* nested_site() const; inline void set_nested_site(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline int pretenure_data() const; inline void set_pretenure_data(int value);
  inline int pretenure_create_count() const; inline void set_pretenure_create_count(int value);
  inline DependentCode* dependent_code() const; inline void set_dependent_code(DependentCode* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* weak_next() const; inline void set_weak_next(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline void Initialize();


  bool IsNestedSite();


  class ElementsKindBits: public BitField<ElementsKind, 0, 15> {};
  class UnusedBits: public BitField<int, 15, 14> {};
  class DoNotInlineBit: public BitField<bool, 29, 1> {};


  class MementoFoundCountBits: public BitField<int, 0, 26> {};
  class PretenureDecisionBits: public BitField<PretenureDecision, 26, 3> {};
  class DeoptDependentCodeBit: public BitField<bool, 29, 1> {};
  static_assert(PretenureDecisionBits::kMax >= kLastPretenureDecisionValue, "PretenureDecisionBits::kMax >= kLastPretenureDecisionValue");



  inline bool IncrementMementoFoundCount(int increment = 1);

  inline void IncrementMementoCreateCount();

  PretenureFlag GetPretenureMode();

  void ResetPretenureDecision();

  inline PretenureDecision pretenure_decision();
  inline void set_pretenure_decision(PretenureDecision decision);

  inline bool deopt_dependent_code();
  inline void set_deopt_dependent_code(bool deopt);

  inline int memento_found_count();
  inline void set_memento_found_count(int count);

  inline int memento_create_count();
  inline void set_memento_create_count(int count);





  inline bool IsZombie();

  inline bool IsMaybeTenure();

  inline void MarkZombie();

  inline bool MakePretenureDecision(PretenureDecision current_decision,
                                    double ratio,
                                    bool maximum_size_scavenge);

  inline bool DigestPretenuringFeedback(bool maximum_size_scavenge);

  inline ElementsKind GetElementsKind();
  inline void SetElementsKind(ElementsKind kind);

  inline bool CanInlineCall();
  inline void SetDoNotInlineCall();

  inline bool SitePointsToLiteral();

  static void DigestTransitionFeedback(Handle<AllocationSite> site,
                                       ElementsKind to_kind);

  void AllocationSitePrint(std::ostream& os);
  void AllocationSiteVerify();

  inline static AllocationSite* cast(Object* object); inline static const AllocationSite* cast(const Object* object);
  static inline AllocationSiteMode GetMode(
      ElementsKind boilerplate_elements_kind);
  static inline AllocationSiteMode GetMode(ElementsKind from, ElementsKind to);
  static inline bool CanTrack(InstanceType type);

  static const int kTransitionInfoOffset = HeapObject::kHeaderSize;
  static const int kNestedSiteOffset = kTransitionInfoOffset + kPointerSize;
  static const int kPretenureDataOffset = kNestedSiteOffset + kPointerSize;
  static const int kPretenureCreateCountOffset =
      kPretenureDataOffset + kPointerSize;
  static const int kDependentCodeOffset =
      kPretenureCreateCountOffset + kPointerSize;
  static const int kWeakNextOffset = kDependentCodeOffset + kPointerSize;
  static const int kSize = kWeakNextOffset + kPointerSize;



  static const int kPointerFieldsBeginOffset = kTransitionInfoOffset;
  static const int kPointerFieldsEndOffset = kWeakNextOffset;


  typedef FixedBodyDescriptor<HeapObject::kHeaderSize, kSize, kSize>
      BodyDescriptor;

 private:
  inline bool PretenuringDecisionMade();

  AllocationSite() = delete; AllocationSite(const AllocationSite&) = delete; void operator=(const AllocationSite&) = delete;
};


class AllocationMemento: public Struct {
 public:
  static const int kAllocationSiteOffset = HeapObject::kHeaderSize;
  static const int kSize = kAllocationSiteOffset + kPointerSize;

  inline Object* allocation_site() const; inline void set_allocation_site(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline bool IsValid();
  inline AllocationSite* GetAllocationSite();
  inline Address GetAllocationSiteUnchecked();

  void AllocationMementoPrint(std::ostream& os);
  void AllocationMementoVerify();

  inline static AllocationMemento* cast(Object* object); inline static const AllocationMemento* cast(const Object* object);

 private:
  AllocationMemento() = delete; AllocationMemento(const AllocationMemento&) = delete; void operator=(const AllocationMemento&) = delete;
};
class AliasedArgumentsEntry: public Struct {
 public:
  inline int aliased_context_slot() const;
  inline void set_aliased_context_slot(int count);

  inline static AliasedArgumentsEntry* cast(Object* object); inline static const AliasedArgumentsEntry* cast(const Object* object);


  void AliasedArgumentsEntryPrint(std::ostream& os);
  void AliasedArgumentsEntryVerify();

  static const int kAliasedContextSlot = HeapObject::kHeaderSize;
  static const int kSize = kAliasedContextSlot + kPointerSize;

 private:
  AliasedArgumentsEntry() = delete; AliasedArgumentsEntry(const AliasedArgumentsEntry&) = delete; void operator=(const AliasedArgumentsEntry&) = delete;
};


enum AllowNullsFlag {ALLOW_NULLS, DISALLOW_NULLS};
enum RobustnessFlag {ROBUST_STRING_TRAVERSAL, FAST_STRING_TRAVERSAL};


class StringHasher {
 public:
  explicit inline StringHasher(int length, uint32_t seed);

  template <typename schar>
  static inline uint32_t HashSequentialString(const schar* chars,
                                              int length,
                                              uint32_t seed);


  static uint32_t ComputeUtf8Hash(Vector<const char> chars,
                                  uint32_t seed,
                                  int* utf16_length_out);




  static uint32_t MakeArrayIndexHash(uint32_t value, int length);




  static const int kZeroHash = 27;


  inline static uint32_t AddCharacterCore(uint32_t running_hash, uint16_t c);
  inline static uint32_t GetHashCore(uint32_t running_hash);
  inline static uint32_t ComputeRunningHash(uint32_t running_hash, const uc16* chars, int length);

  inline static uint32_t ComputeRunningHashOneByte(uint32_t running_hash, const char* chars, int length);



 protected:


  uint32_t GetHashField();


  inline bool has_trivial_hash();

  template<typename Char>
  inline void AddCharacters(const Char* chars, int len);

 private:

  template<typename Char>
  inline void AddCharacter(Char c);

  template<typename Char>
  inline bool UpdateIndex(Char c);

  int length_;
  uint32_t raw_running_hash_;
  uint32_t array_index_;
  bool is_array_index_;
  bool is_first_char_;
  StringHasher(const StringHasher&) = delete; void operator=(const StringHasher&) = delete;
};


class IteratingStringHasher : public StringHasher {
 public:
  static inline uint32_t Hash(String* string, uint32_t seed);
  inline void VisitOneByteString(const uint8_t* chars, int length);
  inline void VisitTwoByteString(const uint16_t* chars, int length);

 private:
  inline IteratingStringHasher(int len, uint32_t seed);
  void VisitConsString(ConsString* cons_string);
  IteratingStringHasher(const IteratingStringHasher&) = delete; void operator=(const IteratingStringHasher&) = delete;
};
class StringShape : public Embedded {
 public:
  inline explicit StringShape(const String* s);
  inline explicit StringShape(Map* s);
  inline explicit StringShape(InstanceType t);
  inline bool IsSequential();
  inline bool IsExternal();
  inline bool IsCons();
  inline bool IsSliced();
  inline bool IsIndirect();
  inline bool IsExternalOneByte();
  inline bool IsExternalTwoByte();
  inline bool IsSequentialOneByte();
  inline bool IsSequentialTwoByte();
  inline bool IsInternalized();
  inline StringRepresentationTag representation_tag();
  inline uint32_t encoding_tag();
  inline uint32_t full_representation_tag();
  inline uint32_t size_tag();

  inline uint32_t type() { return type_; }
  inline void invalidate() { valid_ = false; }
  inline bool valid() { return valid_; }




 private:
  uint32_t type_;

  inline void set_valid() { valid_ = true; }
  bool valid_;



};




class Name: public HeapObject {
 public:

  inline uint32_t hash_field();
  inline void set_hash_field(uint32_t value);


  inline bool HasHashCode();


  inline uint32_t Hash();


  inline bool Equals(Name* other);
  inline static bool Equals(Handle<Name> one, Handle<Name> two);


  inline bool AsArrayIndex(uint32_t* index);


  inline bool IsPrivate();

  inline bool IsUniqueName() const;



  __attribute__((warn_unused_result)) static MaybeHandle<String> ToFunctionName(Handle<Name> name);

  inline static Name* cast(Object* object); inline static const Name* cast(const Object* object);

  void NamePrint(std::ostream& os);

  void NameShortPrint();
  int NameShortPrint(Vector<char> str);



  static const int kHashFieldSlot = HeapObject::kHeaderSize;



  static const int kHashFieldOffset = kHashFieldSlot + kIntSize;

  static const int kSize = kHashFieldSlot + kPointerSize;






  static const int kHashNotComputedMask = 1;
  static const int kIsNotArrayIndexMask = 1 << 1;
  static const int kNofHashBitFields = 2;


  static const int kHashShift = kNofHashBitFields;



  static const uint32_t kHashBitMask = 0xffffffffu >> kHashShift;


  static const int kMaxCachedArrayIndexLength = 7;




  static const int kArrayIndexValueBits = 24;
  static const int kArrayIndexLengthBits =
      kBitsPerInt - kArrayIndexValueBits - kNofHashBitFields;

  static_assert((kArrayIndexLengthBits > 0), "(kArrayIndexLengthBits > 0)");

  class ArrayIndexValueBits : public BitField<unsigned int, kNofHashBitFields,
      kArrayIndexValueBits> {};
  class ArrayIndexLengthBits : public BitField<unsigned int,
      kNofHashBitFields + kArrayIndexValueBits,
      kArrayIndexLengthBits> {};




  static_assert(((kMaxCachedArrayIndexLength + 1) != 0 && (((kMaxCachedArrayIndexLength + 1) & ((kMaxCachedArrayIndexLength + 1) - 1)) == 0)), "IS_POWER_OF_TWO(kMaxCachedArrayIndexLength + 1)");

  static const unsigned int kContainsCachedArrayIndexMask =
      (~static_cast<unsigned>(kMaxCachedArrayIndexLength)
       << ArrayIndexLengthBits::kShift) |
      kIsNotArrayIndexMask;


  static const int kEmptyHashField =
      kIsNotArrayIndexMask | kHashNotComputedMask;

 protected:
  static inline bool IsHashFieldComputed(uint32_t field);

 private:
  Name() = delete; Name(const Name&) = delete; void operator=(const Name&) = delete;
};



class Symbol: public Name {
 public:

  inline Object* name() const; inline void set_name(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline int flags() const; inline void set_flags(int value);



  inline bool is_private() const; inline void set_is_private(bool value);




  inline bool is_well_known_symbol() const; inline void set_is_well_known_symbol(bool value);

  inline static Symbol* cast(Object* object); inline static const Symbol* cast(const Object* object);


  void SymbolPrint(std::ostream& os);
  void SymbolVerify();


  static const int kNameOffset = Name::kSize;
  static const int kFlagsOffset = kNameOffset + kPointerSize;
  static const int kSize = kFlagsOffset + kPointerSize;

  typedef FixedBodyDescriptor<kNameOffset, kFlagsOffset, kSize> BodyDescriptor;

  void SymbolShortPrint(std::ostream& os);

 private:
  static const int kPrivateBit = 0;
  static const int kWellKnownSymbolBit = 1;

  const char* PrivateSymbolToName() const;


  friend class Name;


  Symbol() = delete; Symbol(const Symbol&) = delete; void operator=(const Symbol&) = delete;
};


class ConsString;
class String: public Name {
 public:
  enum Encoding { ONE_BYTE_ENCODING, TWO_BYTE_ENCODING };


  static const int kMaxCachedArrayIndexLength = 7;




  static const int kArrayIndexValueBits = 24;
  static const int kArrayIndexLengthBits =
      kBitsPerInt - kArrayIndexValueBits - kNofHashBitFields;

  static_assert((kArrayIndexLengthBits > 0), "(kArrayIndexLengthBits > 0)");

  class ArrayIndexValueBits : public BitField<unsigned int, kNofHashBitFields,
      kArrayIndexValueBits> {};
  class ArrayIndexLengthBits : public BitField<unsigned int,
      kNofHashBitFields + kArrayIndexValueBits,
      kArrayIndexLengthBits> {};




  static_assert(((kMaxCachedArrayIndexLength + 1) != 0 && (((kMaxCachedArrayIndexLength + 1) & ((kMaxCachedArrayIndexLength + 1) - 1)) == 0)), "IS_POWER_OF_TWO(kMaxCachedArrayIndexLength + 1)");

  static const unsigned int kContainsCachedArrayIndexMask =
      (~static_cast<unsigned>(kMaxCachedArrayIndexLength)
       << ArrayIndexLengthBits::kShift) |
      kIsNotArrayIndexMask;

  class SubStringRange {
   public:
    explicit inline SubStringRange(String* string, int first = 0,
                                   int length = -1);
    class iterator;
    inline iterator begin();
    inline iterator end();

   private:
    String* string_;
    int first_;
    int length_;
  };






  class FlatContent {
   public:

    bool IsFlat() { return state_ != NON_FLAT; }

    bool IsOneByte() { return state_ == ONE_BYTE; }

    bool IsTwoByte() { return state_ == TWO_BYTE; }



    Vector<const uint8_t> ToOneByteVector() {
      do { if (std::string* _msg = ::v8::base::CheckEQImpl( (ONE_BYTE), (state_), "ONE_BYTE" " " "==" " " "state_")) { V8_Fatal(".././src/objects.h", 8855, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
      return Vector<const uint8_t>(onebyte_start, length_);
    }


    Vector<const uc16> ToUC16Vector() {
      do { if (std::string* _msg = ::v8::base::CheckEQImpl( (TWO_BYTE), (state_), "TWO_BYTE" " " "==" " " "state_")) { V8_Fatal(".././src/objects.h", 8861, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
      return Vector<const uc16>(twobyte_start, length_);
    }

    uc16 Get(int i) {
      do { if ((!(i < length_))) { V8_Fatal(".././src/objects.h", 8866, "Check failed: %s.", "i < length_"); } } while (0);
      do { if ((!(state_ != NON_FLAT))) { V8_Fatal(".././src/objects.h", 8867, "Check failed: %s.", "state_ != NON_FLAT"); } } while (0);
      if (state_ == ONE_BYTE) return onebyte_start[i];
      return twobyte_start[i];
    }

    bool UsesSameString(const FlatContent& other) const {
      return onebyte_start == other.onebyte_start;
    }

   private:
    enum State { NON_FLAT, ONE_BYTE, TWO_BYTE };


    explicit FlatContent(const uint8_t* start, int length)
        : onebyte_start(start), length_(length), state_(ONE_BYTE) {}
    explicit FlatContent(const uc16* start, int length)
        : twobyte_start(start), length_(length), state_(TWO_BYTE) { }
    FlatContent() : onebyte_start(0), length_(0), state_(NON_FLAT) { }

    union {
      const uint8_t* onebyte_start;
      const uc16* twobyte_start;
    };
    int length_;
    State state_;

    friend class String;
    friend class IterableSubString;
  };

  template <typename Char>
  inline Vector<const Char> GetCharVector();


  inline int length() const;
  inline void set_length(int value);



  inline int synchronized_length() const;
  inline void synchronized_set_length(int value);





  inline bool IsOneByteRepresentation() const;
  inline bool IsTwoByteRepresentation() const;




  inline bool IsOneByteRepresentationUnderneath();
  inline bool IsTwoByteRepresentationUnderneath();



  inline bool HasOnlyOneByteChars();


  inline void Set(int index, uint16_t value);


  inline uint16_t Get(int index);


  static Handle<Object> ToNumber(Handle<String> subject);
  static inline Handle<String> Flatten(Handle<String> string,
                                       PretenureFlag pretenure = NOT_TENURED);






  FlatContent GetFlatContent();



  inline String* GetUnderlying();
  __attribute__((warn_unused_result)) static ComparisonResult Compare(Handle<String> x,
                                                  Handle<String> y);


  inline bool Equals(String* other);
  inline static bool Equals(Handle<String> one, Handle<String> two);
  bool IsUtf8EqualTo(Vector<const char> str, bool allow_prefix_match = false);
  bool IsOneByteEqualTo(Vector<const uint8_t> str);
  bool IsTwoByteEqualTo(Vector<const uc16> str);
  base::SmartArrayPointer<char> ToCString(AllowNullsFlag allow_nulls,
                                          RobustnessFlag robustness_flag,
                                          int offset, int length,
                                          int* length_output = 0);
  base::SmartArrayPointer<char> ToCString(
      AllowNullsFlag allow_nulls = DISALLOW_NULLS,
      RobustnessFlag robustness_flag = FAST_STRING_TRAVERSAL,
      int* length_output = 0);







  base::SmartArrayPointer<uc16> ToWideCString(
      RobustnessFlag robustness_flag = FAST_STRING_TRAVERSAL);

  bool ComputeArrayIndex(uint32_t* index);


  bool MakeExternal(v8::String::ExternalStringResource* resource);
  bool MakeExternal(v8::String::ExternalOneByteStringResource* resource);


  inline bool AsArrayIndex(uint32_t* index);

  inline static String* cast(Object* object); inline static const String* cast(const Object* object);

  void PrintOn(FILE* out);


  bool LooksValid();


  void StringShortPrint(StringStream* accumulator);
  void PrintUC16(std::ostream& os, int start = 0, int end = -1);

  char* ToAsciiArray();

  void StringPrint(std::ostream& os);
  void StringVerify();

  inline bool IsFlat();


  static const int kLengthOffset = Name::kSize;
  static const int kSize = kLengthOffset + kPointerSize;



  static const int kMaxArrayIndexSize = 10;
  static_assert(kMaxArrayIndexSize < (1 << kArrayIndexLengthBits), "kMaxArrayIndexSize < (1 << kArrayIndexLengthBits)");


  static const int32_t kMaxOneByteCharCode = unibrow::Latin1::kMaxChar;
  static const uint32_t kMaxOneByteCharCodeU = unibrow::Latin1::kMaxChar;
  static const int kMaxUtf16CodeUnit = 0xffff;
  static const uint32_t kMaxUtf16CodeUnitU = kMaxUtf16CodeUnit;
  static const uc32 kMaxCodePoint = 0x10ffff;


  static const int kMaxLength = (1 << 28) - 16;



  static const int kMaxHashCalcLength = 16383;


  static const int kMaxShortPrintLength = 1024;


  const uc16* GetTwoByteData(unsigned start);


  template <typename sinkchar>
  static void WriteToFlat(String* source,
                          sinkchar* sink,
                          int from,
                          int to);





  static inline int NonAsciiStart(const char* chars, int length) {
    const char* start = chars;
    const char* limit = chars + length;

    if (length >= kIntptrSize) {

      while (!IsAligned(reinterpret_cast<intptr_t>(chars), sizeof(uintptr_t))) {
        if (static_cast<uint8_t>(*chars) > unibrow::Utf8::kMaxOneByteChar) {
          return static_cast<int>(chars - start);
        }
        ++chars;
      }

      do { if ((!(unibrow::Utf8::kMaxOneByteChar == 0x7F))) { V8_Fatal(".././src/objects.h", 9089, "Check failed: %s.", "unibrow::Utf8::kMaxOneByteChar == 0x7F"); } } while (0);
      const uintptr_t non_one_byte_mask = kUintptrAllBitsSet / 0xFF * 0x80;
      while (chars + sizeof(uintptr_t) <= limit) {
        if (*reinterpret_cast<const uintptr_t*>(chars) & non_one_byte_mask) {
          return static_cast<int>(chars - start);
        }
        chars += sizeof(uintptr_t);
      }
    }

    while (chars < limit) {
      if (static_cast<uint8_t>(*chars) > unibrow::Utf8::kMaxOneByteChar) {
        return static_cast<int>(chars - start);
      }
      ++chars;
    }

    return static_cast<int>(chars - start);
  }

  static inline bool IsAscii(const char* chars, int length) {
    return NonAsciiStart(chars, length) >= length;
  }

  static inline bool IsAscii(const uint8_t* chars, int length) {
    return
        NonAsciiStart(reinterpret_cast<const char*>(chars), length) >= length;
  }

  static inline int NonOneByteStart(const uc16* chars, int length) {
    const uc16* limit = chars + length;
    const uc16* start = chars;
    while (chars < limit) {
      if (*chars > kMaxOneByteCharCodeU) return static_cast<int>(chars - start);
      ++chars;
    }
    return static_cast<int>(chars - start);
  }

  static inline bool IsOneByte(const uc16* chars, int length) {
    return NonOneByteStart(chars, length) >= length;
  }

  template<class Visitor>
  static inline ConsString* VisitFlat(Visitor* visitor,
                                      String* string,
                                      int offset = 0);

  static Handle<FixedArray> CalculateLineEnds(Handle<String> string,
                                              bool include_ending_line);



  inline void SetForwardedInternalizedString(String* string);
  inline String* GetForwardedInternalizedString();

 private:
  friend class Name;
  friend class StringTableInsertionKey;

  static Handle<String> SlowFlatten(Handle<ConsString> cons,
                                    PretenureFlag tenure);



  bool SlowEquals(String* other);

  static bool SlowEquals(Handle<String> one, Handle<String> two);


  bool SlowAsArrayIndex(uint32_t* index);


  uint32_t ComputeAndSetHash();

  String() = delete; String(const String&) = delete; void operator=(const String&) = delete;
};



class SeqString: public String {
 public:
  inline static SeqString* cast(Object* object); inline static const SeqString* cast(const Object* object);


  static const int kHeaderSize = String::kSize;




  __attribute__((warn_unused_result)) static Handle<String> Truncate(Handle<SeqString> string,
                                                 int new_length);
 private:
  SeqString() = delete; SeqString(const SeqString&) = delete; void operator=(const SeqString&) = delete;
};




class SeqOneByteString: public SeqString {
 public:
  static const bool kHasOneByteEncoding = true;


  inline uint16_t SeqOneByteStringGet(int index);
  inline void SeqOneByteStringSet(int index, uint16_t value);


  inline Address GetCharsAddress();

  inline uint8_t* GetChars();

  inline static SeqOneByteString* cast(Object* object); inline static const SeqOneByteString* cast(const Object* object);




  inline int SeqOneByteStringSize(InstanceType instance_type);


  static int SizeFor(int length) {
    return (((kHeaderSize + length * kCharSize) + kObjectAlignmentMask) & ~kObjectAlignmentMask);
  }


  static const int kMaxSize = 512 * MB - 1;
  static_assert((kMaxSize - kHeaderSize) >= String::kMaxLength, "(kMaxSize - kHeaderSize) >= String::kMaxLength");

 private:
  SeqOneByteString() = delete; SeqOneByteString(const SeqOneByteString&) = delete; void operator=(const SeqOneByteString&) = delete;
};




class SeqTwoByteString: public SeqString {
 public:
  static const bool kHasOneByteEncoding = false;


  inline uint16_t SeqTwoByteStringGet(int index);
  inline void SeqTwoByteStringSet(int index, uint16_t value);


  inline Address GetCharsAddress();

  inline uc16* GetChars();


  const uint16_t* SeqTwoByteStringGetData(unsigned start);

  inline static SeqTwoByteString* cast(Object* object); inline static const SeqTwoByteString* cast(const Object* object);




  inline int SeqTwoByteStringSize(InstanceType instance_type);


  static int SizeFor(int length) {
    return (((kHeaderSize + length * kShortSize) + kObjectAlignmentMask) & ~kObjectAlignmentMask);
  }


  static const int kMaxSize = 512 * MB - 1;
  static_assert(static_cast<int>((kMaxSize - kHeaderSize)/sizeof(uint16_t)) >= String::kMaxLength, "static_cast<int>((kMaxSize - kHeaderSize)/sizeof(uint16_t)) >= String::kMaxLength");


 private:
  SeqTwoByteString() = delete; SeqTwoByteString(const SeqTwoByteString&) = delete; void operator=(const SeqTwoByteString&) = delete;
};
class ConsString: public String {
 public:

  inline String* first();


  inline Object* unchecked_first();
  inline void set_first(String* first,
                        WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline String* second();


  inline Object* unchecked_second();
  inline void set_second(String* second,
                         WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  uint16_t ConsStringGet(int index);

  inline static ConsString* cast(Object* object); inline static const ConsString* cast(const Object* object);


  static const int kFirstOffset = (((String::kSize) + kPointerAlignmentMask) & ~kPointerAlignmentMask);
  static const int kSecondOffset = kFirstOffset + kPointerSize;
  static const int kSize = kSecondOffset + kPointerSize;


  static const int kMinLength = 13;

  typedef FixedBodyDescriptor<kFirstOffset, kSecondOffset + kPointerSize, kSize>
          BodyDescriptor;

  void ConsStringVerify();

 private:
  ConsString() = delete; ConsString(const ConsString&) = delete; void operator=(const ConsString&) = delete;
};
class SlicedString: public String {
 public:
  inline String* parent();
  inline void set_parent(String* parent,
                         WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline int offset() const;
  inline void set_offset(int offset);


  uint16_t SlicedStringGet(int index);

  inline static SlicedString* cast(Object* object); inline static const SlicedString* cast(const Object* object);


  static const int kParentOffset = (((String::kSize) + kPointerAlignmentMask) & ~kPointerAlignmentMask);
  static const int kOffsetOffset = kParentOffset + kPointerSize;
  static const int kSize = kOffsetOffset + kPointerSize;


  static const int kMinLength = 13;

  typedef FixedBodyDescriptor<kParentOffset,
                              kOffsetOffset + kPointerSize, kSize>
          BodyDescriptor;

  void SlicedStringVerify();

 private:
  SlicedString() = delete; SlicedString(const SlicedString&) = delete; void operator=(const SlicedString&) = delete;
};
class ExternalString: public String {
 public:
  inline static ExternalString* cast(Object* object); inline static const ExternalString* cast(const Object* object);


  static const int kResourceOffset = (((String::kSize) + kPointerAlignmentMask) & ~kPointerAlignmentMask);
  static const int kShortSize = kResourceOffset + kPointerSize;
  static const int kResourceDataOffset = kResourceOffset + kPointerSize;
  static const int kSize = kResourceDataOffset + kPointerSize;

  static const int kMaxShortLength =
      (kShortSize - SeqString::kHeaderSize) / kCharSize;


  inline bool is_short();

  static_assert(kResourceOffset == Internals::kStringResourceOffset, "kResourceOffset == Internals::kStringResourceOffset");

 private:
  ExternalString() = delete; ExternalString(const ExternalString&) = delete; void operator=(const ExternalString&) = delete;
};




class ExternalOneByteString : public ExternalString {
 public:
  static const bool kHasOneByteEncoding = true;

  typedef v8::String::ExternalOneByteStringResource Resource;


  inline const Resource* resource();
  inline void set_resource(const Resource* buffer);





  inline void update_data_cache();

  inline const uint8_t* GetChars();


  inline uint16_t ExternalOneByteStringGet(int index);

  inline static ExternalOneByteString* cast(Object* object); inline static const ExternalOneByteString* cast(const Object* object);

  class BodyDescriptor;

 private:
  ExternalOneByteString() = delete; ExternalOneByteString(const ExternalOneByteString&) = delete; void operator=(const ExternalOneByteString&) = delete;
};




class ExternalTwoByteString: public ExternalString {
 public:
  static const bool kHasOneByteEncoding = false;

  typedef v8::String::ExternalStringResource Resource;


  inline const Resource* resource();
  inline void set_resource(const Resource* buffer);





  inline void update_data_cache();

  inline const uint16_t* GetChars();


  inline uint16_t ExternalTwoByteStringGet(int index);


  inline const uint16_t* ExternalTwoByteStringGetData(unsigned start);

  inline static ExternalTwoByteString* cast(Object* object); inline static const ExternalTwoByteString* cast(const Object* object);

  class BodyDescriptor;

 private:
  ExternalTwoByteString() = delete; ExternalTwoByteString(const ExternalTwoByteString&) = delete; void operator=(const ExternalTwoByteString&) = delete;
};





class Relocatable : public Embedded {
 public:
  explicit inline Relocatable(Isolate* isolate);
  inline virtual ~Relocatable();
  virtual void IterateInstance(ObjectVisitor* v) { }
  virtual void PostGarbageCollection() { }

  static void PostGarbageCollectionProcessing(Isolate* isolate);
  static int ArchiveSpacePerThread();
  static char* ArchiveState(Isolate* isolate, char* to);
  static char* RestoreState(Isolate* isolate, char* from);
  static void Iterate(Isolate* isolate, ObjectVisitor* v);
  static void Iterate(ObjectVisitor* v, Relocatable* top);
  static char* Iterate(ObjectVisitor* v, char* t);

 private:
  Isolate* isolate_;
  Relocatable* prev_;
};





class FlatStringReader : public Relocatable {
 public:
  FlatStringReader(Isolate* isolate, Handle<String> str);
  FlatStringReader(Isolate* isolate, Vector<const char> input);
  void PostGarbageCollection();
  inline uc32 Get(int index);
  template <typename Char>
  inline Char Get(int index);
  int length() { return length_; }
 private:
  String** str_;
  bool is_one_byte_;
  int length_;
  const void* start_;
};





class ConsStringIterator {
 public:
  inline ConsStringIterator() {}
  inline explicit ConsStringIterator(ConsString* cons_string, int offset = 0) {
    Reset(cons_string, offset);
  }
  inline void Reset(ConsString* cons_string, int offset = 0) {
    depth_ = 0;

    if (cons_string == 0) return;
    Initialize(cons_string, offset);
  }

  inline String* Next(int* offset_out) {
    *offset_out = 0;
    if (depth_ == 0) return 0;
    return Continue(offset_out);
  }

 private:
  static const int kStackSize = 32;

  static const int kDepthMask = kStackSize-1;
  static_assert(((kStackSize) != 0 && (((kStackSize) & ((kStackSize) - 1)) == 0)), "IS_POWER_OF_TWO(kStackSize)");
  static inline int OffsetForDepth(int depth);

  inline void PushLeft(ConsString* string);
  inline void PushRight(ConsString* string);
  inline void AdjustMaximumDepth();
  inline void Pop();
  inline bool StackBlown() { return maximum_depth_ - depth_ == kStackSize; }
  void Initialize(ConsString* cons_string, int offset);
  String* Continue(int* offset_out);
  String* NextLeaf(bool* blew_stack);
  String* Search(int* offset_out);



  ConsString* frames_[kStackSize];
  ConsString* root_;
  int depth_;
  int maximum_depth_;
  int consumed_;
  ConsStringIterator(const ConsStringIterator&) = delete; void operator=(const ConsStringIterator&) = delete;
};


class StringCharacterStream {
 public:
  inline StringCharacterStream(String* string,
                               int offset = 0);
  inline uint16_t GetNext();
  inline bool HasMore();
  inline void Reset(String* string, int offset = 0);
  inline void VisitOneByteString(const uint8_t* chars, int length);
  inline void VisitTwoByteString(const uint16_t* chars, int length);

 private:
  ConsStringIterator iter_;
  bool is_one_byte_;
  union {
    const uint8_t* buffer8_;
    const uint16_t* buffer16_;
  };
  const uint8_t* end_;
  StringCharacterStream(const StringCharacterStream&) = delete; void operator=(const StringCharacterStream&) = delete;
};


template <typename T>
class VectorIterator {
 public:
  VectorIterator(T* d, int l) : data_(Vector<const T>(d, l)), index_(0) { }
  explicit VectorIterator(Vector<const T> data) : data_(data), index_(0) { }
  T GetNext() { return data_[index_++]; }
  bool has_more() { return index_ < data_.length(); }
 private:
  Vector<const T> data_;
  int index_;
};



class Oddball: public HeapObject {
 public:

  inline String* to_string() const; inline void set_to_string(String* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* to_number() const; inline void set_to_number(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Oddball* to_boolean() const; inline void set_to_boolean(Oddball* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline String* type_of() const; inline void set_type_of(String* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline byte kind() const;
  inline void set_kind(byte kind);


  __attribute__((warn_unused_result)) static inline Handle<Object> ToNumber(Handle<Oddball> input);

  inline static Oddball* cast(Object* object); inline static const Oddball* cast(const Object* object);


  void OddballVerify();


  static void Initialize(Isolate* isolate, Handle<Oddball> oddball,
                         const char* to_string, Handle<Object> to_number,
                         bool to_boolean, const char* type_of, byte kind);


  static const int kToStringOffset = HeapObject::kHeaderSize;
  static const int kToNumberOffset = kToStringOffset + kPointerSize;
  static const int kToBooleanOffset = kToNumberOffset + kPointerSize;
  static const int kTypeOfOffset = kToBooleanOffset + kPointerSize;
  static const int kKindOffset = kTypeOfOffset + kPointerSize;
  static const int kSize = kKindOffset + kPointerSize;

  static const byte kFalse = 0;
  static const byte kTrue = 1;
  static const byte kNotBooleanMask = ~1;
  static const byte kTheHole = 2;
  static const byte kNull = 3;
  static const byte kArgumentsMarker = 4;
  static const byte kUndefined = 5;
  static const byte kUninitialized = 6;
  static const byte kOther = 7;
  static const byte kException = 8;
  static const byte kOptimizedOut = 9;

  typedef FixedBodyDescriptor<kToStringOffset, kTypeOfOffset + kPointerSize,
                              kSize> BodyDescriptor;

  static_assert(kKindOffset == Internals::kOddballKindOffset, "kKindOffset == Internals::kOddballKindOffset");
  static_assert(kNull == Internals::kNullOddballKind, "kNull == Internals::kNullOddballKind");
  static_assert(kUndefined == Internals::kUndefinedOddballKind, "kUndefined == Internals::kUndefinedOddballKind");

 private:
  Oddball() = delete; Oddball(const Oddball&) = delete; void operator=(const Oddball&) = delete;
};


class Cell: public HeapObject {
 public:

  inline Object* value() const; inline void set_value(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static Cell* cast(Object* object); inline static const Cell* cast(const Object* object);

  static inline Cell* FromValueAddress(Address value) {
    Object* result = FromAddress(value - kValueOffset);
    return static_cast<Cell*>(result);
  }

  inline Address ValueAddress() {
    return address() + kValueOffset;
  }


  void CellPrint(std::ostream& os);
  void CellVerify();


  static const int kValueOffset = HeapObject::kHeaderSize;
  static const int kSize = kValueOffset + kPointerSize;

  typedef FixedBodyDescriptor<kValueOffset,
                              kValueOffset + kPointerSize,
                              kSize> BodyDescriptor;

 private:
  Cell() = delete; Cell(const Cell&) = delete; void operator=(const Cell&) = delete;
};


class PropertyCell : public HeapObject {
 public:

  inline Object* property_details_raw() const; inline void set_property_details_raw(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline Object* value() const; inline void set_value(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline DependentCode* dependent_code() const; inline void set_dependent_code(DependentCode* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline PropertyDetails property_details();
  inline void set_property_details(PropertyDetails details);

  PropertyCellConstantType GetConstantType();



  static PropertyCellType UpdatedType(Handle<PropertyCell> cell,
                                      Handle<Object> value,
                                      PropertyDetails details);
  static void UpdateCell(Handle<GlobalDictionary> dictionary, int entry,
                         Handle<Object> value, PropertyDetails details);

  static Handle<PropertyCell> InvalidateEntry(
      Handle<GlobalDictionary> dictionary, int entry);

  static void SetValueWithInvalidation(Handle<PropertyCell> cell,
                                       Handle<Object> new_value);

  inline static PropertyCell* cast(Object* object); inline static const PropertyCell* cast(const Object* object);


  void PropertyCellPrint(std::ostream& os);
  void PropertyCellVerify();


  static const int kDetailsOffset = HeapObject::kHeaderSize;
  static const int kValueOffset = kDetailsOffset + kPointerSize;
  static const int kDependentCodeOffset = kValueOffset + kPointerSize;
  static const int kSize = kDependentCodeOffset + kPointerSize;

  static const int kPointerFieldsBeginOffset = kValueOffset;
  static const int kPointerFieldsEndOffset = kSize;

  typedef FixedBodyDescriptor<kValueOffset,
                              kSize,
                              kSize> BodyDescriptor;

 private:
  PropertyCell() = delete; PropertyCell(const PropertyCell&) = delete; void operator=(const PropertyCell&) = delete;
};


class WeakCell : public HeapObject {
 public:
  inline Object* value() const;


  inline void clear();


  inline void initialize(HeapObject* value);

  inline bool cleared() const;

  inline Object* next() const; inline void set_next(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline void clear_next(Object* the_hole_value);

  inline bool next_cleared();

  inline static WeakCell* cast(Object* object); inline static const WeakCell* cast(const Object* object);

  void WeakCellPrint(std::ostream& os);
  void WeakCellVerify();


  static const int kValueOffset = HeapObject::kHeaderSize;
  static const int kNextOffset = kValueOffset + kPointerSize;
  static const int kSize = kNextOffset + kPointerSize;

  typedef FixedBodyDescriptor<kValueOffset, kSize, kSize> BodyDescriptor;

 private:
  WeakCell() = delete; WeakCell(const WeakCell&) = delete; void operator=(const WeakCell&) = delete;
};



class JSProxy: public JSReceiver {
 public:
  __attribute__((warn_unused_result)) static MaybeHandle<JSProxy> New(Isolate* isolate,
                                                  Handle<Object>,
                                                  Handle<Object>);


  inline Object* handler() const; inline void set_handler(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline JSReceiver* target() const; inline void set_target(JSReceiver* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline Object* hash() const; inline void set_hash(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  static MaybeHandle<Context> GetFunctionRealm(Handle<JSProxy> proxy);

  inline static JSProxy* cast(Object* object); inline static const JSProxy* cast(const Object* object);

  inline bool IsRevoked() const;
  static void Revoke(Handle<JSProxy> proxy);


  static MaybeHandle<Object> GetPrototype(Handle<JSProxy> receiver);


  __attribute__((warn_unused_result)) static Maybe<bool> SetPrototype(Handle<JSProxy> proxy,
                                                  Handle<Object> value,
                                                  bool from_javascript,
                                                  ShouldThrow should_throw);

  __attribute__((warn_unused_result)) static Maybe<bool> IsExtensible(Handle<JSProxy> proxy);


  __attribute__((warn_unused_result)) static Maybe<bool> PreventExtensions(
      Handle<JSProxy> proxy, ShouldThrow should_throw);


  __attribute__((warn_unused_result)) static Maybe<bool> GetOwnPropertyDescriptor(
      Isolate* isolate, Handle<JSProxy> proxy, Handle<Name> name,
      PropertyDescriptor* desc);


  __attribute__((warn_unused_result)) static Maybe<bool> DefineOwnProperty(
      Isolate* isolate, Handle<JSProxy> object, Handle<Object> key,
      PropertyDescriptor* desc, ShouldThrow should_throw);


  __attribute__((warn_unused_result)) static Maybe<bool> HasProperty(Isolate* isolate,
                                                 Handle<JSProxy> proxy,
                                                 Handle<Name> name);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> GetProperty(
      Isolate* isolate, Handle<JSProxy> proxy, Handle<Name> name,
      Handle<Object> receiver);


  __attribute__((warn_unused_result)) static Maybe<bool> SetProperty(Handle<JSProxy> proxy,
                                                 Handle<Name> name,
                                                 Handle<Object> value,
                                                 Handle<Object> receiver,
                                                 LanguageMode language_mode);


  __attribute__((warn_unused_result)) static Maybe<bool> DeletePropertyOrElement(
      Handle<JSProxy> proxy, Handle<Name> name, LanguageMode language_mode);


  __attribute__((warn_unused_result)) static Maybe<bool> OwnPropertyKeys(
      Isolate* isolate, Handle<JSReceiver> receiver, Handle<JSProxy> proxy,
      PropertyFilter filter, KeyAccumulator* accumulator);

  __attribute__((warn_unused_result)) static Maybe<PropertyAttributes> GetPropertyAttributes(
      LookupIterator* it);


  void JSProxyPrint(std::ostream& os);
  void JSProxyVerify();


  static const int kTargetOffset = JSReceiver::kHeaderSize;
  static const int kHandlerOffset = kTargetOffset + kPointerSize;
  static const int kHashOffset = kHandlerOffset + kPointerSize;
  static const int kSize = kHashOffset + kPointerSize;

  typedef FixedBodyDescriptor<JSReceiver::kPropertiesOffset, kSize, kSize>
      BodyDescriptor;

  static Handle<Object> GetIdentityHash(Isolate* isolate,
                                        Handle<JSProxy> receiver);

  static Handle<Smi> GetOrCreateIdentityHash(Handle<JSProxy> proxy);

  static Maybe<bool> SetPrivateProperty(Isolate* isolate, Handle<JSProxy> proxy,
                                        Handle<Symbol> private_name,
                                        PropertyDescriptor* desc,
                                        ShouldThrow should_throw);

 private:
  JSProxy() = delete; JSProxy(const JSProxy&) = delete; void operator=(const JSProxy&) = delete;
};


class JSCollection : public JSObject {
 public:

  inline Object* table() const; inline void set_table(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  static const int kTableOffset = JSObject::kHeaderSize;
  static const int kSize = kTableOffset + kPointerSize;

 private:
  JSCollection() = delete; JSCollection(const JSCollection&) = delete; void operator=(const JSCollection&) = delete;
};



class JSSet : public JSCollection {
 public:
  inline static JSSet* cast(Object* object); inline static const JSSet* cast(const Object* object);

  static void Initialize(Handle<JSSet> set, Isolate* isolate);
  static void Clear(Handle<JSSet> set);


  void JSSetPrint(std::ostream& os);
  void JSSetVerify();

 private:
  JSSet() = delete; JSSet(const JSSet&) = delete; void operator=(const JSSet&) = delete;
};



class JSMap : public JSCollection {
 public:
  inline static JSMap* cast(Object* object); inline static const JSMap* cast(const Object* object);

  static void Initialize(Handle<JSMap> map, Isolate* isolate);
  static void Clear(Handle<JSMap> map);


  void JSMapPrint(std::ostream& os);
  void JSMapVerify();

 private:
  JSMap() = delete; JSMap(const JSMap&) = delete; void operator=(const JSMap&) = delete;
};
template<class Derived, class TableType>
class OrderedHashTableIterator: public JSObject {
 public:

  inline Object* table() const; inline void set_table(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* index() const; inline void set_index(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* kind() const; inline void set_kind(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  void OrderedHashTableIteratorPrint(std::ostream& os);


  static const int kTableOffset = JSObject::kHeaderSize;
  static const int kIndexOffset = kTableOffset + kPointerSize;
  static const int kKindOffset = kIndexOffset + kPointerSize;
  static const int kSize = kKindOffset + kPointerSize;

  enum Kind {
    kKindKeys = 1,
    kKindValues = 2,
    kKindEntries = 3
  };



  bool HasMore();


  void MoveNext() {
    set_index(Smi::FromInt(Smi::cast(index())->value() + 1));
  }




  Smi* Next(JSArray* value_array);



  inline Object* CurrentKey();

 private:


  void Transition();

  OrderedHashTableIterator() = delete; OrderedHashTableIterator(const OrderedHashTableIterator&) = delete; void operator=(const OrderedHashTableIterator&) = delete;
};


class JSSetIterator: public OrderedHashTableIterator<JSSetIterator,
                                                     OrderedHashSet> {
 public:

  void JSSetIteratorPrint(std::ostream& os);
  void JSSetIteratorVerify();

  inline static JSSetIterator* cast(Object* object); inline static const JSSetIterator* cast(const Object* object);



  inline void PopulateValueArray(FixedArray* array);

 private:
  JSSetIterator() = delete; JSSetIterator(const JSSetIterator&) = delete; void operator=(const JSSetIterator&) = delete;
};


class JSMapIterator: public OrderedHashTableIterator<JSMapIterator,
                                                     OrderedHashMap> {
 public:

  void JSMapIteratorPrint(std::ostream& os);
  void JSMapIteratorVerify();

  inline static JSMapIterator* cast(Object* object); inline static const JSMapIterator* cast(const Object* object);



  inline void PopulateValueArray(FixedArray* array);

 private:


  inline Object* CurrentValue();

  JSMapIterator() = delete; JSMapIterator(const JSMapIterator&) = delete; void operator=(const JSMapIterator&) = delete;
};



class JSWeakCollection: public JSObject {
 public:

  inline Object* table() const; inline void set_table(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* next() const; inline void set_next(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  static void Initialize(Handle<JSWeakCollection> collection, Isolate* isolate);
  static void Set(Handle<JSWeakCollection> collection, Handle<Object> key,
                  Handle<Object> value, int32_t hash);
  static bool Delete(Handle<JSWeakCollection> collection, Handle<Object> key,
                     int32_t hash);

  static const int kTableOffset = JSObject::kHeaderSize;
  static const int kNextOffset = kTableOffset + kPointerSize;
  static const int kSize = kNextOffset + kPointerSize;



  enum BodyVisitingPolicy { kVisitStrong, kVisitWeak };


  template <BodyVisitingPolicy>
  class BodyDescriptorImpl;


  typedef BodyDescriptorImpl<kVisitStrong> BodyDescriptor;


  typedef BodyDescriptorImpl<kVisitWeak> BodyDescriptorWeak;

 private:
  JSWeakCollection() = delete; JSWeakCollection(const JSWeakCollection&) = delete; void operator=(const JSWeakCollection&) = delete;
};



class JSWeakMap: public JSWeakCollection {
 public:
  inline static JSWeakMap* cast(Object* object); inline static const JSWeakMap* cast(const Object* object);


  void JSWeakMapPrint(std::ostream& os);
  void JSWeakMapVerify();

 private:
  JSWeakMap() = delete; JSWeakMap(const JSWeakMap&) = delete; void operator=(const JSWeakMap&) = delete;
};



class JSWeakSet: public JSWeakCollection {
 public:
  inline static JSWeakSet* cast(Object* object); inline static const JSWeakSet* cast(const Object* object);


  void JSWeakSetPrint(std::ostream& os);
  void JSWeakSetVerify();

 private:
  JSWeakSet() = delete; JSWeakSet(const JSWeakSet&) = delete; void operator=(const JSWeakSet&) = delete;
};



enum class SharedFlag { kNotShared, kShared };


class JSArrayBuffer: public JSObject {
 public:

  inline void* backing_store() const; inline void set_backing_store(void* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* byte_length() const; inline void set_byte_length(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline uint32_t bit_field() const;
  inline void set_bit_field(uint32_t bits);

  inline bool is_external();
  inline void set_is_external(bool value);

  inline bool is_neuterable();
  inline void set_is_neuterable(bool value);

  inline bool was_neutered();
  inline void set_was_neutered(bool value);

  inline bool is_shared();
  inline void set_is_shared(bool value);

  inline static JSArrayBuffer* cast(Object* object); inline static const JSArrayBuffer* cast(const Object* object);

  void Neuter();

  static void Setup(Handle<JSArrayBuffer> array_buffer, Isolate* isolate,
                    bool is_external, void* data, size_t allocated_length,
                    SharedFlag shared = SharedFlag::kNotShared);

  static bool SetupAllocatingData(Handle<JSArrayBuffer> array_buffer,
                                  Isolate* isolate, size_t allocated_length,
                                  bool initialize = true,
                                  SharedFlag shared = SharedFlag::kNotShared);


  void JSArrayBufferPrint(std::ostream& os);
  void JSArrayBufferVerify();

  static const int kByteLengthOffset = JSObject::kHeaderSize;
  static const int kBackingStoreOffset = kByteLengthOffset + kPointerSize;
  static const int kBitFieldSlot = kBackingStoreOffset + kPointerSize;



  static const int kBitFieldOffset = kBitFieldSlot + kIntSize;

  static const int kSize = kBitFieldSlot + kPointerSize;

  static const int kSizeWithInternalFields =
      kSize + v8::ArrayBuffer::kInternalFieldCount * kPointerSize;



  class BodyDescriptor;

  class IsExternal : public BitField<bool, 1, 1> {};
  class IsNeuterable : public BitField<bool, 2, 1> {};
  class WasNeutered : public BitField<bool, 3, 1> {};
  class IsShared : public BitField<bool, 4, 1> {};

 private:
  JSArrayBuffer() = delete; JSArrayBuffer(const JSArrayBuffer&) = delete; void operator=(const JSArrayBuffer&) = delete;
};


class JSArrayBufferView: public JSObject {
 public:

  inline Object* buffer() const; inline void set_buffer(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* byte_offset() const; inline void set_byte_offset(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline Object* byte_length() const; inline void set_byte_length(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static JSArrayBufferView* cast(Object* object); inline static const JSArrayBufferView* cast(const Object* object);

  void JSArrayBufferViewVerify();

  inline bool WasNeutered() const;

  static const int kBufferOffset = JSObject::kHeaderSize;
  static const int kByteOffsetOffset = kBufferOffset + kPointerSize;
  static const int kByteLengthOffset = kByteOffsetOffset + kPointerSize;
  static const int kViewSize = kByteLengthOffset + kPointerSize;

 private:

  inline Object* raw_byte_offset() const; inline void set_raw_byte_offset(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* raw_byte_length() const; inline void set_raw_byte_length(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  JSArrayBufferView() = delete; JSArrayBufferView(const JSArrayBufferView&) = delete; void operator=(const JSArrayBufferView&) = delete;
};


class JSTypedArray: public JSArrayBufferView {
 public:

  inline Object* length() const; inline void set_length(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline uint32_t length_value() const;

  inline static JSTypedArray* cast(Object* object); inline static const JSTypedArray* cast(const Object* object);

  ExternalArrayType type();
  size_t element_size();

  Handle<JSArrayBuffer> GetBuffer();


  void JSTypedArrayPrint(std::ostream& os);
  void JSTypedArrayVerify();

  static const int kLengthOffset = kViewSize + kPointerSize;
  static const int kSize = kLengthOffset + kPointerSize;

  static const int kSizeWithInternalFields =
      kSize + v8::ArrayBufferView::kInternalFieldCount * kPointerSize;

 private:
  static Handle<JSArrayBuffer> MaterializeArrayBuffer(
      Handle<JSTypedArray> typed_array);

  inline Object* raw_length() const; inline void set_raw_length(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  JSTypedArray() = delete; JSTypedArray(const JSTypedArray&) = delete; void operator=(const JSTypedArray&) = delete;
};


class JSDataView: public JSArrayBufferView {
 public:
  inline static JSDataView* cast(Object* object); inline static const JSDataView* cast(const Object* object);


  void JSDataViewPrint(std::ostream& os);
  void JSDataViewVerify();

  static const int kSize = kViewSize;

  static const int kSizeWithInternalFields =
      kSize + v8::ArrayBufferView::kInternalFieldCount * kPointerSize;

 private:
  JSDataView() = delete; JSDataView(const JSDataView&) = delete; void operator=(const JSDataView&) = delete;
};



class Foreign: public HeapObject {
 public:

  inline Address foreign_address();
  inline void set_foreign_address(Address value);

  inline static Foreign* cast(Object* object); inline static const Foreign* cast(const Object* object);


  void ForeignPrint(std::ostream& os);
  void ForeignVerify();



  static const int kForeignAddressOffset = HeapObject::kHeaderSize;
  static const int kSize = kForeignAddressOffset + kPointerSize;

  static_assert(kForeignAddressOffset == Internals::kForeignAddressOffset, "kForeignAddressOffset == Internals::kForeignAddressOffset");

  class BodyDescriptor;

 private:
  Foreign() = delete; Foreign(const Foreign&) = delete; void operator=(const Foreign&) = delete;
};







class JSArray: public JSObject {
 public:

  inline Object* length() const; inline void set_length(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);



  inline void set_length(Smi* length);

  static bool HasReadOnlyLength(Handle<JSArray> array);
  static bool WouldChangeReadOnlyLength(Handle<JSArray> array, uint32_t index);




  static void Initialize(Handle<JSArray> array, int capacity, int length = 0);



  bool SetLengthWouldNormalize(uint32_t new_length);
  static inline bool SetLengthWouldNormalize(Heap* heap, uint32_t new_length);


  inline bool AllowsSetLength();

  static void SetLength(Handle<JSArray> array, uint32_t length);

  static MaybeHandle<Object> ObservableSetLength(Handle<JSArray> array,
                                                 uint32_t length);


  static inline void SetContent(Handle<JSArray> array,
                                Handle<FixedArrayBase> storage);


  __attribute__((warn_unused_result)) static Maybe<bool> DefineOwnProperty(
      Isolate* isolate, Handle<JSArray> o, Handle<Object> name,
      PropertyDescriptor* desc, ShouldThrow should_throw);

  static bool AnythingToArrayLength(Isolate* isolate,
                                    Handle<Object> length_object,
                                    uint32_t* output);
  __attribute__((warn_unused_result)) static Maybe<bool> ArraySetLength(Isolate* isolate,
                                                    Handle<JSArray> a,
                                                    PropertyDescriptor* desc,
                                                    ShouldThrow should_throw);

  inline static JSArray* cast(Object* object); inline static const JSArray* cast(const Object* object);


  void JSArrayPrint(std::ostream& os);
  void JSArrayVerify();


  static const int kPreallocatedArrayElements = 4;


  static const int kLengthOffset = JSObject::kHeaderSize;
  static const int kSize = kLengthOffset + kPointerSize;





  static const int kInitialMaxFastElementArray =
      (600 * KB - FixedArray::kHeaderSize - kSize - AllocationMemento::kSize) /
      kPointerSize;

 private:
  JSArray() = delete; JSArray(const JSArray&) = delete; void operator=(const JSArray&) = delete;
};


Handle<Object> CacheInitialJSArrayMaps(Handle<Context> native_context,
                                       Handle<Map> initial_map);
class JSRegExpResult: public JSArray {
 public:

  static const int kIndexOffset = JSArray::kSize;
  static const int kInputOffset = kIndexOffset + kPointerSize;
  static const int kSize = kInputOffset + kPointerSize;

  static const int kIndexIndex = 0;
  static const int kInputIndex = 1;
 private:
  JSRegExpResult() = delete; JSRegExpResult(const JSRegExpResult&) = delete; void operator=(const JSRegExpResult&) = delete;
};
class AccessorInfo: public Struct {
 public:
  inline Object* name() const; inline void set_name(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline int flag() const; inline void set_flag(int value);
  inline Object* expected_receiver_type() const; inline void set_expected_receiver_type(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* getter() const; inline void set_getter(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* setter() const; inline void set_setter(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* data() const; inline void set_data(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  void AccessorInfoPrint(std::ostream& os);

  inline bool all_can_read();
  inline void set_all_can_read(bool value);

  inline bool all_can_write();
  inline void set_all_can_write(bool value);

  inline bool is_special_data_property();
  inline void set_is_special_data_property(bool value);

  inline PropertyAttributes property_attributes();
  inline void set_property_attributes(PropertyAttributes attributes);


  static bool IsCompatibleReceiverMap(Isolate* isolate,
                                      Handle<AccessorInfo> info,
                                      Handle<Map> map);
  inline bool IsCompatibleReceiver(Object* receiver);

  inline static AccessorInfo* cast(Object* object); inline static const AccessorInfo* cast(const Object* object);


  void AccessorInfoVerify();



  static int AppendUnique(Handle<Object> descriptors,
                          Handle<FixedArray> array,
                          int valid_descriptors);

  static const int kNameOffset = HeapObject::kHeaderSize;
  static const int kFlagOffset = kNameOffset + kPointerSize;
  static const int kExpectedReceiverTypeOffset = kFlagOffset + kPointerSize;
  static const int kGetterOffset = kExpectedReceiverTypeOffset + kPointerSize;
  static const int kSetterOffset = kGetterOffset + kPointerSize;
  static const int kDataOffset = kSetterOffset + kPointerSize;
  static const int kSize = kDataOffset + kPointerSize;


 private:
  inline bool HasExpectedReceiverType();


  static const int kAllCanReadBit = 0;
  static const int kAllCanWriteBit = 1;
  static const int kSpecialDataProperty = 2;
  class AttributesField : public BitField<PropertyAttributes, 3, 3> {};

  AccessorInfo() = delete; AccessorInfo(const AccessorInfo&) = delete; void operator=(const AccessorInfo&) = delete;
};
class AccessorPair: public Struct {
 public:
  inline Object* getter() const; inline void set_getter(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* setter() const; inline void set_setter(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static AccessorPair* cast(Object* object); inline static const AccessorPair* cast(const Object* object);

  static Handle<AccessorPair> Copy(Handle<AccessorPair> pair);

  inline Object* get(AccessorComponent component);
  inline void set(AccessorComponent component, Object* value);


  static Handle<Object> GetComponent(Handle<AccessorPair> accessor_pair,
                                     AccessorComponent component);


  inline void SetComponents(Object* getter, Object* setter);

  inline bool Equals(AccessorPair* pair);
  inline bool Equals(Object* getter_value, Object* setter_value);

  inline bool ContainsAccessor();


  void AccessorPairPrint(std::ostream& os);
  void AccessorPairVerify();

  static const int kGetterOffset = HeapObject::kHeaderSize;
  static const int kSetterOffset = kGetterOffset + kPointerSize;
  static const int kSize = kSetterOffset + kPointerSize;

 private:





  inline bool IsJSAccessor(Object* obj);

  AccessorPair() = delete; AccessorPair(const AccessorPair&) = delete; void operator=(const AccessorPair&) = delete;
};


class AccessCheckInfo: public Struct {
 public:
  inline Object* named_callback() const; inline void set_named_callback(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* indexed_callback() const; inline void set_indexed_callback(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* callback() const; inline void set_callback(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* data() const; inline void set_data(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static AccessCheckInfo* cast(Object* object); inline static const AccessCheckInfo* cast(const Object* object);


  void AccessCheckInfoPrint(std::ostream& os);
  void AccessCheckInfoVerify();

  static const int kNamedCallbackOffset = HeapObject::kHeaderSize;
  static const int kIndexedCallbackOffset = kNamedCallbackOffset + kPointerSize;
  static const int kCallbackOffset = kIndexedCallbackOffset + kPointerSize;
  static const int kDataOffset = kCallbackOffset + kPointerSize;
  static const int kSize = kDataOffset + kPointerSize;

 private:
  AccessCheckInfo() = delete; AccessCheckInfo(const AccessCheckInfo&) = delete; void operator=(const AccessCheckInfo&) = delete;
};


class InterceptorInfo: public Struct {
 public:
  inline Object* getter() const; inline void set_getter(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* setter() const; inline void set_setter(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* query() const; inline void set_query(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* deleter() const; inline void set_deleter(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* enumerator() const; inline void set_enumerator(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* data() const; inline void set_data(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline bool can_intercept_symbols() const; inline void set_can_intercept_symbols(bool value);
  inline bool all_can_read() const; inline void set_all_can_read(bool value);
  inline bool non_masking() const; inline void set_non_masking(bool value);

  inline int flags() const;
  inline void set_flags(int flags);

  inline static InterceptorInfo* cast(Object* object); inline static const InterceptorInfo* cast(const Object* object);


  void InterceptorInfoPrint(std::ostream& os);
  void InterceptorInfoVerify();

  static const int kGetterOffset = HeapObject::kHeaderSize;
  static const int kSetterOffset = kGetterOffset + kPointerSize;
  static const int kQueryOffset = kSetterOffset + kPointerSize;
  static const int kDeleterOffset = kQueryOffset + kPointerSize;
  static const int kEnumeratorOffset = kDeleterOffset + kPointerSize;
  static const int kDataOffset = kEnumeratorOffset + kPointerSize;
  static const int kFlagsOffset = kDataOffset + kPointerSize;
  static const int kSize = kFlagsOffset + kPointerSize;

  static const int kCanInterceptSymbolsBit = 0;
  static const int kAllCanReadBit = 1;
  static const int kNonMasking = 2;

 private:
  InterceptorInfo() = delete; InterceptorInfo(const InterceptorInfo&) = delete; void operator=(const InterceptorInfo&) = delete;
};


class CallHandlerInfo: public Struct {
 public:
  inline Object* callback() const; inline void set_callback(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* data() const; inline void set_data(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* fast_handler() const; inline void set_fast_handler(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static CallHandlerInfo* cast(Object* object); inline static const CallHandlerInfo* cast(const Object* object);


  void CallHandlerInfoPrint(std::ostream& os);
  void CallHandlerInfoVerify();

  static const int kCallbackOffset = HeapObject::kHeaderSize;
  static const int kDataOffset = kCallbackOffset + kPointerSize;
  static const int kFastHandlerOffset = kDataOffset + kPointerSize;
  static const int kSize = kFastHandlerOffset + kPointerSize;

 private:
  CallHandlerInfo() = delete; CallHandlerInfo(const CallHandlerInfo&) = delete; void operator=(const CallHandlerInfo&) = delete;
};


class TemplateInfo: public Struct {
 public:
  inline Object* tag() const; inline void set_tag(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* serial_number() const; inline void set_serial_number(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline int number_of_properties() const; inline void set_number_of_properties(int value);
  inline Object* property_list() const; inline void set_property_list(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* property_accessors() const; inline void set_property_accessors(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  void TemplateInfoVerify();

  static const int kTagOffset = HeapObject::kHeaderSize;
  static const int kSerialNumberOffset = kTagOffset + kPointerSize;
  static const int kNumberOfProperties = kSerialNumberOffset + kPointerSize;
  static const int kPropertyListOffset = kNumberOfProperties + kPointerSize;
  static const int kPropertyAccessorsOffset =
      kPropertyListOffset + kPointerSize;
  static const int kPropertyIntrinsicsOffset =
      kPropertyAccessorsOffset + kPointerSize;
  static const int kHeaderSize = kPropertyIntrinsicsOffset + kPointerSize;

 private:
  TemplateInfo() = delete; TemplateInfo(const TemplateInfo&) = delete; void operator=(const TemplateInfo&) = delete;
};


class FunctionTemplateInfo: public TemplateInfo {
 public:
  inline Object* call_code() const; inline void set_call_code(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* prototype_template() const; inline void set_prototype_template(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* parent_template() const; inline void set_parent_template(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* named_property_handler() const; inline void set_named_property_handler(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* indexed_property_handler() const; inline void set_indexed_property_handler(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* instance_template() const; inline void set_instance_template(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* class_name() const; inline void set_class_name(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* signature() const; inline void set_signature(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* instance_call_handler() const; inline void set_instance_call_handler(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* access_check_info() const; inline void set_access_check_info(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline int flag() const; inline void set_flag(int value);

  inline int length() const;
  inline void set_length(int value);


  inline bool hidden_prototype() const; inline void set_hidden_prototype(bool value);
  inline bool undetectable() const; inline void set_undetectable(bool value);


  inline bool needs_access_check() const; inline void set_needs_access_check(bool value);
  inline bool read_only_prototype() const; inline void set_read_only_prototype(bool value);
  inline bool remove_prototype() const; inline void set_remove_prototype(bool value);
  inline bool do_not_cache() const; inline void set_do_not_cache(bool value);
  inline bool instantiated() const; inline void set_instantiated(bool value);
  inline bool accept_any_receiver() const; inline void set_accept_any_receiver(bool value);

  inline static FunctionTemplateInfo* cast(Object* object); inline static const FunctionTemplateInfo* cast(const Object* object);


  void FunctionTemplateInfoPrint(std::ostream& os);
  void FunctionTemplateInfoVerify();

  static const int kCallCodeOffset = TemplateInfo::kHeaderSize;
  static const int kPrototypeTemplateOffset =
      kCallCodeOffset + kPointerSize;
  static const int kParentTemplateOffset =
      kPrototypeTemplateOffset + kPointerSize;
  static const int kNamedPropertyHandlerOffset =
      kParentTemplateOffset + kPointerSize;
  static const int kIndexedPropertyHandlerOffset =
      kNamedPropertyHandlerOffset + kPointerSize;
  static const int kInstanceTemplateOffset =
      kIndexedPropertyHandlerOffset + kPointerSize;
  static const int kClassNameOffset = kInstanceTemplateOffset + kPointerSize;
  static const int kSignatureOffset = kClassNameOffset + kPointerSize;
  static const int kInstanceCallHandlerOffset = kSignatureOffset + kPointerSize;
  static const int kAccessCheckInfoOffset =
      kInstanceCallHandlerOffset + kPointerSize;
  static const int kFlagOffset = kAccessCheckInfoOffset + kPointerSize;
  static const int kLengthOffset = kFlagOffset + kPointerSize;
  static const int kSize = kLengthOffset + kPointerSize;


  bool IsTemplateFor(Object* object);
  bool IsTemplateFor(Map* map);



  Object* GetCompatibleReceiver(Isolate* isolate, Object* receiver);

 private:

  static const int kHiddenPrototypeBit = 0;
  static const int kUndetectableBit = 1;
  static const int kNeedsAccessCheckBit = 2;
  static const int kReadOnlyPrototypeBit = 3;
  static const int kRemovePrototypeBit = 4;
  static const int kDoNotCacheBit = 5;
  static const int kInstantiatedBit = 6;
  static const int kAcceptAnyReceiver = 7;

  FunctionTemplateInfo() = delete; FunctionTemplateInfo(const FunctionTemplateInfo&) = delete; void operator=(const FunctionTemplateInfo&) = delete;
};


class ObjectTemplateInfo: public TemplateInfo {
 public:
  inline Object* constructor() const; inline void set_constructor(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
  inline Object* internal_field_count() const; inline void set_internal_field_count(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline static ObjectTemplateInfo* cast(Object* object); inline static const ObjectTemplateInfo* cast(const Object* object);


  void ObjectTemplateInfoPrint(std::ostream& os);
  void ObjectTemplateInfoVerify();

  static const int kConstructorOffset = TemplateInfo::kHeaderSize;
  static const int kInternalFieldCountOffset =
      kConstructorOffset + kPointerSize;
  static const int kSize = kInternalFieldCountOffset + kPointerSize;
};




class DebugInfo: public Struct {
 public:

  inline SharedFunctionInfo* shared() const; inline void set_shared(SharedFunctionInfo* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  inline AbstractCode* abstract_code() const; inline void set_abstract_code(AbstractCode* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);

  inline FixedArray* break_points() const; inline void set_break_points(FixedArray* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  bool HasBreakPoint(int code_offset);

  Object* GetBreakPointInfo(int code_offset);

  static void ClearBreakPoint(Handle<DebugInfo> debug_info, int code_offset,
                              Handle<Object> break_point_object);

  static void SetBreakPoint(Handle<DebugInfo> debug_info, int code_offset,
                            int source_position, int statement_position,
                            Handle<Object> break_point_object);

  Handle<Object> GetBreakPointObjects(int code_offset);

  static Handle<Object> FindBreakPointInfo(Handle<DebugInfo> debug_info,
                                           Handle<Object> break_point_object);

  int GetBreakPointCount();

  static Smi* uninitialized() { return Smi::FromInt(0); }

  inline BytecodeArray* original_bytecode_array();

  inline static DebugInfo* cast(Object* object); inline static const DebugInfo* cast(const Object* object);


  void DebugInfoPrint(std::ostream& os);
  void DebugInfoVerify();

  static const int kSharedFunctionInfoIndex = Struct::kHeaderSize;
  static const int kAbstractCodeIndex = kSharedFunctionInfoIndex + kPointerSize;
  static const int kBreakPointsStateIndex = kAbstractCodeIndex + kPointerSize;
  static const int kSize = kBreakPointsStateIndex + kPointerSize;

  static const int kEstimatedNofBreakPointsInFunction = 16;

 private:
  static const int kNoBreakPointInfo = -1;


  int GetBreakPointInfoIndex(int code_offset);

  DebugInfo() = delete; DebugInfo(const DebugInfo&) = delete; void operator=(const DebugInfo&) = delete;
};





class BreakPointInfo: public Struct {
 public:

  inline int code_offset() const; inline void set_code_offset(int value);

  inline int source_position() const; inline void set_source_position(int value);


  inline int statement_position() const; inline void set_statement_position(int value);

  inline Object* break_point_objects() const; inline void set_break_point_objects(Object* value, WriteBarrierMode mode = UPDATE_WRITE_BARRIER);


  static void ClearBreakPoint(Handle<BreakPointInfo> info,
                              Handle<Object> break_point_object);

  static void SetBreakPoint(Handle<BreakPointInfo> info,
                            Handle<Object> break_point_object);

  static bool HasBreakPointObject(Handle<BreakPointInfo> info,
                                  Handle<Object> break_point_object);

  int GetBreakPointCount();

  inline static BreakPointInfo* cast(Object* object); inline static const BreakPointInfo* cast(const Object* object);


  void BreakPointInfoPrint(std::ostream& os);
  void BreakPointInfoVerify();

  static const int kCodeOffsetIndex = Struct::kHeaderSize;
  static const int kSourcePositionIndex = kCodeOffsetIndex + kPointerSize;
  static const int kStatementPositionIndex =
      kSourcePositionIndex + kPointerSize;
  static const int kBreakPointObjectsIndex =
      kStatementPositionIndex + kPointerSize;
  static const int kSize = kBreakPointObjectsIndex + kPointerSize;

 private:
  BreakPointInfo() = delete; BreakPointInfo(const BreakPointInfo&) = delete; void operator=(const BreakPointInfo&) = delete;
};
class VisitorSynchronization : public AllStatic {
 public:

  enum SyncTag {
    kStringTable, kExternalStringsTable, kStrongRootList, kSmiRootList, kBootstrapper, kTop, kRelocatable, kDebug, kCompilationCache, kHandleScope, kDispatchTable, kBuiltins, kGlobalHandles, kEternalHandles, kThreadManager, kStrongRoots, kExtensions,
    kNumberOfSyncTags
  };


  static const char* const kTags[kNumberOfSyncTags];
  static const char* const kTagNames[kNumberOfSyncTags];
};



class ObjectVisitor : public Embedded {
 public:
  virtual ~ObjectVisitor() {}



  virtual void VisitPointers(Object** start, Object** end) = 0;


  virtual void VisitPointer(Object** p) { VisitPointers(p, p + 1); }


  virtual void VisitNextCodeLink(Object** p) { VisitPointers(p, p + 1); }





  virtual void VisitCodeTarget(RelocInfo* rinfo);


  virtual void VisitCodeEntry(Address entry_address);


  virtual void VisitCell(RelocInfo* rinfo);


  virtual void VisitRuntimeEntry(RelocInfo* rinfo) {}


  virtual void VisitExternalOneByteString(
      v8::String::ExternalOneByteStringResource** resource) {}
  virtual void VisitExternalTwoByteString(
      v8::String::ExternalStringResource** resource) {}


  virtual void VisitDebugTarget(RelocInfo* rinfo);



  virtual void VisitCodeAgeSequence(RelocInfo* rinfo);


  virtual void VisitEmbeddedPointer(RelocInfo* rinfo);


  virtual void VisitExternalReference(RelocInfo* rinfo);


  virtual void VisitExternalReference(Address* p) {}


  virtual void VisitInternalReference(RelocInfo* rinfo) {}


  virtual void VisitEmbedderReference(Object** p, uint16_t class_id) {}




  virtual void Synchronize(VisitorSynchronization::SyncTag tag) {}
};



class BooleanBit : public AllStatic {
 public:
  static inline bool get(int value, int bit_position) {
    return (value & (1 << bit_position)) != 0;
  }

  static inline int set(int value, int bit_position, bool v) {
    if (v) {
      value |= (1 << bit_position);
    } else {
      value &= ~(1 << bit_position);
    }
    return value;
  }
};


}
}


namespace v8 {
namespace internal {

class AllocationInfo;
class AllocationObserver;
class CompactionSpace;
class CompactionSpaceCollection;
class FreeList;
class Isolate;
class MemoryAllocator;
class MemoryChunk;
class NewSpacePage;
class Page;
class PagedSpace;
class SemiSpace;
class SkipList;
class SlotsBuffer;
class SlotSet;
class TypedSlotSet;
class Space;
class MarkBit {
 public:
  typedef uint32_t CellType;

  inline MarkBit(CellType* cell, CellType mask) : cell_(cell), mask_(mask) {}


  bool operator==(const MarkBit& other) {
    return cell_ == other.cell_ && mask_ == other.mask_;
  }


 private:
  inline CellType* cell() { return cell_; }
  inline CellType mask() { return mask_; }

  inline MarkBit Next() {
    CellType new_mask = mask_ << 1;
    if (new_mask == 0) {
      return MarkBit(cell_ + 1, 1);
    } else {
      return MarkBit(cell_, new_mask);
    }
  }

  inline void Set() { *cell_ |= mask_; }
  inline bool Get() { return (*cell_ & mask_) != 0; }
  inline void Clear() { *cell_ &= ~mask_; }

  CellType* cell_;
  CellType mask_;

  friend class Marking;
};



class Bitmap {
 public:
  static const uint32_t kBitsPerCell = 32;
  static const uint32_t kBitsPerCellLog2 = 5;
  static const uint32_t kBitIndexMask = kBitsPerCell - 1;
  static const uint32_t kBytesPerCell = kBitsPerCell / kBitsPerByte;
  static const uint32_t kBytesPerCellLog2 = kBitsPerCellLog2 - kBitsPerByteLog2;

  static const size_t kLength = (1 << kPageSizeBits) >> (kPointerSizeLog2);

  static const size_t kSize =
      (1 << kPageSizeBits) >> (kPointerSizeLog2 + kBitsPerByteLog2);


  static int CellsForLength(int length) {
    return (length + kBitsPerCell - 1) >> kBitsPerCellLog2;
  }

  int CellsCount() { return CellsForLength(kLength); }

  static int SizeFor(int cells_count) {
    return sizeof(MarkBit::CellType) * cells_count;
  }

  inline static uint32_t IndexToCell(uint32_t index) {
    return index >> kBitsPerCellLog2;
  }

  inline static uint32_t IndexInCell(uint32_t index) {
    return index & kBitIndexMask;
  }

  inline static uint32_t CellToIndex(uint32_t index) {
    return index << kBitsPerCellLog2;
  }

  inline static uint32_t CellAlignIndex(uint32_t index) {
    return (index + kBitIndexMask) & ~kBitIndexMask;
  }

  inline MarkBit::CellType* cells() {
    return reinterpret_cast<MarkBit::CellType*>(this);
  }

  inline Address address() { return reinterpret_cast<Address>(this); }

  inline static Bitmap* FromAddress(Address addr) {
    return reinterpret_cast<Bitmap*>(addr);
  }

  inline MarkBit MarkBitFromIndex(uint32_t index) {
    MarkBit::CellType mask = 1u << IndexInCell(index);
    MarkBit::CellType* cell = this->cells() + (index >> kBitsPerCellLog2);
    return MarkBit(cell, mask);
  }

  static inline void Clear(MemoryChunk* chunk);

  static inline void SetAllBits(MemoryChunk* chunk);

  static void PrintWord(uint32_t word, uint32_t himask = 0) {
    for (uint32_t mask = 1; mask != 0; mask <<= 1) {
      if ((mask & himask) != 0) PrintF("[");
      PrintF((mask & word) ? "1" : "0");
      if ((mask & himask) != 0) PrintF("]");
    }
  }

  class CellPrinter {
   public:
    CellPrinter() : seq_start(0), seq_type(0), seq_length(0) {}

    void Print(uint32_t pos, uint32_t cell) {
      if (cell == seq_type) {
        seq_length++;
        return;
      }

      Flush();

      if (IsSeq(cell)) {
        seq_start = pos;
        seq_length = 0;
        seq_type = cell;
        return;
      }

      PrintF("%d: ", pos);
      PrintWord(cell);
      PrintF("\n");
    }

    void Flush() {
      if (seq_length > 0) {
        PrintF("%d: %dx%d\n", seq_start, seq_type == 0 ? 0 : 1,
               seq_length * kBitsPerCell);
        seq_length = 0;
      }
    }

    static bool IsSeq(uint32_t cell) { return cell == 0 || cell == 0xFFFFFFFF; }

   private:
    uint32_t seq_start;
    uint32_t seq_type;
    uint32_t seq_length;
  };

  void Print() {
    CellPrinter printer;
    for (int i = 0; i < CellsCount(); i++) {
      printer.Print(i, cells()[i]);
    }
    printer.Flush();
    PrintF("\n");
  }

  bool IsClean() {
    for (int i = 0; i < CellsCount(); i++) {
      if (cells()[i] != 0) {
        return false;
      }
    }
    return true;
  }



  void ClearRange(uint32_t cell_base_index, uint32_t index) {
    do { if (std::string* _msg = ::v8::base::CheckEQImpl( (IndexInCell(cell_base_index)), (0u), "IndexInCell(cell_base_index)" " " "==" " " "0u")) { V8_Fatal(".././src/heap/spaces.h", 277, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (index), (cell_base_index), "index" " " ">=" " " "cell_base_index")) { V8_Fatal(".././src/heap/spaces.h", 278, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    uint32_t start_cell_index = IndexToCell(cell_base_index);
    uint32_t end_cell_index = IndexToCell(index);
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (end_cell_index), (start_cell_index), "end_cell_index" " " ">=" " " "start_cell_index")) { V8_Fatal(".././src/heap/spaces.h", 281, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);

    for (uint32_t i = start_cell_index; i < end_cell_index; i++) {
      cells()[i] = 0;
    }

    uint32_t clear_mask = ~((1u << IndexInCell(index)) - 1);
    cells()[end_cell_index] &= clear_mask;
  }
};

enum FreeListCategoryType {
  kTiniest,
  kTiny,
  kSmall,
  kMedium,
  kLarge,
  kHuge,

  kFirstCategory = kTiniest,
  kLastCategory = kHuge,
  kNumberOfCategories = kLastCategory + 1,
  kInvalidCategory
};

enum FreeMode { kLinkCategory, kDoNotLinkCategory };


class FreeListCategory {
 public:
  static const int kSize = kIntSize +
                           kIntSize +
                           kPointerSize +
                           kPointerSize +
                           kPointerSize;

  FreeListCategory()
      : type_(kInvalidCategory),
        available_(0),
        top_(nullptr),
        prev_(nullptr),
        next_(nullptr) {}

  void Initialize(FreeListCategoryType type) {
    type_ = type;
    available_ = 0;
    top_ = nullptr;
    prev_ = nullptr;
    next_ = nullptr;
  }

  void Invalidate();

  void Reset();

  void ResetStats() { Reset(); }

  void RepairFreeList(Heap* heap);



  void Relink();

  bool Free(FreeSpace* node, int size_in_bytes, FreeMode mode);



  FreeSpace* PickNodeFromList(int* node_size);




  FreeSpace* TryPickNodeFromList(int minimum_size, int* node_size);



  FreeSpace* SearchForNodeInList(int minimum_size, int* node_size);

  inline FreeList* owner();
  inline bool is_linked();
  bool is_empty() { return top() == nullptr; }
  int available() const { return available_; }


  intptr_t SumFreeList();
  int FreeListLength();


 private:


  static const int kVeryLongFreeList = 500;

  inline Page* page();

  FreeSpace* top() { return top_; }
  void set_top(FreeSpace* top) { top_ = top; }
  FreeListCategory* prev() { return prev_; }
  void set_prev(FreeListCategory* prev) { prev_ = prev; }
  FreeListCategory* next() { return next_; }
  void set_next(FreeListCategory* next) { next_ = next; }


  FreeListCategoryType type_;



  int available_;


  FreeSpace* top_;

  FreeListCategory* prev_;
  FreeListCategory* next_;

  friend class FreeList;
  friend class PagedSpace;
};





class MemoryChunk {
 public:
  enum MemoryChunkFlags {
    IS_EXECUTABLE,
    POINTERS_TO_HERE_ARE_INTERESTING,
    POINTERS_FROM_HERE_ARE_INTERESTING,
    IN_FROM_SPACE,
    IN_TO_SPACE,
    NEW_SPACE_BELOW_AGE_MARK,
    EVACUATION_CANDIDATE,
    NEVER_EVACUATE,





    HAS_PROGRESS_BAR,




    BLACK_PAGE,





    FORCE_EVACUATION_CANDIDATE_FOR_TESTING,


    NEVER_ALLOCATE_ON_PAGE,



    PRE_FREED,



    COMPACTION_WAS_ABORTED,


    NUM_MEMORY_CHUNK_FLAGS
  };






  enum ConcurrentSweepingState {
    kSweepingDone,
    kSweepingPending,
    kSweepingInProgress,
  };




  static const int kWriteBarrierCounterGranularity = 500;

  static const int kPointersToHereAreInterestingMask =
      1 << POINTERS_TO_HERE_ARE_INTERESTING;

  static const int kPointersFromHereAreInterestingMask =
      1 << POINTERS_FROM_HERE_ARE_INTERESTING;

  static const int kEvacuationCandidateMask = 1 << EVACUATION_CANDIDATE;

  static const int kSkipEvacuationSlotsRecordingMask =
      (1 << EVACUATION_CANDIDATE) | (1 << IN_FROM_SPACE) | (1 << IN_TO_SPACE);

  static const intptr_t kAlignment =
      (static_cast<uintptr_t>(1) << kPageSizeBits);

  static const intptr_t kAlignmentMask = kAlignment - 1;

  static const intptr_t kSizeOffset = 0;

  static const intptr_t kFlagsOffset = kSizeOffset + kPointerSize;

  static const intptr_t kLiveBytesOffset =
      kSizeOffset + kPointerSize
      + kIntptrSize
      + kPointerSize
      + kPointerSize
      + 2 * kPointerSize
      + kPointerSize
      + kPointerSize
      + kIntSize;

  static const size_t kOldToNewSlotsOffset =
      kLiveBytesOffset + kIntSize;

  static const size_t kWriteBarrierCounterOffset =
      kOldToNewSlotsOffset + kPointerSize
      + kPointerSize
      + kPointerSize
      + kPointerSize;

  static const size_t kMinHeaderSize =
      kWriteBarrierCounterOffset +
      kIntptrSize
      + kPointerSize
      + kPointerSize
      + kPointerSize
      + 2 * kPointerSize
      + kPointerSize
      + kPointerSize

      + FreeListCategory::kSize * kNumberOfCategories;




  static const size_t kHeaderSize = kMinHeaderSize;

  static const int kBodyOffset =
      (((kHeaderSize + Bitmap::kSize) + kCodeAlignmentMask) & ~kCodeAlignmentMask);




  static const int kObjectStartAlignment = 32 * kPointerSize;
  static const int kObjectStartOffset =
      kBodyOffset - 1 +
      (kObjectStartAlignment - (kBodyOffset - 1) % kObjectStartAlignment);


  static const int kPageSize = 1 << kPageSizeBits;
  static const intptr_t kPageAlignmentMask = (1 << kPageSizeBits) - 1;

  static const int kAllocatableMemory = kPageSize - kObjectStartOffset;

  static inline void IncrementLiveBytesFromMutator(HeapObject* object, int by);
  static inline void IncrementLiveBytesFromGC(HeapObject* object, int by);


  static MemoryChunk* FromAddress(Address a) {
    return reinterpret_cast<MemoryChunk*>(OffsetFrom(a) & ~kAlignmentMask);
  }

  static inline MemoryChunk* FromAnyPointerAddress(Heap* heap, Address addr);

  static inline void UpdateHighWaterMark(Address mark) {
    if (mark == nullptr) return;



    MemoryChunk* chunk = MemoryChunk::FromAddress(mark - 1);
    intptr_t new_mark = static_cast<intptr_t>(mark - chunk->address());
    intptr_t old_mark = 0;
    do {
      old_mark = chunk->high_water_mark_.Value();
    } while ((new_mark > old_mark) &&
             !chunk->high_water_mark_.TrySetValue(old_mark, new_mark));
  }

  Address address() { return reinterpret_cast<Address>(this); }

  bool is_valid() { return address() != 0; }

  base::Mutex* mutex() { return mutex_; }

  bool Contains(Address addr) {
    return addr >= area_start() && addr < area_end();
  }



  bool ContainsLimit(Address addr) {
    return addr >= area_start() && addr <= area_end();
  }

  AtomicValue<ConcurrentSweepingState>& concurrent_sweeping_state() {
    return concurrent_sweeping_;
  }


  inline void ResetLiveBytes();
  inline void IncrementLiveBytes(int by);

  int LiveBytes() {
    do { if (std::string* _msg = ::v8::base::CheckLEImpl( (static_cast<unsigned>(live_byte_count_)), (size_), "static_cast<unsigned>(live_byte_count_)" " " "<=" " " "size_")) { V8_Fatal(".././src/heap/spaces.h", 586, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    do { if ((!(!IsFlagSet(BLACK_PAGE) || live_byte_count_ == 0))) { V8_Fatal(".././src/heap/spaces.h", 587, "Check failed: %s.", "!IsFlagSet(BLACK_PAGE) || live_byte_count_ == 0"); } } while (0);
    return live_byte_count_;
  }

  void SetLiveBytes(int live_bytes) {
    if (IsFlagSet(BLACK_PAGE)) return;
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (live_bytes), (0), "live_bytes" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 593, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    do { if (std::string* _msg = ::v8::base::CheckLEImpl( (static_cast<size_t>(live_bytes)), (size_), "static_cast<size_t>(live_bytes)" " " "<=" " " "size_")) { V8_Fatal(".././src/heap/spaces.h", 594, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    live_byte_count_ = live_bytes;
  }

  int write_barrier_counter() {
    return static_cast<int>(write_barrier_counter_);
  }

  void set_write_barrier_counter(int counter) {
    write_barrier_counter_ = counter;
  }

  size_t size() const { return size_; }

  inline Heap* heap() const { return heap_; }

  inline SkipList* skip_list() { return skip_list_; }

  inline void set_skip_list(SkipList* skip_list) { skip_list_ = skip_list; }

  inline SlotSet* old_to_new_slots() { return old_to_new_slots_; }
  inline SlotSet* old_to_old_slots() { return old_to_old_slots_; }
  inline TypedSlotSet* typed_old_to_old_slots() {
    return typed_old_to_old_slots_;
  }

  void AllocateOldToNewSlots();
  void ReleaseOldToNewSlots();
  void AllocateOldToOldSlots();
  void ReleaseOldToOldSlots();
  void AllocateTypedOldToOldSlots();
  void ReleaseTypedOldToOldSlots();

  Address area_start() { return area_start_; }
  Address area_end() { return area_end_; }
  int area_size() { return static_cast<int>(area_end() - area_start()); }

  bool CommitArea(size_t requested);


  size_t CommittedPhysicalMemory() { return high_water_mark_.Value(); }

  int progress_bar() {
    do { if ((!(IsFlagSet(HAS_PROGRESS_BAR)))) { V8_Fatal(".././src/heap/spaces.h", 637, "Check failed: %s.", "IsFlagSet(HAS_PROGRESS_BAR)"); } } while (0);
    return progress_bar_;
  }

  void set_progress_bar(int progress_bar) {
    do { if ((!(IsFlagSet(HAS_PROGRESS_BAR)))) { V8_Fatal(".././src/heap/spaces.h", 642, "Check failed: %s.", "IsFlagSet(HAS_PROGRESS_BAR)"); } } while (0);
    progress_bar_ = progress_bar;
  }

  void ResetProgressBar() {
    if (IsFlagSet(MemoryChunk::HAS_PROGRESS_BAR)) {
      set_progress_bar(0);
      ClearFlag(MemoryChunk::HAS_PROGRESS_BAR);
    }
  }

  inline Bitmap* markbits() {
    return Bitmap::FromAddress(address() + kHeaderSize);
  }

  inline uint32_t AddressToMarkbitIndex(Address addr) {
    return static_cast<uint32_t>(addr - this->address()) >> kPointerSizeLog2;
  }

  inline Address MarkbitIndexToAddress(uint32_t index) {
    return this->address() + (index << kPointerSizeLog2);
  }

  void PrintMarkbits() { markbits()->Print(); }

  void SetFlag(int flag) { flags_ |= static_cast<uintptr_t>(1) << flag; }

  void ClearFlag(int flag) { flags_ &= ~(static_cast<uintptr_t>(1) << flag); }

  bool IsFlagSet(int flag) {
    return (flags_ & (static_cast<uintptr_t>(1) << flag)) != 0;
  }



  void SetFlags(intptr_t flags, intptr_t mask) {
    flags_ = (flags_ & ~mask) | (flags & mask);
  }


  intptr_t GetFlags() { return flags_; }

  bool NeverEvacuate() { return IsFlagSet(NEVER_EVACUATE); }

  void MarkNeverEvacuate() { SetFlag(NEVER_EVACUATE); }

  bool IsEvacuationCandidate() {
    do { if ((!(!(IsFlagSet(NEVER_EVACUATE) && IsFlagSet(EVACUATION_CANDIDATE))))) { V8_Fatal(".././src/heap/spaces.h", 689, "Check failed: %s.", "!(IsFlagSet(NEVER_EVACUATE) && IsFlagSet(EVACUATION_CANDIDATE))"); } } while (0);
    return IsFlagSet(EVACUATION_CANDIDATE);
  }

  bool CanAllocate() {
    return !IsEvacuationCandidate() && !IsFlagSet(NEVER_ALLOCATE_ON_PAGE);
  }

  bool ShouldSkipEvacuationSlotRecording() {
    return (flags_ & kSkipEvacuationSlotsRecordingMask) != 0;
  }

  Executability executable() {
    return IsFlagSet(IS_EXECUTABLE) ? EXECUTABLE : NOT_EXECUTABLE;
  }

  bool InNewSpace() {
    return (flags_ & ((1 << IN_FROM_SPACE) | (1 << IN_TO_SPACE))) != 0;
  }

  bool InToSpace() { return IsFlagSet(IN_TO_SPACE); }

  bool InFromSpace() { return IsFlagSet(IN_FROM_SPACE); }

  MemoryChunk* next_chunk() { return next_chunk_.Value(); }

  MemoryChunk* prev_chunk() { return prev_chunk_.Value(); }

  void set_next_chunk(MemoryChunk* next) { next_chunk_.SetValue(next); }

  void set_prev_chunk(MemoryChunk* prev) { prev_chunk_.SetValue(prev); }

  Space* owner() const {
    if ((reinterpret_cast<intptr_t>(owner_) & kPageHeaderTagMask) ==
        kPageHeaderTag) {
      return reinterpret_cast<Space*>(reinterpret_cast<intptr_t>(owner_) -
                                      kPageHeaderTag);
    } else {
      return nullptr;
    }
  }

  void set_owner(Space* space) {
    do { if ((!((reinterpret_cast<intptr_t>(space) & kPageHeaderTagMask) == 0))) { V8_Fatal(".././src/heap/spaces.h", 732, "Check failed: %s.", "(reinterpret_cast<intptr_t>(space) & kPageHeaderTagMask) == 0"); } } while (0);
    owner_ = reinterpret_cast<Address>(space) + kPageHeaderTag;
    do { if ((!((reinterpret_cast<intptr_t>(owner_) & kPageHeaderTagMask) == kPageHeaderTag))) { V8_Fatal(".././src/heap/spaces.h", 735, "Check failed: %s.", "(reinterpret_cast<intptr_t>(owner_) & kPageHeaderTagMask) == kPageHeaderTag"); } } while (0);

  }

  bool HasPageHeader() { return owner() != nullptr; }

  void InsertAfter(MemoryChunk* other);
  void Unlink();

 protected:
  static MemoryChunk* Initialize(Heap* heap, Address base, size_t size,
                                 Address area_start, Address area_end,
                                 Executability executable, Space* owner,
                                 base::VirtualMemory* reservation);


  void ReleaseAllocatedMemory();

  base::VirtualMemory* reserved_memory() { return &reservation_; }

  size_t size_;
  intptr_t flags_;


  Address area_start_;
  Address area_end_;


  base::VirtualMemory reservation_;




  Address owner_;

  Heap* heap_;



  int progress_bar_;


  int live_byte_count_;




  SlotSet* old_to_new_slots_;
  SlotSet* old_to_old_slots_;
  TypedSlotSet* typed_old_to_old_slots_;

  SkipList* skip_list_;

  intptr_t write_barrier_counter_;



  AtomicValue<intptr_t> high_water_mark_;

  base::Mutex* mutex_;

  AtomicValue<ConcurrentSweepingState> concurrent_sweeping_;


  AtomicNumber<intptr_t> available_in_free_list_;
  AtomicNumber<intptr_t> wasted_memory_;


  AtomicValue<MemoryChunk*> next_chunk_;

  AtomicValue<MemoryChunk*> prev_chunk_;

  FreeListCategory categories_[kNumberOfCategories];

 private:
  void InitializeReservedMemory() { reservation_.Reset(); }

  friend class MemoryAllocator;
  friend class MemoryChunkValidator;
};







class Page : public MemoryChunk {
 public:




  inline static Page* FromAddress(Address a) {
    return reinterpret_cast<Page*>(OffsetFrom(a) & ~kPageAlignmentMask);
  }


  inline static Page* FromAnyPointerAddress(Heap* heap, Address addr);





  inline static Page* FromAllocationTop(Address top) {
    Page* p = FromAddress(top - kPointerSize);
    return p;
  }


  inline Page* next_page() {
    do { if ((!(next_chunk()->owner() == owner()))) { V8_Fatal(".././src/heap/spaces.h", 845, "Check failed: %s.", "next_chunk()->owner() == owner()"); } } while (0);
    return static_cast<Page*>(next_chunk());
  }
  inline Page* prev_page() {
    do { if ((!(prev_chunk()->owner() == owner()))) { V8_Fatal(".././src/heap/spaces.h", 849, "Check failed: %s.", "prev_chunk()->owner() == owner()"); } } while (0);
    return static_cast<Page*>(prev_chunk());
  }
  inline void set_next_page(Page* page);
  inline void set_prev_page(Page* page);


  static bool IsAlignedToPageSize(Address a) {
    return 0 == (OffsetFrom(a) & kPageAlignmentMask);
  }


  inline int Offset(Address a) {
    int offset = static_cast<int>(a - address());
    return offset;
  }


  Address OffsetToAddress(int offset) {
    do { if ((!((Page::kObjectStartOffset <= offset) && (offset <= Page::kPageSize)))) { V8_Fatal(".././src/heap/spaces.h", 868, "Check failed: %s.", "(Page::kObjectStartOffset <= offset) && (offset <= Page::kPageSize)"); } } while (0);
    return address() + offset;
  }
  static const int kMaxRegularHeapObjectSize = 600 * KB;

  inline void ClearGCFields();

  static inline Page* Initialize(Heap* heap, MemoryChunk* chunk,
                                 Executability executable, PagedSpace* owner);

  void InitializeAsAnchor(PagedSpace* owner);




  void WaitUntilSweepingCompleted() {
    mutex_->Lock();
    mutex_->Unlock();
    do { if ((!(SweepingDone()))) { V8_Fatal(".././src/heap/spaces.h", 896, "Check failed: %s.", "SweepingDone()"); } } while (0);
  }

  bool SweepingDone() {
    return concurrent_sweeping_state().Value() == kSweepingDone;
  }

  void ResetFreeListStatistics();

  int LiveBytesFromFreeList() {
    return static_cast<int>(area_size() - wasted_memory() -
                            available_in_free_list());
  }

  template <typename Callback>
  inline void ForAllFreeListCategories(Callback callback) {
    for (int i = kFirstCategory; i < kNumberOfCategories; i++) {
      callback(&categories_[i]);
    }
  }

  FreeListCategory* free_list_category(FreeListCategoryType type) {
    return &categories_[type];
  }






  intptr_t wasted_memory() { return wasted_memory_.Value(); } void set_wasted_memory(intptr_t wasted_memory) { wasted_memory_.SetValue(wasted_memory); } void add_wasted_memory(intptr_t wasted_memory) { wasted_memory_.Increment(wasted_memory); }
  intptr_t available_in_free_list() { return available_in_free_list_.Value(); } void set_available_in_free_list(intptr_t available_in_free_list) { available_in_free_list_.SetValue(available_in_free_list); } void add_available_in_free_list(intptr_t available_in_free_list) { available_in_free_list_.Increment(available_in_free_list); }




  void Print();


  inline void MarkNeverAllocateForTesting();
  inline void MarkEvacuationCandidate();
  inline void ClearEvacuationCandidate();

 private:
  inline void InitializeFreeListCategories();

  friend class MemoryAllocator;
};


class LargePage : public MemoryChunk {
 public:
  HeapObject* GetObject() { return HeapObject::FromAddress(area_start()); }

  inline LargePage* next_page() {
    return static_cast<LargePage*>(next_chunk());
  }

  inline void set_next_page(LargePage* page) { set_next_chunk(page); }





  static const int kMaxCodePageSize = 512 * MB;

 private:
  static inline LargePage* Initialize(Heap* heap, MemoryChunk* chunk);

  friend class MemoryAllocator;
};




class Space : public Malloced {
 public:
  Space(Heap* heap, AllocationSpace id, Executability executable)
      : allocation_observers_(new List<AllocationObserver*>()),
        allocation_observers_paused_(false),
        heap_(heap),
        id_(id),
        executable_(executable),
        committed_(0),
        max_committed_(0) {}

  virtual ~Space() {}

  Heap* heap() const { return heap_; }


  Executability executable() { return executable_; }


  AllocationSpace identity() { return id_; }

  virtual void AddAllocationObserver(AllocationObserver* observer) {
    allocation_observers_->Add(observer);
  }

  virtual void RemoveAllocationObserver(AllocationObserver* observer) {
    bool removed = allocation_observers_->RemoveElement(observer);
    USE(removed);
    do { if ((!(removed))) { V8_Fatal(".././src/heap/spaces.h", 999, "Check failed: %s.", "removed"); } } while (0);
  }

  virtual void PauseAllocationObservers() {
    allocation_observers_paused_ = true;
  }

  virtual void ResumeAllocationObservers() {
    allocation_observers_paused_ = false;
  }

  void AllocationStep(Address soon_object, int size);



  virtual intptr_t CommittedMemory() { return committed_; }

  virtual intptr_t MaximumCommittedMemory() { return max_committed_; }


  virtual intptr_t Size() = 0;



  virtual intptr_t SizeOfObjects() { return Size(); }


  virtual size_t CommittedPhysicalMemory() = 0;


  virtual intptr_t Available() = 0;

  virtual int RoundSizeDownToObjectAlignment(int size) {
    if (id_ == CODE_SPACE) {
      return RoundDown(size, kCodeAlignment);
    } else {
      return RoundDown(size, kPointerSize);
    }
  }


  virtual void Print() = 0;


 protected:
  void AccountCommitted(intptr_t bytes) {
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (bytes), (0), "bytes" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 1045, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    committed_ += bytes;
    if (committed_ > max_committed_) {
      max_committed_ = committed_;
    }
  }

  void AccountUncommitted(intptr_t bytes) {
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (bytes), (0), "bytes" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 1053, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    committed_ -= bytes;
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (committed_), (0), "committed_" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 1055, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
  }

  v8::base::SmartPointer<List<AllocationObserver*>> allocation_observers_;
  bool allocation_observers_paused_;

 private:
  Heap* heap_;
  AllocationSpace id_;
  Executability executable_;


  intptr_t committed_;
  intptr_t max_committed_;
};


class MemoryChunkValidator {

  static_assert(MemoryChunk::kSizeOffset == __builtin_offsetof(MemoryChunk,size_), "MemoryChunk::kSizeOffset == offsetof(MemoryChunk, size_)");
  static_assert(MemoryChunk::kLiveBytesOffset == __builtin_offsetof(MemoryChunk,live_byte_count_), "MemoryChunk::kLiveBytesOffset == offsetof(MemoryChunk, live_byte_count_)");

  static_assert(MemoryChunk::kOldToNewSlotsOffset == __builtin_offsetof(MemoryChunk,old_to_new_slots_), "MemoryChunk::kOldToNewSlotsOffset == offsetof(MemoryChunk, old_to_new_slots_)");

  static_assert(MemoryChunk::kWriteBarrierCounterOffset == __builtin_offsetof(MemoryChunk,write_barrier_counter_), "MemoryChunk::kWriteBarrierCounterOffset == offsetof(MemoryChunk, write_barrier_counter_)");



  static_assert(sizeof(MemoryChunk) <= MemoryChunk::kHeaderSize, "sizeof(MemoryChunk) <= MemoryChunk::kHeaderSize");
  static_assert(sizeof(LargePage) <= MemoryChunk::kHeaderSize, "sizeof(LargePage) <= MemoryChunk::kHeaderSize");
  static_assert(sizeof(Page) <= MemoryChunk::kHeaderSize, "sizeof(Page) <= MemoryChunk::kHeaderSize");
};
class CodeRange {
 public:
  explicit CodeRange(Isolate* isolate);
  ~CodeRange() { TearDown(); }




  bool SetUp(size_t requested_size);

  bool valid() { return code_range_ != 0; }
  Address start() {
    do { if ((!(valid()))) { V8_Fatal(".././src/heap/spaces.h", 1108, "Check failed: %s.", "valid()"); } } while (0);
    return static_cast<Address>(code_range_->address());
  }
  size_t size() {
    do { if ((!(valid()))) { V8_Fatal(".././src/heap/spaces.h", 1112, "Check failed: %s.", "valid()"); } } while (0);
    return code_range_->size();
  }
  bool contains(Address address) {
    if (!valid()) return false;
    Address start = static_cast<Address>(code_range_->address());
    return start <= address && address < start + code_range_->size();
  }




  __attribute__((warn_unused_result)) Address AllocateRawMemory(const size_t requested_size,
                                            const size_t commit_size,
                                            size_t* allocated);
  bool CommitRawMemory(Address start, size_t length);
  bool UncommitRawMemory(Address start, size_t length);
  void FreeRawMemory(Address buf, size_t length);

 private:


  void TearDown();

  Isolate* isolate_;


  base::VirtualMemory* code_range_;

  class FreeBlock {
   public:
    FreeBlock() : start(0), size(0) {}
    FreeBlock(Address start_arg, size_t size_arg)
        : start(start_arg), size(size_arg) {
      do { if ((!(IsAddressAligned(start, MemoryChunk::kAlignment)))) { V8_Fatal(".././src/heap/spaces.h", 1146, "Check failed: %s.", "IsAddressAligned(start, MemoryChunk::kAlignment)"); } } while (0);
      do { if ((!(size >= static_cast<size_t>(Page::kPageSize)))) { V8_Fatal(".././src/heap/spaces.h", 1147, "Check failed: %s.", "size >= static_cast<size_t>(Page::kPageSize)"); } } while (0);
    }
    FreeBlock(void* start_arg, size_t size_arg)
        : start(static_cast<Address>(start_arg)), size(size_arg) {
      do { if ((!(IsAddressAligned(start, MemoryChunk::kAlignment)))) { V8_Fatal(".././src/heap/spaces.h", 1151, "Check failed: %s.", "IsAddressAligned(start, MemoryChunk::kAlignment)"); } } while (0);
      do { if ((!(size >= static_cast<size_t>(Page::kPageSize)))) { V8_Fatal(".././src/heap/spaces.h", 1152, "Check failed: %s.", "size >= static_cast<size_t>(Page::kPageSize)"); } } while (0);
    }

    Address start;
    size_t size;
  };



  base::Mutex code_range_mutex_;




  List<FreeBlock> free_list_;



  List<FreeBlock> allocation_list_;
  int current_allocation_block_index_;





  bool GetNextAllocationBlock(size_t requested);

  static int CompareFreeBlockAddress(const FreeBlock* left,
                                     const FreeBlock* right);
  bool ReserveBlock(const size_t requested_size, FreeBlock* block);
  void ReleaseBlock(const FreeBlock* block);

  CodeRange(const CodeRange&) = delete; void operator=(const CodeRange&) = delete;
};


class SkipList {
 public:
  SkipList() { Clear(); }

  void Clear() {
    for (int idx = 0; idx < kSize; idx++) {
      starts_[idx] = reinterpret_cast<Address>(-1);
    }
  }

  Address StartFor(Address addr) { return starts_[RegionNumber(addr)]; }

  void AddObject(Address addr, int size) {
    int start_region = RegionNumber(addr);
    int end_region = RegionNumber(addr + size - kPointerSize);
    for (int idx = start_region; idx <= end_region; idx++) {
      if (starts_[idx] > addr) {
        starts_[idx] = addr;
      } else {



        do { if (std::string* _msg = ::v8::base::CheckEQImpl( (start_region), (idx), "start_region" " " "==" " " "idx")) { V8_Fatal(".././src/heap/spaces.h", 1210, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
      }
    }
  }

  static inline int RegionNumber(Address addr) {
    return (OffsetFrom(addr) & Page::kPageAlignmentMask) >> kRegionSizeLog2;
  }

  static void Update(Address addr, int size) {
    Page* page = Page::FromAddress(addr);
    SkipList* list = page->skip_list();
    if (list == 0) {
      list = new SkipList();
      page->set_skip_list(list);
    }

    list->AddObject(addr, size);
  }

 private:
  static const int kRegionSizeLog2 = 13;
  static const int kRegionSize = 1 << kRegionSizeLog2;
  static const int kSize = Page::kPageSize / kRegionSize;

  static_assert(Page::kPageSize % kRegionSize == 0, "Page::kPageSize % kRegionSize == 0");

  Address starts_[kSize];
};
class MemoryAllocator {
 public:
  enum AllocationMode {
    kRegular,
    kPooled,
  };

  explicit MemoryAllocator(Isolate* isolate);



  bool SetUp(intptr_t max_capacity, intptr_t capacity_executable);

  void TearDown();




  template <typename PageType, MemoryAllocator::AllocationMode mode = kRegular,
            typename SpaceType>
  PageType* AllocatePage(intptr_t size, SpaceType* owner,
                         Executability executable);

  LargePage* AllocateLargePage(intptr_t object_size, Space* owner,
                               Executability executable);



  void PreFreeMemory(MemoryChunk* chunk);


  void PerformFreeMemory(MemoryChunk* chunk);



  template <MemoryAllocator::AllocationMode mode = kRegular>
  void Free(MemoryChunk* chunk);


  intptr_t Size() { return size_.Value(); }


  intptr_t SizeExecutable() { return size_executable_.Value(); }


  intptr_t Available() {
    intptr_t size = Size();
    return capacity_ < size ? 0 : capacity_ - size;
  }


  intptr_t AvailableExecutable() {
    intptr_t executable_size = SizeExecutable();
    if (capacity_executable_ < executable_size) return 0;
    return capacity_executable_ - executable_size;
  }


  intptr_t MaxAvailable() {
    return (Available() / Page::kPageSize) * Page::kAllocatableMemory;
  }



  inline bool IsOutsideAllocatedSpace(const void* address) {
    return address < lowest_ever_allocated_.Value() ||
           address >= highest_ever_allocated_.Value();
  }



  void ReportStatistics();





  MemoryChunk* AllocateChunk(intptr_t reserve_area_size,
                             intptr_t commit_area_size,
                             Executability executable, Space* space);

  Address ReserveAlignedMemory(size_t requested, size_t alignment,
                               base::VirtualMemory* controller);
  Address AllocateAlignedMemory(size_t reserve_size, size_t commit_size,
                                size_t alignment, Executability executable,
                                base::VirtualMemory* controller);

  bool CommitMemory(Address addr, size_t size, Executability executable);

  void FreeMemory(base::VirtualMemory* reservation, Executability executable);
  void FreeMemory(Address addr, size_t size, Executability executable);





  bool CommitBlock(Address start, size_t size, Executability executable);





  bool UncommitBlock(Address start, size_t size);



  void ZapBlock(Address start, size_t size);

  void PerformAllocationCallback(ObjectSpace space, AllocationAction action,
                                 size_t size);

  void AddMemoryAllocationCallback(MemoryAllocationCallback callback,
                                   ObjectSpace space, AllocationAction action);

  void RemoveMemoryAllocationCallback(MemoryAllocationCallback callback);

  bool MemoryAllocationCallbackRegistered(MemoryAllocationCallback callback);

  static int CodePageGuardStartOffset();

  static int CodePageGuardSize();

  static int CodePageAreaStartOffset();

  static int CodePageAreaEndOffset();

  static int CodePageAreaSize() {
    return CodePageAreaEndOffset() - CodePageAreaStartOffset();
  }

  static int PageAreaSize(AllocationSpace space) {
    do { if (std::string* _msg = ::v8::base::CheckNEImpl( (LO_SPACE), (space), "LO_SPACE" " " "!=" " " "space")) { V8_Fatal(".././src/heap/spaces.h", 1379, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    return (space == CODE_SPACE) ? CodePageAreaSize()
                                 : Page::kAllocatableMemory;
  }

  __attribute__((warn_unused_result)) bool CommitExecutableMemory(base::VirtualMemory* vm,
                                              Address start, size_t commit_size,
                                              size_t reserved_size);

 private:


  template <typename SpaceType>
  MemoryChunk* AllocatePagePooled(SpaceType* owner);


  void FreePooled(MemoryChunk* chunk);

  Isolate* isolate_;


  intptr_t capacity_;

  intptr_t capacity_executable_;


  AtomicNumber<intptr_t> size_;

  AtomicNumber<intptr_t> size_executable_;






  AtomicValue<void*> lowest_ever_allocated_;
  AtomicValue<void*> highest_ever_allocated_;

  struct MemoryAllocationCallbackRegistration {
    MemoryAllocationCallbackRegistration(MemoryAllocationCallback callback,
                                         ObjectSpace space,
                                         AllocationAction action)
        : callback(callback), space(space), action(action) {}
    MemoryAllocationCallback callback;
    ObjectSpace space;
    AllocationAction action;
  };


  List<MemoryAllocationCallbackRegistration> memory_allocation_callbacks_;





  Page* InitializePagesInChunk(int chunk_id, int pages_in_chunk,
                               PagedSpace* owner);

  void UpdateAllocatedSpaceLimits(void* low, void* high) {



    void* ptr = nullptr;
    do {
      ptr = lowest_ever_allocated_.Value();
    } while ((low < ptr) && !lowest_ever_allocated_.TrySetValue(ptr, low));
    do {
      ptr = highest_ever_allocated_.Value();
    } while ((high > ptr) && !highest_ever_allocated_.TrySetValue(ptr, high));
  }

  List<MemoryChunk*> chunk_pool_;

  MemoryAllocator() = delete; MemoryAllocator(const MemoryAllocator&) = delete; void operator=(const MemoryAllocator&) = delete;
};
class ObjectIterator : public Malloced {
 public:
  virtual ~ObjectIterator() {}

  virtual HeapObject* next_object() = 0;
};
class HeapObjectIterator : public ObjectIterator {
 public:

  explicit HeapObjectIterator(PagedSpace* space);
  explicit HeapObjectIterator(Page* page);




  inline HeapObject* Next();
  inline HeapObject* next_object() override;

 private:
  enum PageMode { kOnePageOnly, kAllPagesInSpace };

  Address cur_addr_;
  Address cur_end_;
  PagedSpace* space_;
  PageMode page_mode_;


  inline HeapObject* FromCurrentPage();



  bool AdvanceToNextPage();


  inline void Initialize(PagedSpace* owner, Address start, Address end,
                         PageMode mode);
};





class PageIterator : public Embedded {
 public:
  explicit inline PageIterator(PagedSpace* space);

  inline bool has_next();
  inline Page* next();

 private:
  PagedSpace* space_;
  Page* prev_page_;


  Page* next_page_;
};
class AllocationInfo {
 public:
  AllocationInfo() : top_(nullptr), limit_(nullptr) {}
  AllocationInfo(Address top, Address limit) : top_(top), limit_(limit) {}

  void Reset(Address top, Address limit) {
    set_top(top);
    set_limit(limit);
  }

  inline void set_top(Address top) {
    do { if ((!(!v8::internal::FLAG_enable_slow_asserts || (top == 0 || (reinterpret_cast<intptr_t>(top) & kHeapObjectTagMask) == 0)))) { V8_Fatal(".././src/heap/spaces.h", 1551, "Check failed: %s.", "!v8::internal::FLAG_enable_slow_asserts || (top == 0 || (reinterpret_cast<intptr_t>(top) & kHeapObjectTagMask) == 0)"); } } while (0);

    top_ = top;
  }

  inline Address top() const {
    do { if ((!(!v8::internal::FLAG_enable_slow_asserts || (top_ == 0 || (reinterpret_cast<intptr_t>(top_) & kHeapObjectTagMask) == 0)))) { V8_Fatal(".././src/heap/spaces.h", 1557, "Check failed: %s.", "!v8::internal::FLAG_enable_slow_asserts || (top_ == 0 || (reinterpret_cast<intptr_t>(top_) & kHeapObjectTagMask) == 0)"); } } while (0);

    return top_;
  }

  Address* top_address() { return &top_; }

  inline void set_limit(Address limit) {
    limit_ = limit;
  }

  inline Address limit() const {
    return limit_;
  }

  Address* limit_address() { return &limit_; }


  bool VerifyPagedAllocation() {
    return (Page::FromAllocationTop(top_) == Page::FromAllocationTop(limit_)) &&
           (top_ <= limit_);
  }


 private:

  Address top_;

  Address limit_;
};
class AllocationStats : public Embedded {
 public:
  AllocationStats() { Clear(); }


  void Clear() {
    capacity_ = 0;
    max_capacity_ = 0;
    size_ = 0;
  }

  void ClearSize() { size_ = capacity_; }


  intptr_t Capacity() { return capacity_; }
  intptr_t MaxCapacity() { return max_capacity_; }
  intptr_t Size() {
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (size_), (0), "size_" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 1611, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    return size_;
  }




  void ExpandSpace(int size_in_bytes) {
    capacity_ += size_in_bytes;
    size_ += size_in_bytes;
    if (capacity_ > max_capacity_) {
      max_capacity_ = capacity_;
    }
    do { if ((!(size_ >= 0))) { V8_Fatal(".././src/heap/spaces.h", 1624, "Check failed: %s.", "size_ >= 0"); } } while (0);
  }




  void ShrinkSpace(int size_in_bytes) {
    capacity_ -= size_in_bytes;
    size_ -= size_in_bytes;
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (size_), (0), "size_" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 1633, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
  }


  void AllocateBytes(intptr_t size_in_bytes) {
    size_ += size_in_bytes;
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (size_), (0), "size_" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 1639, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
  }


  void DeallocateBytes(intptr_t size_in_bytes) {
    size_ -= size_in_bytes;
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (size_), (0), "size_" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 1645, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
  }


  void Merge(const AllocationStats& other) {
    capacity_ += other.capacity_;
    size_ += other.size_;
    if (other.max_capacity_ > max_capacity_) {
      max_capacity_ = other.max_capacity_;
    }
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (size_), (0), "size_" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 1655, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
  }

  void DecreaseCapacity(intptr_t size_in_bytes) {
    capacity_ -= size_in_bytes;
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (capacity_), (0), "capacity_" " " ">=" " " "0")) { V8_Fatal(".././src/heap/spaces.h", 1660, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (capacity_), (size_), "capacity_" " " ">=" " " "size_")) { V8_Fatal(".././src/heap/spaces.h", 1661, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
  }

  void IncreaseCapacity(intptr_t size_in_bytes) { capacity_ += size_in_bytes; }

 private:


  intptr_t capacity_;


  intptr_t max_capacity_;


  intptr_t size_;
};
class FreeList {
 public:


  static inline int GuaranteedAllocatable(int maximum_freed) {
    if (maximum_freed <= kTiniestListMax) {


      return 0;
    } else if (maximum_freed <= kTinyListMax) {
      return kTinyAllocationMax;
    } else if (maximum_freed <= kSmallListMax) {
      return kSmallAllocationMax;
    } else if (maximum_freed <= kMediumListMax) {
      return kMediumAllocationMax;
    } else if (maximum_freed <= kLargeListMax) {
      return kLargeAllocationMax;
    }
    return maximum_freed;
  }

  explicit FreeList(PagedSpace* owner);







  int Free(Address start, int size_in_bytes, FreeMode mode);




  __attribute__((warn_unused_result)) HeapObject* Allocate(int size_in_bytes);


  void Reset();

  void ResetStats() {
    wasted_bytes_.SetValue(0);
    ForAllFreeListCategories(
        [](FreeListCategory* category) { category->ResetStats(); });
  }


  intptr_t Available() {
    intptr_t available = 0;
    ForAllFreeListCategories([&available](FreeListCategory* category) {
      available += category->available();
    });
    return available;
  }

  bool IsEmpty() {
    bool empty = true;
    ForAllFreeListCategories([&empty](FreeListCategory* category) {
      if (!category->is_empty()) empty = false;
    });
    return empty;
  }


  void RepairLists(Heap* heap);

  intptr_t EvictFreeListItems(Page* page);
  bool ContainsPageFreeListItems(Page* page);

  PagedSpace* owner() { return owner_; }
  intptr_t wasted_bytes() { return wasted_bytes_.Value(); }

  template <typename Callback>
  void ForAllFreeListCategories(FreeListCategoryType type, Callback callback) {
    FreeListCategory* current = categories_[type];
    while (current != nullptr) {
      FreeListCategory* next = current->next();
      callback(current);
      current = next;
    }
  }

  template <typename Callback>
  void ForAllFreeListCategories(Callback callback) {
    for (int i = kFirstCategory; i < kNumberOfCategories; i++) {
      ForAllFreeListCategories(static_cast<FreeListCategoryType>(i), callback);
    }
  }

  bool AddCategory(FreeListCategory* category);
  void RemoveCategory(FreeListCategory* category);
  void PrintCategories(FreeListCategoryType type);


  intptr_t SumFreeLists();
  bool IsVeryLong();


 private:
  class FreeListCategoryIterator {
   public:
    FreeListCategoryIterator(FreeList* free_list, FreeListCategoryType type)
        : current_(free_list->categories_[type]) {}

    bool HasNext() { return current_ != nullptr; }

    FreeListCategory* Next() {
      do { if ((!(HasNext()))) { V8_Fatal(".././src/heap/spaces.h", 1805, "Check failed: %s.", "HasNext()"); } } while (0);
      FreeListCategory* tmp = current_;
      current_ = current_->next();
      return tmp;
    }

   private:
    FreeListCategory* current_;
  };


  static const int kMinBlockSize = 3 * kPointerSize;
  static const int kMaxBlockSize = Page::kAllocatableMemory;

  static const int kTiniestListMax = 0xa * kPointerSize;
  static const int kTinyListMax = 0x1f * kPointerSize;
  static const int kSmallListMax = 0xff * kPointerSize;
  static const int kMediumListMax = 0x7ff * kPointerSize;
  static const int kLargeListMax = 0x3fff * kPointerSize;
  static const int kTinyAllocationMax = kTiniestListMax;
  static const int kSmallAllocationMax = kTinyListMax;
  static const int kMediumAllocationMax = kSmallListMax;
  static const int kLargeAllocationMax = kMediumListMax;

  FreeSpace* FindNodeFor(int size_in_bytes, int* node_size);



  FreeSpace* FindNodeIn(FreeListCategoryType type, int* node_size);



  FreeSpace* TryFindNodeIn(FreeListCategoryType type, int* node_size,
                           int minimum_size);


  FreeSpace* SearchForNodeInList(FreeListCategoryType type, int* node_size,
                                 int minimum_size);

  FreeListCategoryType SelectFreeListCategoryType(size_t size_in_bytes) {
    if (size_in_bytes <= kTiniestListMax) {
      return kTiniest;
    } else if (size_in_bytes <= kTinyListMax) {
      return kTiny;
    } else if (size_in_bytes <= kSmallListMax) {
      return kSmall;
    } else if (size_in_bytes <= kMediumListMax) {
      return kMedium;
    } else if (size_in_bytes <= kLargeListMax) {
      return kLarge;
    }
    return kHuge;
  }


  FreeListCategoryType SelectFastAllocationFreeListCategoryType(
      size_t size_in_bytes) {
    if (size_in_bytes <= kSmallAllocationMax) {
      return kSmall;
    } else if (size_in_bytes <= kMediumAllocationMax) {
      return kMedium;
    } else if (size_in_bytes <= kLargeAllocationMax) {
      return kLarge;
    }
    return kHuge;
  }

  FreeListCategory* top(FreeListCategoryType type) { return categories_[type]; }

  PagedSpace* owner_;
  AtomicNumber<intptr_t> wasted_bytes_;
  FreeListCategory* categories_[kNumberOfCategories];

  friend class FreeListCategory;

  FreeList() = delete; FreeList(const FreeList&) = delete; void operator=(const FreeList&) = delete;
};


class AllocationResult {
 public:

  AllocationResult(Object* object)
      : object_(object) {


    do { if ((!(!object->IsSmi()))) { V8_Fatal(".././src/heap/spaces.h", 1891, "Check failed: %s.", "!object->IsSmi()"); } } while (0);
  }

  AllocationResult() : object_(Smi::FromInt(NEW_SPACE)) {}

  static inline AllocationResult Retry(AllocationSpace space = NEW_SPACE) {
    return AllocationResult(space);
  }

  inline bool IsRetry() { return object_->IsSmi(); }

  template <typename T>
  bool To(T** obj) {
    if (IsRetry()) return false;
    *obj = T::cast(object_);
    return true;
  }

  Object* ToObjectChecked() {
    do { if ((!(!IsRetry()))) { V8_Fatal(".././src/heap/spaces.h", 1910, "Check failed: %s.", "!IsRetry()"); } } while (0);
    return object_;
  }

  inline AllocationSpace RetrySpace();

 private:
  explicit AllocationResult(AllocationSpace space)
      : object_(Smi::FromInt(static_cast<int>(space))) {}

  Object* object_;
};


static_assert(sizeof(AllocationResult) == kPointerSize, "sizeof(AllocationResult) == kPointerSize");
class LocalAllocationBuffer {
 public:



  static inline LocalAllocationBuffer InvalidBuffer();



  static inline LocalAllocationBuffer FromResult(Heap* heap,
                                                 AllocationResult result,
                                                 intptr_t size);

  ~LocalAllocationBuffer() { Close(); }


  LocalAllocationBuffer(const LocalAllocationBuffer& other);
  LocalAllocationBuffer& operator=(const LocalAllocationBuffer& other);

  __attribute__((warn_unused_result)) inline AllocationResult AllocateRawAligned(
      int size_in_bytes, AllocationAlignment alignment);

  inline bool IsValid() { return allocation_info_.top() != nullptr; }



  inline bool TryMerge(LocalAllocationBuffer* other);

 private:
  LocalAllocationBuffer(Heap* heap, AllocationInfo allocation_info);

  void Close();

  Heap* heap_;
  AllocationInfo allocation_info_;
};

class PagedSpace : public Space {
 public:
  static const intptr_t kCompactionMemoryWanted = 500 * KB;


  PagedSpace(Heap* heap, AllocationSpace id, Executability executable);

  ~PagedSpace() override { TearDown(); }





  bool SetUp();



  bool HasBeenSetUp();


  inline bool Contains(Address a);
  inline bool Contains(Object* o);
  bool ContainsSlow(Address addr);





  Object* FindObject(Address addr);



  void RepairFreeListsAfterDeserialization();


  void PrepareForMarkCompact();


  intptr_t Capacity() { return accounting_stats_.Capacity(); }


  size_t CommittedPhysicalMemory() override;

  void ResetFreeListStatistics();






  void ClearStats() {
    accounting_stats_.ClearSize();
    free_list_.ResetStats();
    ResetFreeListStatistics();
  }





  intptr_t Available() override { return free_list_.Available(); }





  intptr_t Size() override { return accounting_stats_.Size(); }



  intptr_t SizeOfObjects() override;



  virtual intptr_t Waste() { return free_list_.wasted_bytes(); }


  Address top() { return allocation_info_.top(); }
  Address limit() { return allocation_info_.limit(); }


  Address* allocation_top_address() { return allocation_info_.top_address(); }


  Address* allocation_limit_address() {
    return allocation_info_.limit_address();
  }

  enum UpdateSkipList { UPDATE_SKIP_LIST, IGNORE_SKIP_LIST };




  __attribute__((warn_unused_result)) inline AllocationResult AllocateRawUnaligned(
      int size_in_bytes, UpdateSkipList update_skip_list = UPDATE_SKIP_LIST);

  __attribute__((warn_unused_result)) inline AllocationResult AllocateRawUnalignedSynchronized(
      int size_in_bytes);



  __attribute__((warn_unused_result)) inline AllocationResult AllocateRawAligned(
      int size_in_bytes, AllocationAlignment alignment);



  __attribute__((warn_unused_result)) inline AllocationResult AllocateRaw(
      int size_in_bytes, AllocationAlignment alignment);





  int Free(Address start, int size_in_bytes) {
    int wasted = free_list_.Free(start, size_in_bytes, kLinkCategory);
    accounting_stats_.DeallocateBytes(size_in_bytes);
    return size_in_bytes - wasted;
  }

  int UnaccountedFree(Address start, int size_in_bytes) {
    int wasted = free_list_.Free(start, size_in_bytes, kDoNotLinkCategory);
    return size_in_bytes - wasted;
  }

  void ResetFreeList() { free_list_.Reset(); }


  void SetTopAndLimit(Address top, Address limit) {
    do { if ((!(top == limit || Page::FromAddress(top) == Page::FromAddress(limit - 1)))) { V8_Fatal(".././src/heap/spaces.h", 2109, "Check failed: %s.", "top == limit || Page::FromAddress(top) == Page::FromAddress(limit - 1)"); } } while (0);

    MemoryChunk::UpdateHighWaterMark(allocation_info_.top());
    allocation_info_.Reset(top, limit);
  }


  void EmptyAllocationInfo() {


    int old_linear_size = static_cast<int>(limit() - top());
    Free(top(), old_linear_size);
    SetTopAndLimit(0, 0);
  }

  void Allocate(int bytes) { accounting_stats_.AllocateBytes(bytes); }

  void IncreaseCapacity(int size);


  void ReleasePage(Page* page);


  Page* anchor() { return &anchor_; }



  virtual void Verify(ObjectVisitor* visitor);



  virtual void VerifyObject(HeapObject* obj) {}




  void Print() override;


  void ReportStatistics();


  void CollectCodeStatistics();
  static void ReportCodeStatistics(Isolate* isolate);
  static void ResetCodeStatistics(Isolate* isolate);






  bool EnsureSweeperProgress(intptr_t size_in_bytes);

  Page* FirstPage() { return anchor_.next_page(); }
  Page* LastPage() { return anchor_.prev_page(); }

  void EvictEvacuationCandidatesFromLinearAllocationArea();

  bool CanExpand(size_t size);


  int CountTotalPages();


  inline int AreaSize() { return area_size_; }

  virtual bool is_local() { return false; }



  void MergeCompactionSpace(CompactionSpace* other);



  virtual void RefillFreeList();

  FreeList* free_list() { return &free_list_; }

  base::Mutex* mutex() { return &space_mutex_; }

  inline void UnlinkFreeListCategories(Page* page);
  inline intptr_t RelinkFreeListCategories(Page* page);

 protected:


  virtual bool snapshotable() { return true; }

  bool HasPages() { return anchor_.next_page() != &anchor_; }



  void TearDown();




  bool Expand();



  inline HeapObject* AllocateLinearly(int size_in_bytes);




  inline HeapObject* AllocateLinearlyAligned(int* size_in_bytes,
                                             AllocationAlignment alignment);




  __attribute__((warn_unused_result)) virtual HeapObject* SweepAndRetryAllocation(
      int size_in_bytes);


  __attribute__((warn_unused_result)) HeapObject* SlowAllocateRaw(int size_in_bytes);

  int area_size_;


  AllocationStats accounting_stats_;


  Page anchor_;


  FreeList free_list_;


  AllocationInfo allocation_info_;


  base::Mutex space_mutex_;

  friend class IncrementalMarking;
  friend class MarkCompactCollector;
  friend class PageIterator;


  friend class HeapTester;
};


class NumberAndSizeInfo : public Embedded {
 public:
  NumberAndSizeInfo() : number_(0), bytes_(0) {}

  int number() const { return number_; }
  void increment_number(int num) { number_ += num; }

  int bytes() const { return bytes_; }
  void increment_bytes(int size) { bytes_ += size; }

  void clear() {
    number_ = 0;
    bytes_ = 0;
  }

 private:
  int number_;
  int bytes_;
};




class HistogramInfo : public NumberAndSizeInfo {
 public:
  HistogramInfo() : NumberAndSizeInfo() {}

  const char* name() { return name_; }
  void set_name(const char* name) { name_ = name; }

 private:
  const char* name_;
};


enum SemiSpaceId { kFromSpace = 0, kToSpace = 1 };


class NewSpacePage : public MemoryChunk {
 public:
  static inline NewSpacePage* Initialize(Heap* heap, MemoryChunk* chunk,
                                         Executability executable,
                                         SemiSpace* owner);

  static bool IsAtStart(Address addr) {
    return (reinterpret_cast<intptr_t>(addr) & Page::kPageAlignmentMask) ==
           kObjectStartOffset;
  }

  static bool IsAtEnd(Address addr) {
    return (reinterpret_cast<intptr_t>(addr) & Page::kPageAlignmentMask) == 0;
  }


  static inline NewSpacePage* FromAddress(Address address_in_page) {
    Address page_start =
        reinterpret_cast<Address>(reinterpret_cast<uintptr_t>(address_in_page) &
                                  ~Page::kPageAlignmentMask);
    NewSpacePage* page = reinterpret_cast<NewSpacePage*>(page_start);
    return page;
  }



  static inline NewSpacePage* FromLimit(Address address_limit) {
    return NewSpacePage::FromAddress(address_limit - 1);
  }


  static inline bool OnSamePage(Address address1, Address address2) {
    return NewSpacePage::FromAddress(address1) ==
           NewSpacePage::FromAddress(address2);
  }

  inline NewSpacePage* next_page() {
    return static_cast<NewSpacePage*>(next_chunk());
  }

  inline void set_next_page(NewSpacePage* page) { set_next_chunk(page); }

  inline NewSpacePage* prev_page() {
    return static_cast<NewSpacePage*>(prev_chunk());
  }

  inline void set_prev_page(NewSpacePage* page) { set_prev_chunk(page); }

  SemiSpace* semi_space() { return reinterpret_cast<SemiSpace*>(owner()); }

  bool is_anchor() { return !this->InNewSpace(); }

 private:


  static const intptr_t kCopyOnFlipFlagsMask =
      (1 << MemoryChunk::POINTERS_TO_HERE_ARE_INTERESTING) |
      (1 << MemoryChunk::POINTERS_FROM_HERE_ARE_INTERESTING);



  explicit NewSpacePage(SemiSpace* owner) { InitializeAsAnchor(owner); }




  void InitializeAsAnchor(SemiSpace* owner);

  friend class SemiSpace;
  friend class SemiSpaceIterator;
};
class SemiSpace : public Space {
 public:
  static void Swap(SemiSpace* from, SemiSpace* to);

  SemiSpace(Heap* heap, SemiSpaceId semispace)
      : Space(heap, NEW_SPACE, NOT_EXECUTABLE),
        current_capacity_(0),
        maximum_capacity_(0),
        minimum_capacity_(0),
        age_mark_(nullptr),
        committed_(false),
        id_(semispace),
        anchor_(this),
        current_page_(nullptr) {}

  inline bool Contains(HeapObject* o);
  inline bool Contains(Object* o);
  inline bool ContainsSlow(Address a);

  void SetUp(int initial_capacity, int maximum_capacity);
  void TearDown();
  bool HasBeenSetUp() { return maximum_capacity_ != 0; }

  bool Commit();
  bool Uncommit();
  bool is_committed() { return committed_; }



  bool GrowTo(int new_capacity);




  bool ShrinkTo(int new_capacity);


  Address space_start() {
    do { if (std::string* _msg = ::v8::base::CheckNEImpl( (anchor_.next_page()), (anchor()), "anchor_.next_page()" " " "!=" " " "anchor()")) { V8_Fatal(".././src/heap/spaces.h", 2407, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    return anchor_.next_page()->area_start();
  }

  NewSpacePage* first_page() { return anchor_.next_page(); }
  NewSpacePage* current_page() { return current_page_; }


  Address space_end() { return anchor_.prev_page()->area_end(); }


  Address page_low() { return current_page_->area_start(); }


  Address page_high() { return current_page_->area_end(); }

  bool AdvancePage() {
    NewSpacePage* next_page = current_page_->next_page();
    if (next_page == anchor()) return false;
    current_page_ = next_page;
    return true;
  }


  void Reset();


  Address age_mark() { return age_mark_; }
  void set_age_mark(Address mark);


  int current_capacity() { return current_capacity_; }


  int maximum_capacity() { return maximum_capacity_; }


  int minimum_capacity() { return minimum_capacity_; }

  SemiSpaceId id() { return id_; }


  size_t CommittedPhysicalMemory() override;




  intptr_t Size() override {
    V8_Fatal(".././src/heap/spaces.h", 2455, "unreachable code");
    return 0;
  }

  intptr_t SizeOfObjects() override { return Size(); }

  intptr_t Available() override {
    V8_Fatal(".././src/heap/spaces.h", 2462, "unreachable code");
    return 0;
  }


  void Print() override;



  static void AssertValidRange(Address from, Address to);






  virtual void Verify();


 private:
  inline NewSpacePage* anchor() { return &anchor_; }


  void FixPagesFlags(intptr_t flags, intptr_t flag_mask);


  int current_capacity_;


  int maximum_capacity_;


  int minimum_capacity_;


  Address age_mark_;

  bool committed_;
  SemiSpaceId id_;

  NewSpacePage anchor_;
  NewSpacePage* current_page_;

  friend class SemiSpaceIterator;
  friend class NewSpacePageIterator;
};







class SemiSpaceIterator : public ObjectIterator {
 public:

  explicit SemiSpaceIterator(NewSpace* space);

  inline HeapObject* Next();


  inline HeapObject* next_object() override;

 private:
  void Initialize(Address start, Address end);


  Address current_;

  Address limit_;
};




class NewSpacePageIterator : public Embedded {
 public:

  explicit inline NewSpacePageIterator(NewSpace* space);



  explicit inline NewSpacePageIterator(SemiSpace* space);



  inline NewSpacePageIterator(Address start, Address limit);

  inline bool has_next();
  inline NewSpacePage* next();

 private:
  NewSpacePage* prev_page_;


  NewSpacePage* next_page_;

  NewSpacePage* last_page_;
};
class NewSpace : public Space {
 public:
  explicit NewSpace(Heap* heap)
      : Space(heap, NEW_SPACE, NOT_EXECUTABLE),
        to_space_(heap, kToSpace),
        from_space_(heap, kFromSpace),
        reservation_(),
        pages_used_(0),
        top_on_previous_step_(0),
        allocated_histogram_(nullptr),
        promoted_histogram_(nullptr) {}

  inline bool Contains(HeapObject* o);
  inline bool ContainsSlow(Address a);
  inline bool Contains(Object* o);

  bool SetUp(int initial_semispace_capacity, int max_semispace_capacity);



  void TearDown();


  bool HasBeenSetUp() {
    return to_space_.HasBeenSetUp() && from_space_.HasBeenSetUp();
  }


  void Flip();



  void Grow();


  void Shrink();


  intptr_t Size() override {
    return pages_used_ * NewSpacePage::kAllocatableMemory +
           static_cast<int>(top() - to_space_.page_low());
  }




  int SizeAsInt() { return static_cast<int>(Size()); }


  intptr_t Capacity() {
    do { if ((!(!v8::internal::FLAG_enable_slow_asserts || (to_space_.current_capacity() == from_space_.current_capacity())))) { V8_Fatal(".././src/heap/spaces.h", 2619, "Check failed: %s.", "!v8::internal::FLAG_enable_slow_asserts || (to_space_.current_capacity() == from_space_.current_capacity())"); } } while (0);
    return (to_space_.current_capacity() / Page::kPageSize) *
           NewSpacePage::kAllocatableMemory;
  }



  intptr_t TotalCapacity() {
    do { if ((!(to_space_.current_capacity() == from_space_.current_capacity()))) { V8_Fatal(".././src/heap/spaces.h", 2627, "Check failed: %s.", "to_space_.current_capacity() == from_space_.current_capacity()"); } } while (0);
    return to_space_.current_capacity();
  }



  intptr_t CommittedMemory() override {
    return from_space_.CommittedMemory() + to_space_.CommittedMemory();
  }

  intptr_t MaximumCommittedMemory() override {
    return from_space_.MaximumCommittedMemory() +
           to_space_.MaximumCommittedMemory();
  }


  size_t CommittedPhysicalMemory() override;


  intptr_t Available() override { return Capacity() - Size(); }

  size_t AllocatedSinceLastGC() {
    bool seen_age_mark = false;
    Address age_mark = to_space_.age_mark();
    NewSpacePage* current_page = to_space_.first_page();
    NewSpacePage* age_mark_page = NewSpacePage::FromAddress(age_mark);
    NewSpacePage* last_page = NewSpacePage::FromAddress(top() - kPointerSize);
    if (age_mark_page == last_page) {
      if (top() - age_mark >= 0) {
        return top() - age_mark;
      }

      return 0;
    }
    while (current_page != last_page) {
      if (current_page == age_mark_page) {
        seen_age_mark = true;
        break;
      }
      current_page = current_page->next_page();
    }
    if (!seen_age_mark) {

      return 0;
    }
    intptr_t allocated = age_mark_page->area_end() - age_mark;
    do { if (std::string* _msg = ::v8::base::CheckEQImpl( (current_page), (age_mark_page), "current_page" " " "==" " " "age_mark_page")) { V8_Fatal(".././src/heap/spaces.h", 2673, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    current_page = age_mark_page->next_page();
    while (current_page != last_page) {
      allocated += NewSpacePage::kAllocatableMemory;
      current_page = current_page->next_page();
    }
    allocated += top() - current_page->area_start();
    do { if (std::string* _msg = ::v8::base::CheckLEImpl( (0), (allocated), "0" " " "<=" " " "allocated")) { V8_Fatal(".././src/heap/spaces.h", 2680, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    do { if (std::string* _msg = ::v8::base::CheckLEImpl( (allocated), (Size()), "allocated" " " "<=" " " "Size()")) { V8_Fatal(".././src/heap/spaces.h", 2681, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    return static_cast<size_t>(allocated);
  }


  int MaximumCapacity() {
    do { if ((!(to_space_.maximum_capacity() == from_space_.maximum_capacity()))) { V8_Fatal(".././src/heap/spaces.h", 2687, "Check failed: %s.", "to_space_.maximum_capacity() == from_space_.maximum_capacity()"); } } while (0);
    return to_space_.maximum_capacity();
  }

  bool IsAtMaximumCapacity() { return TotalCapacity() == MaximumCapacity(); }


  int InitialTotalCapacity() {
    do { if ((!(to_space_.minimum_capacity() == from_space_.minimum_capacity()))) { V8_Fatal(".././src/heap/spaces.h", 2695, "Check failed: %s.", "to_space_.minimum_capacity() == from_space_.minimum_capacity()"); } } while (0);
    return to_space_.minimum_capacity();
  }


  Address top() {
    do { if ((!(to_space_.current_page()->ContainsLimit(allocation_info_.top())))) { V8_Fatal(".././src/heap/spaces.h", 2701, "Check failed: %s.", "to_space_.current_page()->ContainsLimit(allocation_info_.top())"); } } while (0);
    return allocation_info_.top();
  }


  Address limit() {
    do { if ((!(to_space_.current_page()->ContainsLimit(allocation_info_.limit())))) { V8_Fatal(".././src/heap/spaces.h", 2707, "Check failed: %s.", "to_space_.current_page()->ContainsLimit(allocation_info_.limit())"); } } while (0);
    return allocation_info_.limit();
  }


  Address bottom() { return to_space_.space_start(); }


  Address age_mark() { return from_space_.age_mark(); }

  void set_age_mark(Address mark) { to_space_.set_age_mark(mark); }


  Address* allocation_top_address() { return allocation_info_.top_address(); }


  Address* allocation_limit_address() {
    return allocation_info_.limit_address();
  }

  __attribute__((warn_unused_result)) inline AllocationResult AllocateRawAligned( int size_in_bytes, AllocationAlignment alignment);


  __attribute__((warn_unused_result)) inline AllocationResult AllocateRawUnaligned(int size_in_bytes);


  __attribute__((warn_unused_result)) inline AllocationResult AllocateRaw( int size_in_bytes, AllocationAlignment alignment);


  __attribute__((warn_unused_result)) inline AllocationResult AllocateRawSynchronized(
      int size_in_bytes, AllocationAlignment alignment);


  void ResetAllocationInfo();






  void UpdateInlineAllocationLimit(int size_in_bytes);

  void DisableInlineAllocationSteps() {
    top_on_previous_step_ = 0;
    UpdateInlineAllocationLimit(0);
  }





  void AddAllocationObserver(AllocationObserver* observer) override;

  void RemoveAllocationObserver(AllocationObserver* observer) override;




  Address FromSpacePageLow() { return from_space_.page_low(); }
  Address FromSpacePageHigh() { return from_space_.page_high(); }
  Address FromSpaceStart() { return from_space_.space_start(); }
  Address FromSpaceEnd() { return from_space_.space_end(); }


  Address ToSpaceStart() { return to_space_.space_start(); }
  Address ToSpaceEnd() { return to_space_.space_end(); }

  inline bool ToSpaceContainsSlow(Address a);
  inline bool FromSpaceContainsSlow(Address a);
  inline bool ToSpaceContains(Object* o);
  inline bool FromSpaceContains(Object* o);





  bool AddFreshPage();
  bool AddFreshPageSynchronized();



  virtual void Verify();




  void Print() override { to_space_.Print(); }



  void CollectStatistics();

  void ReportStatistics();

  void ClearHistograms();




  void RecordAllocation(HeapObject* obj);
  void RecordPromotion(HeapObject* obj);


  bool CommitFromSpaceIfNeeded() {
    if (from_space_.is_committed()) return true;
    return from_space_.Commit();
  }

  bool UncommitFromSpace() {
    if (!from_space_.is_committed()) return true;
    return from_space_.Uncommit();
  }

  bool IsFromSpaceCommitted() { return from_space_.is_committed(); }

  SemiSpace* active_space() { return &to_space_; }

  void PauseAllocationObservers() override;
  void ResumeAllocationObservers() override;

 private:

  void UpdateAllocationInfo();

  base::Mutex mutex_;


  SemiSpace to_space_;
  SemiSpace from_space_;
  base::VirtualMemory reservation_;
  int pages_used_;



  AllocationInfo allocation_info_;

  Address top_on_previous_step_;

  HistogramInfo* allocated_histogram_;
  HistogramInfo* promoted_histogram_;

  bool EnsureAllocation(int size_in_bytes, AllocationAlignment alignment);







  void InlineAllocationStep(Address top, Address new_top, Address soon_object,
                            size_t size);
  intptr_t GetNextInlineAllocationStepSize();
  void StartNextInlineAllocationStep();

  friend class SemiSpaceIterator;
};

class PauseAllocationObserversScope {
 public:
  explicit PauseAllocationObserversScope(Heap* heap);
  ~PauseAllocationObserversScope();

 private:
  Heap* heap_;
  PauseAllocationObserversScope(const PauseAllocationObserversScope&) = delete; void operator=(const PauseAllocationObserversScope&) = delete;
};




class CompactionSpace : public PagedSpace {
 public:
  CompactionSpace(Heap* heap, AllocationSpace id, Executability executable)
      : PagedSpace(heap, id, executable) {}

  bool is_local() override { return true; }

 protected:

  bool snapshotable() override { return false; }

  __attribute__((warn_unused_result)) HeapObject* SweepAndRetryAllocation(
      int size_in_bytes) override;
};



class CompactionSpaceCollection : public Malloced {
 public:
  explicit CompactionSpaceCollection(Heap* heap)
      : old_space_(heap, OLD_SPACE, Executability::NOT_EXECUTABLE),
        code_space_(heap, CODE_SPACE, Executability::EXECUTABLE) {}

  CompactionSpace* Get(AllocationSpace space) {
    switch (space) {
      case OLD_SPACE:
        return &old_space_;
      case CODE_SPACE:
        return &code_space_;
      default:
        V8_Fatal(".././src/heap/spaces.h", 2907, "unreachable code");
    }
    V8_Fatal(".././src/heap/spaces.h", 2909, "unreachable code");
    return nullptr;
  }

 private:
  CompactionSpace old_space_;
  CompactionSpace code_space_;
};





class OldSpace : public PagedSpace {
 public:


  OldSpace(Heap* heap, AllocationSpace id, Executability executable)
      : PagedSpace(heap, id, executable) {}
};
class MapSpace : public PagedSpace {
 public:

  MapSpace(Heap* heap, AllocationSpace id)
      : PagedSpace(heap, id, NOT_EXECUTABLE) {}

  int RoundSizeDownToObjectAlignment(int size) override {
    if (base::bits::IsPowerOfTwo32(Map::kSize)) {
      return RoundDown(size, Map::kSize);
    } else {
      return (size / Map::kSize) * Map::kSize;
    }
  }


  void VerifyObject(HeapObject* obj) override;

};
class LargeObjectSpace : public Space {
 public:
  LargeObjectSpace(Heap* heap, AllocationSpace id);
  virtual ~LargeObjectSpace();


  bool SetUp();


  void TearDown();

  static intptr_t ObjectSizeFor(intptr_t chunk_size) {
    if (chunk_size <= (Page::kPageSize + Page::kObjectStartOffset)) return 0;
    return chunk_size - Page::kPageSize - Page::kObjectStartOffset;
  }



  __attribute__((warn_unused_result)) AllocationResult
      AllocateRaw(int object_size, Executability executable);


  inline intptr_t Available() override;

  intptr_t Size() override { return size_; }

  intptr_t SizeOfObjects() override { return objects_size_; }


  size_t CommittedPhysicalMemory() override;

  int PageCount() { return page_count_; }



  Object* FindObject(Address a);



  LargePage* FindPage(Address a);


  void ClearMarkingStateOfLiveObjects();


  void FreeUnmarkedObjects();


  bool Contains(HeapObject* obj);


  bool ContainsSlow(Address addr) { return FindObject(addr)->IsHeapObject(); }


  bool IsEmpty() { return first_page_ == 0; }

  LargePage* first_page() { return first_page_; }


  virtual void Verify();



  void Print() override;
  void ReportStatistics();
  void CollectCodeStatistics();


 private:

  LargePage* first_page_;
  intptr_t size_;
  int page_count_;
  intptr_t objects_size_;

  HashMap chunk_map_;

  friend class LargeObjectIterator;
};


class LargeObjectIterator : public ObjectIterator {
 public:
  explicit LargeObjectIterator(LargeObjectSpace* space);

  HeapObject* Next();


  virtual HeapObject* next_object() { return Next(); }

 private:
  LargePage* current_;
};

class LargePageIterator : public Embedded {
 public:
  explicit inline LargePageIterator(LargeObjectSpace* space);

  inline LargePage* next();

 private:
  LargePage* next_page_;
};



class MemoryChunkIterator : public Embedded {
 public:
  enum Mode { ALL, ALL_BUT_MAP_SPACE, ALL_BUT_CODE_SPACE };
  inline explicit MemoryChunkIterator(Heap* heap, Mode mode);


  inline MemoryChunk* next();

 private:
  enum State {
    kOldSpaceState,
    kMapState,
    kCodeState,
    kLargeObjectState,
    kFinishedState
  };
  State state_;
  const Mode mode_;
  PageIterator old_iterator_;
  PageIterator code_iterator_;
  PageIterator map_iterator_;
  LargePageIterator lo_iterator_;
};


struct CommentStatistic {
  const char* comment;
  int size;
  int count;
  void Clear() {
    comment = 0;
    size = 0;
    count = 0;
  }

  static const int kMaxComments = 64;
};

}
}
namespace v8 {
namespace internal {

enum SlotCallbackResult { KEEP_SLOT, REMOVE_SLOT };







class SlotSet : public Malloced {
 public:
  SlotSet() {
    for (int i = 0; i < kBuckets; i++) {
      bucket[i] = nullptr;
    }
  }

  ~SlotSet() {
    for (int i = 0; i < kBuckets; i++) {
      ReleaseBucket(i);
    }
  }

  void SetPageStart(Address page_start) { page_start_ = page_start; }


  void Insert(int slot_offset) {
    int bucket_index, cell_index, bit_index;
    SlotToIndices(slot_offset, &bucket_index, &cell_index, &bit_index);
    if (bucket[bucket_index] == nullptr) {
      bucket[bucket_index] = AllocateBucket();
    }
    bucket[bucket_index][cell_index] |= 1u << bit_index;
  }


  void Remove(int slot_offset) {
    int bucket_index, cell_index, bit_index;
    SlotToIndices(slot_offset, &bucket_index, &cell_index, &bit_index);
    if (bucket[bucket_index] != nullptr) {
      uint32_t cell = bucket[bucket_index][cell_index];
      if (cell) {
        uint32_t bit_mask = 1u << bit_index;
        if (cell & bit_mask) {
          bucket[bucket_index][cell_index] ^= bit_mask;
        }
      }
    }
  }



  void RemoveRange(int start_offset, int end_offset) {
    do { if (std::string* _msg = ::v8::base::CheckLEImpl( (start_offset), (end_offset), "start_offset" " " "<=" " " "end_offset")) { V8_Fatal(".././src/heap/slot-set.h", 67, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    int start_bucket, start_cell, start_bit;
    SlotToIndices(start_offset, &start_bucket, &start_cell, &start_bit);
    int end_bucket, end_cell, end_bit;
    SlotToIndices(end_offset, &end_bucket, &end_cell, &end_bit);
    uint32_t start_mask = (1u << start_bit) - 1;
    uint32_t end_mask = ~((1u << end_bit) - 1);
    if (start_bucket == end_bucket && start_cell == end_cell) {
      MaskCell(start_bucket, start_cell, start_mask | end_mask);
      return;
    }
    int current_bucket = start_bucket;
    int current_cell = start_cell;
    MaskCell(current_bucket, current_cell, start_mask);
    current_cell++;
    if (current_bucket < end_bucket) {
      if (bucket[current_bucket] != nullptr) {
        while (current_cell < kCellsPerBucket) {
          bucket[current_bucket][current_cell] = 0;
          current_cell++;
        }
      }


      current_bucket++;
      current_cell = 0;
    }
    do { if ((!(current_bucket == end_bucket || (current_bucket < end_bucket && current_cell == 0)))) { V8_Fatal(".././src/heap/slot-set.h", 95, "Check failed: %s.", "current_bucket == end_bucket || (current_bucket < end_bucket && current_cell == 0)"); } } while (0);

    while (current_bucket < end_bucket) {
      ReleaseBucket(current_bucket);
      current_bucket++;
    }

    do { if ((!(current_bucket == end_bucket && current_cell <= end_cell))) { V8_Fatal(".././src/heap/slot-set.h", 101, "Check failed: %s.", "current_bucket == end_bucket && current_cell <= end_cell"); } } while (0);
    if (current_bucket == kBuckets || bucket[current_bucket] == nullptr) {
      return;
    }
    while (current_cell < end_cell) {
      bucket[current_bucket][current_cell] = 0;
      current_cell++;
    }

    do { if ((!(current_bucket == end_bucket && current_cell == end_cell))) { V8_Fatal(".././src/heap/slot-set.h", 110, "Check failed: %s.", "current_bucket == end_bucket && current_cell == end_cell"); } } while (0);
    MaskCell(end_bucket, end_cell, end_mask);
  }


  bool Lookup(int slot_offset) {
    int bucket_index, cell_index, bit_index;
    SlotToIndices(slot_offset, &bucket_index, &cell_index, &bit_index);
    if (bucket[bucket_index] != nullptr) {
      uint32_t cell = bucket[bucket_index][cell_index];
      return (cell & (1u << bit_index)) != 0;
    }
    return false;
  }
  template <typename Callback>
  int Iterate(Callback callback) {
    int new_count = 0;
    for (int bucket_index = 0; bucket_index < kBuckets; bucket_index++) {
      if (bucket[bucket_index] != nullptr) {
        int in_bucket_count = 0;
        uint32_t* current_bucket = bucket[bucket_index];
        int cell_offset = bucket_index * kBitsPerBucket;
        for (int i = 0; i < kCellsPerBucket; i++, cell_offset += kBitsPerCell) {
          if (current_bucket[i]) {
            uint32_t cell = current_bucket[i];
            uint32_t old_cell = cell;
            uint32_t new_cell = cell;
            while (cell) {
              int bit_offset = base::bits::CountTrailingZeros32(cell);
              uint32_t bit_mask = 1u << bit_offset;
              uint32_t slot = (cell_offset + bit_offset) << kPointerSizeLog2;
              if (callback(page_start_ + slot) == KEEP_SLOT) {
                ++in_bucket_count;
              } else {
                new_cell ^= bit_mask;
              }
              cell ^= bit_mask;
            }
            if (old_cell != new_cell) {
              current_bucket[i] = new_cell;
            }
          }
        }
        if (in_bucket_count == 0) {
          ReleaseBucket(bucket_index);
        }
        new_count += in_bucket_count;
      }
    }
    return new_count;
  }

 private:
  static const int kMaxSlots = (1 << kPageSizeBits) / kPointerSize;
  static const int kCellsPerBucket = 32;
  static const int kCellsPerBucketLog2 = 5;
  static const int kBitsPerCell = 32;
  static const int kBitsPerCellLog2 = 5;
  static const int kBitsPerBucket = kCellsPerBucket * kBitsPerCell;
  static const int kBitsPerBucketLog2 = kCellsPerBucketLog2 + kBitsPerCellLog2;
  static const int kBuckets = kMaxSlots / kCellsPerBucket / kBitsPerCell;

  uint32_t* AllocateBucket() {
    uint32_t* result = NewArray<uint32_t>(kCellsPerBucket);
    for (int i = 0; i < kCellsPerBucket; i++) {
      result[i] = 0;
    }
    return result;
  }

  void ReleaseBucket(int bucket_index) {
    DeleteArray<uint32_t>(bucket[bucket_index]);
    bucket[bucket_index] = nullptr;
  }

  void MaskCell(int bucket_index, int cell_index, uint32_t mask) {
    uint32_t* cells = bucket[bucket_index];
    if (cells != nullptr && cells[cell_index] != 0) {
      cells[cell_index] &= mask;
    }
  }


  void SlotToIndices(int slot_offset, int* bucket_index, int* cell_index,
                     int* bit_index) {
    do { if (std::string* _msg = ::v8::base::CheckEQImpl( (slot_offset % kPointerSize), (0), "slot_offset % kPointerSize" " " "==" " " "0")) { V8_Fatal(".././src/heap/slot-set.h", 205, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    int slot = slot_offset >> kPointerSizeLog2;
    do { if ((!(slot >= 0 && slot <= kMaxSlots))) { V8_Fatal(".././src/heap/slot-set.h", 207, "Check failed: %s.", "slot >= 0 && slot <= kMaxSlots"); } } while (0);
    *bucket_index = slot >> kBitsPerBucketLog2;
    *cell_index = (slot >> kBitsPerCellLog2) & (kCellsPerBucket - 1);
    *bit_index = slot & (kBitsPerCell - 1);
  }

  uint32_t* bucket[kBuckets];
  Address page_start_;
};

enum SlotType {
  EMBEDDED_OBJECT_SLOT,
  OBJECT_SLOT,
  RELOCATED_CODE_OBJECT,
  CELL_TARGET_SLOT,
  CODE_TARGET_SLOT,
  CODE_ENTRY_SLOT,
  DEBUG_TARGET_SLOT,
  NUMBER_OF_SLOT_TYPES
};
class TypedSlotSet {
 public:
  typedef uint32_t TypedSlot;
  static const int kMaxOffset = 1 << 29;

  explicit TypedSlotSet(Address page_start) : page_start_(page_start) {
    chunk_ = new Chunk(nullptr, kInitialBufferSize);
  }

  ~TypedSlotSet() {
    Chunk* chunk = chunk_;
    while (chunk != nullptr) {
      Chunk* next = chunk->next;
      delete chunk;
      chunk = next;
    }
  }


  void Insert(SlotType type, int offset) {
    TypedSlot slot = ToTypedSlot(type, offset);
    if (!chunk_->AddSlot(slot)) {
      chunk_ = new Chunk(chunk_, NextCapacity(chunk_->capacity));
      bool added = chunk_->AddSlot(slot);
      do { if ((!(added))) { V8_Fatal(".././src/heap/slot-set.h", 259, "Check failed: %s.", "added"); } } while (0);
      USE(added);
    }
  }
  template <typename Callback>
  int Iterate(Callback callback) {
    static_assert(NUMBER_OF_SLOT_TYPES < 8, "NUMBER_OF_SLOT_TYPES < 8");
    const TypedSlot kRemovedSlot = TypeField::encode(NUMBER_OF_SLOT_TYPES);
    Chunk* chunk = chunk_;
    int new_count = 0;
    while (chunk != nullptr) {
      TypedSlot* buffer = chunk->buffer;
      int count = chunk->count;
      for (int i = 0; i < count; i++) {
        TypedSlot slot = buffer[i];
        if (slot != kRemovedSlot) {
          SlotType type = TypeField::decode(slot);
          Address addr = page_start_ + OffsetField::decode(slot);
          if (callback(type, addr) == KEEP_SLOT) {
            new_count++;
          } else {
            buffer[i] = kRemovedSlot;
          }
        }
      }
      chunk = chunk->next;
    }
    return new_count;
  }

 private:
  static const int kInitialBufferSize = 100;
  static const int kMaxBufferSize = 16 * KB;

  static int NextCapacity(int capacity) {
    return Min(kMaxBufferSize, capacity * 2);
  }

  static TypedSlot ToTypedSlot(SlotType type, int offset) {
    return TypeField::encode(type) | OffsetField::encode(offset);
  }

  class OffsetField : public BitField<int, 0, 29> {};
  class TypeField : public BitField<SlotType, 29, 3> {};

  struct Chunk : Malloced {
    explicit Chunk(Chunk* next_chunk, int capacity)
        : next(next_chunk), count(0), capacity(capacity) {
      buffer = NewArray<TypedSlot>(capacity);
    }
    bool AddSlot(TypedSlot slot) {
      if (count == capacity) return false;
      buffer[count++] = slot;
      return true;
    }
    ~Chunk() { DeleteArray(buffer); }
    Chunk* next;
    int count;
    int capacity;
    TypedSlot* buffer;
  };

  Address page_start_;
  Chunk* chunk_;
};

}
}

namespace v8 {
namespace internal {



class StoreBuffer {
 public:
  static const int kStoreBufferSize = 1 << (14 + kPointerSizeLog2);
  static const int kStoreBufferMask = kStoreBufferSize - 1;

  static void StoreBufferOverflow(Isolate* isolate);

  explicit StoreBuffer(Heap* heap);
  void SetUp();
  void TearDown();


  inline Address* top_address() { return reinterpret_cast<Address*>(&top_); }

  void MoveEntriesToRememberedSet();

 private:
  Heap* heap_;

  Address* top_;



  Address* start_;
  Address* limit_;

  base::VirtualMemory* virtual_memory_;
};

}
}


namespace v8 {
namespace internal {

using v8::MemoryPressureLevel;
class AllocationObserver;
class ArrayBufferTracker;
class GCIdleTimeAction;
class GCIdleTimeHandler;
class GCIdleTimeHeapState;
class GCTracer;
class HeapObjectsFilter;
class HeapStats;
class HistogramTimer;
class Isolate;
class MemoryReducer;
class ObjectStats;
class Scavenger;
class ScavengeJob;
class WeakObjectRetainer;

typedef void (*ObjectSlotCallback)(HeapObject** from, HeapObject* to);






class PromotionQueue {
 public:
  explicit PromotionQueue(Heap* heap)
      : front_(0),
        rear_(0),
        limit_(0),
        emergency_stack_(0),
        heap_(heap) {}

  void Initialize();

  void Destroy() {
    do { if ((!(is_empty()))) { V8_Fatal(".././src/heap/heap.h", 322, "Check failed: %s.", "is_empty()"); } } while (0);
    delete emergency_stack_;
    emergency_stack_ = 0;
  }

  Page* GetHeadPage() {
    return Page::FromAllocationTop(reinterpret_cast<Address>(rear_));
  }

  void SetNewLimit(Address limit) {

    if (emergency_stack_) return;


    if (Page::FromAllocationTop(limit) != GetHeadPage()) return;

    limit_ = reinterpret_cast<struct Entry*>(limit);

    if (limit_ <= rear_) {
      return;
    }

    RelocateQueueHead();
  }

  bool IsBelowPromotionQueue(Address to_space_top) {


    if (emergency_stack_) return true;




    if (GetHeadPage() != Page::FromAddress(to_space_top)) {
      return true;
    }


    return reinterpret_cast<struct Entry*>(to_space_top) <= rear_;
  }

  bool is_empty() {
    return (front_ == rear_) &&
           (emergency_stack_ == 0 || emergency_stack_->length() == 0);
  }

  inline void insert(HeapObject* target, int32_t size, bool was_marked_black);

  void remove(HeapObject** target, int32_t* size, bool* was_marked_black) {
    do { if ((!(!is_empty()))) { V8_Fatal(".././src/heap/heap.h", 371, "Check failed: %s.", "!is_empty()"); } } while (0);
    if (front_ == rear_) {
      Entry e = emergency_stack_->RemoveLast();
      *target = e.obj_;
      *size = e.size_;
      *was_marked_black = e.was_marked_black_;
      return;
    }

    struct Entry* entry = reinterpret_cast<struct Entry*>(--front_);
    *target = entry->obj_;
    *size = entry->size_;
    *was_marked_black = entry->was_marked_black_;


    SemiSpace::AssertValidRange(reinterpret_cast<Address>(rear_),
                                reinterpret_cast<Address>(front_));
  }

 private:
  struct Entry {
    Entry(HeapObject* obj, int32_t size, bool was_marked_black)
        : obj_(obj), size_(size), was_marked_black_(was_marked_black) {}

    HeapObject* obj_;
    int32_t size_ : 31;
    bool was_marked_black_ : 1;
  };

  void RelocateQueueHead();


  struct Entry* front_;
  struct Entry* rear_;
  struct Entry* limit_;

  List<Entry>* emergency_stack_;

  Heap* heap_;

  PromotionQueue(const PromotionQueue&) = delete; void operator=(const PromotionQueue&) = delete;
};


enum ArrayStorageAllocationMode {
  DONT_INITIALIZE_ARRAY_ELEMENTS,
  INITIALIZE_ARRAY_ELEMENTS_WITH_HOLE
};

enum class ClearRecordedSlots { kYes, kNo };

class Heap {
 public:

  enum RootListIndex {

    kByteArrayMapRootIndex, kFreeSpaceMapRootIndex, kOnePointerFillerMapRootIndex, kTwoPointerFillerMapRootIndex, kUndefinedValueRootIndex, kTheHoleValueRootIndex, kNullValueRootIndex, kTrueValueRootIndex, kFalseValueRootIndex, kempty_stringRootIndex, kUninitializedValueRootIndex, kCellMapRootIndex, kGlobalPropertyCellMapRootIndex, kSharedFunctionInfoMapRootIndex, kMetaMapRootIndex, kHeapNumberMapRootIndex, kMutableHeapNumberMapRootIndex, kFloat32x4MapRootIndex, kInt32x4MapRootIndex, kUint32x4MapRootIndex, kBool32x4MapRootIndex, kInt16x8MapRootIndex, kUint16x8MapRootIndex, kBool16x8MapRootIndex, kInt8x16MapRootIndex, kUint8x16MapRootIndex, kBool8x16MapRootIndex, kNativeContextMapRootIndex, kFixedArrayMapRootIndex, kCodeMapRootIndex, kScopeInfoMapRootIndex, kFixedCOWArrayMapRootIndex, kFixedDoubleArrayMapRootIndex, kWeakCellMapRootIndex, kTransitionArrayMapRootIndex, kOneByteStringMapRootIndex, kOneByteInternalizedStringMapRootIndex, kFunctionContextMapRootIndex, kEmptyFixedArrayRootIndex, kEmptyByteArrayRootIndex, kEmptyDescriptorArrayRootIndex, kNoInterceptorResultSentinelRootIndex, kArgumentsMarkerRootIndex, kExceptionRootIndex, kTerminationExceptionRootIndex, kOptimizedOutRootIndex, kNumberStringCacheRootIndex, kInstanceofCacheFunctionRootIndex, kInstanceofCacheMapRootIndex, kInstanceofCacheAnswerRootIndex, kSingleCharacterStringCacheRootIndex, kStringSplitCacheRootIndex, kRegExpMultipleCacheRootIndex, kHashSeedRootIndex, kHashTableMapRootIndex, kOrderedHashTableMapRootIndex, kSymbolMapRootIndex, kStringMapRootIndex, kConsOneByteStringMapRootIndex, kConsStringMapRootIndex, kSlicedStringMapRootIndex, kSlicedOneByteStringMapRootIndex, kExternalStringMapRootIndex, kExternalStringWithOneByteDataMapRootIndex, kExternalOneByteStringMapRootIndex, kNativeSourceStringMapRootIndex, kShortExternalStringMapRootIndex, kShortExternalStringWithOneByteDataMapRootIndex, kInternalizedStringMapRootIndex, kExternalInternalizedStringMapRootIndex, kExternalInternalizedStringWithOneByteDataMapRootIndex, kExternalOneByteInternalizedStringMapRootIndex, kShortExternalInternalizedStringMapRootIndex, kShortExternalInternalizedStringWithOneByteDataMapRootIndex, kShortExternalOneByteInternalizedStringMapRootIndex, kShortExternalOneByteStringMapRootIndex, kFixedUint8ArrayMapRootIndex, kFixedInt8ArrayMapRootIndex, kFixedUint16ArrayMapRootIndex, kFixedInt16ArrayMapRootIndex, kFixedUint32ArrayMapRootIndex, kFixedInt32ArrayMapRootIndex, kFixedFloat32ArrayMapRootIndex, kFixedFloat64ArrayMapRootIndex, kFixedUint8ClampedArrayMapRootIndex, kEmptyFixedUint8ArrayRootIndex, kEmptyFixedInt8ArrayRootIndex, kEmptyFixedUint16ArrayRootIndex, kEmptyFixedInt16ArrayRootIndex, kEmptyFixedUint32ArrayRootIndex, kEmptyFixedInt32ArrayRootIndex, kEmptyFixedFloat32ArrayRootIndex, kEmptyFixedFloat64ArrayRootIndex, kEmptyFixedUint8ClampedArrayRootIndex, kSloppyArgumentsElementsMapRootIndex, kCatchContextMapRootIndex, kWithContextMapRootIndex, kDebugEvaluateContextMapRootIndex, kBlockContextMapRootIndex, kModuleContextMapRootIndex, kScriptContextMapRootIndex, kScriptContextTableMapRootIndex, kUndefinedMapRootIndex, kTheHoleMapRootIndex, kNullMapRootIndex, kBooleanMapRootIndex, kUninitializedMapRootIndex, kArgumentsMarkerMapRootIndex, kNoInterceptorResultSentinelMapRootIndex, kExceptionMapRootIndex, kTerminationExceptionMapRootIndex, kOptimizedOutMapRootIndex, kJSMessageObjectMapRootIndex, kForeignMapRootIndex, kNeanderMapRootIndex, kExternalMapRootIndex, kNanValueRootIndex, kInfinityValueRootIndex, kMinusZeroValueRootIndex, kMinusInfinityValueRootIndex, kMessageListenersRootIndex, kCodeStubsRootIndex, kNonMonomorphicCacheRootIndex, kPolymorphicCodeCacheRootIndex, kJsEntryCodeRootIndex, kJsConstructEntryCodeRootIndex, kNativesSourceCacheRootIndex, kExperimentalNativesSourceCacheRootIndex, kExtraNativesSourceCacheRootIndex, kExperimentalExtraNativesSourceCacheRootIndex, kEmptyScriptRootIndex, kIntrinsicFunctionNamesRootIndex, kEmptyPropertiesDictionaryRootIndex, kUndefinedCellRootIndex, kObservationStateRootIndex, kSymbolRegistryRootIndex, kScriptListRootIndex, kEmptySlowElementDictionaryRootIndex, kMaterializedObjectsRootIndex, kMicrotaskQueueRootIndex, kDummyVectorRootIndex, kClearedOptimizedCodeMapRootIndex, kDetachedContextsRootIndex, kRetainedMapsRootIndex, kWeakObjectToCodeTableRootIndex, kArrayProtectorRootIndex, kEmptyPropertyCellRootIndex, kWeakStackTraceListRootIndex, kNoScriptSharedFunctionInfosRootIndex, kBytecodeArrayMapRootIndex, kEmptyWeakCellRootIndex, kSpeciesProtectorRootIndex,



        kanonymous_stringRootIndex, kapply_stringRootIndex, kassign_stringRootIndex, karguments_stringRootIndex, kArguments_stringRootIndex, kArray_stringRootIndex, kbind_stringRootIndex, kbool16x8_stringRootIndex, kBool16x8_stringRootIndex, kbool32x4_stringRootIndex, kBool32x4_stringRootIndex, kbool8x16_stringRootIndex, kBool8x16_stringRootIndex, kboolean_stringRootIndex, kBoolean_stringRootIndex, kbound__stringRootIndex, kbyte_length_stringRootIndex, kbyte_offset_stringRootIndex, kcall_stringRootIndex, kcallee_stringRootIndex, kcaller_stringRootIndex, kcell_value_stringRootIndex, kchar_at_stringRootIndex, kclosure_stringRootIndex, kcompare_ic_stringRootIndex, kconfigurable_stringRootIndex, kconstructor_stringRootIndex, kconstruct_stringRootIndex, kcreate_stringRootIndex, kDate_stringRootIndex, kdefault_stringRootIndex, kdefineProperty_stringRootIndex, kdeleteProperty_stringRootIndex, kdisplay_name_stringRootIndex, kdone_stringRootIndex, kdot_result_stringRootIndex, kdot_stringRootIndex, kentries_stringRootIndex, kenumerable_stringRootIndex, kError_stringRootIndex, keval_stringRootIndex, kfalse_stringRootIndex, kfloat32x4_stringRootIndex, kFloat32x4_stringRootIndex, kfor_api_stringRootIndex, kfor_stringRootIndex, kfunction_stringRootIndex, kFunction_stringRootIndex, kGenerator_stringRootIndex, kgetOwnPropertyDescriptor_stringRootIndex, kgetOwnPropertyDescriptors_stringRootIndex, kgetPrototypeOf_stringRootIndex, kget_stringRootIndex, kglobal_stringRootIndex, khas_stringRootIndex, killegal_access_stringRootIndex, killegal_argument_stringRootIndex, kindex_stringRootIndex, kinfinity_stringRootIndex, kinput_stringRootIndex, kint16x8_stringRootIndex, kInt16x8_stringRootIndex, kint32x4_stringRootIndex, kInt32x4_stringRootIndex, kint8x16_stringRootIndex, kInt8x16_stringRootIndex, kisExtensible_stringRootIndex, kisView_stringRootIndex, kKeyedLoadMonomorphic_stringRootIndex, kKeyedStoreMonomorphic_stringRootIndex, klast_index_stringRootIndex, klength_stringRootIndex, kMap_stringRootIndex, kminus_infinity_stringRootIndex, kminus_zero_stringRootIndex, kname_stringRootIndex, knan_stringRootIndex, knext_stringRootIndex, knull_stringRootIndex, knull_to_stringRootIndex, knumber_stringRootIndex, kNumber_stringRootIndex, kobject_stringRootIndex, kObject_stringRootIndex, kownKeys_stringRootIndex, kpreventExtensions_stringRootIndex, kprivate_api_stringRootIndex, kPromise_stringRootIndex, kproto_stringRootIndex, kprototype_stringRootIndex, kProxy_stringRootIndex, kquery_colon_stringRootIndex, kRegExp_stringRootIndex, ksetPrototypeOf_stringRootIndex, kset_stringRootIndex, kSet_stringRootIndex, ksource_mapping_url_stringRootIndex, ksource_stringRootIndex, ksource_url_stringRootIndex, kstack_stringRootIndex, kstrict_compare_ic_stringRootIndex, kstring_stringRootIndex, kString_stringRootIndex, ksymbol_stringRootIndex, kSymbol_stringRootIndex, kthis_stringRootIndex, kthrow_stringRootIndex, ktoJSON_stringRootIndex, ktoString_stringRootIndex, ktrue_stringRootIndex, kuint16x8_stringRootIndex, kUint16x8_stringRootIndex, kuint32x4_stringRootIndex, kUint32x4_stringRootIndex, kuint8x16_stringRootIndex, kUint8x16_stringRootIndex, kundefined_stringRootIndex, kundefined_to_stringRootIndex, kvalueOf_stringRootIndex, kvalues_stringRootIndex, kvalue_stringRootIndex, kWeakMap_stringRootIndex, kWeakSet_stringRootIndex, kwritable_stringRootIndex,



            karray_iteration_kind_symbolRootIndex, karray_iterator_next_symbolRootIndex, karray_iterator_object_symbolRootIndex, kcall_site_function_symbolRootIndex, kcall_site_position_symbolRootIndex, kcall_site_receiver_symbolRootIndex, kcall_site_strict_symbolRootIndex, kclass_end_position_symbolRootIndex, kclass_start_position_symbolRootIndex, kdetailed_stack_trace_symbolRootIndex, kelements_transition_symbolRootIndex, kerror_end_pos_symbolRootIndex, kerror_script_symbolRootIndex, kerror_start_pos_symbolRootIndex, kformatted_stack_trace_symbolRootIndex, kfrozen_symbolRootIndex, khash_code_symbolRootIndex, khidden_properties_symbolRootIndex, khome_object_symbolRootIndex, kinternal_error_symbolRootIndex, kintl_impl_object_symbolRootIndex, kintl_initialized_marker_symbolRootIndex, kintl_pattern_symbolRootIndex, kintl_resolved_symbolRootIndex, kmegamorphic_symbolRootIndex, knative_context_index_symbolRootIndex, knonexistent_symbolRootIndex, knonextensible_symbolRootIndex, knormal_ic_symbolRootIndex, knot_mapped_symbolRootIndex, kobserved_symbolRootIndex, kpremonomorphic_symbolRootIndex, kpromise_combined_deferred_symbolRootIndex, kpromise_debug_marker_symbolRootIndex, kpromise_has_handler_symbolRootIndex, kpromise_on_resolve_symbolRootIndex, kpromise_on_reject_symbolRootIndex, kpromise_raw_symbolRootIndex, kpromise_status_symbolRootIndex, kpromise_value_symbolRootIndex, ksealed_symbolRootIndex, kstack_trace_symbolRootIndex, kstrict_function_transition_symbolRootIndex, kstring_iterator_iterated_string_symbolRootIndex, kstring_iterator_next_index_symbolRootIndex, kuninitialized_symbolRootIndex,



                kiterator_symbolRootIndex, kmatch_symbolRootIndex, kreplace_symbolRootIndex, ksearch_symbolRootIndex, kspecies_symbolRootIndex, ksplit_symbolRootIndex, kto_primitive_symbolRootIndex, kunscopables_symbolRootIndex,
                    khas_instance_symbolRootIndex, kis_concat_spreadable_symbolRootIndex, kto_string_tag_symbolRootIndex,




                        kBoxMapRootIndex, kAccessorInfoMapRootIndex, kAccessorPairMapRootIndex, kAccessCheckInfoMapRootIndex, kInterceptorInfoMapRootIndex, kCallHandlerInfoMapRootIndex, kFunctionTemplateInfoMapRootIndex, kObjectTemplateInfoMapRootIndex, kScriptMapRootIndex, kAllocationSiteMapRootIndex, kAllocationMementoMapRootIndex, kCodeCacheMapRootIndex, kPolymorphicCodeCacheMapRootIndex, kTypeFeedbackInfoMapRootIndex, kAliasedArgumentsEntryMapRootIndex, kDebugInfoMapRootIndex, kBreakPointInfoMapRootIndex, kPrototypeInfoMapRootIndex, kSloppyBlockWithEvalContextExtensionMapRootIndex,

                            kStringTableRootIndex,


    kStackLimitRootIndex, kRealStackLimitRootIndex, kLastScriptIdRootIndex, kArgumentsAdaptorDeoptPCOffsetRootIndex, kConstructStubDeoptPCOffsetRootIndex, kGetterStubDeoptPCOffsetRootIndex, kSetterStubDeoptPCOffsetRootIndex,

        kRootListLength,
    kStrongRootListLength = kStringTableRootIndex,
    kSmiRootsStart = kStringTableRootIndex + 1
  };

  enum FindMementoMode { kForRuntime, kForGC };

  enum HeapState { NOT_IN_GC, SCAVENGE, MARK_COMPACT };





  enum InvocationMode { SEQUENTIAL_TO_SWEEPER, CONCURRENT_TO_SWEEPER };

  enum UpdateAllocationSiteMode { kGlobal, kCached };



  class RelocationLock {
   public:
    explicit RelocationLock(Heap* heap) : heap_(heap) {
      heap_->relocation_mutex_.Lock();
    }

    ~RelocationLock() { heap_->relocation_mutex_.Unlock(); }

   private:
    Heap* heap_;
  };



  struct Chunk {
    uint32_t size;
    Address start;
    Address end;
  };
  typedef List<Chunk> Reservation;

  static const intptr_t kMinimumOldGenerationAllocationLimit =
      8 * (Page::kPageSize > MB ? Page::kPageSize : MB);

  static const int kInitalOldGenerationLimitFactor = 2;






  static const int kPointerMultiplier = i::kPointerSize / 4;



  static const int kMaxSemiSpaceSizeLowMemoryDevice = 1 * kPointerMultiplier;
  static const int kMaxSemiSpaceSizeMediumMemoryDevice = 4 * kPointerMultiplier;
  static const int kMaxSemiSpaceSizeHighMemoryDevice = 8 * kPointerMultiplier;
  static const int kMaxSemiSpaceSizeHugeMemoryDevice = 8 * kPointerMultiplier;



  static const int kMaxOldSpaceSizeLowMemoryDevice = 128 * kPointerMultiplier;
  static const int kMaxOldSpaceSizeMediumMemoryDevice =
      256 * kPointerMultiplier;
  static const int kMaxOldSpaceSizeHighMemoryDevice = 512 * kPointerMultiplier;
  static const int kMaxOldSpaceSizeHugeMemoryDevice = 700 * kPointerMultiplier;



  static const int kMaxExecutableSizeLowMemoryDevice = 96 * kPointerMultiplier;
  static const int kMaxExecutableSizeMediumMemoryDevice =
      192 * kPointerMultiplier;
  static const int kMaxExecutableSizeHighMemoryDevice =
      256 * kPointerMultiplier;
  static const int kMaxExecutableSizeHugeMemoryDevice =
      256 * kPointerMultiplier;

  static const int kTraceRingBufferSize = 512;
  static const int kStacktraceBufferSize = 512;

  static const double kMinHeapGrowingFactor;
  static const double kMaxHeapGrowingFactor;
  static const double kMaxHeapGrowingFactorMemoryConstrained;
  static const double kMaxHeapGrowingFactorIdle;
  static const double kTargetMutatorUtilization;

  static const int kNoGCFlags = 0;
  static const int kReduceMemoryFootprintMask = 1;
  static const int kAbortIncrementalMarkingMask = 2;
  static const int kFinalizeIncrementalMarkingMask = 4;


  static const int kMakeHeapIterableMask = kAbortIncrementalMarkingMask;


  static const int kOldSpaceRoots = 0x20;


  static const int kMinObjectSizeInWords = 2;

  static_assert(kUndefinedValueRootIndex == Internals::kUndefinedValueRootIndex, "kUndefinedValueRootIndex == Internals::kUndefinedValueRootIndex");

  static_assert(kNullValueRootIndex == Internals::kNullValueRootIndex, "kNullValueRootIndex == Internals::kNullValueRootIndex");
  static_assert(kTrueValueRootIndex == Internals::kTrueValueRootIndex, "kTrueValueRootIndex == Internals::kTrueValueRootIndex");
  static_assert(kFalseValueRootIndex == Internals::kFalseValueRootIndex, "kFalseValueRootIndex == Internals::kFalseValueRootIndex");
  static_assert(kempty_stringRootIndex == Internals::kEmptyStringRootIndex, "kempty_stringRootIndex == Internals::kEmptyStringRootIndex");



  static int GetMaximumFillToAlign(AllocationAlignment alignment);


  static int GetFillToAlign(Address address, AllocationAlignment alignment);

  template <typename T>
  static inline bool IsOneByte(T t, int chars);

  static void FatalProcessOutOfMemory(const char* location,
                                      bool take_snapshot = false);

  static bool RootIsImmortalImmovable(int root_index);


  static bool IsValidAllocationSpace(AllocationSpace space);



  static bool RootCanBeWrittenAfterInitialization(RootListIndex root_index);


  static inline bool ShouldZapGarbage() {

    return true;







  }

  static double HeapGrowingFactor(double gc_speed, double mutator_speed);



  static inline void CopyBlock(Address dst, Address src, int byte_size);



  static int GetStaticVisitorIdForMap(Map* map);



  void NotifyDeserializationComplete();

  intptr_t old_generation_allocation_limit() const {
    return old_generation_allocation_limit_;
  }

  bool always_allocate() { return always_allocate_scope_count_.Value() != 0; }

  Address* NewSpaceAllocationTopAddress() {
    return new_space_.allocation_top_address();
  }
  Address* NewSpaceAllocationLimitAddress() {
    return new_space_.allocation_limit_address();
  }

  Address* OldSpaceAllocationTopAddress() {
    return old_space_->allocation_top_address();
  }
  Address* OldSpaceAllocationLimitAddress() {
    return old_space_->allocation_limit_address();
  }



  bool CanExpandOldGeneration(int size = 0) {
    if (force_oom_) return false;
    return (CommittedOldGenerationMemory() + size) < MaxOldGenerationSize();
  }


  inline void ClearInstanceofCache();


  void RepairFreeListsAfterDeserialization();



  void MoveElements(FixedArray* array, int dst_index, int src_index, int len);





  void CreateFillerObjectAt(Address addr, int size, ClearRecordedSlots mode);

  bool CanMoveObjectStart(HeapObject* object);


  void AdjustLiveBytes(HeapObject* object, int by, InvocationMode mode);



  FixedArrayBase* LeftTrimFixedArray(FixedArrayBase* obj, int elements_to_trim);


  template<Heap::InvocationMode mode>
  void RightTrimFixedArray(FixedArrayBase* obj, int elements_to_trim);


  inline Oddball* ToBoolean(bool condition);


  bool IsHeapIterable();


  int NotifyContextDisposed(bool dependant_context);

  void set_native_contexts_list(Object* object) {
    native_contexts_list_ = object;
  }
  Object* native_contexts_list() const { return native_contexts_list_; }

  void set_allocation_sites_list(Object* object) {
    allocation_sites_list_ = object;
  }
  Object* allocation_sites_list() { return allocation_sites_list_; }


  Object** allocation_sites_list_address() { return &allocation_sites_list_; }

  void set_encountered_weak_collections(Object* weak_collection) {
    encountered_weak_collections_ = weak_collection;
  }
  Object* encountered_weak_collections() const {
    return encountered_weak_collections_;
  }

  void set_encountered_weak_cells(Object* weak_cell) {
    encountered_weak_cells_ = weak_cell;
  }
  Object* encountered_weak_cells() const { return encountered_weak_cells_; }

  void set_encountered_transition_arrays(Object* transition_array) {
    encountered_transition_arrays_ = transition_array;
  }
  Object* encountered_transition_arrays() const {
    return encountered_transition_arrays_;
  }


  int ms_count() const { return ms_count_; }



  inline bool AllowedToBeMigrated(HeapObject* object, AllocationSpace dest);

  void CheckHandleCount();


  uint32_t allocations_count() { return allocations_count_; }


  void PrintShortHeapStatistics();

  inline HeapState gc_state() { return gc_state_; }

  inline bool IsInGCPostProcessing() { return gc_post_processing_depth_ > 0; }



  template <FindMementoMode mode>
  inline AllocationMemento* FindAllocationMemento(HeapObject* object);


  bool ReserveSpace(Reservation* reservations);





  void CreateApiObjects();


  bool IdleNotification(double deadline_in_seconds);
  bool IdleNotification(int idle_time_in_ms);

  void MemoryPressureNotification(MemoryPressureLevel level,
                                  bool is_isolate_locked);
  void CheckMemoryPressure();

  double MonotonicallyIncreasingTimeInMs();

  void RecordStats(HeapStats* stats, bool take_snapshot = false);


  void CheckNewSpaceExpansionCriteria();

  inline bool HeapIsFullEnoughToStartIncrementalMarking(intptr_t limit) {
    if (FLAG_stress_compaction && (gc_count_ & 1) != 0) return true;

    intptr_t adjusted_allocation_limit = limit - new_space_.Capacity();

    if (PromotedTotalSize() >= adjusted_allocation_limit) return true;

    if (HighMemoryPressure()) return true;

    return false;
  }

  void VisitExternalResources(v8::ExternalResourceVisitor* visitor);



  inline bool ShouldBePromoted(Address old_address, int object_size);

  void ClearNormalizedMapCaches();

  void IncrementDeferredCount(v8::Isolate::UseCounterFeature feature);

  inline bool OldGenerationAllocationLimitReached();

  void QueueMemoryChunkForFree(MemoryChunk* chunk);
  void FreeQueuedChunks(MemoryChunk* list_head);
  void FreeQueuedChunks();
  void WaitUntilUnmappingOfFreeChunksCompleted();



  inline void CompletelyClearInstanceofCache();

  inline uint32_t HashSeed();

  inline int NextScriptId();

  inline void SetArgumentsAdaptorDeoptPCOffset(int pc_offset);
  inline void SetConstructStubDeoptPCOffset(int pc_offset);
  inline void SetGetterStubDeoptPCOffset(int pc_offset);
  inline void SetSetterStubDeoptPCOffset(int pc_offset);


  void RememberUnmappedPage(Address page, bool compacted);



  int global_ic_age() { return global_ic_age_; }

  void AgeInlineCaches() {
    global_ic_age_ = (global_ic_age_ + 1) & SharedFunctionInfo::ICAgeBits::kMax;
  }

  int64_t amount_of_external_allocated_memory() {
    return amount_of_external_allocated_memory_;
  }

  void update_amount_of_external_allocated_memory(int64_t delta) {
    amount_of_external_allocated_memory_ += delta;
  }

  void DeoptMarkedAllocationSites();

  bool DeoptMaybeTenuredAllocationSites() {
    return new_space_.IsAtMaximumCapacity() && maximum_size_scavenges_ == 0;
  }

  void AddWeakObjectToCodeDependency(Handle<HeapObject> obj,
                                     Handle<DependentCode> dep);

  DependentCode* LookupWeakObjectToCodeDependency(Handle<HeapObject> obj);

  void AddRetainedMap(Handle<Map> map);





  inline void OnAllocationEvent(HeapObject* object, int size_in_bytes);


  inline void OnMoveEvent(HeapObject* target, HeapObject* source,
                          int size_in_bytes);

  bool deserialization_complete() const { return deserialization_complete_; }

  bool HasLowAllocationRate();
  bool HasHighFragmentation();
  bool HasHighFragmentation(intptr_t used, intptr_t committed);

  void SetOptimizeForLatency() { optimize_for_memory_usage_ = false; }
  void SetOptimizeForMemoryUsage();
  bool ShouldOptimizeForMemoryUsage() {
    return optimize_for_memory_usage_ || HighMemoryPressure();
  }
  bool HighMemoryPressure() {
    return memory_pressure_level_.Value() != MemoryPressureLevel::kNone;
  }







  bool ConfigureHeap(int max_semi_space_size, int max_old_space_size,
                     int max_executable_size, size_t code_range_size);
  bool ConfigureHeapDefault();



  bool SetUp();



  bool CreateHeapObjects();


  void TearDown();


  bool HasBeenSetUp();





  Address NewSpaceTop() { return new_space_.top(); }

  NewSpace* new_space() { return &new_space_; }
  OldSpace* old_space() { return old_space_; }
  OldSpace* code_space() { return code_space_; }
  MapSpace* map_space() { return map_space_; }
  LargeObjectSpace* lo_space() { return lo_space_; }

  PagedSpace* paged_space(int idx) {
    switch (idx) {
      case OLD_SPACE:
        return old_space();
      case MAP_SPACE:
        return map_space();
      case CODE_SPACE:
        return code_space();
      case NEW_SPACE:
      case LO_SPACE:
        V8_Fatal(".././src/heap/heap.h", 898, "unreachable code");
    }
    return 0;
  }

  Space* space(int idx) {
    switch (idx) {
      case NEW_SPACE:
        return new_space();
      case LO_SPACE:
        return lo_space();
      default:
        return paged_space(idx);
    }
  }


  const char* GetSpaceName(int idx);





  void SetEmbedderHeapTracer(EmbedderHeapTracer* tracer);

  void RegisterExternallyReferencedObject(Object** object);





  GCTracer* tracer() { return tracer_; }

  EmbedderHeapTracer* embedder_heap_tracer() { return embedder_heap_tracer_; }

  PromotionQueue* promotion_queue() { return &promotion_queue_; }

  inline Isolate* isolate();

  MarkCompactCollector* mark_compact_collector() {
    return mark_compact_collector_;
  }







  inline Map* byte_array_map(); inline Map* free_space_map(); inline Map* one_pointer_filler_map(); inline Map* two_pointer_filler_map(); inline Oddball* undefined_value(); inline Oddball* the_hole_value(); inline Oddball* null_value(); inline Oddball* true_value(); inline Oddball* false_value(); inline String* empty_string(); inline Oddball* uninitialized_value(); inline Map* cell_map(); inline Map* global_property_cell_map(); inline Map* shared_function_info_map(); inline Map* meta_map(); inline Map* heap_number_map(); inline Map* mutable_heap_number_map(); inline Map* float32x4_map(); inline Map* int32x4_map(); inline Map* uint32x4_map(); inline Map* bool32x4_map(); inline Map* int16x8_map(); inline Map* uint16x8_map(); inline Map* bool16x8_map(); inline Map* int8x16_map(); inline Map* uint8x16_map(); inline Map* bool8x16_map(); inline Map* native_context_map(); inline Map* fixed_array_map(); inline Map* code_map(); inline Map* scope_info_map(); inline Map* fixed_cow_array_map(); inline Map* fixed_double_array_map(); inline Map* weak_cell_map(); inline Map* transition_array_map(); inline Map* one_byte_string_map(); inline Map* one_byte_internalized_string_map(); inline Map* function_context_map(); inline FixedArray* empty_fixed_array(); inline ByteArray* empty_byte_array(); inline DescriptorArray* empty_descriptor_array(); inline Oddball* no_interceptor_result_sentinel(); inline Oddball* arguments_marker(); inline Oddball* exception(); inline Oddball* termination_exception(); inline Oddball* optimized_out(); inline FixedArray* number_string_cache(); inline Object* instanceof_cache_function(); inline Object* instanceof_cache_map(); inline Object* instanceof_cache_answer(); inline FixedArray* single_character_string_cache(); inline FixedArray* string_split_cache(); inline FixedArray* regexp_multiple_cache(); inline Smi* hash_seed(); inline Map* hash_table_map(); inline Map* ordered_hash_table_map(); inline Map* symbol_map(); inline Map* string_map(); inline Map* cons_one_byte_string_map(); inline Map* cons_string_map(); inline Map* sliced_string_map(); inline Map* sliced_one_byte_string_map(); inline Map* external_string_map(); inline Map* external_string_with_one_byte_data_map(); inline Map* external_one_byte_string_map(); inline Map* native_source_string_map(); inline Map* short_external_string_map(); inline Map* short_external_string_with_one_byte_data_map(); inline Map* internalized_string_map(); inline Map* external_internalized_string_map(); inline Map* external_internalized_string_with_one_byte_data_map(); inline Map* external_one_byte_internalized_string_map(); inline Map* short_external_internalized_string_map(); inline Map* short_external_internalized_string_with_one_byte_data_map(); inline Map* short_external_one_byte_internalized_string_map(); inline Map* short_external_one_byte_string_map(); inline Map* fixed_uint8_array_map(); inline Map* fixed_int8_array_map(); inline Map* fixed_uint16_array_map(); inline Map* fixed_int16_array_map(); inline Map* fixed_uint32_array_map(); inline Map* fixed_int32_array_map(); inline Map* fixed_float32_array_map(); inline Map* fixed_float64_array_map(); inline Map* fixed_uint8_clamped_array_map(); inline FixedTypedArrayBase* empty_fixed_uint8_array(); inline FixedTypedArrayBase* empty_fixed_int8_array(); inline FixedTypedArrayBase* empty_fixed_uint16_array(); inline FixedTypedArrayBase* empty_fixed_int16_array(); inline FixedTypedArrayBase* empty_fixed_uint32_array(); inline FixedTypedArrayBase* empty_fixed_int32_array(); inline FixedTypedArrayBase* empty_fixed_float32_array(); inline FixedTypedArrayBase* empty_fixed_float64_array(); inline FixedTypedArrayBase* empty_fixed_uint8_clamped_array(); inline Map* sloppy_arguments_elements_map(); inline Map* catch_context_map(); inline Map* with_context_map(); inline Map* debug_evaluate_context_map(); inline Map* block_context_map(); inline Map* module_context_map(); inline Map* script_context_map(); inline Map* script_context_table_map(); inline Map* undefined_map(); inline Map* the_hole_map(); inline Map* null_map(); inline Map* boolean_map(); inline Map* uninitialized_map(); inline Map* arguments_marker_map(); inline Map* no_interceptor_result_sentinel_map(); inline Map* exception_map(); inline Map* termination_exception_map(); inline Map* optimized_out_map(); inline Map* message_object_map(); inline Map* foreign_map(); inline Map* neander_map(); inline Map* external_map(); inline HeapNumber* nan_value(); inline HeapNumber* infinity_value(); inline HeapNumber* minus_zero_value(); inline HeapNumber* minus_infinity_value(); inline JSObject* message_listeners(); inline UnseededNumberDictionary* code_stubs(); inline UnseededNumberDictionary* non_monomorphic_cache(); inline PolymorphicCodeCache* polymorphic_code_cache(); inline Code* js_entry_code(); inline Code* js_construct_entry_code(); inline FixedArray* natives_source_cache(); inline FixedArray* experimental_natives_source_cache(); inline FixedArray* extra_natives_source_cache(); inline FixedArray* experimental_extra_natives_source_cache(); inline Script* empty_script(); inline NameDictionary* intrinsic_function_names(); inline NameDictionary* empty_properties_dictionary(); inline Cell* undefined_cell(); inline JSObject* observation_state(); inline Object* symbol_registry(); inline Object* script_list(); inline SeededNumberDictionary* empty_slow_element_dictionary(); inline FixedArray* materialized_objects(); inline FixedArray* microtask_queue(); inline TypeFeedbackVector* dummy_vector(); inline FixedArray* cleared_optimized_code_map(); inline FixedArray* detached_contexts(); inline ArrayList* retained_maps(); inline WeakHashTable* weak_object_to_code_table(); inline PropertyCell* array_protector(); inline PropertyCell* empty_property_cell(); inline Object* weak_stack_trace_list(); inline Object* noscript_shared_function_infos(); inline Map* bytecode_array_map(); inline WeakCell* empty_weak_cell(); inline PropertyCell* species_protector(); inline Smi* stack_limit(); inline Smi* real_stack_limit(); inline Smi* last_script_id(); inline Smi* arguments_adaptor_deopt_pc_offset(); inline Smi* construct_stub_deopt_pc_offset(); inline Smi* getter_stub_deopt_pc_offset(); inline Smi* setter_stub_deopt_pc_offset(); inline StringTable* string_table();




  inline Map* box_map(); inline Map* accessor_info_map(); inline Map* accessor_pair_map(); inline Map* access_check_info_map(); inline Map* interceptor_info_map(); inline Map* call_handler_info_map(); inline Map* function_template_info_map(); inline Map* object_template_info_map(); inline Map* script_map(); inline Map* allocation_site_map(); inline Map* allocation_memento_map(); inline Map* code_cache_map(); inline Map* polymorphic_code_cache_map(); inline Map* type_feedback_info_map(); inline Map* aliased_arguments_entry_map(); inline Map* debug_info_map(); inline Map* break_point_info_map(); inline Map* prototype_info_map(); inline Map* sloppy_block_with_eval_context_extension_map();



  inline String* anonymous_string(); inline String* apply_string(); inline String* assign_string(); inline String* arguments_string(); inline String* Arguments_string(); inline String* Array_string(); inline String* bind_string(); inline String* bool16x8_string(); inline String* Bool16x8_string(); inline String* bool32x4_string(); inline String* Bool32x4_string(); inline String* bool8x16_string(); inline String* Bool8x16_string(); inline String* boolean_string(); inline String* Boolean_string(); inline String* bound__string(); inline String* byte_length_string(); inline String* byte_offset_string(); inline String* call_string(); inline String* callee_string(); inline String* caller_string(); inline String* cell_value_string(); inline String* char_at_string(); inline String* closure_string(); inline String* compare_ic_string(); inline String* configurable_string(); inline String* constructor_string(); inline String* construct_string(); inline String* create_string(); inline String* Date_string(); inline String* default_string(); inline String* defineProperty_string(); inline String* deleteProperty_string(); inline String* display_name_string(); inline String* done_string(); inline String* dot_result_string(); inline String* dot_string(); inline String* entries_string(); inline String* enumerable_string(); inline String* Error_string(); inline String* eval_string(); inline String* false_string(); inline String* float32x4_string(); inline String* Float32x4_string(); inline String* for_api_string(); inline String* for_string(); inline String* function_string(); inline String* Function_string(); inline String* Generator_string(); inline String* getOwnPropertyDescriptor_string(); inline String* getOwnPropertyDescriptors_string(); inline String* getPrototypeOf_string(); inline String* get_string(); inline String* global_string(); inline String* has_string(); inline String* illegal_access_string(); inline String* illegal_argument_string(); inline String* index_string(); inline String* infinity_string(); inline String* input_string(); inline String* int16x8_string(); inline String* Int16x8_string(); inline String* int32x4_string(); inline String* Int32x4_string(); inline String* int8x16_string(); inline String* Int8x16_string(); inline String* isExtensible_string(); inline String* isView_string(); inline String* KeyedLoadMonomorphic_string(); inline String* KeyedStoreMonomorphic_string(); inline String* last_index_string(); inline String* length_string(); inline String* Map_string(); inline String* minus_infinity_string(); inline String* minus_zero_string(); inline String* name_string(); inline String* nan_string(); inline String* next_string(); inline String* null_string(); inline String* null_to_string(); inline String* number_string(); inline String* Number_string(); inline String* object_string(); inline String* Object_string(); inline String* ownKeys_string(); inline String* preventExtensions_string(); inline String* private_api_string(); inline String* Promise_string(); inline String* proto_string(); inline String* prototype_string(); inline String* Proxy_string(); inline String* query_colon_string(); inline String* RegExp_string(); inline String* setPrototypeOf_string(); inline String* set_string(); inline String* Set_string(); inline String* source_mapping_url_string(); inline String* source_string(); inline String* source_url_string(); inline String* stack_string(); inline String* strict_compare_ic_string(); inline String* string_string(); inline String* String_string(); inline String* symbol_string(); inline String* Symbol_string(); inline String* this_string(); inline String* throw_string(); inline String* toJSON_string(); inline String* toString_string(); inline String* true_string(); inline String* uint16x8_string(); inline String* Uint16x8_string(); inline String* uint32x4_string(); inline String* Uint32x4_string(); inline String* uint8x16_string(); inline String* Uint8x16_string(); inline String* undefined_string(); inline String* undefined_to_string(); inline String* valueOf_string(); inline String* values_string(); inline String* value_string(); inline String* WeakMap_string(); inline String* WeakSet_string(); inline String* writable_string();



  inline Symbol* array_iteration_kind_symbol(); inline Symbol* array_iterator_next_symbol(); inline Symbol* array_iterator_object_symbol(); inline Symbol* call_site_function_symbol(); inline Symbol* call_site_position_symbol(); inline Symbol* call_site_receiver_symbol(); inline Symbol* call_site_strict_symbol(); inline Symbol* class_end_position_symbol(); inline Symbol* class_start_position_symbol(); inline Symbol* detailed_stack_trace_symbol(); inline Symbol* elements_transition_symbol(); inline Symbol* error_end_pos_symbol(); inline Symbol* error_script_symbol(); inline Symbol* error_start_pos_symbol(); inline Symbol* formatted_stack_trace_symbol(); inline Symbol* frozen_symbol(); inline Symbol* hash_code_symbol(); inline Symbol* hidden_properties_symbol(); inline Symbol* home_object_symbol(); inline Symbol* internal_error_symbol(); inline Symbol* intl_impl_object_symbol(); inline Symbol* intl_initialized_marker_symbol(); inline Symbol* intl_pattern_symbol(); inline Symbol* intl_resolved_symbol(); inline Symbol* megamorphic_symbol(); inline Symbol* native_context_index_symbol(); inline Symbol* nonexistent_symbol(); inline Symbol* nonextensible_symbol(); inline Symbol* normal_ic_symbol(); inline Symbol* not_mapped_symbol(); inline Symbol* observed_symbol(); inline Symbol* premonomorphic_symbol(); inline Symbol* promise_combined_deferred_symbol(); inline Symbol* promise_debug_marker_symbol(); inline Symbol* promise_has_handler_symbol(); inline Symbol* promise_on_resolve_symbol(); inline Symbol* promise_on_reject_symbol(); inline Symbol* promise_raw_symbol(); inline Symbol* promise_status_symbol(); inline Symbol* promise_value_symbol(); inline Symbol* sealed_symbol(); inline Symbol* stack_trace_symbol(); inline Symbol* strict_function_transition_symbol(); inline Symbol* string_iterator_iterated_string_symbol(); inline Symbol* string_iterator_next_index_symbol(); inline Symbol* uninitialized_symbol();



  inline Symbol* iterator_symbol(); inline Symbol* match_symbol(); inline Symbol* replace_symbol(); inline Symbol* search_symbol(); inline Symbol* species_symbol(); inline Symbol* split_symbol(); inline Symbol* to_primitive_symbol(); inline Symbol* unscopables_symbol();
  inline Symbol* has_instance_symbol(); inline Symbol* is_concat_spreadable_symbol(); inline Symbol* to_string_tag_symbol();


  Object* root(RootListIndex index) { return roots_[index]; }
  Handle<Object> root_handle(RootListIndex index) {
    return Handle<Object>(&roots_[index]);
  }


  Object** roots_array_start() { return roots_; }


  void SetRootCodeStubs(UnseededNumberDictionary* value) {
    roots_[kCodeStubsRootIndex] = value;
  }


  void SetRootNonMonomorphicCache(UnseededNumberDictionary* value) {
    roots_[kNonMonomorphicCacheRootIndex] = value;
  }

  void SetRootMaterializedObjects(FixedArray* objects) {
    roots_[kMaterializedObjectsRootIndex] = objects;
  }

  void SetRootScriptList(Object* value) {
    roots_[kScriptListRootIndex] = value;
  }

  void SetRootStringTable(StringTable* value) {
    roots_[kStringTableRootIndex] = value;
  }

  void SetRootNoScriptSharedFunctionInfos(Object* value) {
    roots_[kNoScriptSharedFunctionInfosRootIndex] = value;
  }




  void SetStackLimits();



  void ClearStackLimits();


  bool RootCanBeTreatedAsConstant(RootListIndex root_index);

  Map* MapForFixedTypedArray(ExternalArrayType array_type);
  RootListIndex RootIndexForFixedTypedArray(ExternalArrayType array_type);

  RootListIndex RootIndexForEmptyFixedTypedArray(ElementsKind kind);
  FixedTypedArrayBase* EmptyFixedTypedArrayForMap(Map* map);

  void RegisterStrongRoots(Object** start, Object** end);
  void UnregisterStrongRoots(Object** start);






  bool inline_allocation_disabled() { return inline_allocation_disabled_; }


  void EnableInlineAllocation();
  void DisableInlineAllocation();
  inline bool CollectGarbage(
      AllocationSpace space, const char* gc_reason = 0,
      const GCCallbackFlags gc_callback_flags = kNoGCCallbackFlags);




  void CollectAllGarbage(
      int flags = kFinalizeIncrementalMarkingMask, const char* gc_reason = 0,
      const GCCallbackFlags gc_callback_flags = kNoGCCallbackFlags);


  void CollectAllAvailableGarbage(const char* gc_reason = 0);



  void ReportExternalMemoryPressure(const char* gc_reason = 0);


  void HandleGCRequest();






  void IterateRoots(ObjectVisitor* v, VisitMode mode);

  void IterateStrongRoots(ObjectVisitor* v, VisitMode mode);


  void IterateSmiRoots(ObjectVisitor* v);

  void IterateWeakRoots(ObjectVisitor* v, VisitMode mode);


  void IteratePromotedObject(HeapObject* target, int size,
                             bool was_marked_black,
                             ObjectSlotCallback callback);

  void IteratePromotedObjectPointers(HeapObject* object, Address start,
                                     Address end, bool record_slots,
                                     ObjectSlotCallback callback);






  inline void RecordWrite(Object* object, int offset, Object* o);

  Address* store_buffer_top_address() { return store_buffer()->top_address(); }

  void ClearRecordedSlot(HeapObject* object, Object** slot);
  void ClearRecordedSlotRange(Address start, Address end);







  void StartIdleIncrementalMarking();



  void StartIncrementalMarking(int gc_flags = kNoGCFlags,
                               const GCCallbackFlags gc_callback_flags =
                                   GCCallbackFlags::kNoGCCallbackFlags,
                               const char* reason = nullptr);

  void FinalizeIncrementalMarkingIfComplete(const char* comment);

  bool TryFinalizeIdleIncrementalMarking(double idle_time_in_ms);

  void RegisterReservationsForBlackAllocation(Reservation* reservations);

  IncrementalMarking* incremental_marking() { return incremental_marking_; }






  inline void RegisterExternalString(String* string);



  inline void FinalizeExternalString(String* string);






  inline bool InNewSpace(Object* object);
  inline bool InFromSpace(Object* object);
  inline bool InToSpace(Object* object);


  inline bool InOldSpace(Object* object);



  bool Contains(HeapObject* value);



  bool InSpace(HeapObject* value, AllocationSpace space);



  bool ContainsSlow(Address addr);
  bool InSpaceSlow(Address addr, AllocationSpace space);
  inline bool InNewSpaceSlow(Address address);
  inline bool InOldSpaceSlow(Address address);
  size_t NumberOfTrackedHeapObjectTypes();




  size_t ObjectCountAtLastGC(size_t index);
  size_t ObjectSizeAtLastGC(size_t index);


  bool GetObjectTypeName(size_t index, const char** object_type,
                         const char** object_sub_type);






  intptr_t MaxReserved() {
    return 2 * max_semi_space_size_ + max_old_generation_size_;
  }
  int MaxSemiSpaceSize() { return max_semi_space_size_; }
  int InitialSemiSpaceSize() { return initial_semispace_size_; }
  intptr_t MaxOldGenerationSize() { return max_old_generation_size_; }
  intptr_t MaxExecutableSize() { return max_executable_size_; }



  intptr_t Capacity();


  intptr_t CommittedMemory();


  intptr_t CommittedOldGenerationMemory();


  intptr_t CommittedMemoryExecutable();


  size_t CommittedPhysicalMemory();


  intptr_t MaximumCommittedMemory() { return maximum_committed_; }



  void UpdateMaximumCommitted();




  intptr_t Available();


  intptr_t SizeOfObjects();

  void UpdateSurvivalStatistics(int start_new_space_size);

  inline void IncrementPromotedObjectsSize(intptr_t object_size) {
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (object_size), (0), "object_size" " " ">=" " " "0")) { V8_Fatal(".././src/heap/heap.h", 1224, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    promoted_objects_size_ += object_size;
  }
  inline intptr_t promoted_objects_size() { return promoted_objects_size_; }

  inline void IncrementSemiSpaceCopiedObjectSize(intptr_t object_size) {
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (object_size), (0), "object_size" " " ">=" " " "0")) { V8_Fatal(".././src/heap/heap.h", 1230, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    semi_space_copied_object_size_ += object_size;
  }
  inline intptr_t semi_space_copied_object_size() {
    return semi_space_copied_object_size_;
  }

  inline intptr_t SurvivedNewSpaceObjectSize() {
    return promoted_objects_size_ + semi_space_copied_object_size_;
  }

  inline void IncrementNodesDiedInNewSpace() { nodes_died_in_new_space_++; }

  inline void IncrementNodesCopiedInNewSpace() { nodes_copied_in_new_space_++; }

  inline void IncrementNodesPromoted() { nodes_promoted_++; }

  inline void IncrementYoungSurvivorsCounter(intptr_t survived) {
    do { if (std::string* _msg = ::v8::base::CheckGEImpl( (survived), (0), "survived" " " ">=" " " "0")) { V8_Fatal(".././src/heap/heap.h", 1248, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    survived_last_scavenge_ = survived;
    survived_since_last_expansion_ += survived;
  }

  inline intptr_t PromotedTotalSize() {
    int64_t total = PromotedSpaceSizeOfObjects() + PromotedExternalMemorySize();
    if (total > std::numeric_limits<intptr_t>::max()) {

      return std::numeric_limits<intptr_t>::max();
    }
    if (total < 0) return 0;
    return static_cast<intptr_t>(total);
  }

  void UpdateNewSpaceAllocationCounter() {
    new_space_allocation_counter_ = NewSpaceAllocationCounter();
  }

  size_t NewSpaceAllocationCounter() {
    return new_space_allocation_counter_ + new_space()->AllocatedSinceLastGC();
  }


  void set_new_space_allocation_counter(size_t new_value) {
    new_space_allocation_counter_ = new_value;
  }

  void UpdateOldGenerationAllocationCounter() {
    old_generation_allocation_counter_ = OldGenerationAllocationCounter();
  }

  size_t OldGenerationAllocationCounter() {
    return old_generation_allocation_counter_ + PromotedSinceLastGC();
  }


  void set_old_generation_allocation_counter(size_t new_value) {
    old_generation_allocation_counter_ = new_value;
  }

  size_t PromotedSinceLastGC() {
    return PromotedSpaceSizeOfObjects() - old_generation_size_at_last_gc_;
  }

  int gc_count() const { return gc_count_; }


  intptr_t PromotedSpaceSizeOfObjects();

  double total_regexp_code_generated() { return total_regexp_code_generated_; }
  void IncreaseTotalRegexpCodeGenerated(int size) {
    total_regexp_code_generated_ += size;
  }

  void IncrementCodeGeneratedBytes(bool is_crankshafted, int size) {
    if (is_crankshafted) {
      crankshaft_codegen_bytes_generated_ += size;
    } else {
      full_codegen_bytes_generated_ += size;
    }
  }





  void AddGCPrologueCallback(v8::Isolate::GCCallback callback,
                             GCType gc_type_filter, bool pass_isolate = true);
  void RemoveGCPrologueCallback(v8::Isolate::GCCallback callback);

  void AddGCEpilogueCallback(v8::Isolate::GCCallback callback,
                             GCType gc_type_filter, bool pass_isolate = true);
  void RemoveGCEpilogueCallback(v8::Isolate::GCCallback callback);

  void CallGCPrologueCallbacks(GCType gc_type, GCCallbackFlags flags);
  void CallGCEpilogueCallbacks(GCType gc_type, GCCallbackFlags flags);






  __attribute__((warn_unused_result)) HeapObject* PrecedeWithFiller(HeapObject* object,
                                                int filler_size);




  __attribute__((warn_unused_result)) HeapObject* AlignWithFiller(HeapObject* object,
                                              int object_size,
                                              int allocation_size,
                                              AllocationAlignment alignment);





  void RegisterNewArrayBuffer(JSArrayBuffer* buffer);
  void UnregisterArrayBuffer(JSArrayBuffer* buffer);

  inline ArrayBufferTracker* array_buffer_tracker() {
    return array_buffer_tracker_;
  }
  template <UpdateAllocationSiteMode mode>
  inline void UpdateAllocationSite(HeapObject* object,
                                   HashMap* pretenuring_feedback);


  inline void RemoveAllocationSitePretenuringFeedback(AllocationSite* site);




  void MergeAllocationSitePretenuringFeedback(
      const HashMap& local_pretenuring_feedback);





  void Verify();



  void set_allocation_timeout(int timeout) { allocation_timeout_ = timeout; }

  void TracePathToObjectFrom(Object* target, Object* root);
  void TracePathToObject(Object* target);
  void TracePathToGlobal();

  void Print();
  void PrintHandles();


  void ReportHeapStatistics(const char* title);
  void ReportCodeStatistics(const char* title);


  int CountHandlesForObject(Object* object);


 private:
  class PretenuringScope;
  class UnmapFreeMemoryTask;




  class ExternalStringTable {
   public:

    inline void AddString(String* string);

    inline void Iterate(ObjectVisitor* v);



    void CleanUp();


    void TearDown();

   private:
    explicit ExternalStringTable(Heap* heap) : heap_(heap) {}

    inline void Verify();

    inline void AddOldString(String* string);


    inline void ShrinkNewStrings(int position);



    List<Object*> new_space_strings_;
    List<Object*> old_space_strings_;

    Heap* heap_;

    friend class Heap;

    ExternalStringTable(const ExternalStringTable&) = delete; void operator=(const ExternalStringTable&) = delete;
  };

  struct StrongRootsList;

  struct StringTypeTable {
    InstanceType type;
    int size;
    RootListIndex index;
  };

  struct ConstantStringTable {
    const char* contents;
    RootListIndex index;
  };

  struct StructTable {
    InstanceType type;
    int size;
    RootListIndex index;
  };

  struct GCCallbackPair {
    GCCallbackPair(v8::Isolate::GCCallback callback, GCType gc_type,
                   bool pass_isolate)
        : callback(callback), gc_type(gc_type), pass_isolate(pass_isolate) {}

    bool operator==(const GCCallbackPair& other) const {
      return other.callback == callback;
    }

    v8::Isolate::GCCallback callback;
    GCType gc_type;
    bool pass_isolate;
  };

  typedef String* (*ExternalStringTableUpdaterCallback)(Heap* heap,
                                                        Object** pointer);

  static const int kInitialStringTableSize = 2048;
  static const int kInitialEvalCacheSize = 64;
  static const int kInitialNumberStringCacheSize = 256;

  static const int kRememberedUnmappedPages = 128;

  static const StringTypeTable string_type_table[];
  static const ConstantStringTable constant_string_table[];
  static const StructTable struct_table[];

  static const int kYoungSurvivalRateHighThreshold = 90;
  static const int kYoungSurvivalRateAllowedDeviation = 15;
  static const int kOldSurvivalRateLowThreshold = 10;

  static const int kMaxMarkCompactsInIdleRound = 7;
  static const int kIdleScavengeThreshold = 5;

  static const int kInitialFeedbackCapacity = 256;

  Heap();

  static String* UpdateNewSpaceReferenceInExternalStringTableEntry(
      Heap* heap, Object** pointer);


  static AllocationSpace SelectSpace(PretenureFlag pretenure) {
    return (pretenure == TENURED) ? OLD_SPACE : NEW_SPACE;
  }



  inline void set_byte_array_map(Map* value); inline void set_free_space_map(Map* value); inline void set_one_pointer_filler_map(Map* value); inline void set_two_pointer_filler_map(Map* value); inline void set_undefined_value(Oddball* value); inline void set_the_hole_value(Oddball* value); inline void set_null_value(Oddball* value); inline void set_true_value(Oddball* value); inline void set_false_value(Oddball* value); inline void set_empty_string(String* value); inline void set_uninitialized_value(Oddball* value); inline void set_cell_map(Map* value); inline void set_global_property_cell_map(Map* value); inline void set_shared_function_info_map(Map* value); inline void set_meta_map(Map* value); inline void set_heap_number_map(Map* value); inline void set_mutable_heap_number_map(Map* value); inline void set_float32x4_map(Map* value); inline void set_int32x4_map(Map* value); inline void set_uint32x4_map(Map* value); inline void set_bool32x4_map(Map* value); inline void set_int16x8_map(Map* value); inline void set_uint16x8_map(Map* value); inline void set_bool16x8_map(Map* value); inline void set_int8x16_map(Map* value); inline void set_uint8x16_map(Map* value); inline void set_bool8x16_map(Map* value); inline void set_native_context_map(Map* value); inline void set_fixed_array_map(Map* value); inline void set_code_map(Map* value); inline void set_scope_info_map(Map* value); inline void set_fixed_cow_array_map(Map* value); inline void set_fixed_double_array_map(Map* value); inline void set_weak_cell_map(Map* value); inline void set_transition_array_map(Map* value); inline void set_one_byte_string_map(Map* value); inline void set_one_byte_internalized_string_map(Map* value); inline void set_function_context_map(Map* value); inline void set_empty_fixed_array(FixedArray* value); inline void set_empty_byte_array(ByteArray* value); inline void set_empty_descriptor_array(DescriptorArray* value); inline void set_no_interceptor_result_sentinel(Oddball* value); inline void set_arguments_marker(Oddball* value); inline void set_exception(Oddball* value); inline void set_termination_exception(Oddball* value); inline void set_optimized_out(Oddball* value); inline void set_number_string_cache(FixedArray* value); inline void set_instanceof_cache_function(Object* value); inline void set_instanceof_cache_map(Object* value); inline void set_instanceof_cache_answer(Object* value); inline void set_single_character_string_cache(FixedArray* value); inline void set_string_split_cache(FixedArray* value); inline void set_regexp_multiple_cache(FixedArray* value); inline void set_hash_seed(Smi* value); inline void set_hash_table_map(Map* value); inline void set_ordered_hash_table_map(Map* value); inline void set_symbol_map(Map* value); inline void set_string_map(Map* value); inline void set_cons_one_byte_string_map(Map* value); inline void set_cons_string_map(Map* value); inline void set_sliced_string_map(Map* value); inline void set_sliced_one_byte_string_map(Map* value); inline void set_external_string_map(Map* value); inline void set_external_string_with_one_byte_data_map(Map* value); inline void set_external_one_byte_string_map(Map* value); inline void set_native_source_string_map(Map* value); inline void set_short_external_string_map(Map* value); inline void set_short_external_string_with_one_byte_data_map(Map* value); inline void set_internalized_string_map(Map* value); inline void set_external_internalized_string_map(Map* value); inline void set_external_internalized_string_with_one_byte_data_map(Map* value); inline void set_external_one_byte_internalized_string_map(Map* value); inline void set_short_external_internalized_string_map(Map* value); inline void set_short_external_internalized_string_with_one_byte_data_map(Map* value); inline void set_short_external_one_byte_internalized_string_map(Map* value); inline void set_short_external_one_byte_string_map(Map* value); inline void set_fixed_uint8_array_map(Map* value); inline void set_fixed_int8_array_map(Map* value); inline void set_fixed_uint16_array_map(Map* value); inline void set_fixed_int16_array_map(Map* value); inline void set_fixed_uint32_array_map(Map* value); inline void set_fixed_int32_array_map(Map* value); inline void set_fixed_float32_array_map(Map* value); inline void set_fixed_float64_array_map(Map* value); inline void set_fixed_uint8_clamped_array_map(Map* value); inline void set_empty_fixed_uint8_array(FixedTypedArrayBase* value); inline void set_empty_fixed_int8_array(FixedTypedArrayBase* value); inline void set_empty_fixed_uint16_array(FixedTypedArrayBase* value); inline void set_empty_fixed_int16_array(FixedTypedArrayBase* value); inline void set_empty_fixed_uint32_array(FixedTypedArrayBase* value); inline void set_empty_fixed_int32_array(FixedTypedArrayBase* value); inline void set_empty_fixed_float32_array(FixedTypedArrayBase* value); inline void set_empty_fixed_float64_array(FixedTypedArrayBase* value); inline void set_empty_fixed_uint8_clamped_array(FixedTypedArrayBase* value); inline void set_sloppy_arguments_elements_map(Map* value); inline void set_catch_context_map(Map* value); inline void set_with_context_map(Map* value); inline void set_debug_evaluate_context_map(Map* value); inline void set_block_context_map(Map* value); inline void set_module_context_map(Map* value); inline void set_script_context_map(Map* value); inline void set_script_context_table_map(Map* value); inline void set_undefined_map(Map* value); inline void set_the_hole_map(Map* value); inline void set_null_map(Map* value); inline void set_boolean_map(Map* value); inline void set_uninitialized_map(Map* value); inline void set_arguments_marker_map(Map* value); inline void set_no_interceptor_result_sentinel_map(Map* value); inline void set_exception_map(Map* value); inline void set_termination_exception_map(Map* value); inline void set_optimized_out_map(Map* value); inline void set_message_object_map(Map* value); inline void set_foreign_map(Map* value); inline void set_neander_map(Map* value); inline void set_external_map(Map* value); inline void set_nan_value(HeapNumber* value); inline void set_infinity_value(HeapNumber* value); inline void set_minus_zero_value(HeapNumber* value); inline void set_minus_infinity_value(HeapNumber* value); inline void set_message_listeners(JSObject* value); inline void set_code_stubs(UnseededNumberDictionary* value); inline void set_non_monomorphic_cache(UnseededNumberDictionary* value); inline void set_polymorphic_code_cache(PolymorphicCodeCache* value); inline void set_js_entry_code(Code* value); inline void set_js_construct_entry_code(Code* value); inline void set_natives_source_cache(FixedArray* value); inline void set_experimental_natives_source_cache(FixedArray* value); inline void set_extra_natives_source_cache(FixedArray* value); inline void set_experimental_extra_natives_source_cache(FixedArray* value); inline void set_empty_script(Script* value); inline void set_intrinsic_function_names(NameDictionary* value); inline void set_empty_properties_dictionary(NameDictionary* value); inline void set_undefined_cell(Cell* value); inline void set_observation_state(JSObject* value); inline void set_symbol_registry(Object* value); inline void set_script_list(Object* value); inline void set_empty_slow_element_dictionary(SeededNumberDictionary* value); inline void set_materialized_objects(FixedArray* value); inline void set_microtask_queue(FixedArray* value); inline void set_dummy_vector(TypeFeedbackVector* value); inline void set_cleared_optimized_code_map(FixedArray* value); inline void set_detached_contexts(FixedArray* value); inline void set_retained_maps(ArrayList* value); inline void set_weak_object_to_code_table(WeakHashTable* value); inline void set_array_protector(PropertyCell* value); inline void set_empty_property_cell(PropertyCell* value); inline void set_weak_stack_trace_list(Object* value); inline void set_noscript_shared_function_infos(Object* value); inline void set_bytecode_array_map(Map* value); inline void set_empty_weak_cell(WeakCell* value); inline void set_species_protector(PropertyCell* value); inline void set_stack_limit(Smi* value); inline void set_real_stack_limit(Smi* value); inline void set_last_script_id(Smi* value); inline void set_arguments_adaptor_deopt_pc_offset(Smi* value); inline void set_construct_stub_deopt_pc_offset(Smi* value); inline void set_getter_stub_deopt_pc_offset(Smi* value); inline void set_setter_stub_deopt_pc_offset(Smi* value); inline void set_string_table(StringTable* value);


  StoreBuffer* store_buffer() { return &store_buffer_; }

  void set_current_gc_flags(int flags) {
    current_gc_flags_ = flags;
    do { if ((!(!ShouldFinalizeIncrementalMarking() || !ShouldAbortIncrementalMarking()))) { V8_Fatal(".././src/heap/heap.h", 1518, "Check failed: %s.", "!ShouldFinalizeIncrementalMarking() || !ShouldAbortIncrementalMarking()"); } } while (0);

  }

  inline bool ShouldReduceMemory() const {
    return current_gc_flags_ & kReduceMemoryFootprintMask;
  }

  inline bool ShouldAbortIncrementalMarking() const {
    return current_gc_flags_ & kAbortIncrementalMarkingMask;
  }

  inline bool ShouldFinalizeIncrementalMarking() const {
    return current_gc_flags_ & kFinalizeIncrementalMarkingMask;
  }

  void PreprocessStackTraces();


  GarbageCollector SelectGarbageCollector(AllocationSpace space,
                                          const char** reason);




  void EnsureFillerObjectAtTop();



  void MakeHeapIterable();




  bool CollectGarbage(
      GarbageCollector collector, const char* gc_reason,
      const char* collector_reason,
      const GCCallbackFlags gc_callback_flags = kNoGCCallbackFlags);




  bool PerformGarbageCollection(
      GarbageCollector collector,
      const GCCallbackFlags gc_callback_flags = kNoGCCallbackFlags);

  inline void UpdateOldSpaceLimits();


  void InitializeJSObjectFromMap(JSObject* obj, FixedArray* properties,
                                 Map* map);


  void InitializeJSObjectBody(JSObject* obj, Map* map, int start_offset);

  void InitializeAllocationMemento(AllocationMemento* memento,
                                   AllocationSite* allocation_site);

  bool CreateInitialMaps();
  void CreateInitialObjects();



  void CreateJSEntryStub();
  void CreateJSConstructEntryStub();

  void CreateFixedStubs();

  HeapObject* DoubleAlignForDeserialization(HeapObject* object, int size);


  void EnsureFromSpaceIsCommitted();


  bool UncommitFromSpace() { return new_space_.UncommitFromSpace(); }


  void ZapFromSpace();



  void ResetAllAllocationSitesDependentCode(PretenureFlag flag);




  void EvaluateOldSpaceLocalPretenuring(uint64_t size_of_objects_before_gc);


  void ReportStatisticsBeforeGC();
  void ReportStatisticsAfterGC();


  int FullSizeNumberStringCacheLength();

  void FlushNumberStringCache();



  bool IsHighSurvivalRate() { return high_survival_rate_period_length_ > 0; }

  void ConfigureInitialOldGenerationSize();

  bool HasLowYoungGenerationAllocationRate();
  bool HasLowOldGenerationAllocationRate();
  double YoungGenerationMutatorUtilization();
  double OldGenerationMutatorUtilization();

  void ReduceNewSpaceSize();

  bool TryFinalizeIdleIncrementalMarking(
      double idle_time_in_ms, size_t size_of_objects,
      size_t mark_compact_speed_in_bytes_per_ms);

  GCIdleTimeHeapState ComputeHeapState();

  bool PerformIdleTimeAction(GCIdleTimeAction action,
                             GCIdleTimeHeapState heap_state,
                             double deadline_in_ms);

  void IdleNotificationEpilogue(GCIdleTimeAction action,
                                GCIdleTimeHeapState heap_state, double start_ms,
                                double deadline_in_ms);

  inline void UpdateAllocationsHash(HeapObject* object);
  inline void UpdateAllocationsHash(uint32_t value);
  void PrintAlloctionsHash();

  void AddToRingBuffer(const char* string);
  void GetFromRingBuffer(char* buffer);

  void CompactRetainedMaps(ArrayList* retained_maps);

  void CollectGarbageOnMemoryPressure(const char* source);





  void FinalizeIncrementalMarking(const char* gc_reason);







  HistogramTimer* GCTypeTimer(GarbageCollector collector);
  void ProcessPretenuringFeedback();







  void GarbageCollectionPrologue();
  void GarbageCollectionEpilogue();


  void MarkCompact();


  void MarkCompactPrologue();
  void MarkCompactEpilogue();


  void Scavenge();

  Address DoScavenge(ObjectVisitor* scavenge_visitor, Address new_space_front);

  void UpdateNewSpaceReferencesInExternalStringTable(
      ExternalStringTableUpdaterCallback updater_func);

  void UpdateReferencesInExternalStringTable(
      ExternalStringTableUpdaterCallback updater_func);

  void ProcessAllWeakReferences(WeakObjectRetainer* retainer);
  void ProcessYoungWeakReferences(WeakObjectRetainer* retainer);
  void ProcessNativeContexts(WeakObjectRetainer* retainer);
  void ProcessAllocationSites(WeakObjectRetainer* retainer);
  void ProcessWeakListRoots(WeakObjectRetainer* retainer);





  inline intptr_t OldGenerationSpaceAvailable() {
    return old_generation_allocation_limit_ - PromotedTotalSize();
  }


  double get_max_gc_pause() { return max_gc_pause_; }


  intptr_t get_max_alive_after_gc() { return max_alive_after_gc_; }


  double get_min_in_mutator() { return min_in_mutator_; }


  void UpdateCumulativeGCStatistics(double duration, double spent_in_mutator,
                                    double marking_time);

  bool MaximumSizeScavenge() { return maximum_size_scavenges_ > 0; }







  void DampenOldGenerationAllocationLimit(intptr_t old_gen_size,
                                          double gc_speed,
                                          double mutator_speed);




  intptr_t CalculateOldGenerationAllocationLimit(double factor,
                                                 intptr_t old_gen_size);


  void SetOldGenerationAllocationLimit(intptr_t old_gen_size, double gc_speed,
                                       double mutator_speed);





  bool RecentIdleNotificationHappened();
  void ScheduleIdleScavengeIfNeeded(int bytes_allocated);





  void heap_iterator_start() { heap_iterator_depth_++; }

  void heap_iterator_end() { heap_iterator_depth_--; }

  bool in_heap_iterator() { return heap_iterator_depth_ > 0; }
  __attribute__((warn_unused_result)) AllocationResult CopyJSObject(JSObject* source,
                                                AllocationSite* site = 0);


  __attribute__((warn_unused_result)) AllocationResult
  AllocateMap(InstanceType instance_type, int instance_size,
              ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND);





  __attribute__((warn_unused_result)) AllocationResult AllocateJSObject(
      JSFunction* constructor, PretenureFlag pretenure = NOT_TENURED,
      AllocationSite* allocation_site = 0);




  __attribute__((warn_unused_result)) AllocationResult
  AllocateJSObjectFromMap(Map* map, PretenureFlag pretenure = NOT_TENURED,
                          AllocationSite* allocation_site = 0);


  __attribute__((warn_unused_result)) AllocationResult
  AllocateHeapNumber(double value, MutableMode mode = IMMUTABLE,
                     PretenureFlag pretenure = NOT_TENURED);





  AllocationResult AllocateFloat32x4(float lanes[4], PretenureFlag pretenure = NOT_TENURED); AllocationResult AllocateInt32x4(int32_t lanes[4], PretenureFlag pretenure = NOT_TENURED); AllocationResult AllocateUint32x4(uint32_t lanes[4], PretenureFlag pretenure = NOT_TENURED); AllocationResult AllocateBool32x4(bool lanes[4], PretenureFlag pretenure = NOT_TENURED); AllocationResult AllocateInt16x8(int16_t lanes[8], PretenureFlag pretenure = NOT_TENURED); AllocationResult AllocateUint16x8(uint16_t lanes[8], PretenureFlag pretenure = NOT_TENURED); AllocationResult AllocateBool16x8(bool lanes[8], PretenureFlag pretenure = NOT_TENURED); AllocationResult AllocateInt8x16(int8_t lanes[16], PretenureFlag pretenure = NOT_TENURED); AllocationResult AllocateUint8x16(uint8_t lanes[16], PretenureFlag pretenure = NOT_TENURED); AllocationResult AllocateBool8x16(bool lanes[16], PretenureFlag pretenure = NOT_TENURED);



  __attribute__((warn_unused_result)) AllocationResult
  AllocateByteArray(int length, PretenureFlag pretenure = NOT_TENURED);


  __attribute__((warn_unused_result)) AllocationResult
  AllocateBytecodeArray(int length, const byte* raw_bytecodes, int frame_size,
                        int parameter_count, FixedArray* constant_pool);



  __attribute__((warn_unused_result)) AllocationResult CopyCode(Code* code,
                                            Vector<byte> reloc_info);

  __attribute__((warn_unused_result)) AllocationResult CopyCode(Code* code);

  __attribute__((warn_unused_result)) AllocationResult
  CopyBytecodeArray(BytecodeArray* bytecode_array);


  __attribute__((warn_unused_result)) AllocationResult
  AllocateFixedArray(int length, PretenureFlag pretenure = NOT_TENURED);





  __attribute__((warn_unused_result)) inline AllocationResult AllocateRaw(
      int size_in_bytes, AllocationSpace space,
      AllocationAlignment aligment = kWordAligned);


  __attribute__((warn_unused_result)) AllocationResult
      Allocate(Map* map, AllocationSpace space,
               AllocationSite* allocation_site = 0);


  __attribute__((warn_unused_result)) AllocationResult
      AllocatePartialMap(InstanceType instance_type, int instance_size);



  __attribute__((warn_unused_result)) AllocationResult
      AllocateFillerObject(int size, bool double_align, AllocationSpace space);


  __attribute__((warn_unused_result)) AllocationResult
      AllocateRawFixedArray(int length, PretenureFlag pretenure);


  __attribute__((warn_unused_result)) AllocationResult
      AllocateRawFixedDoubleArray(int length, PretenureFlag pretenure);


  __attribute__((warn_unused_result)) AllocationResult
      AllocateFixedArrayWithFiller(int length, PretenureFlag pretenure,
                                   Object* filler);





  __attribute__((warn_unused_result)) AllocationResult
      AllocateRawOneByteString(int length, PretenureFlag pretenure);
  __attribute__((warn_unused_result)) AllocationResult
      AllocateRawTwoByteString(int length, PretenureFlag pretenure);



  __attribute__((warn_unused_result)) inline AllocationResult AllocateInternalizedStringFromUtf8(
      Vector<const char> str, int chars, uint32_t hash_field);

  __attribute__((warn_unused_result)) inline AllocationResult AllocateOneByteInternalizedString(
      Vector<const uint8_t> str, uint32_t hash_field);

  __attribute__((warn_unused_result)) inline AllocationResult AllocateTwoByteInternalizedString(
      Vector<const uc16> str, uint32_t hash_field);

  template <bool is_one_byte, typename T>
  __attribute__((warn_unused_result)) AllocationResult
      AllocateInternalizedStringImpl(T t, int chars, uint32_t hash_field);

  template <typename T>
  __attribute__((warn_unused_result)) inline AllocationResult AllocateInternalizedStringImpl(
      T t, int chars, uint32_t hash_field);


  __attribute__((warn_unused_result)) AllocationResult AllocateUninitializedFixedArray(int length);


  __attribute__((warn_unused_result)) inline AllocationResult CopyFixedArray(FixedArray* src);


  __attribute__((warn_unused_result)) AllocationResult
  CopyFixedArrayAndGrow(FixedArray* src, int grow_by, PretenureFlag pretenure);


  __attribute__((warn_unused_result)) AllocationResult CopyFixedArrayUpTo(FixedArray* src,
                                                      int new_len,
                                                      PretenureFlag pretenure);


  __attribute__((warn_unused_result)) AllocationResult
      CopyFixedArrayWithMap(FixedArray* src, Map* map);


  __attribute__((warn_unused_result)) inline AllocationResult CopyFixedDoubleArray(
      FixedDoubleArray* src);



  __attribute__((warn_unused_result)) AllocationResult
      LookupSingleCharacterStringFromCode(uint16_t code);


  __attribute__((warn_unused_result)) AllocationResult AllocateSymbol();


  __attribute__((warn_unused_result)) AllocationResult AllocateFixedTypedArrayWithExternalPointer(
      int length, ExternalArrayType array_type, void* external_pointer,
      PretenureFlag pretenure);


  __attribute__((warn_unused_result)) AllocationResult
  AllocateFixedTypedArray(int length, ExternalArrayType array_type,
                          bool initialize, PretenureFlag pretenure);


  __attribute__((warn_unused_result)) AllocationResult CopyAndTenureFixedCOWArray(FixedArray* src);


  __attribute__((warn_unused_result)) AllocationResult
      CopyFixedDoubleArrayWithMap(FixedDoubleArray* src, Map* map);


  __attribute__((warn_unused_result)) AllocationResult AllocateUninitializedFixedDoubleArray(
      int length, PretenureFlag pretenure = NOT_TENURED);


  __attribute__((warn_unused_result)) AllocationResult AllocateEmptyFixedArray();


  __attribute__((warn_unused_result)) AllocationResult
      AllocateEmptyFixedTypedArray(ExternalArrayType array_type);


  __attribute__((warn_unused_result)) AllocationResult AllocateCell(Object* value);


  __attribute__((warn_unused_result)) AllocationResult AllocatePropertyCell();

  __attribute__((warn_unused_result)) AllocationResult AllocateWeakCell(HeapObject* value);

  __attribute__((warn_unused_result)) AllocationResult AllocateTransitionArray(int capacity);


  __attribute__((warn_unused_result)) AllocationResult AllocateStruct(InstanceType type);


  __attribute__((warn_unused_result)) AllocationResult
      AllocateForeign(Address address, PretenureFlag pretenure = NOT_TENURED);

  __attribute__((warn_unused_result)) AllocationResult
      AllocateCode(int object_size, bool immovable);

  __attribute__((warn_unused_result)) AllocationResult InternalizeStringWithKey(HashTableKey* key);

  __attribute__((warn_unused_result)) AllocationResult InternalizeString(String* str);



  void set_force_oom(bool value) { force_oom_ = value; }



  int64_t amount_of_external_allocated_memory_;


  int64_t amount_of_external_allocated_memory_at_last_global_gc_;



  Isolate* isolate_;

  Object* roots_[kRootListLength];

  size_t code_range_size_;
  int max_semi_space_size_;
  int initial_semispace_size_;
  intptr_t max_old_generation_size_;
  intptr_t initial_old_generation_size_;
  bool old_generation_size_configured_;
  intptr_t max_executable_size_;
  intptr_t maximum_committed_;



  intptr_t survived_since_last_expansion_;


  intptr_t survived_last_scavenge_;



  AtomicNumber<size_t> always_allocate_scope_count_;



  AtomicValue<MemoryPressureLevel> memory_pressure_level_;


  int contexts_disposed_;




  int number_of_disposed_maps_;

  int global_ic_age_;

  NewSpace new_space_;
  OldSpace* old_space_;
  OldSpace* code_space_;
  MapSpace* map_space_;
  LargeObjectSpace* lo_space_;
  HeapState gc_state_;
  int gc_post_processing_depth_;
  Address new_space_top_after_last_gc_;


  int64_t PromotedExternalMemorySize();


  uint32_t allocations_count_;


  uint32_t raw_allocations_hash_;


  unsigned int ms_count_;


  unsigned int gc_count_;


  int remembered_unmapped_pages_index_;
  Address remembered_unmapped_pages_[kRememberedUnmappedPages];





  int allocation_timeout_;






  intptr_t old_generation_allocation_limit_;



  bool old_gen_exhausted_;



  bool optimize_for_memory_usage_;



  bool inline_allocation_disabled_;



  Object* native_contexts_list_;
  Object* allocation_sites_list_;




  Object* encountered_weak_collections_;

  Object* encountered_weak_cells_;

  Object* encountered_transition_arrays_;

  List<GCCallbackPair> gc_epilogue_callbacks_;
  List<GCCallbackPair> gc_prologue_callbacks_;


  double total_regexp_code_generated_;

  int deferred_counters_[v8::Isolate::kUseCounterFeatureCount];

  GCTracer* tracer_;
  EmbedderHeapTracer* embedder_heap_tracer_;

  int high_survival_rate_period_length_;
  intptr_t promoted_objects_size_;
  double promotion_ratio_;
  double promotion_rate_;
  intptr_t semi_space_copied_object_size_;
  intptr_t previous_semi_space_copied_object_size_;
  double semi_space_copied_rate_;
  int nodes_died_in_new_space_;
  int nodes_copied_in_new_space_;
  int nodes_promoted_;





  unsigned int maximum_size_scavenges_;


  double max_gc_pause_;


  double total_gc_time_ms_;


  intptr_t max_alive_after_gc_;


  double min_in_mutator_;


  double marking_time_;


  double sweeping_time_;


  double last_idle_notification_time_;


  double last_gc_time_;

  Scavenger* scavenge_collector_;

  MarkCompactCollector* mark_compact_collector_;

  StoreBuffer store_buffer_;

  IncrementalMarking* incremental_marking_;

  GCIdleTimeHandler* gc_idle_time_handler_;

  MemoryReducer* memory_reducer_;

  ObjectStats* object_stats_;

  ScavengeJob* scavenge_job_;

  AllocationObserver* idle_scavenge_observer_;


  size_t full_codegen_bytes_generated_;
  size_t crankshaft_codegen_bytes_generated_;




  size_t new_space_allocation_counter_;




  size_t old_generation_allocation_counter_;


  size_t old_generation_size_at_last_gc_;




  int gcs_since_last_deopt_;






  HashMap* global_pretenuring_feedback_;

  char trace_ring_buffer_[kTraceRingBufferSize];



  bool ring_buffer_full_;
  size_t ring_buffer_end_;


  PromotionQueue promotion_queue_;



  bool configured_;


  int current_gc_flags_;



  GCCallbackFlags current_gc_callback_flags_;

  ExternalStringTable external_string_table_;

  MemoryChunk* chunks_queued_for_free_;

  size_t concurrent_unmapping_tasks_active_;

  base::Semaphore pending_unmapping_tasks_semaphore_;

  base::Mutex relocation_mutex_;

  int gc_callbacks_depth_;

  bool deserialization_complete_;

  StrongRootsList* strong_roots_list_;

  ArrayBufferTracker* array_buffer_tracker_;


  int heap_iterator_depth_;


  bool force_oom_;


  friend class AlwaysAllocateScope;
  friend class GCCallbacksScope;
  friend class GCTracer;
  friend class HeapIterator;
  friend class IdleScavengeObserver;
  friend class IncrementalMarking;
  friend class IteratePromotedObjectsVisitor;
  friend class MarkCompactCollector;
  friend class MarkCompactMarkingVisitor;
  friend class NewSpace;
  friend class ObjectStatsVisitor;
  friend class Page;
  friend class Scavenger;
  friend class StoreBuffer;


  friend class Factory;


  friend class Isolate;


  friend class HeapTester;

  Heap(const Heap&) = delete; void operator=(const Heap&) = delete;
};


class HeapStats {
 public:
  static const int kStartMarker = 0xDECADE00;
  static const int kEndMarker = 0xDECADE01;

  int* start_marker;
  int* new_space_size;
  int* new_space_capacity;
  intptr_t* old_space_size;
  intptr_t* old_space_capacity;
  intptr_t* code_space_size;
  intptr_t* code_space_capacity;
  intptr_t* map_space_size;
  intptr_t* map_space_capacity;
  intptr_t* lo_space_size;
  int* global_handle_count;
  int* weak_global_handle_count;
  int* pending_global_handle_count;
  int* near_death_global_handle_count;
  int* free_global_handle_count;
  intptr_t* memory_allocator_size;
  intptr_t* memory_allocator_capacity;
  int* objects_per_type;
  int* size_per_type;
  int* os_error;
  char* last_few_messages;
  char* js_stacktrace;
  int* end_marker;
};


class AlwaysAllocateScope {
 public:
  explicit inline AlwaysAllocateScope(Isolate* isolate);
  inline ~AlwaysAllocateScope();

 private:
  Heap* heap_;
};







class VerifyPointersVisitor : public ObjectVisitor {
 public:
  inline void VisitPointers(Object** start, Object** end) override;
};



class VerifySmisVisitor : public ObjectVisitor {
 public:
  inline void VisitPointers(Object** start, Object** end) override;
};




class AllSpaces : public Embedded {
 public:
  explicit AllSpaces(Heap* heap) : heap_(heap), counter_(FIRST_SPACE) {}
  Space* next();

 private:
  Heap* heap_;
  int counter_;
};




class OldSpaces : public Embedded {
 public:
  explicit OldSpaces(Heap* heap) : heap_(heap), counter_(OLD_SPACE) {}
  OldSpace* next();

 private:
  Heap* heap_;
  int counter_;
};





class PagedSpaces : public Embedded {
 public:
  explicit PagedSpaces(Heap* heap) : heap_(heap), counter_(OLD_SPACE) {}
  PagedSpace* next();

 private:
  Heap* heap_;
  int counter_;
};





class SpaceIterator : public Malloced {
 public:
  explicit SpaceIterator(Heap* heap);
  virtual ~SpaceIterator();

  bool has_next();
  ObjectIterator* next();

 private:
  ObjectIterator* CreateIterator();

  Heap* heap_;
  int current_space_;
  ObjectIterator* iterator_;
};
class HeapIterator : public Embedded {
 public:
  enum HeapObjectsFiltering { kNoFiltering, kFilterUnreachable };

  explicit HeapIterator(Heap* heap,
                        HeapObjectsFiltering filtering = kNoFiltering);
  ~HeapIterator();

  HeapObject* next();

 private:
  struct MakeHeapIterableHelper {
    explicit MakeHeapIterableHelper(Heap* heap) { heap->MakeHeapIterable(); }
  };

  HeapObject* NextObject();





  MakeHeapIterableHelper make_heap_iterable_helper_;
  DisallowHeapAllocation no_heap_allocation_;

  Heap* heap_;
  HeapObjectsFiltering filtering_;
  HeapObjectsFilter* filter_;

  SpaceIterator* space_iterator_;

  ObjectIterator* object_iterator_;
};




class KeyedLookupCache {
 public:

  int Lookup(Handle<Map> map, Handle<Name> name);


  void Update(Handle<Map> map, Handle<Name> name, int field_offset);


  void Clear();

  static const int kLength = 256;
  static const int kCapacityMask = kLength - 1;
  static const int kMapHashShift = 5;
  static const int kHashMask = -4;
  static const int kEntriesPerBucket = 4;
  static const int kEntryLength = 2;
  static const int kMapIndex = 0;
  static const int kKeyIndex = 1;
  static const int kNotFound = -1;


  static_assert((kEntriesPerBucket & (kEntriesPerBucket - 1)) == 0, "(kEntriesPerBucket & (kEntriesPerBucket - 1)) == 0");
  static_assert(kEntriesPerBucket == -kHashMask, "kEntriesPerBucket == -kHashMask");

 private:
  KeyedLookupCache() {
    for (int i = 0; i < kLength; ++i) {
      keys_[i].map = 0;
      keys_[i].name = 0;
      field_offsets_[i] = kNotFound;
    }
  }

  static inline int Hash(Handle<Map> map, Handle<Name> name);



  Address keys_address() { return reinterpret_cast<Address>(&keys_); }

  Address field_offsets_address() {
    return reinterpret_cast<Address>(&field_offsets_);
  }

  struct Key {
    Map* map;
    Name* name;
  };

  Key keys_[kLength];
  int field_offsets_[kLength];

  friend class ExternalReference;
  friend class Isolate;
  KeyedLookupCache(const KeyedLookupCache&) = delete; void operator=(const KeyedLookupCache&) = delete;
};






class DescriptorLookupCache {
 public:


  inline int Lookup(Map* source, Name* name);


  inline void Update(Map* source, Name* name, int result);


  void Clear();

  static const int kAbsent = -2;

 private:
  DescriptorLookupCache() {
    for (int i = 0; i < kLength; ++i) {
      keys_[i].source = 0;
      keys_[i].name = 0;
      results_[i] = kAbsent;
    }
  }

  static inline int Hash(Object* source, Name* name);

  static const int kLength = 64;
  struct Key {
    Map* source;
    Name* name;
  };

  Key keys_[kLength];
  int results_[kLength];

  friend class Isolate;
  DescriptorLookupCache(const DescriptorLookupCache&) = delete; void operator=(const DescriptorLookupCache&) = delete;
};



class WeakObjectRetainer {
 public:
  virtual ~WeakObjectRetainer() {}




  virtual Object* RetainAs(Object* object) = 0;
};






class PathTracer : public ObjectVisitor {
 public:
  enum WhatToFind {
    FIND_ALL,
    FIND_FIRST
  };


  static const int kMarkTag = 2;




  PathTracer(Object* search_target, WhatToFind what_to_find,
             VisitMode visit_mode)
      : search_target_(search_target),
        found_target_(false),
        found_target_in_trace_(false),
        what_to_find_(what_to_find),
        visit_mode_(visit_mode),
        object_stack_(20),
        no_allocation() {}

  void VisitPointers(Object** start, Object** end) override;

  void Reset();
  void TracePathFrom(Object** root);

  bool found() const { return found_target_; }

  static Object* const kAnyGlobalObject;

 protected:
  class MarkVisitor;
  class UnmarkVisitor;

  void MarkRecursively(Object** p, MarkVisitor* mark_visitor);
  void UnmarkRecursively(Object** p, UnmarkVisitor* unmark_visitor);
  virtual void ProcessResults();

  Object* search_target_;
  bool found_target_;
  bool found_target_in_trace_;
  WhatToFind what_to_find_;
  VisitMode visit_mode_;
  List<Object*> object_stack_;

  DisallowHeapAllocation no_allocation;

 private:
  PathTracer() = delete; PathTracer(const PathTracer&) = delete; void operator=(const PathTracer&) = delete;
};




class AllocationObserver {
 public:
  explicit AllocationObserver(intptr_t step_size)
      : step_size_(step_size), bytes_to_next_step_(step_size) {
    do { if ((!(step_size >= kPointerSize))) { V8_Fatal(".././src/heap/heap.h", 2614, "Check failed: %s.", "step_size >= kPointerSize"); } } while (0);
  }
  virtual ~AllocationObserver() {}




  void AllocationStep(int bytes_allocated, Address soon_object, size_t size) {
    bytes_to_next_step_ -= bytes_allocated;
    if (bytes_to_next_step_ <= 0) {
      Step(static_cast<int>(step_size_ - bytes_to_next_step_), soon_object,
           size);
      step_size_ = GetNextStepSize();
      bytes_to_next_step_ = step_size_;
    }
  }

 protected:
  intptr_t step_size() const { return step_size_; }
  intptr_t bytes_to_next_step() const { return bytes_to_next_step_; }
  virtual void Step(int bytes_allocated, Address soon_object, size_t size) = 0;


  virtual intptr_t GetNextStepSize() { return step_size_; }

  intptr_t step_size_;
  intptr_t bytes_to_next_step_;

 private:
  friend class LargeObjectSpace;
  friend class NewSpace;
  friend class PagedSpace;
  AllocationObserver(const AllocationObserver&) = delete; void operator=(const AllocationObserver&) = delete;
};

}
}


namespace v8 {
namespace internal {


enum ContextLookupFlags {
  FOLLOW_CONTEXT_CHAIN = 1 << 0,
  FOLLOW_PROTOTYPE_CHAIN = 1 << 1,
  STOP_AT_DECLARATION_SCOPE = 1 << 2,
  SKIP_WITH_CONTEXT = 1 << 3,

  DONT_FOLLOW_CHAINS = 0,
  FOLLOW_CHAINS = FOLLOW_CONTEXT_CHAIN | FOLLOW_PROTOTYPE_CHAIN,
  LEXICAL_TEST =
      FOLLOW_CONTEXT_CHAIN | STOP_AT_DECLARATION_SCOPE | SKIP_WITH_CONTEXT,
};
enum BindingFlags {
  MUTABLE_IS_INITIALIZED,
  MUTABLE_CHECK_INITIALIZED,
  IMMUTABLE_IS_INITIALIZED,
  IMMUTABLE_CHECK_INITIALIZED,
  IMMUTABLE_IS_INITIALIZED_HARMONY,
  IMMUTABLE_CHECK_INITIALIZED_HARMONY,
  MISSING_BINDING
};
class ScriptContextTable : public FixedArray {
 public:

  static inline ScriptContextTable* cast(Object* context);

  struct LookupResult {
    int context_index;
    int slot_index;
    VariableMode mode;
    InitializationFlag init_flag;
    MaybeAssignedFlag maybe_assigned_flag;
  };

  inline int used() const;
  inline void set_used(int used);

  static inline Handle<Context> GetContext(Handle<ScriptContextTable> table,
                                           int i);





  __attribute__((warn_unused_result))
  static bool Lookup(Handle<ScriptContextTable> table, Handle<String> name,
                     LookupResult* result);

  __attribute__((warn_unused_result))
  static Handle<ScriptContextTable> Extend(Handle<ScriptContextTable> table,
                                           Handle<Context> script_context);

  static int GetContextOffset(int context_index) {
    return kFirstContextOffset + context_index * kPointerSize;
  }

 private:
  static const int kUsedSlot = 0;
  static const int kFirstContextSlot = kUsedSlot + 1;
  static const int kFirstContextOffset =
      FixedArray::kHeaderSize + kFirstContextSlot * kPointerSize;

  ScriptContextTable() = delete; ScriptContextTable(const ScriptContextTable&) = delete; void operator=(const ScriptContextTable&) = delete;
};
class Context: public FixedArray {
 public:

  static inline Context* cast(Object* context);


  enum {

    CLOSURE_INDEX,
    PREVIOUS_INDEX,




    EXTENSION_INDEX,
    NATIVE_CONTEXT_INDEX,



    GLOBAL_PROXY_INDEX, EMBEDDER_DATA_INDEX, ACCESSOR_PROPERTY_DESCRIPTOR_MAP_INDEX, ALLOW_CODE_GEN_FROM_STRINGS_INDEX, ARRAY_BUFFER_FUN_INDEX, ARRAY_BUFFER_MAP_INDEX, ARRAY_FUNCTION_INDEX, BOOL16X8_FUNCTION_INDEX, BOOL32X4_FUNCTION_INDEX, BOOL8X16_FUNCTION_INDEX, BOOLEAN_FUNCTION_INDEX, BOUND_FUNCTION_WITH_CONSTRUCTOR_MAP_INDEX, BOUND_FUNCTION_WITHOUT_CONSTRUCTOR_MAP_INDEX, CALL_AS_CONSTRUCTOR_DELEGATE_INDEX, CALL_AS_FUNCTION_DELEGATE_INDEX, CONTEXT_EXTENSION_FUNCTION_INDEX, DATA_PROPERTY_DESCRIPTOR_MAP_INDEX, DATA_VIEW_FUN_INDEX, DATE_FUNCTION_INDEX, ERROR_MESSAGE_FOR_CODE_GEN_FROM_STRINGS_INDEX, ERRORS_THROWN_INDEX, EXTRAS_EXPORTS_OBJECT_INDEX, EXTRAS_UTILS_OBJECT_INDEX, FAST_ALIASED_ARGUMENTS_MAP_INDEX, FLOAT32_ARRAY_FUN_INDEX, FLOAT32X4_FUNCTION_INDEX, FLOAT64_ARRAY_FUN_INDEX, TEMPLATE_INSTANTIATIONS_CACHE_INDEX, FUNCTION_FUNCTION_INDEX, GENERATOR_FUNCTION_FUNCTION_INDEX, GENERATOR_OBJECT_PROTOTYPE_MAP_INDEX, INITIAL_ARRAY_PROTOTYPE_INDEX, INITIAL_OBJECT_PROTOTYPE_INDEX, INT16_ARRAY_FUN_INDEX, INT16X8_FUNCTION_INDEX, INT32_ARRAY_FUN_INDEX, INT32X4_FUNCTION_INDEX, INT8_ARRAY_FUN_INDEX, INT8X16_FUNCTION_INDEX, INTERNAL_ARRAY_FUNCTION_INDEX, ITERATOR_RESULT_MAP_INDEX, JS_ARRAY_FAST_SMI_ELEMENTS_MAP_INDEX, JS_ARRAY_FAST_HOLEY_SMI_ELEMENTS_MAP_INDEX, JS_ARRAY_FAST_ELEMENTS_MAP_INDEX, JS_ARRAY_FAST_HOLEY_ELEMENTS_MAP_INDEX, JS_ARRAY_FAST_DOUBLE_ELEMENTS_MAP_INDEX, JS_ARRAY_FAST_HOLEY_DOUBLE_ELEMENTS_MAP_INDEX, JS_MAP_FUN_INDEX, JS_MAP_MAP_INDEX, JS_SET_FUN_INDEX, JS_SET_MAP_INDEX, JS_WEAK_MAP_FUN_INDEX, JS_WEAK_SET_FUN_INDEX, MAP_CACHE_INDEX, MAP_ITERATOR_MAP_INDEX, STRING_ITERATOR_MAP_INDEX, MESSAGE_LISTENERS_INDEX, NATIVES_UTILS_OBJECT_INDEX, NORMALIZED_MAP_CACHE_INDEX, NUMBER_FUNCTION_INDEX, OBJECT_FUNCTION_INDEX, OBJECT_FUNCTION_PROTOTYPE_MAP_INDEX, OPAQUE_REFERENCE_FUNCTION_INDEX, PROXY_CALLABLE_MAP_INDEX, PROXY_CONSTRUCTOR_MAP_INDEX, PROXY_FUNCTION_INDEX, PROXY_FUNCTION_MAP_INDEX, PROXY_MAP_INDEX, REGEXP_FUNCTION_INDEX, REGEXP_RESULT_MAP_INDEX, SCRIPT_CONTEXT_TABLE_INDEX, SCRIPT_FUNCTION_INDEX, SECURITY_TOKEN_INDEX, SELF_WEAK_CELL_INDEX, SET_ITERATOR_MAP_INDEX, SHARED_ARRAY_BUFFER_FUN_INDEX, SLOPPY_ARGUMENTS_MAP_INDEX, SLOPPY_FUNCTION_MAP_INDEX, SLOPPY_FUNCTION_WITHOUT_PROTOTYPE_MAP_INDEX, SLOPPY_FUNCTION_WITH_READONLY_PROTOTYPE_MAP_INDEX, WASM_FUNCTION_MAP_INDEX, SLOPPY_GENERATOR_FUNCTION_MAP_INDEX, SLOW_ALIASED_ARGUMENTS_MAP_INDEX, STRICT_ARGUMENTS_MAP_INDEX, STRICT_FUNCTION_MAP_INDEX, STRICT_FUNCTION_WITHOUT_PROTOTYPE_MAP_INDEX, STRICT_GENERATOR_FUNCTION_MAP_INDEX, STRING_FUNCTION_INDEX, STRING_FUNCTION_PROTOTYPE_MAP_INDEX, SYMBOL_FUNCTION_INDEX, UINT16_ARRAY_FUN_INDEX, UINT16X8_FUNCTION_INDEX, UINT32_ARRAY_FUN_INDEX, UINT32X4_FUNCTION_INDEX, UINT8_ARRAY_FUN_INDEX, UINT8_CLAMPED_ARRAY_FUN_INDEX, UINT8X16_FUNCTION_INDEX, IS_ARRAYLIKE, GET_TEMPLATE_CALL_SITE_INDEX, MAKE_RANGE_ERROR_INDEX, MAKE_TYPE_ERROR_INDEX, OBJECT_FREEZE, OBJECT_IS_EXTENSIBLE, OBJECT_IS_FROZEN, OBJECT_IS_SEALED, OBJECT_KEYS, REFLECT_APPLY_INDEX, REFLECT_CONSTRUCT_INDEX, REFLECT_DEFINE_PROPERTY_INDEX, REFLECT_DELETE_PROPERTY_INDEX, SPREAD_ARGUMENTS_INDEX, SPREAD_ITERABLE_INDEX, ORDINARY_HAS_INSTANCE_INDEX, MATH_FLOOR, MATH_SQRT, ARRAY_CONCAT_INDEX, ARRAY_POP_INDEX, ARRAY_PUSH_INDEX, ARRAY_SHIFT_INDEX, ARRAY_SPLICE_INDEX, ARRAY_SLICE_INDEX, ARRAY_UNSHIFT_INDEX, ARRAY_VALUES_ITERATOR_INDEX, DERIVED_GET_TRAP_INDEX, ERROR_FUNCTION_INDEX, EVAL_ERROR_FUNCTION_INDEX, GET_STACK_TRACE_LINE_INDEX, GLOBAL_EVAL_FUN_INDEX, JSON_SERIALIZE_ADAPTER_INDEX, MAKE_ERROR_FUNCTION_INDEX, MAP_DELETE_METHOD_INDEX, MAP_GET_METHOD_INDEX, MAP_HAS_METHOD_INDEX, MAP_SET_METHOD_INDEX, MATH_POW_METHOD_INDEX, MESSAGE_GET_COLUMN_NUMBER_INDEX, MESSAGE_GET_LINE_NUMBER_INDEX, MESSAGE_GET_SOURCE_LINE_INDEX, NATIVE_OBJECT_GET_NOTIFIER_INDEX, NATIVE_OBJECT_NOTIFIER_PERFORM_CHANGE, NATIVE_OBJECT_OBSERVE_INDEX, NO_SIDE_EFFECTS_TO_STRING_FUN_INDEX, OBJECT_VALUE_OF, OBJECT_TO_STRING, OBSERVERS_BEGIN_SPLICE_INDEX, OBSERVERS_END_SPLICE_INDEX, OBSERVERS_ENQUEUE_SPLICE_INDEX, OBSERVERS_NOTIFY_CHANGE_INDEX, PROMISE_CATCH_INDEX, PROMISE_CHAIN_INDEX, PROMISE_CREATE_INDEX, PROMISE_FUNCTION_INDEX, PROMISE_HAS_USER_DEFINED_REJECT_HANDLER_INDEX, PROMISE_REJECT_INDEX, PROMISE_RESOLVE_INDEX, PROMISE_THEN_INDEX, RANGE_ERROR_FUNCTION_INDEX, REFERENCE_ERROR_FUNCTION_INDEX, SET_ADD_METHOD_INDEX, SET_DELETE_METHOD_INDEX, SET_HAS_METHOD_INDEX, STACK_OVERFLOW_BOILERPLATE_INDEX, SYNTAX_ERROR_FUNCTION_INDEX, TYPE_ERROR_FUNCTION_INDEX, URI_ERROR_FUNCTION_INDEX,




    OPTIMIZED_FUNCTIONS_LIST,
    OPTIMIZED_CODE_LIST,
    DEOPTIMIZED_CODE_LIST,
    NEXT_CONTEXT_LINK,


    NATIVE_CONTEXT_SLOTS,
    FIRST_WEAK_SLOT = OPTIMIZED_FUNCTIONS_LIST,
    FIRST_JS_ARRAY_MAP_SLOT = JS_ARRAY_FAST_SMI_ELEMENTS_MAP_INDEX,

    MIN_CONTEXT_SLOTS = GLOBAL_PROXY_INDEX,

    THROWN_OBJECT_INDEX = MIN_CONTEXT_SLOTS,


    WRAPPED_CONTEXT_INDEX = MIN_CONTEXT_SLOTS,
    WHITE_LIST_INDEX = MIN_CONTEXT_SLOTS + 1
  };

  void IncrementErrorsThrown();
  int GetErrorsThrown();


  inline JSFunction* closure();
  inline void set_closure(JSFunction* closure);

  inline Context* previous();
  inline void set_previous(Context* context);

  inline bool has_extension();
  inline HeapObject* extension();
  inline void set_extension(HeapObject* object);
  JSObject* extension_object();
  JSReceiver* extension_receiver();
  ScopeInfo* scope_info();
  String* catch_name();

  inline JSModule* module();
  inline void set_module(JSModule* module);



  Context* declaration_context();
  bool is_declaration_context();


  Context* closure_context();


  JSObject* global_proxy();
  void set_global_proxy(JSObject* global);


  JSGlobalObject* global_object();


  Context* script_context();


  inline Context* native_context();
  inline void set_native_context(Context* context);




  inline bool IsNativeContext();
  inline bool IsFunctionContext();
  inline bool IsCatchContext();
  inline bool IsWithContext();
  inline bool IsDebugEvaluateContext();
  inline bool IsBlockContext();
  inline bool IsModuleContext();
  inline bool IsScriptContext();

  inline bool HasSameSecurityTokenAs(Context* that);


  void InitializeGlobalSlots();


  void AddOptimizedFunction(JSFunction* function);
  void RemoveOptimizedFunction(JSFunction* function);
  void SetOptimizedFunctionsListHead(Object* head);
  Object* OptimizedFunctionsListHead();



  void AddOptimizedCode(Code* code);
  void SetOptimizedCodeListHead(Object* head);
  Object* OptimizedCodeListHead();
  void SetDeoptimizedCodeListHead(Object* head);
  Object* DeoptimizedCodeListHead();

  Handle<Object> ErrorMessageForCodeGenerationFromStrings();

  static int ImportedFieldIndexForName(Handle<String> name);
  static int IntrinsicIndexForName(Handle<String> name);





  inline void set_global_proxy_object(JSObject* value); inline bool is_global_proxy_object(JSObject* value); inline JSObject* global_proxy_object(); inline void set_embedder_data(FixedArray* value); inline bool is_embedder_data(FixedArray* value); inline FixedArray* embedder_data(); inline void set_accessor_property_descriptor_map(Map* value); inline bool is_accessor_property_descriptor_map(Map* value); inline Map* accessor_property_descriptor_map(); inline void set_allow_code_gen_from_strings(Object* value); inline bool is_allow_code_gen_from_strings(Object* value); inline Object* allow_code_gen_from_strings(); inline void set_array_buffer_fun(JSFunction* value); inline bool is_array_buffer_fun(JSFunction* value); inline JSFunction* array_buffer_fun(); inline void set_array_buffer_map(Map* value); inline bool is_array_buffer_map(Map* value); inline Map* array_buffer_map(); inline void set_array_function(JSFunction* value); inline bool is_array_function(JSFunction* value); inline JSFunction* array_function(); inline void set_bool16x8_function(JSFunction* value); inline bool is_bool16x8_function(JSFunction* value); inline JSFunction* bool16x8_function(); inline void set_bool32x4_function(JSFunction* value); inline bool is_bool32x4_function(JSFunction* value); inline JSFunction* bool32x4_function(); inline void set_bool8x16_function(JSFunction* value); inline bool is_bool8x16_function(JSFunction* value); inline JSFunction* bool8x16_function(); inline void set_boolean_function(JSFunction* value); inline bool is_boolean_function(JSFunction* value); inline JSFunction* boolean_function(); inline void set_bound_function_with_constructor_map(Map* value); inline bool is_bound_function_with_constructor_map(Map* value); inline Map* bound_function_with_constructor_map(); inline void set_bound_function_without_constructor_map(Map* value); inline bool is_bound_function_without_constructor_map(Map* value); inline Map* bound_function_without_constructor_map(); inline void set_call_as_constructor_delegate(JSFunction* value); inline bool is_call_as_constructor_delegate(JSFunction* value); inline JSFunction* call_as_constructor_delegate(); inline void set_call_as_function_delegate(JSFunction* value); inline bool is_call_as_function_delegate(JSFunction* value); inline JSFunction* call_as_function_delegate(); inline void set_context_extension_function(JSFunction* value); inline bool is_context_extension_function(JSFunction* value); inline JSFunction* context_extension_function(); inline void set_data_property_descriptor_map(Map* value); inline bool is_data_property_descriptor_map(Map* value); inline Map* data_property_descriptor_map(); inline void set_data_view_fun(JSFunction* value); inline bool is_data_view_fun(JSFunction* value); inline JSFunction* data_view_fun(); inline void set_date_function(JSFunction* value); inline bool is_date_function(JSFunction* value); inline JSFunction* date_function(); inline void set_error_message_for_code_gen_from_strings(Object* value); inline bool is_error_message_for_code_gen_from_strings(Object* value); inline Object* error_message_for_code_gen_from_strings(); inline void set_errors_thrown(Smi* value); inline bool is_errors_thrown(Smi* value); inline Smi* errors_thrown(); inline void set_extras_binding_object(JSObject* value); inline bool is_extras_binding_object(JSObject* value); inline JSObject* extras_binding_object(); inline void set_extras_utils_object(JSObject* value); inline bool is_extras_utils_object(JSObject* value); inline JSObject* extras_utils_object(); inline void set_fast_aliased_arguments_map(Map* value); inline bool is_fast_aliased_arguments_map(Map* value); inline Map* fast_aliased_arguments_map(); inline void set_float32_array_fun(JSFunction* value); inline bool is_float32_array_fun(JSFunction* value); inline JSFunction* float32_array_fun(); inline void set_float32x4_function(JSFunction* value); inline bool is_float32x4_function(JSFunction* value); inline JSFunction* float32x4_function(); inline void set_float64_array_fun(JSFunction* value); inline bool is_float64_array_fun(JSFunction* value); inline JSFunction* float64_array_fun(); inline void set_template_instantiations_cache(UnseededNumberDictionary* value); inline bool is_template_instantiations_cache(UnseededNumberDictionary* value); inline UnseededNumberDictionary* template_instantiations_cache(); inline void set_function_function(JSFunction* value); inline bool is_function_function(JSFunction* value); inline JSFunction* function_function(); inline void set_generator_function_function(JSFunction* value); inline bool is_generator_function_function(JSFunction* value); inline JSFunction* generator_function_function(); inline void set_generator_object_prototype_map(Map* value); inline bool is_generator_object_prototype_map(Map* value); inline Map* generator_object_prototype_map(); inline void set_initial_array_prototype(JSObject* value); inline bool is_initial_array_prototype(JSObject* value); inline JSObject* initial_array_prototype(); inline void set_initial_object_prototype(JSObject* value); inline bool is_initial_object_prototype(JSObject* value); inline JSObject* initial_object_prototype(); inline void set_int16_array_fun(JSFunction* value); inline bool is_int16_array_fun(JSFunction* value); inline JSFunction* int16_array_fun(); inline void set_int16x8_function(JSFunction* value); inline bool is_int16x8_function(JSFunction* value); inline JSFunction* int16x8_function(); inline void set_int32_array_fun(JSFunction* value); inline bool is_int32_array_fun(JSFunction* value); inline JSFunction* int32_array_fun(); inline void set_int32x4_function(JSFunction* value); inline bool is_int32x4_function(JSFunction* value); inline JSFunction* int32x4_function(); inline void set_int8_array_fun(JSFunction* value); inline bool is_int8_array_fun(JSFunction* value); inline JSFunction* int8_array_fun(); inline void set_int8x16_function(JSFunction* value); inline bool is_int8x16_function(JSFunction* value); inline JSFunction* int8x16_function(); inline void set_internal_array_function(JSFunction* value); inline bool is_internal_array_function(JSFunction* value); inline JSFunction* internal_array_function(); inline void set_iterator_result_map(Map* value); inline bool is_iterator_result_map(Map* value); inline Map* iterator_result_map(); inline void set_js_array_fast_smi_elements_map_index(Map* value); inline bool is_js_array_fast_smi_elements_map_index(Map* value); inline Map* js_array_fast_smi_elements_map_index(); inline void set_js_array_fast_holey_smi_elements_map_index(Map* value); inline bool is_js_array_fast_holey_smi_elements_map_index(Map* value); inline Map* js_array_fast_holey_smi_elements_map_index(); inline void set_js_array_fast_elements_map_index(Map* value); inline bool is_js_array_fast_elements_map_index(Map* value); inline Map* js_array_fast_elements_map_index(); inline void set_js_array_fast_holey_elements_map_index(Map* value); inline bool is_js_array_fast_holey_elements_map_index(Map* value); inline Map* js_array_fast_holey_elements_map_index(); inline void set_js_array_fast_double_elements_map_index(Map* value); inline bool is_js_array_fast_double_elements_map_index(Map* value); inline Map* js_array_fast_double_elements_map_index(); inline void set_js_array_fast_holey_double_elements_map_index(Map* value); inline bool is_js_array_fast_holey_double_elements_map_index(Map* value); inline Map* js_array_fast_holey_double_elements_map_index(); inline void set_js_map_fun(JSFunction* value); inline bool is_js_map_fun(JSFunction* value); inline JSFunction* js_map_fun(); inline void set_js_map_map(Map* value); inline bool is_js_map_map(Map* value); inline Map* js_map_map(); inline void set_js_set_fun(JSFunction* value); inline bool is_js_set_fun(JSFunction* value); inline JSFunction* js_set_fun(); inline void set_js_set_map(Map* value); inline bool is_js_set_map(Map* value); inline Map* js_set_map(); inline void set_js_weak_map_fun(JSFunction* value); inline bool is_js_weak_map_fun(JSFunction* value); inline JSFunction* js_weak_map_fun(); inline void set_js_weak_set_fun(JSFunction* value); inline bool is_js_weak_set_fun(JSFunction* value); inline JSFunction* js_weak_set_fun(); inline void set_map_cache(Object* value); inline bool is_map_cache(Object* value); inline Object* map_cache(); inline void set_map_iterator_map(Map* value); inline bool is_map_iterator_map(Map* value); inline Map* map_iterator_map(); inline void set_string_iterator_map(Map* value); inline bool is_string_iterator_map(Map* value); inline Map* string_iterator_map(); inline void set_message_listeners(JSObject* value); inline bool is_message_listeners(JSObject* value); inline JSObject* message_listeners(); inline void set_natives_utils_object(Object* value); inline bool is_natives_utils_object(Object* value); inline Object* natives_utils_object(); inline void set_normalized_map_cache(Object* value); inline bool is_normalized_map_cache(Object* value); inline Object* normalized_map_cache(); inline void set_number_function(JSFunction* value); inline bool is_number_function(JSFunction* value); inline JSFunction* number_function(); inline void set_object_function(JSFunction* value); inline bool is_object_function(JSFunction* value); inline JSFunction* object_function(); inline void set_object_function_prototype_map(Map* value); inline bool is_object_function_prototype_map(Map* value); inline Map* object_function_prototype_map(); inline void set_opaque_reference_function(JSFunction* value); inline bool is_opaque_reference_function(JSFunction* value); inline JSFunction* opaque_reference_function(); inline void set_proxy_callable_map(Map* value); inline bool is_proxy_callable_map(Map* value); inline Map* proxy_callable_map(); inline void set_proxy_constructor_map(Map* value); inline bool is_proxy_constructor_map(Map* value); inline Map* proxy_constructor_map(); inline void set_proxy_function(JSFunction* value); inline bool is_proxy_function(JSFunction* value); inline JSFunction* proxy_function(); inline void set_proxy_function_map(Map* value); inline bool is_proxy_function_map(Map* value); inline Map* proxy_function_map(); inline void set_proxy_map(Map* value); inline bool is_proxy_map(Map* value); inline Map* proxy_map(); inline void set_regexp_function(JSFunction* value); inline bool is_regexp_function(JSFunction* value); inline JSFunction* regexp_function(); inline void set_regexp_result_map(Map* value); inline bool is_regexp_result_map(Map* value); inline Map* regexp_result_map(); inline void set_script_context_table(ScriptContextTable* value); inline bool is_script_context_table(ScriptContextTable* value); inline ScriptContextTable* script_context_table(); inline void set_script_function(JSFunction* value); inline bool is_script_function(JSFunction* value); inline JSFunction* script_function(); inline void set_security_token(Object* value); inline bool is_security_token(Object* value); inline Object* security_token(); inline void set_self_weak_cell(WeakCell* value); inline bool is_self_weak_cell(WeakCell* value); inline WeakCell* self_weak_cell(); inline void set_set_iterator_map(Map* value); inline bool is_set_iterator_map(Map* value); inline Map* set_iterator_map(); inline void set_shared_array_buffer_fun(JSFunction* value); inline bool is_shared_array_buffer_fun(JSFunction* value); inline JSFunction* shared_array_buffer_fun(); inline void set_sloppy_arguments_map(Map* value); inline bool is_sloppy_arguments_map(Map* value); inline Map* sloppy_arguments_map(); inline void set_sloppy_function_map(Map* value); inline bool is_sloppy_function_map(Map* value); inline Map* sloppy_function_map(); inline void set_sloppy_function_without_prototype_map(Map* value); inline bool is_sloppy_function_without_prototype_map(Map* value); inline Map* sloppy_function_without_prototype_map(); inline void set_sloppy_function_with_readonly_prototype_map(Map* value); inline bool is_sloppy_function_with_readonly_prototype_map(Map* value); inline Map* sloppy_function_with_readonly_prototype_map(); inline void set_wasm_function_map(Map* value); inline bool is_wasm_function_map(Map* value); inline Map* wasm_function_map(); inline void set_sloppy_generator_function_map(Map* value); inline bool is_sloppy_generator_function_map(Map* value); inline Map* sloppy_generator_function_map(); inline void set_slow_aliased_arguments_map(Map* value); inline bool is_slow_aliased_arguments_map(Map* value); inline Map* slow_aliased_arguments_map(); inline void set_strict_arguments_map(Map* value); inline bool is_strict_arguments_map(Map* value); inline Map* strict_arguments_map(); inline void set_strict_function_map(Map* value); inline bool is_strict_function_map(Map* value); inline Map* strict_function_map(); inline void set_strict_function_without_prototype_map(Map* value); inline bool is_strict_function_without_prototype_map(Map* value); inline Map* strict_function_without_prototype_map(); inline void set_strict_generator_function_map(Map* value); inline bool is_strict_generator_function_map(Map* value); inline Map* strict_generator_function_map(); inline void set_string_function(JSFunction* value); inline bool is_string_function(JSFunction* value); inline JSFunction* string_function(); inline void set_string_function_prototype_map(Map* value); inline bool is_string_function_prototype_map(Map* value); inline Map* string_function_prototype_map(); inline void set_symbol_function(JSFunction* value); inline bool is_symbol_function(JSFunction* value); inline JSFunction* symbol_function(); inline void set_uint16_array_fun(JSFunction* value); inline bool is_uint16_array_fun(JSFunction* value); inline JSFunction* uint16_array_fun(); inline void set_uint16x8_function(JSFunction* value); inline bool is_uint16x8_function(JSFunction* value); inline JSFunction* uint16x8_function(); inline void set_uint32_array_fun(JSFunction* value); inline bool is_uint32_array_fun(JSFunction* value); inline JSFunction* uint32_array_fun(); inline void set_uint32x4_function(JSFunction* value); inline bool is_uint32x4_function(JSFunction* value); inline JSFunction* uint32x4_function(); inline void set_uint8_array_fun(JSFunction* value); inline bool is_uint8_array_fun(JSFunction* value); inline JSFunction* uint8_array_fun(); inline void set_uint8_clamped_array_fun(JSFunction* value); inline bool is_uint8_clamped_array_fun(JSFunction* value); inline JSFunction* uint8_clamped_array_fun(); inline void set_uint8x16_function(JSFunction* value); inline bool is_uint8x16_function(JSFunction* value); inline JSFunction* uint8x16_function(); inline void set_is_arraylike(JSFunction* value); inline bool is_is_arraylike(JSFunction* value); inline JSFunction* is_arraylike(); inline void set_get_template_call_site(JSFunction* value); inline bool is_get_template_call_site(JSFunction* value); inline JSFunction* get_template_call_site(); inline void set_make_range_error(JSFunction* value); inline bool is_make_range_error(JSFunction* value); inline JSFunction* make_range_error(); inline void set_make_type_error(JSFunction* value); inline bool is_make_type_error(JSFunction* value); inline JSFunction* make_type_error(); inline void set_object_freeze(JSFunction* value); inline bool is_object_freeze(JSFunction* value); inline JSFunction* object_freeze(); inline void set_object_is_extensible(JSFunction* value); inline bool is_object_is_extensible(JSFunction* value); inline JSFunction* object_is_extensible(); inline void set_object_is_frozen(JSFunction* value); inline bool is_object_is_frozen(JSFunction* value); inline JSFunction* object_is_frozen(); inline void set_object_is_sealed(JSFunction* value); inline bool is_object_is_sealed(JSFunction* value); inline JSFunction* object_is_sealed(); inline void set_object_keys(JSFunction* value); inline bool is_object_keys(JSFunction* value); inline JSFunction* object_keys(); inline void set_reflect_apply(JSFunction* value); inline bool is_reflect_apply(JSFunction* value); inline JSFunction* reflect_apply(); inline void set_reflect_construct(JSFunction* value); inline bool is_reflect_construct(JSFunction* value); inline JSFunction* reflect_construct(); inline void set_reflect_define_property(JSFunction* value); inline bool is_reflect_define_property(JSFunction* value); inline JSFunction* reflect_define_property(); inline void set_reflect_delete_property(JSFunction* value); inline bool is_reflect_delete_property(JSFunction* value); inline JSFunction* reflect_delete_property(); inline void set_spread_arguments(JSFunction* value); inline bool is_spread_arguments(JSFunction* value); inline JSFunction* spread_arguments(); inline void set_spread_iterable(JSFunction* value); inline bool is_spread_iterable(JSFunction* value); inline JSFunction* spread_iterable(); inline void set_ordinary_has_instance(JSFunction* value); inline bool is_ordinary_has_instance(JSFunction* value); inline JSFunction* ordinary_has_instance(); inline void set_math_floor(JSFunction* value); inline bool is_math_floor(JSFunction* value); inline JSFunction* math_floor(); inline void set_math_sqrt(JSFunction* value); inline bool is_math_sqrt(JSFunction* value); inline JSFunction* math_sqrt(); inline void set_array_concat(JSFunction* value); inline bool is_array_concat(JSFunction* value); inline JSFunction* array_concat(); inline void set_array_pop(JSFunction* value); inline bool is_array_pop(JSFunction* value); inline JSFunction* array_pop(); inline void set_array_push(JSFunction* value); inline bool is_array_push(JSFunction* value); inline JSFunction* array_push(); inline void set_array_shift(JSFunction* value); inline bool is_array_shift(JSFunction* value); inline JSFunction* array_shift(); inline void set_array_splice(JSFunction* value); inline bool is_array_splice(JSFunction* value); inline JSFunction* array_splice(); inline void set_array_slice(JSFunction* value); inline bool is_array_slice(JSFunction* value); inline JSFunction* array_slice(); inline void set_array_unshift(JSFunction* value); inline bool is_array_unshift(JSFunction* value); inline JSFunction* array_unshift(); inline void set_array_values_iterator(JSFunction* value); inline bool is_array_values_iterator(JSFunction* value); inline JSFunction* array_values_iterator(); inline void set_derived_get_trap(JSFunction* value); inline bool is_derived_get_trap(JSFunction* value); inline JSFunction* derived_get_trap(); inline void set_error_function(JSFunction* value); inline bool is_error_function(JSFunction* value); inline JSFunction* error_function(); inline void set_eval_error_function(JSFunction* value); inline bool is_eval_error_function(JSFunction* value); inline JSFunction* eval_error_function(); inline void set_get_stack_trace_line_fun(JSFunction* value); inline bool is_get_stack_trace_line_fun(JSFunction* value); inline JSFunction* get_stack_trace_line_fun(); inline void set_global_eval_fun(JSFunction* value); inline bool is_global_eval_fun(JSFunction* value); inline JSFunction* global_eval_fun(); inline void set_json_serialize_adapter(JSFunction* value); inline bool is_json_serialize_adapter(JSFunction* value); inline JSFunction* json_serialize_adapter(); inline void set_make_error_function(JSFunction* value); inline bool is_make_error_function(JSFunction* value); inline JSFunction* make_error_function(); inline void set_map_delete(JSFunction* value); inline bool is_map_delete(JSFunction* value); inline JSFunction* map_delete(); inline void set_map_get(JSFunction* value); inline bool is_map_get(JSFunction* value); inline JSFunction* map_get(); inline void set_map_has(JSFunction* value); inline bool is_map_has(JSFunction* value); inline JSFunction* map_has(); inline void set_map_set(JSFunction* value); inline bool is_map_set(JSFunction* value); inline JSFunction* map_set(); inline void set_math_pow(JSFunction* value); inline bool is_math_pow(JSFunction* value); inline JSFunction* math_pow(); inline void set_message_get_column_number(JSFunction* value); inline bool is_message_get_column_number(JSFunction* value); inline JSFunction* message_get_column_number(); inline void set_message_get_line_number(JSFunction* value); inline bool is_message_get_line_number(JSFunction* value); inline JSFunction* message_get_line_number(); inline void set_message_get_source_line(JSFunction* value); inline bool is_message_get_source_line(JSFunction* value); inline JSFunction* message_get_source_line(); inline void set_native_object_get_notifier(JSFunction* value); inline bool is_native_object_get_notifier(JSFunction* value); inline JSFunction* native_object_get_notifier(); inline void set_native_object_notifier_perform_change(JSFunction* value); inline bool is_native_object_notifier_perform_change(JSFunction* value); inline JSFunction* native_object_notifier_perform_change(); inline void set_native_object_observe(JSFunction* value); inline bool is_native_object_observe(JSFunction* value); inline JSFunction* native_object_observe(); inline void set_no_side_effects_to_string_fun(JSFunction* value); inline bool is_no_side_effects_to_string_fun(JSFunction* value); inline JSFunction* no_side_effects_to_string_fun(); inline void set_object_value_of(JSFunction* value); inline bool is_object_value_of(JSFunction* value); inline JSFunction* object_value_of(); inline void set_object_to_string(JSFunction* value); inline bool is_object_to_string(JSFunction* value); inline JSFunction* object_to_string(); inline void set_observers_begin_perform_splice(JSFunction* value); inline bool is_observers_begin_perform_splice(JSFunction* value); inline JSFunction* observers_begin_perform_splice(); inline void set_observers_end_perform_splice(JSFunction* value); inline bool is_observers_end_perform_splice(JSFunction* value); inline JSFunction* observers_end_perform_splice(); inline void set_observers_enqueue_splice(JSFunction* value); inline bool is_observers_enqueue_splice(JSFunction* value); inline JSFunction* observers_enqueue_splice(); inline void set_observers_notify_change(JSFunction* value); inline bool is_observers_notify_change(JSFunction* value); inline JSFunction* observers_notify_change(); inline void set_promise_catch(JSFunction* value); inline bool is_promise_catch(JSFunction* value); inline JSFunction* promise_catch(); inline void set_promise_chain(JSFunction* value); inline bool is_promise_chain(JSFunction* value); inline JSFunction* promise_chain(); inline void set_promise_create(JSFunction* value); inline bool is_promise_create(JSFunction* value); inline JSFunction* promise_create(); inline void set_promise_function(JSFunction* value); inline bool is_promise_function(JSFunction* value); inline JSFunction* promise_function(); inline void set_promise_has_user_defined_reject_handler(JSFunction* value); inline bool is_promise_has_user_defined_reject_handler(JSFunction* value); inline JSFunction* promise_has_user_defined_reject_handler(); inline void set_promise_reject(JSFunction* value); inline bool is_promise_reject(JSFunction* value); inline JSFunction* promise_reject(); inline void set_promise_resolve(JSFunction* value); inline bool is_promise_resolve(JSFunction* value); inline JSFunction* promise_resolve(); inline void set_promise_then(JSFunction* value); inline bool is_promise_then(JSFunction* value); inline JSFunction* promise_then(); inline void set_range_error_function(JSFunction* value); inline bool is_range_error_function(JSFunction* value); inline JSFunction* range_error_function(); inline void set_reference_error_function(JSFunction* value); inline bool is_reference_error_function(JSFunction* value); inline JSFunction* reference_error_function(); inline void set_set_add(JSFunction* value); inline bool is_set_add(JSFunction* value); inline JSFunction* set_add(); inline void set_set_delete(JSFunction* value); inline bool is_set_delete(JSFunction* value); inline JSFunction* set_delete(); inline void set_set_has(JSFunction* value); inline bool is_set_has(JSFunction* value); inline JSFunction* set_has(); inline void set_stack_overflow_boilerplate(JSObject* value); inline bool is_stack_overflow_boilerplate(JSObject* value); inline JSObject* stack_overflow_boilerplate(); inline void set_syntax_error_function(JSFunction* value); inline bool is_syntax_error_function(JSFunction* value); inline JSFunction* syntax_error_function(); inline void set_type_error_function(JSFunction* value); inline bool is_type_error_function(JSFunction* value); inline JSFunction* type_error_function(); inline void set_uri_error_function(JSFunction* value); inline bool is_uri_error_function(JSFunction* value); inline JSFunction* uri_error_function();
  Handle<Object> Lookup(Handle<String> name,
                        ContextLookupFlags flags,
                        int* index,
                        PropertyAttributes* attributes,
                        BindingFlags* binding_flags);


  static int SlotOffset(int index) {
    return kHeaderSize + index * kPointerSize - kHeapObjectTag;
  }

  static int FunctionMapIndex(LanguageMode language_mode, FunctionKind kind) {
    if (IsGeneratorFunction(kind)) {
      return is_strict(language_mode) ? STRICT_GENERATOR_FUNCTION_MAP_INDEX
                                      : SLOPPY_GENERATOR_FUNCTION_MAP_INDEX;
    }

    if (IsClassConstructor(kind)) {

      return STRICT_FUNCTION_MAP_INDEX;
    }

    if (IsArrowFunction(kind) || IsConciseMethod(kind) ||
        IsAccessorFunction(kind)) {
      return STRICT_FUNCTION_WITHOUT_PROTOTYPE_MAP_INDEX;
    }

    return is_strict(language_mode) ? STRICT_FUNCTION_MAP_INDEX
                                    : SLOPPY_FUNCTION_MAP_INDEX;
  }

  static int ArrayMapIndex(ElementsKind elements_kind) {
    do { if ((!(IsFastElementsKind(elements_kind)))) { V8_Fatal(".././src/contexts.h", 549, "Check failed: %s.", "IsFastElementsKind(elements_kind)"); } } while (0);
    return elements_kind + FIRST_JS_ARRAY_MAP_SLOT;
  }

  static const int kSize = kHeaderSize + NATIVE_CONTEXT_SLOTS * kPointerSize;
  static const int kNotFound = -1;


  typedef FixedBodyDescriptor<
      kHeaderSize, kSize, kSize> ScavengeBodyDescriptor;

  typedef FixedBodyDescriptor<
      kHeaderSize,
      kHeaderSize + FIRST_WEAK_SLOT * kPointerSize,
      kSize> MarkCompactBodyDescriptor;

 private:


  static bool IsBootstrappingOrNativeContext(Isolate* isolate, Object* object);
  static bool IsBootstrappingOrValidParentContext(Object* object, Context* kid);


  static_assert(kHeaderSize == Internals::kContextHeaderSize, "kHeaderSize == Internals::kContextHeaderSize");
  static_assert(EMBEDDER_DATA_INDEX == Internals::kContextEmbedderDataIndex, "EMBEDDER_DATA_INDEX == Internals::kContextEmbedderDataIndex");
};

}
}
namespace v8 {
namespace internal {

class DateCache {
 public:
  static const int kMsPerMin = 60 * 1000;
  static const int kSecPerDay = 24 * 60 * 60;
  static const int64_t kMsPerDay = kSecPerDay * 1000;
  static const int64_t kMsPerMonth = kMsPerDay * 30;


  static const int kMaxEpochTimeInSec = kMaxInt;
  static const int64_t kMaxEpochTimeInMs =
      static_cast<int64_t>(kMaxInt) * 1000;


  static const int64_t kMaxTimeInMs =
      static_cast<int64_t>(864000000) * 10000000;



  static const int64_t kMaxTimeBeforeUTCInMs = kMaxTimeInMs + kMsPerMonth;


  static const int kInvalidLocalOffsetInMs = kMaxInt;


  static const int kInvalidStamp = -1;

  DateCache() : stamp_(0), tz_cache_(base::OS::CreateTimezoneCache()) {
    ResetDateCache();
  }

  virtual ~DateCache() {
    base::OS::DisposeTimezoneCache(tz_cache_);
    tz_cache_ = 0;
  }



  void ResetDateCache();



  static int DaysFromTime(int64_t time_ms) {
    if (time_ms < 0) time_ms -= (kMsPerDay - 1);
    return static_cast<int>(time_ms / kMsPerDay);
  }




  static int TimeInDay(int64_t time_ms, int days) {
    return static_cast<int>(time_ms - days * kMsPerDay);
  }




  int Weekday(int days) {
    int result = (days + 4) % 7;
    return result >= 0 ? result : result + 7;
  }


  bool IsLeap(int year) {
    return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);
  }



  int LocalOffsetInMs() {
    if (local_offset_ms_ == kInvalidLocalOffsetInMs) {
      local_offset_ms_ = GetLocalOffsetFromOS();
    }
    return local_offset_ms_;
  }


  const char* LocalTimezone(int64_t time_ms) {
    if (time_ms < 0 || time_ms > kMaxEpochTimeInMs) {
      time_ms = EquivalentTime(time_ms);
    }
    return base::OS::LocalTimezone(static_cast<double>(time_ms), tz_cache_);
  }


  int TimezoneOffset(int64_t time_ms) {
    int64_t local_ms = ToLocal(time_ms);
    return static_cast<int>((time_ms - local_ms) / kMsPerMin);
  }



  int64_t ToLocal(int64_t time_ms) {
    return time_ms + LocalOffsetInMs() + DaylightSavingsOffsetInMs(time_ms);
  }



  int64_t ToUTC(int64_t time_ms) {
    const int kMsPerHour = 3600 * 1000;
    time_ms -= LocalOffsetInMs();
    return time_ms - DaylightSavingsOffsetInMs(time_ms - kMsPerHour);
  }
  int64_t EquivalentTime(int64_t time_ms) {
    int days = DaysFromTime(time_ms);
    int time_within_day_ms = static_cast<int>(time_ms - days * kMsPerDay);
    int year, month, day;
    YearMonthDayFromDays(days, &year, &month, &day);
    int new_days = DaysFromYearMonth(EquivalentYear(year), month) + day - 1;
    return static_cast<int64_t>(new_days) * kMsPerDay + time_within_day_ms;
  }





  int EquivalentYear(int year) {
    int week_day = Weekday(DaysFromYearMonth(year, 0));
    int recent_year = (IsLeap(year) ? 1956 : 1967) + (week_day * 12) % 28;


    return 2008 + (recent_year + 3 * 28 - 2008) % 28;
  }



  void YearMonthDayFromDays(int days, int* year, int* month, int* day);



  int DaysFromYearMonth(int year, int month);


  void BreakDownTime(int64_t time_ms, int* year, int* month, int* day,
                     int* weekday, int* hour, int* min, int* sec, int* ms);





  Smi* stamp() { return stamp_; }
  void* stamp_address() { return &stamp_; }


  virtual int GetDaylightSavingsOffsetFromOS(int64_t time_sec) {
    double time_ms = static_cast<double>(time_sec * 1000);
    return static_cast<int>(
        base::OS::DaylightSavingsOffset(time_ms, tz_cache_));
  }

  virtual int GetLocalOffsetFromOS() {
    double offset = base::OS::LocalTimeOffset(tz_cache_);
    do { if ((!(offset < kInvalidLocalOffsetInMs))) { V8_Fatal(".././src/date.h", 213, "Check failed: %s.", "offset < kInvalidLocalOffsetInMs"); } } while (0);
    return static_cast<int>(offset);
  }

 private:





  static const int kDefaultDSTDeltaInSec = 19 * kSecPerDay;


  static const int kDSTSize = 32;



  struct DST {
    int start_sec;
    int end_sec;
    int offset_ms;
    int last_used;
  };



  int DaylightSavingsOffsetInMs(int64_t time_ms);






  void ProbeDST(int time_sec);



  DST* LeastRecentlyUsedDST(DST* skip);



  inline void ExtendTheAfterSegment(int time_sec, int offset_ms);


  inline void ClearSegment(DST* segment);

  bool InvalidSegment(DST* segment) {
    return segment->start_sec > segment->end_sec;
  }

  Smi* stamp_;


  DST dst_[kDSTSize];
  int dst_usage_counter_;
  DST* before_;
  DST* after_;

  int local_offset_ms_;


  bool ymd_valid_;
  int ymd_days_;
  int ymd_year_;
  int ymd_month_;
  int ymd_day_;

  base::TimezoneCache* tz_cache_;
};

}
}
namespace v8 {
namespace internal {

class Execution final : public AllStatic {
 public:






  __attribute__((warn_unused_result)) static MaybeHandle<Object> Call(Isolate* isolate,
                                                  Handle<Object> callable,
                                                  Handle<Object> receiver,
                                                  int argc,
                                                  Handle<Object> argv[]);



  __attribute__((warn_unused_result)) static MaybeHandle<Object> New(Handle<JSFunction> constructor,
                                                 int argc,
                                                 Handle<Object> argv[]);
  __attribute__((warn_unused_result)) static MaybeHandle<Object> New(Isolate* isolate,
                                                 Handle<Object> constructor,
                                                 Handle<Object> new_target,
                                                 int argc,
                                                 Handle<Object> argv[]);







  static MaybeHandle<Object> TryCall(Isolate* isolate, Handle<Object> callable,
                                     Handle<Object> receiver, int argc,
                                     Handle<Object> argv[],
                                     MaybeHandle<Object>* exception_out = 0);

  static Handle<String> GetStackTraceLine(Handle<Object> recv,
                                          Handle<JSFunction> fun,
                                          Handle<Object> pos,
                                          Handle<Object> is_global);
};


class ExecutionAccess;
class PostponeInterruptsScope;





class StackGuard final {
 public:


  void SetStackLimit(uintptr_t limit);




  void AdjustStackLimitForSimulator();


  char* ArchiveStackGuard(char* to);
  char* RestoreStackGuard(char* from);
  static int ArchiveSpacePerThread() { return sizeof(ThreadLocal); }
  void FreeThreadResources();


  void InitThread(const ExecutionAccess& lock);


  void ClearThread(const ExecutionAccess& lock);
  inline bool CheckDebugBreak() { return CheckInterrupt(DEBUGBREAK); } inline void RequestDebugBreak() { RequestInterrupt(DEBUGBREAK); } inline void ClearDebugBreak() { ClearInterrupt(DEBUGBREAK); } inline bool CheckDebugCommand() { return CheckInterrupt(DEBUGCOMMAND); } inline void RequestDebugCommand() { RequestInterrupt(DEBUGCOMMAND); } inline void ClearDebugCommand() { ClearInterrupt(DEBUGCOMMAND); } inline bool CheckTerminateExecution() { return CheckInterrupt(TERMINATE_EXECUTION); } inline void RequestTerminateExecution() { RequestInterrupt(TERMINATE_EXECUTION); } inline void ClearTerminateExecution() { ClearInterrupt(TERMINATE_EXECUTION); } inline bool CheckGC() { return CheckInterrupt(GC_REQUEST); } inline void RequestGC() { RequestInterrupt(GC_REQUEST); } inline void ClearGC() { ClearInterrupt(GC_REQUEST); } inline bool CheckInstallCode() { return CheckInterrupt(INSTALL_CODE); } inline void RequestInstallCode() { RequestInterrupt(INSTALL_CODE); } inline void ClearInstallCode() { ClearInterrupt(INSTALL_CODE); } inline bool CheckApiInterrupt() { return CheckInterrupt(API_INTERRUPT); } inline void RequestApiInterrupt() { RequestInterrupt(API_INTERRUPT); } inline void ClearApiInterrupt() { ClearInterrupt(API_INTERRUPT); } inline bool CheckDeoptMarkedAllocationSites() { return CheckInterrupt(DEOPT_MARKED_ALLOCATION_SITES); } inline void RequestDeoptMarkedAllocationSites() { RequestInterrupt(DEOPT_MARKED_ALLOCATION_SITES); } inline void ClearDeoptMarkedAllocationSites() { ClearInterrupt(DEOPT_MARKED_ALLOCATION_SITES); }



  enum InterruptFlag {

    DEBUGBREAK = (1 << 0), DEBUGCOMMAND = (1 << 1), TERMINATE_EXECUTION = (1 << 2), GC_REQUEST = (1 << 3), INSTALL_CODE = (1 << 4), API_INTERRUPT = (1 << 5), DEOPT_MARKED_ALLOCATION_SITES = (1 << 6),


    ALL_INTERRUPTS = DEBUGBREAK | DEBUGCOMMAND | TERMINATE_EXECUTION | GC_REQUEST | INSTALL_CODE | API_INTERRUPT | DEOPT_MARKED_ALLOCATION_SITES | 0

  };

  uintptr_t climit() { return thread_local_.climit(); }
  uintptr_t jslimit() { return thread_local_.jslimit(); }



  uintptr_t real_climit() {
    return thread_local_.real_climit_;
  }
  uintptr_t real_jslimit() {
    return thread_local_.real_jslimit_;
  }
  Address address_of_jslimit() {
    return reinterpret_cast<Address>(&thread_local_.jslimit_);
  }
  Address address_of_real_jslimit() {
    return reinterpret_cast<Address>(&thread_local_.real_jslimit_);
  }



  Object* HandleInterrupts();
  void HandleGCInterrupt();

 private:
  StackGuard();

  bool CheckInterrupt(InterruptFlag flag);
  void RequestInterrupt(InterruptFlag flag);
  void ClearInterrupt(InterruptFlag flag);
  bool CheckAndClearInterrupt(InterruptFlag flag);


  bool has_pending_interrupts(const ExecutionAccess& lock) {
    return thread_local_.interrupt_flags_ != 0;
  }


  inline void set_interrupt_limits(const ExecutionAccess& lock);



  inline void reset_limits(const ExecutionAccess& lock);


  void EnableInterrupts();
  void DisableInterrupts();


  static const uintptr_t kInterruptLimit = (0xfffffffffffffffeUL);
  static const uintptr_t kIllegalLimit = (0xfffffffffffffff8UL);





  void PushPostponeInterruptsScope(PostponeInterruptsScope* scope);
  void PopPostponeInterruptsScope();

  class ThreadLocal final {
   public:
    ThreadLocal() { Clear(); }


    void Clear();


    bool Initialize(Isolate* isolate);
    uintptr_t real_jslimit_;
    uintptr_t real_climit_;



    base::AtomicWord jslimit_;
    base::AtomicWord climit_;

    uintptr_t jslimit() {
      return bit_cast<uintptr_t>(base::NoBarrier_Load(&jslimit_));
    }
    void set_jslimit(uintptr_t limit) {
      return base::NoBarrier_Store(&jslimit_,
                                   static_cast<base::AtomicWord>(limit));
    }
    uintptr_t climit() {
      return bit_cast<uintptr_t>(base::NoBarrier_Load(&climit_));
    }
    void set_climit(uintptr_t limit) {
      return base::NoBarrier_Store(&climit_,
                                   static_cast<base::AtomicWord>(limit));
    }

    PostponeInterruptsScope* postpone_interrupts_;
    int interrupt_flags_;
  };



  Isolate* isolate_;
  ThreadLocal thread_local_;

  friend class Isolate;
  friend class StackLimitCheck;
  friend class PostponeInterruptsScope;

  StackGuard(const StackGuard&) = delete; void operator=(const StackGuard&) = delete;
};

}
}







namespace v8 {
namespace internal {




class Memory {
 public:
  static uint8_t& uint8_at(Address addr) {
    return *reinterpret_cast<uint8_t*>(addr);
  }

  static uint16_t& uint16_at(Address addr) {
    return *reinterpret_cast<uint16_t*>(addr);
  }

  static uint32_t& uint32_at(Address addr) {
    return *reinterpret_cast<uint32_t*>(addr);
  }

  static int32_t& int32_at(Address addr) {
    return *reinterpret_cast<int32_t*>(addr);
  }

  static uint64_t& uint64_at(Address addr) {
    return *reinterpret_cast<uint64_t*>(addr);
  }

  static int& int_at(Address addr) {
    return *reinterpret_cast<int*>(addr);
  }

  static unsigned& unsigned_at(Address addr) {
    return *reinterpret_cast<unsigned*>(addr);
  }

  static intptr_t& intptr_at(Address addr) {
    return *reinterpret_cast<intptr_t*>(addr);
  }

  static uintptr_t& uintptr_at(Address addr) {
    return *reinterpret_cast<uintptr_t*>(addr);
  }

  static double& double_at(Address addr) {
    return *reinterpret_cast<double*>(addr);
  }

  static Address& Address_at(Address addr) {
    return *reinterpret_cast<Address*>(addr);
  }

  static Object*& Object_at(Address addr) {
    return *reinterpret_cast<Object**>(addr);
  }

  static Handle<Object>& Object_Handle_at(Address addr) {
    return *reinterpret_cast<Handle<Object>*>(addr);
  }
};

}
}


namespace v8 {
namespace internal {

struct Register;

class SafepointEntry : public Embedded {
 public:
  SafepointEntry() : info_(0), bits_(0) {}

  SafepointEntry(unsigned info, uint8_t* bits) : info_(info), bits_(bits) {
    do { if ((!(is_valid()))) { V8_Fatal(".././src/safepoint-table.h", 23, "Check failed: %s.", "is_valid()"); } } while (0);
  }

  bool is_valid() const { return bits_ != 0; }

  bool Equals(const SafepointEntry& other) const {
    return info_ == other.info_ && bits_ == other.bits_;
  }

  void Reset() {
    info_ = 0;
    bits_ = 0;
  }

  int deoptimization_index() const {
    do { if ((!(is_valid()))) { V8_Fatal(".././src/safepoint-table.h", 38, "Check failed: %s.", "is_valid()"); } } while (0);
    return DeoptimizationIndexField::decode(info_);
  }

  static const int kArgumentsFieldBits = 3;
  static const int kSaveDoublesFieldBits = 1;
  static const int kDeoptIndexBits =
      32 - kArgumentsFieldBits - kSaveDoublesFieldBits;
  class DeoptimizationIndexField:
    public BitField<int, 0, kDeoptIndexBits> {};
  class ArgumentsField:
    public BitField<unsigned,
                    kDeoptIndexBits,
                    kArgumentsFieldBits> {};
  class SaveDoublesField:
    public BitField<bool,
                    kDeoptIndexBits + kArgumentsFieldBits,
                    kSaveDoublesFieldBits> { };

  int argument_count() const {
    do { if ((!(is_valid()))) { V8_Fatal(".././src/safepoint-table.h", 58, "Check failed: %s.", "is_valid()"); } } while (0);
    return ArgumentsField::decode(info_);
  }

  bool has_doubles() const {
    do { if ((!(is_valid()))) { V8_Fatal(".././src/safepoint-table.h", 63, "Check failed: %s.", "is_valid()"); } } while (0);
    return SaveDoublesField::decode(info_);
  }

  uint8_t* bits() {
    do { if ((!(is_valid()))) { V8_Fatal(".././src/safepoint-table.h", 68, "Check failed: %s.", "is_valid()"); } } while (0);
    return bits_;
  }

  bool HasRegisters() const;
  bool HasRegisterAt(int reg_index) const;

 private:
  unsigned info_;
  uint8_t* bits_;
};


class SafepointTable : public Embedded {
 public:
  explicit SafepointTable(Code* code);

  int size() const {
    return kHeaderSize +
           (length_ * (kPcAndDeoptimizationIndexSize + entry_size_));
  }
  unsigned length() const { return length_; }
  unsigned entry_size() const { return entry_size_; }

  unsigned GetPcOffset(unsigned index) const {
    do { if ((!(index < length_))) { V8_Fatal(".././src/safepoint-table.h", 93, "Check failed: %s.", "index < length_"); } } while (0);
    return Memory::uint32_at(GetPcOffsetLocation(index));
  }

  SafepointEntry GetEntry(unsigned index) const {
    do { if ((!(index < length_))) { V8_Fatal(".././src/safepoint-table.h", 98, "Check failed: %s.", "index < length_"); } } while (0);
    unsigned info = Memory::uint32_at(GetInfoLocation(index));
    uint8_t* bits = &Memory::uint8_at(entries_ + (index * entry_size_));
    return SafepointEntry(info, bits);
  }


  SafepointEntry FindEntry(Address pc) const;

  void PrintEntry(unsigned index, std::ostream& os) const;

 private:
  static const uint8_t kNoRegisters = 0xFF;

  static const int kLengthOffset = 0;
  static const int kEntrySizeOffset = kLengthOffset + kIntSize;
  static const int kHeaderSize = kEntrySizeOffset + kIntSize;

  static const int kPcSize = kIntSize;
  static const int kDeoptimizationIndexSize = kIntSize;
  static const int kPcAndDeoptimizationIndexSize =
      kPcSize + kDeoptimizationIndexSize;

  Address GetPcOffsetLocation(unsigned index) const {
    return pc_and_deoptimization_indexes_ +
           (index * kPcAndDeoptimizationIndexSize);
  }

  Address GetInfoLocation(unsigned index) const {
    return GetPcOffsetLocation(index) + kPcSize;
  }

  static void PrintBits(std::ostream& os,
                        uint8_t byte, int digits);

  DisallowHeapAllocation no_allocation_;
  Code* code_;
  unsigned length_;
  unsigned entry_size_;

  Address pc_and_deoptimization_indexes_;
  Address entries_;

  friend class SafepointTableBuilder;
  friend class SafepointEntry;

  SafepointTable(const SafepointTable&) = delete; void operator=(const SafepointTable&) = delete;
};


class Safepoint : public Embedded {
 public:
  typedef enum {
    kSimple = 0,
    kWithRegisters = 1 << 0,
    kWithDoubles = 1 << 1,
    kWithRegistersAndDoubles = kWithRegisters | kWithDoubles
  } Kind;

  enum DeoptMode {
    kNoLazyDeopt,
    kLazyDeopt
  };

  static const int kNoDeoptimizationIndex =
      (1 << (SafepointEntry::kDeoptIndexBits)) - 1;

  void DefinePointerSlot(int index, Zone* zone) { indexes_->Add(index, zone); }
  void DefinePointerRegister(Register reg, Zone* zone);

 private:
  Safepoint(ZoneList<int>* indexes, ZoneList<int>* registers)
      : indexes_(indexes), registers_(registers) {}
  ZoneList<int>* indexes_;
  ZoneList<int>* registers_;

  friend class SafepointTableBuilder;
};


class SafepointTableBuilder : public Embedded {
 public:
  explicit SafepointTableBuilder(Zone* zone)
      : deoptimization_info_(32, zone),
        deopt_index_list_(32, zone),
        indexes_(32, zone),
        registers_(32, zone),
        emitted_(false),
        last_lazy_safepoint_(0),
        zone_(zone) { }


  unsigned GetCodeOffset() const;


  Safepoint DefineSafepoint(Assembler* assembler,
                            Safepoint::Kind kind,
                            int arguments,
                            Safepoint::DeoptMode mode);



  void RecordLazyDeoptimizationIndex(int index);
  void BumpLastLazySafepointIndex() {
    last_lazy_safepoint_ = deopt_index_list_.length();
  }



  void Emit(Assembler* assembler, int bits_per_entry);


 private:
  struct DeoptimizationInfo {
    unsigned pc;
    unsigned arguments;
    bool has_doubles;
  };

  uint32_t EncodeExceptPC(const DeoptimizationInfo& info, unsigned index);

  ZoneList<DeoptimizationInfo> deoptimization_info_;
  ZoneList<unsigned> deopt_index_list_;
  ZoneList<ZoneList<int>*> indexes_;
  ZoneList<ZoneList<int>*> registers_;

  unsigned offset_;
  bool emitted_;
  int last_lazy_safepoint_;

  Zone* zone_;

  SafepointTableBuilder(const SafepointTableBuilder&) = delete; void operator=(const SafepointTableBuilder&) = delete;
};

}
}



namespace v8 {
namespace internal {




typedef uint32_t RegList;



int NumRegs(RegList list);

void SetUpJSCallerSavedCodeData();


int JSCallerSavedCode(int n);



class ExternalCallbackScope;
class StackFrameIteratorBase;
class ThreadLocalTop;
class Isolate;

class InnerPointerToCodeCache {
 public:
  struct InnerPointerToCodeCacheEntry {
    Address inner_pointer;
    Code* code;
    SafepointEntry safepoint_entry;
  };

  explicit InnerPointerToCodeCache(Isolate* isolate) : isolate_(isolate) {
    Flush();
  }

  Code* GcSafeFindCodeForInnerPointer(Address inner_pointer);
  Code* GcSafeCastToCode(HeapObject* object, Address inner_pointer);

  void Flush() {
    memset(&cache_[0], 0, sizeof(cache_));
  }

  InnerPointerToCodeCacheEntry* GetCacheEntry(Address inner_pointer);

 private:
  InnerPointerToCodeCacheEntry* cache(int index) { return &cache_[index]; }

  Isolate* isolate_;

  static const int kInnerPointerToCodeCacheSize = 1024;
  InnerPointerToCodeCacheEntry cache_[kInnerPointerToCodeCacheSize];

  InnerPointerToCodeCache(const InnerPointerToCodeCache&) = delete; void operator=(const InnerPointerToCodeCache&) = delete;
};



class TryBlockConstant : public AllStatic {
 public:
  static const int kElementCount = 1;
};


class StackHandlerConstants : public AllStatic {
 public:
  static const int kNextOffset = 0 * kPointerSize;

  static const int kSize = kNextOffset + kPointerSize;
  static const int kSlotCount = kSize >> kPointerSizeLog2;
};


class StackHandler : public Embedded {
 public:

  inline Address address() const;


  inline StackHandler* next() const;


  static inline StackHandler* FromAddress(Address address);

 private:
  StackHandler() = delete; StackHandler(const StackHandler&) = delete; void operator=(const StackHandler&) = delete;
};
class CommonFrameConstants : public AllStatic {
 public:
  static const int kCallerFPOffset = 0 * kPointerSize;
  static const int kCallerPCOffset = kCallerFPOffset + 1 * kFPOnStackSize;
  static const int kCallerSPOffset = kCallerPCOffset + 1 * kPCOnStackSize;





  static const int kFixedFrameSizeAboveFp = kPCOnStackSize + kFPOnStackSize;
  static const int kFixedSlotCountAboveFp =
      kFixedFrameSizeAboveFp / kPointerSize;
  static const int kCPSlotSize =
      FLAG_enable_embedded_constant_pool ? kPointerSize : 0;
  static const int kCPSlotCount = kCPSlotSize / kPointerSize;
  static const int kConstantPoolOffset = kCPSlotSize ? -1 * kPointerSize : 0;
  static const int kContextOrFrameTypeSize = kPointerSize;
  static const int kContextOrFrameTypeOffset =
      -(kCPSlotSize + kContextOrFrameTypeSize);
};
class StandardFrameConstants : public CommonFrameConstants {
 public:
  static const int kFixedFrameSizeFromFp = 2 * kPointerSize + kCPSlotSize;
  static const int kFixedFrameSize =
      kFixedFrameSizeAboveFp + kFixedFrameSizeFromFp;
  static const int kFixedSlotCountFromFp = kFixedFrameSizeFromFp / kPointerSize;
  static const int kFixedSlotCount = kFixedFrameSize / kPointerSize;
  static const int kContextOffset = kContextOrFrameTypeOffset;
  static const int kFunctionOffset = -2 * kPointerSize - kCPSlotSize;
  static const int kExpressionsOffset = -3 * kPointerSize - kCPSlotSize;
  static const int kLastObjectOffset = kContextOffset;
};
class TypedFrameConstants : public CommonFrameConstants {
 public:
  static const int kFrameTypeSize = kContextOrFrameTypeSize;
  static const int kFrameTypeOffset = kContextOrFrameTypeOffset;
  static const int kFixedFrameSizeFromFp = kCPSlotSize + kFrameTypeSize;
  static const int kFixedSlotCountFromFp = kFixedFrameSizeFromFp / kPointerSize;
  static const int kFixedFrameSize =
      StandardFrameConstants::kFixedFrameSizeAboveFp + kFixedFrameSizeFromFp;
  static const int kFixedSlotCount = kFixedFrameSize / kPointerSize;
  static const int kFirstPushedFrameValueOffset =
      -StandardFrameConstants::kCPSlotSize - kFrameTypeSize - kPointerSize;
};
class ArgumentsAdaptorFrameConstants : public TypedFrameConstants {
 public:

  static const int kFunctionOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (0)*kPointerSize);
  static const int kLengthOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (1)*kPointerSize);
  static const int kFixedFrameSize = (TypedFrameConstants::kFixedFrameSize + (2)*kPointerSize); static const int kFixedSlotCount = kFixedFrameSize / kPointerSize; static const int kFixedFrameSizeFromFp = (TypedFrameConstants::kFixedFrameSizeFromFp + (2)*kPointerSize); static const int kFixedSlotCountFromFp = kFixedFrameSizeFromFp / kPointerSize;
};

class InternalFrameConstants : public TypedFrameConstants {
 public:

  static const int kCodeOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (0)*kPointerSize);
  static const int kFixedFrameSize = (TypedFrameConstants::kFixedFrameSize + (1)*kPointerSize); static const int kFixedSlotCount = kFixedFrameSize / kPointerSize; static const int kFixedFrameSizeFromFp = (TypedFrameConstants::kFixedFrameSizeFromFp + (1)*kPointerSize); static const int kFixedSlotCountFromFp = kFixedFrameSizeFromFp / kPointerSize;
};

class FrameDropperFrameConstants : public InternalFrameConstants {
 public:

  static const int kFunctionOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (1)*kPointerSize);
  static const int kFixedFrameSize = (TypedFrameConstants::kFixedFrameSize + (2)*kPointerSize); static const int kFixedSlotCount = kFixedFrameSize / kPointerSize; static const int kFixedFrameSizeFromFp = (TypedFrameConstants::kFixedFrameSizeFromFp + (2)*kPointerSize); static const int kFixedSlotCountFromFp = kFixedFrameSizeFromFp / kPointerSize;
};

class ConstructFrameConstants : public TypedFrameConstants {
 public:

  static const int kContextOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (0)*kPointerSize);
  static const int kAllocationSiteOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (1)*kPointerSize);
  static const int kLengthOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (2)*kPointerSize);
  static const int kImplicitReceiverOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (3)*kPointerSize);
  static const int kFixedFrameSize = (TypedFrameConstants::kFixedFrameSize + (4)*kPointerSize); static const int kFixedSlotCount = kFixedFrameSize / kPointerSize; static const int kFixedFrameSizeFromFp = (TypedFrameConstants::kFixedFrameSizeFromFp + (4)*kPointerSize); static const int kFixedSlotCountFromFp = kFixedFrameSizeFromFp / kPointerSize;
};

class StubFailureTrampolineFrameConstants : public InternalFrameConstants {
 public:
  static const int kArgumentsArgumentsOffset =
      (TypedFrameConstants::kFirstPushedFrameValueOffset - (0)*kPointerSize);
  static const int kArgumentsLengthOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (1)*kPointerSize);
  static const int kArgumentsPointerOffset = (TypedFrameConstants::kFirstPushedFrameValueOffset - (2)*kPointerSize);
  static const int kFixedHeaderBottomOffset = kArgumentsPointerOffset;
  static const int kFixedFrameSize = (TypedFrameConstants::kFixedFrameSize + (3)*kPointerSize); static const int kFixedSlotCount = kFixedFrameSize / kPointerSize; static const int kFixedFrameSizeFromFp = (TypedFrameConstants::kFixedFrameSizeFromFp + (3)*kPointerSize); static const int kFixedSlotCountFromFp = kFixedFrameSizeFromFp / kPointerSize;
};


class InterpreterFrameConstants : public AllStatic {
 public:

  static const int kFixedFrameSize =
      StandardFrameConstants::kFixedFrameSize + 3 * kPointerSize;
  static const int kFixedFrameSizeFromFp =
      StandardFrameConstants::kFixedFrameSizeFromFp + 3 * kPointerSize;


  static const int kNewTargetFromFp =
      -StandardFrameConstants::kFixedFrameSizeFromFp - 1 * kPointerSize;
  static const int kBytecodeArrayFromFp =
      -StandardFrameConstants::kFixedFrameSizeFromFp - 2 * kPointerSize;
  static const int kBytecodeOffsetFromFp =
      -StandardFrameConstants::kFixedFrameSizeFromFp - 3 * kPointerSize;
  static const int kRegisterFilePointerFromFp =
      -StandardFrameConstants::kFixedFrameSizeFromFp - 4 * kPointerSize;

  static const int kExpressionsOffset = kRegisterFilePointerFromFp;


  static const int kBytecodeArrayExpressionIndex = -2;
  static const int kBytecodeOffsetExpressionIndex = -1;
  static const int kRegisterFileExpressionIndex = 0;


  static const int kLastParamFromRegisterPointer =
      StandardFrameConstants::kFixedFrameSize + 4 * kPointerSize;

  static const int kBytecodeOffsetFromRegisterPointer = 1 * kPointerSize;
  static const int kBytecodeArrayFromRegisterPointer = 2 * kPointerSize;
  static const int kNewTargetFromRegisterPointer = 3 * kPointerSize;
  static const int kFunctionFromRegisterPointer = 4 * kPointerSize;
  static const int kContextFromRegisterPointer = 5 * kPointerSize;
};

inline static int FPOffsetToFrameSlot(int frame_offset) {
  return StandardFrameConstants::kFixedSlotCountAboveFp - 1 -
         frame_offset / kPointerSize;
}

inline static int FrameSlotToFPOffset(int slot) {
  return (StandardFrameConstants::kFixedSlotCountAboveFp - 1 - slot) *
         kPointerSize;
}


class StackFrame : public Embedded {
 public:

  enum Type {
    NONE = 0,
    ENTRY, ENTRY_CONSTRUCT, EXIT, JAVA_SCRIPT, OPTIMIZED, WASM, WASM_TO_JS, JS_TO_WASM, INTERPRETED, STUB, STUB_FAILURE_TRAMPOLINE, INTERNAL, CONSTRUCT, ARGUMENTS_ADAPTOR,
    NUMBER_OF_TYPES,


    MANUAL
  };






  enum Id {
    ID_MIN_VALUE = kMinInt,
    ID_MAX_VALUE = kMaxInt,
    NO_ID = 0
  };


  enum JsFrameMarker {
    INNER_JSENTRY_FRAME = 0,
    OUTERMOST_JSENTRY_FRAME = 1
  };

  struct State {
    State() : sp(0), fp(0), pc_address(0),
              constant_pool_address(0) { }
    Address sp;
    Address fp;
    Address* pc_address;
    Address* constant_pool_address;
  };



  StackFrame(const StackFrame& original) {
    this->state_ = original.state_;
    this->iterator_ = 0;
    this->isolate_ = original.isolate_;
  }


  bool is_entry() const { return type() == ENTRY; }
  bool is_entry_construct() const { return type() == ENTRY_CONSTRUCT; }
  bool is_exit() const { return type() == EXIT; }
  bool is_optimized() const { return type() == OPTIMIZED; }
  bool is_interpreted() const { return type() == INTERPRETED; }
  bool is_wasm() const { return type() == WASM; }
  bool is_wasm_to_js() const { return type() == WASM_TO_JS; }
  bool is_js_to_wasm() const { return type() == JS_TO_WASM; }
  bool is_arguments_adaptor() const { return type() == ARGUMENTS_ADAPTOR; }
  bool is_internal() const { return type() == INTERNAL; }
  bool is_stub_failure_trampoline() const {
    return type() == STUB_FAILURE_TRAMPOLINE;
  }
  bool is_construct() const { return type() == CONSTRUCT; }
  virtual bool is_standard() const { return false; }

  bool is_java_script() const {
    Type type = this->type();
    return (type == JAVA_SCRIPT) || (type == OPTIMIZED) ||
           (type == INTERPRETED);
  }


  Address sp() const { return state_.sp; }
  Address fp() const { return state_.fp; }
  Address caller_sp() const { return GetCallerStackPointer(); }




  Address UnpaddedFP() const;

  Address pc() const { return *pc_address(); }
  void set_pc(Address pc) { *pc_address() = pc; }

  Address constant_pool() const { return *constant_pool_address(); }
  void set_constant_pool(Address constant_pool) {
    *constant_pool_address() = constant_pool;
  }

  virtual void SetCallerFp(Address caller_fp) = 0;


  void UpdateFp(Address fp) { state_.fp = fp; }

  Address* pc_address() const { return state_.pc_address; }

  Address* constant_pool_address() const {
    return state_.constant_pool_address;
  }


  Id id() const { return static_cast<Id>(OffsetFrom(caller_sp())); }


  inline StackHandler* top_handler() const;


  virtual Type type() const = 0;



  virtual Code* unchecked_code() const = 0;


  inline Code* LookupCode() const;


  static inline Code* GetContainingCode(Isolate* isolate, Address pc);




  static Code* GetSafepointData(Isolate* isolate,
                                Address pc,
                                SafepointEntry* safepoint_entry,
                                unsigned* stack_slots);

  virtual void Iterate(ObjectVisitor* v) const = 0;
  static void IteratePc(ObjectVisitor* v, Address* pc_address,
                        Address* constant_pool_address, Code* holder);




  static void SetReturnAddressLocationResolver(
      ReturnAddressLocationResolver resolver);


  static inline Address* ResolveReturnAddressLocation(Address* pc_address);


  enum PrintMode { OVERVIEW, DETAILS };
  virtual void Print(StringStream* accumulator,
                     PrintMode mode,
                     int index) const { }

  Isolate* isolate() const { return isolate_; }

 protected:
  inline explicit StackFrame(StackFrameIteratorBase* iterator);
  virtual ~StackFrame() { }


  virtual Address GetCallerStackPointer() const = 0;


  static void PrintIndex(StringStream* accumulator,
                         PrintMode mode,
                         int index);


  static Type ComputeType(const StackFrameIteratorBase* iterator, State* state);


  bool can_access_heap_objects() const;


 private:
  const StackFrameIteratorBase* iterator_;
  Isolate* isolate_;
  State state_;

  static ReturnAddressLocationResolver return_address_location_resolver_;


  virtual void ComputeCallerState(State* state) const = 0;


  virtual Type GetCallerState(State* state) const;

  static const intptr_t kIsolateTag = 1;

  friend class StackFrameIterator;
  friend class StackFrameIteratorBase;
  friend class StackHandlerIterator;
  friend class SafeStackFrameIterator;

 private:
  void operator=(const StackFrame& original);
};



class EntryFrame: public StackFrame {
 public:
  Type type() const override { return ENTRY; }

  Code* unchecked_code() const override;


  void Iterate(ObjectVisitor* v) const override;

  static EntryFrame* cast(StackFrame* frame) {
    do { if ((!(frame->is_entry()))) { V8_Fatal(".././src/frames.h", 568, "Check failed: %s.", "frame->is_entry()"); } } while (0);
    return static_cast<EntryFrame*>(frame);
  }
  void SetCallerFp(Address caller_fp) override;

 protected:
  inline explicit EntryFrame(StackFrameIteratorBase* iterator);




  Address GetCallerStackPointer() const override { return 0; }

 private:
  void ComputeCallerState(State* state) const override;
  Type GetCallerState(State* state) const override;

  friend class StackFrameIteratorBase;
};


class EntryConstructFrame: public EntryFrame {
 public:
  Type type() const override { return ENTRY_CONSTRUCT; }

  Code* unchecked_code() const override;

  static EntryConstructFrame* cast(StackFrame* frame) {
    do { if ((!(frame->is_entry_construct()))) { V8_Fatal(".././src/frames.h", 596, "Check failed: %s.", "frame->is_entry_construct()"); } } while (0);
    return static_cast<EntryConstructFrame*>(frame);
  }

 protected:
  inline explicit EntryConstructFrame(StackFrameIteratorBase* iterator);

 private:
  friend class StackFrameIteratorBase;
};



class ExitFrame: public StackFrame {
 public:
  Type type() const override { return EXIT; }

  Code* unchecked_code() const override;

  Object*& code_slot() const;


  void Iterate(ObjectVisitor* v) const override;

  void SetCallerFp(Address caller_fp) override;

  static ExitFrame* cast(StackFrame* frame) {
    do { if ((!(frame->is_exit()))) { V8_Fatal(".././src/frames.h", 623, "Check failed: %s.", "frame->is_exit()"); } } while (0);
    return static_cast<ExitFrame*>(frame);
  }




  static Type GetStateForFramePointer(Address fp, State* state);
  static Address ComputeStackPointer(Address fp);
  static void FillState(Address fp, Address sp, State* state);

 protected:
  inline explicit ExitFrame(StackFrameIteratorBase* iterator);

  Address GetCallerStackPointer() const override;

 private:
  void ComputeCallerState(State* state) const override;

  friend class StackFrameIteratorBase;
};


class StandardFrame: public StackFrame {
 public:

  bool is_standard() const override { return true; }


  inline Object* context() const;


  inline Object* GetExpression(int index) const;
  inline void SetExpression(int index, Object* value);
  int ComputeExpressionsCount() const;

  void SetCallerFp(Address caller_fp) override;

  static StandardFrame* cast(StackFrame* frame) {
    do { if ((!(frame->is_standard()))) { V8_Fatal(".././src/frames.h", 662, "Check failed: %s.", "frame->is_standard()"); } } while (0);
    return static_cast<StandardFrame*>(frame);
  }

 protected:
  inline explicit StandardFrame(StackFrameIteratorBase* iterator);

  void ComputeCallerState(State* state) const override;


  inline Address caller_fp() const;
  inline Address caller_pc() const;



  static inline Address ComputePCAddress(Address fp);



  static inline Address ComputeConstantPoolAddress(Address fp);



  void IterateExpressions(ObjectVisitor* v) const;


  virtual Address GetExpressionAddress(int n) const;



  static inline bool IsArgumentsAdaptorFrame(Address fp);



  static inline bool IsConstructFrame(Address fp);


  void IterateCompiledFrame(ObjectVisitor* v) const;

 private:
  friend class StackFrame;
  friend class SafeStackFrameIterator;
};


class FrameSummary : public Embedded {
 public:
  FrameSummary(Object* receiver, JSFunction* function,
               AbstractCode* abstract_code, int code_offset,
               bool is_constructor);

  Handle<Object> receiver() { return receiver_; }
  Handle<JSFunction> function() { return function_; }
  Handle<AbstractCode> abstract_code() { return abstract_code_; }
  int code_offset() { return code_offset_; }
  bool is_constructor() { return is_constructor_; }

  void Print();

 private:
  Handle<Object> receiver_;
  Handle<JSFunction> function_;
  Handle<AbstractCode> abstract_code_;
  int code_offset_;
  bool is_constructor_;
};

class JavaScriptFrame : public StandardFrame {
 public:
  Type type() const override { return JAVA_SCRIPT; }


  inline JSFunction* function() const;
  inline Object* receiver() const;
  inline void set_receiver(Object* value);


  inline Address GetParameterSlot(int index) const;
  inline Object* GetParameter(int index) const;
  inline int ComputeParametersCount() const {
    return GetNumberOfIncomingArguments();
  }


  inline Address GetOperandSlot(int index) const;
  inline Object* GetOperand(int index) const;
  inline int ComputeOperandsCount() const;


  void SaveOperandStack(FixedArray* store) const;
  void RestoreOperandStack(FixedArray* store);


  void SetParameterValue(int index, Object* value) const;


  bool IsConstructor() const;



  bool HasInlinedFrames() const;




  inline bool has_adapted_arguments() const;
  int GetArgumentsLength() const;


  void Iterate(ObjectVisitor* v) const override;


  void Print(StringStream* accumulator, PrintMode mode,
             int index) const override;


  Code* unchecked_code() const override;


  virtual void GetFunctions(List<JSFunction*>* functions) const;


  virtual void Summarize(List<FrameSummary>* frames);






  virtual int LookupExceptionHandlerInTable(
      int* data, HandlerTable::CatchPrediction* prediction);


  static Register fp_register();
  static Register context_register();
  static Register constant_pool_pointer_register();

  static JavaScriptFrame* cast(StackFrame* frame) {
    do { if ((!(frame->is_java_script()))) { V8_Fatal(".././src/frames.h", 800, "Check failed: %s.", "frame->is_java_script()"); } } while (0);
    return static_cast<JavaScriptFrame*>(frame);
  }

  static void PrintFunctionAndOffset(JSFunction* function, Code* code,
                                     Address pc, FILE* file,
                                     bool print_line_number);

  static void PrintTop(Isolate* isolate, FILE* file, bool print_args,
                       bool print_line_number);

 protected:
  inline explicit JavaScriptFrame(StackFrameIteratorBase* iterator);

  Address GetCallerStackPointer() const override;

  virtual int GetNumberOfIncomingArguments() const;



  void IterateArguments(ObjectVisitor* v) const;

 private:
  inline Object* function_slot_object() const;

  friend class StackFrameIteratorBase;
};


class StubFrame : public StandardFrame {
 public:
  Type type() const override { return STUB; }


  void Iterate(ObjectVisitor* v) const override;


  Code* unchecked_code() const override;

 protected:
  inline explicit StubFrame(StackFrameIteratorBase* iterator);

  Address GetCallerStackPointer() const override;

  virtual int GetNumberOfIncomingArguments() const;

  friend class StackFrameIteratorBase;
};


class OptimizedFrame : public JavaScriptFrame {
 public:
  Type type() const override { return OPTIMIZED; }


  void Iterate(ObjectVisitor* v) const override;




  void GetFunctions(List<JSFunction*>* functions) const override;

  void Summarize(List<FrameSummary>* frames) override;


  int LookupExceptionHandlerInTable(
      int* data, HandlerTable::CatchPrediction* prediction) override;

  DeoptimizationInputData* GetDeoptimizationData(int* deopt_index) const;

  static int StackSlotOffsetRelativeToFp(int slot_index);

 protected:
  inline explicit OptimizedFrame(StackFrameIteratorBase* iterator);

 private:
  friend class StackFrameIteratorBase;

  Object* StackSlotAt(int index) const;
};


class InterpretedFrame : public JavaScriptFrame {
 public:
  Type type() const override { return INTERPRETED; }


  int LookupExceptionHandlerInTable(
      int* data, HandlerTable::CatchPrediction* prediction) override;


  int GetBytecodeOffset() const;



  void PatchBytecodeOffset(int new_offset);


  Object* GetBytecodeArray() const;



  void PatchBytecodeArray(Object* bytecode_array);


  Object* GetInterpreterRegister(int register_index) const;


  void Summarize(List<FrameSummary>* frames) override;

 protected:
  inline explicit InterpretedFrame(StackFrameIteratorBase* iterator);

  Address GetExpressionAddress(int n) const override;

 private:
  friend class StackFrameIteratorBase;
};





class ArgumentsAdaptorFrame: public JavaScriptFrame {
 public:
  Type type() const override { return ARGUMENTS_ADAPTOR; }


  Code* unchecked_code() const override;

  static ArgumentsAdaptorFrame* cast(StackFrame* frame) {
    do { if ((!(frame->is_arguments_adaptor()))) { V8_Fatal(".././src/frames.h", 931, "Check failed: %s.", "frame->is_arguments_adaptor()"); } } while (0);
    return static_cast<ArgumentsAdaptorFrame*>(frame);
  }


  void Print(StringStream* accumulator, PrintMode mode,
             int index) const override;

  static int GetLength(Address fp);

 protected:
  inline explicit ArgumentsAdaptorFrame(StackFrameIteratorBase* iterator);

  int GetNumberOfIncomingArguments() const override;

  Address GetCallerStackPointer() const override;

 private:
  friend class StackFrameIteratorBase;
};

class WasmFrame : public StandardFrame {
 public:
  Type type() const override { return WASM; }


  void Iterate(ObjectVisitor* v) const override;


  void Print(StringStream* accumulator, PrintMode mode,
             int index) const override;


  Code* unchecked_code() const override;

  static WasmFrame* cast(StackFrame* frame) {
    do { if ((!(frame->is_wasm()))) { V8_Fatal(".././src/frames.h", 967, "Check failed: %s.", "frame->is_wasm()"); } } while (0);
    return static_cast<WasmFrame*>(frame);
  }

 protected:
  inline explicit WasmFrame(StackFrameIteratorBase* iterator);

  Address GetCallerStackPointer() const override;

 private:
  friend class StackFrameIteratorBase;
};

class WasmToJsFrame : public StubFrame {
 public:
  Type type() const override { return WASM_TO_JS; }

 protected:
  inline explicit WasmToJsFrame(StackFrameIteratorBase* iterator);

 private:
  friend class StackFrameIteratorBase;
};

class JsToWasmFrame : public StubFrame {
 public:
  Type type() const override { return JS_TO_WASM; }

 protected:
  inline explicit JsToWasmFrame(StackFrameIteratorBase* iterator);

 private:
  friend class StackFrameIteratorBase;
};

class InternalFrame: public StandardFrame {
 public:
  Type type() const override { return INTERNAL; }


  void Iterate(ObjectVisitor* v) const override;


  Code* unchecked_code() const override;

  static InternalFrame* cast(StackFrame* frame) {
    do { if ((!(frame->is_internal()))) { V8_Fatal(".././src/frames.h", 1013, "Check failed: %s.", "frame->is_internal()"); } } while (0);
    return static_cast<InternalFrame*>(frame);
  }

 protected:
  inline explicit InternalFrame(StackFrameIteratorBase* iterator);

  Address GetCallerStackPointer() const override;

 private:
  friend class StackFrameIteratorBase;
};


class StubFailureTrampolineFrame: public StandardFrame {
 public:
  Type type() const override { return STUB_FAILURE_TRAMPOLINE; }



  Code* unchecked_code() const override;

  void Iterate(ObjectVisitor* v) const override;


  static Register fp_register();
  static Register context_register();
  static Register constant_pool_pointer_register();

 protected:
  inline explicit StubFailureTrampolineFrame(
      StackFrameIteratorBase* iterator);

  Address GetCallerStackPointer() const override;

 private:
  friend class StackFrameIteratorBase;
};




class ConstructFrame: public InternalFrame {
 public:
  Type type() const override { return CONSTRUCT; }

  static ConstructFrame* cast(StackFrame* frame) {
    do { if ((!(frame->is_construct()))) { V8_Fatal(".././src/frames.h", 1060, "Check failed: %s.", "frame->is_construct()"); } } while (0);
    return static_cast<ConstructFrame*>(frame);
  }

 protected:
  inline explicit ConstructFrame(StackFrameIteratorBase* iterator);

 private:
  friend class StackFrameIteratorBase;
};


class StackFrameIteratorBase : public Embedded {
 public:
  Isolate* isolate() const { return isolate_; }

  bool done() const { return frame_ == 0; }

 protected:

  StackFrameIteratorBase(Isolate* isolate, bool can_access_heap_objects);

  Isolate* isolate_;

  EntryFrame EntryFrame_; EntryConstructFrame EntryConstructFrame_; ExitFrame ExitFrame_; JavaScriptFrame JavaScriptFrame_; OptimizedFrame OptimizedFrame_; WasmFrame WasmFrame_; WasmToJsFrame WasmToJsFrame_; JsToWasmFrame JsToWasmFrame_; InterpretedFrame InterpretedFrame_; StubFrame StubFrame_; StubFailureTrampolineFrame StubFailureTrampolineFrame_; InternalFrame InternalFrame_; ConstructFrame ConstructFrame_; ArgumentsAdaptorFrame ArgumentsAdaptorFrame_;

  StackFrame* frame_;
  StackHandler* handler_;
  const bool can_access_heap_objects_;

  StackHandler* handler() const {
    do { if ((!(!done()))) { V8_Fatal(".././src/frames.h", 1091, "Check failed: %s.", "!done()"); } } while (0);
    return handler_;
  }


  StackFrame* SingletonFor(StackFrame::Type type, StackFrame::State* state);

  StackFrame* SingletonFor(StackFrame::Type type);

 private:
  friend class StackFrame;
  StackFrameIteratorBase(const StackFrameIteratorBase&) = delete; void operator=(const StackFrameIteratorBase&) = delete;
};


class StackFrameIterator: public StackFrameIteratorBase {
 public:

  explicit StackFrameIterator(Isolate* isolate);

  StackFrameIterator(Isolate* isolate, ThreadLocalTop* t);

  StackFrame* frame() const {
    do { if ((!(!done()))) { V8_Fatal(".././src/frames.h", 1114, "Check failed: %s.", "!done()"); } } while (0);
    return frame_;
  }
  void Advance();

 private:

  void Reset(ThreadLocalTop* top);

  StackFrameIterator(const StackFrameIterator&) = delete; void operator=(const StackFrameIterator&) = delete;
};


class JavaScriptFrameIterator : public Embedded {
 public:
  inline explicit JavaScriptFrameIterator(Isolate* isolate);
  inline JavaScriptFrameIterator(Isolate* isolate, ThreadLocalTop* top);

  JavaScriptFrameIterator(Isolate* isolate, StackFrame::Id id);

  inline JavaScriptFrame* frame() const;

  bool done() const { return iterator_.done(); }
  void Advance();




  void AdvanceToArgumentsFrame();

 private:
  StackFrameIterator iterator_;
};





class StackTraceFrameIterator: public JavaScriptFrameIterator {
 public:
  explicit StackTraceFrameIterator(Isolate* isolate);
  void Advance();

 private:
  bool IsValidFrame();
};


class SafeStackFrameIterator: public StackFrameIteratorBase {
 public:
  SafeStackFrameIterator(Isolate* isolate,
                         Address fp, Address sp,
                         Address js_entry_sp);

  inline StackFrame* frame() const;
  void Advance();

  StackFrame::Type top_frame_type() const { return top_frame_type_; }

 private:
  void AdvanceOneFrame();

  bool IsValidStackAddress(Address addr) const {
    return low_bound_ <= addr && addr <= high_bound_;
  }
  bool IsValidFrame(StackFrame* frame) const;
  bool IsValidCaller(StackFrame* frame);
  bool IsValidExitFrame(Address fp) const;
  bool IsValidTop(ThreadLocalTop* top) const;

  const Address low_bound_;
  const Address high_bound_;
  StackFrame::Type top_frame_type_;
  ExternalCallbackScope* external_callback_scope_;
};


class StackFrameLocator : public Embedded {
 public:
  explicit StackFrameLocator(Isolate* isolate) : iterator_(isolate) {}



  JavaScriptFrame* FindJavaScriptFrame(int n);

 private:
  StackFrameIterator iterator_;
};




Vector<StackFrame*> CreateStackMap(Isolate* isolate, Zone* zone);

}
}
namespace v8 {

namespace base {
class TimeDelta;
}

namespace internal {

class Isolate;
class JSArrayBuffer;

class FutexWaitListNode {
 public:
  FutexWaitListNode()
      : prev_(nullptr),
        next_(nullptr),
        backing_store_(nullptr),
        wait_addr_(0),
        waiting_(false),
        interrupted_(false) {}

  void NotifyWake();

 private:
  friend class FutexEmulation;
  friend class FutexWaitList;

  base::ConditionVariable cond_;
  FutexWaitListNode* prev_;
  FutexWaitListNode* next_;
  void* backing_store_;
  size_t wait_addr_;
  bool waiting_;
  bool interrupted_;

  FutexWaitListNode(const FutexWaitListNode&) = delete; void operator=(const FutexWaitListNode&) = delete;
};


class FutexWaitList {
 public:
  FutexWaitList();

  void AddNode(FutexWaitListNode* node);
  void RemoveNode(FutexWaitListNode* node);

 private:
  friend class FutexEmulation;

  FutexWaitListNode* head_;
  FutexWaitListNode* tail_;

  FutexWaitList(const FutexWaitList&) = delete; void operator=(const FutexWaitList&) = delete;
};


class FutexEmulation : public AllStatic {
 public:

  enum Result {
    kOk = 0,
    kNotEqual = -1,
    kTimedOut = -2,
  };







  static Object* Wait(Isolate* isolate, Handle<JSArrayBuffer> array_buffer,
                      size_t addr, int32_t value, double rel_timeout_ms);




  static Object* Wake(Isolate* isolate, Handle<JSArrayBuffer> array_buffer,
                      size_t addr, int num_waiters_to_wake);






  static Object* WakeOrRequeue(Isolate* isolate,
                               Handle<JSArrayBuffer> array_buffer, size_t addr,
                               int num_waiters_to_wake, int32_t value,
                               size_t addr2);



  static Object* NumWaitersForTesting(Isolate* isolate,
                                      Handle<JSArrayBuffer> array_buffer,
                                      size_t addr);

 private:
  friend class FutexWaitListNode;

  static base::LazyMutex mutex_;
  static base::LazyInstance<FutexWaitList>::type wait_list_;
};
}
}








namespace v8 {

class HeapGraphNode;
struct HeapStatsUpdate;

typedef uint32_t SnapshotObjectId;


struct CpuProfileDeoptFrame {
  int script_id;
  size_t position;
};

}





namespace v8 {

struct CpuProfileDeoptInfo {

  const char* deopt_reason;
  std::vector<CpuProfileDeoptFrame> stack;
};

}





namespace v8 {




class CpuProfileNode {
 public:
  struct LineTick {

    int line;


    unsigned int hit_count;
  };


  Local<String> GetFunctionName() const;


  int GetScriptId() const;


  Local<String> GetScriptResourceName() const;





  int GetLineNumber() const;





  int GetColumnNumber() const;




  unsigned int GetHitLineCount() const;






  bool GetLineTicks(LineTick* entries, unsigned int length) const;




  const char* GetBailoutReason() const;




  unsigned GetHitCount() const;


  unsigned GetCallUid() const;


  unsigned GetNodeId() const;


  int GetChildrenCount() const;


  const CpuProfileNode* GetChild(int index) const;


  const std::vector<CpuProfileDeoptInfo>& GetDeoptInfos() const;

  static const int kNoLineNumberInfo = Message::kNoLineNumberInfo;
  static const int kNoColumnNumberInfo = Message::kNoColumnInfo;
};






class CpuProfile {
 public:

  Local<String> GetTitle() const;


  const CpuProfileNode* GetTopDownRoot() const;





  int GetSamplesCount() const;





  const CpuProfileNode* GetSample(int index) const;






  int64_t GetSampleTimestamp(int index) const;





  int64_t GetStartTime() const;






  int64_t GetEndTime() const;





  void Delete();
};






class CpuProfiler {
 public:





  void SetSamplingInterval(int us);
  void StartProfiling(Local<String> title, bool record_samples = false);





  CpuProfile* StopProfiling(Local<String> title);






  void CollectSample();




  void SetIdle(bool is_idle);

 private:
  CpuProfiler();
  ~CpuProfiler();
  CpuProfiler(const CpuProfiler&);
  CpuProfiler& operator=(const CpuProfiler&);
};






class HeapGraphEdge {
 public:
  enum Type {
    kContextVariable = 0,
    kElement = 1,
    kProperty = 2,
    kInternal = 3,


    kHidden = 4,

    kShortcut = 5,

    kWeak = 6
  };


  Type GetType() const;





  Local<Value> GetName() const;


  const HeapGraphNode* GetFromNode() const;


  const HeapGraphNode* GetToNode() const;
};





class HeapGraphNode {
 public:
  enum Type {
    kHidden = 0,
    kArray = 1,
    kString = 2,
    kObject = 3,
    kCode = 4,
    kClosure = 5,
    kRegExp = 6,
    kHeapNumber = 7,
    kNative = 8,
    kSynthetic = 9,

    kConsString = 10,
    kSlicedString = 11,
    kSymbol = 12,
    kSimdValue = 13
  };


  Type GetType() const;






  Local<String> GetName() const;





  SnapshotObjectId GetId() const;


  size_t GetShallowSize() const;


  int GetChildrenCount() const;


  const HeapGraphEdge* GetChild(int index) const;
};





class OutputStream {
 public:
  enum WriteResult {
    kContinue = 0,
    kAbort = 1
  };
  virtual ~OutputStream() {}

  virtual void EndOfStream() = 0;

  virtual int GetChunkSize() { return 1024; }





  virtual WriteResult WriteAsciiChunk(char* data, int size) = 0;





  virtual WriteResult WriteHeapStatsChunk(HeapStatsUpdate* data, int count) {
    return kAbort;
  }
};





class HeapSnapshot {
 public:
  enum SerializationFormat {
    kJSON = 0
  };


  const HeapGraphNode* GetRoot() const;


  const HeapGraphNode* GetNodeById(SnapshotObjectId id) const;


  int GetNodesCount() const;


  const HeapGraphNode* GetNode(int index) const;


  SnapshotObjectId GetMaxSnapshotJSObjectId() const;






  void Delete();
  void Serialize(OutputStream* stream,
                 SerializationFormat format = kJSON) const;
};






class ActivityControl {
 public:
  enum ControlOption {
    kContinue = 0,
    kAbort = 1
  };
  virtual ~ActivityControl() {}




  virtual ControlOption ReportProgressValue(int done, int total) = 0;
};






class AllocationProfile {
 public:
  struct Allocation {



    size_t size;




    unsigned int count;
  };




  struct Node {




    Local<String> name;





    Local<String> script_name;





    int script_id;




    int start_position;





    int line_number;





    int column_number;






    std::vector<Node*> children;




    std::vector<Allocation> allocations;
  };






  virtual Node* GetRootNode() = 0;

  virtual ~AllocationProfile() {}

  static const int kNoLineNumberInfo = Message::kNoLineNumberInfo;
  static const int kNoColumnNumberInfo = Message::kNoColumnInfo;
};






class HeapProfiler {
 public:






  typedef RetainedObjectInfo* (*WrapperInfoCallback)(uint16_t class_id,
                                                     Local<Value> wrapper);


  int GetSnapshotCount();


  const HeapSnapshot* GetHeapSnapshot(int index);





  SnapshotObjectId GetObjectId(Local<Value> value);





  Local<Value> FindObjectById(SnapshotObjectId id);






  void ClearObjectIds();






  static const SnapshotObjectId kUnknownObjectId = 0;




  class ObjectNameResolver {
   public:




    virtual const char* GetName(Local<Object> object) = 0;

   protected:
    virtual ~ObjectNameResolver() {}
  };




  const HeapSnapshot* TakeHeapSnapshot(
      ActivityControl* control = 0,
      ObjectNameResolver* global_object_name_resolver = 0);
  void StartTrackingHeapObjects(bool track_allocations = false);
  SnapshotObjectId GetHeapStats(OutputStream* stream,
                                int64_t* timestamp_us = 0);






  void StopTrackingHeapObjects();
  bool StartSamplingHeapProfiler(uint64_t sample_interval = 512 * 1024,
                                 int stack_depth = 16);




  void StopSamplingHeapProfiler();







  AllocationProfile* GetAllocationProfile();





  void DeleteAllHeapSnapshots();


  void SetWrapperClassInfoProvider(
      uint16_t class_id,
      WrapperInfoCallback callback);






  static const uint16_t kPersistentHandleNoClassId = 0;


  size_t GetProfilerMemorySize();




  void SetRetainedObjectInfo(UniqueId id, RetainedObjectInfo* info);

 private:
  HeapProfiler();
  ~HeapProfiler();
  HeapProfiler(const HeapProfiler&);
  HeapProfiler& operator=(const HeapProfiler&);
};
class RetainedObjectInfo {
 public:

  virtual void Dispose() = 0;


  virtual bool IsEquivalent(RetainedObjectInfo* other) = 0;





  virtual intptr_t GetHash() = 0;





  virtual const char* GetLabel() = 0;
  virtual const char* GetGroupLabel() { return GetLabel(); }





  virtual intptr_t GetElementCount() { return -1; }


  virtual intptr_t GetSizeInBytes() { return -1; }

 protected:
  RetainedObjectInfo() {}
  virtual ~RetainedObjectInfo() {}

 private:
  RetainedObjectInfo(const RetainedObjectInfo&);
  RetainedObjectInfo& operator=(const RetainedObjectInfo&);
};






struct HeapStatsUpdate {
  HeapStatsUpdate(uint32_t index, uint32_t count, uint32_t size)
    : index(index), count(count), size(size) { }
  uint32_t index;
  uint32_t count;
  uint32_t size;
};


}





namespace v8 {
namespace internal {

class HeapStats;
class ObjectVisitor;
struct ObjectGroup {
  explicit ObjectGroup(size_t length)
      : info(0), length(length) {
    do { if ((!(length > 0))) { V8_Fatal(".././src/global-handles.h", 40, "Check failed: %s.", "length > 0"); } } while (0);
    objects = new Object**[length];
  }
  ~ObjectGroup();

  v8::RetainedObjectInfo* info;
  Object*** objects;
  size_t length;
};


struct ImplicitRefGroup {
  ImplicitRefGroup(HeapObject** parent, size_t length)
      : parent(parent), length(length) {
    do { if ((!(length > 0))) { V8_Fatal(".././src/global-handles.h", 54, "Check failed: %s.", "length > 0"); } } while (0);
    children = new Object**[length];
  }
  ~ImplicitRefGroup();

  HeapObject** parent;
  Object*** children;
  size_t length;
};



struct ObjectGroupConnection {
  ObjectGroupConnection(UniqueId id, Object** object)
      : id(id), object(object) {}

  bool operator==(const ObjectGroupConnection& other) const {
    return id == other.id;
  }

  bool operator<(const ObjectGroupConnection& other) const {
    return id < other.id;
  }

  UniqueId id;
  Object** object;
};


struct ObjectGroupRetainerInfo {
  ObjectGroupRetainerInfo(UniqueId id, RetainedObjectInfo* info)
      : id(id), info(info) {}

  bool operator==(const ObjectGroupRetainerInfo& other) const {
    return id == other.id;
  }

  bool operator<(const ObjectGroupRetainerInfo& other) const {
    return id < other.id;
  }

  UniqueId id;
  RetainedObjectInfo* info;
};


enum WeaknessType {
  NORMAL_WEAK,





  PHANTOM_WEAK,
  PHANTOM_WEAK_2_INTERNAL_FIELDS
};


class GlobalHandles {
 public:
  ~GlobalHandles();


  Handle<Object> Create(Object* value);


  static Handle<Object> CopyGlobal(Object** location);


  static void Destroy(Object** location);

  typedef WeakCallbackData<v8::Value, void>::Callback WeakCallback;





  enum PhantomState { Nonphantom, Phantom };
  static void MakeWeak(Object** location, void* parameter,
                       WeakCallback weak_callback);



  static void MakeWeak(Object** location, void* parameter,
                       WeakCallbackInfo<void>::Callback weak_callback,
                       v8::WeakCallbackType type);

  void RecordStats(HeapStats* stats);


  int NumberOfWeakHandles();



  int NumberOfGlobalObjectWeakHandles();


  int global_handles_count() const {
    return number_of_global_handles_;
  }


  static void* ClearWeakness(Object** location);


  static void MarkIndependent(Object** location);


  static void MarkPartiallyDependent(Object** location);

  static bool IsIndependent(Object** location);


  static bool IsNearDeath(Object** location);


  static bool IsWeak(Object** location);



  int PostGarbageCollectionProcessing(
      GarbageCollector collector, const v8::GCCallbackFlags gc_callback_flags);


  void IterateStrongRoots(ObjectVisitor* v);


  void IterateAllRoots(ObjectVisitor* v);


  void IterateAllRootsWithClassIds(ObjectVisitor* v);



  void IterateAllRootsInNewSpaceWithClassIds(ObjectVisitor* v);



  void IterateWeakRootsInNewSpaceWithClassIds(ObjectVisitor* v);


  void IterateWeakRoots(ObjectVisitor* v);



  void IdentifyWeakHandles(WeakSlotCallback f);







  void IterateNewSpaceStrongAndDependentRoots(ObjectVisitor* v);



  void IdentifyNewSpaceWeakIndependentHandles(WeakSlotCallbackWithHeap f);



  void IterateNewSpaceWeakIndependentRoots(ObjectVisitor* v);



  void MarkNewSpaceWeakUnmodifiedObjectsPending(
      WeakSlotCallbackWithHeap is_unscavenged);



  void IterateNewSpaceWeakUnmodifiedRoots(ObjectVisitor* v);



  void IdentifyWeakUnmodifiedObjects(WeakSlotCallback is_unmodified);




  bool IterateObjectGroups(ObjectVisitor* v, WeakSlotCallbackWithHeap can_skip);


  void PrintObjectGroups();




  void AddObjectGroup(Object*** handles,
                      size_t length,
                      v8::RetainedObjectInfo* info);




  void SetObjectGroupId(Object** handle, UniqueId id);




  void SetRetainedObjectInfo(UniqueId id, RetainedObjectInfo* info);




  void SetReferenceFromGroup(UniqueId id, Object** child);




  void SetReference(HeapObject** parent, Object** child);

  List<ObjectGroup*>* object_groups() {
    ComputeObjectGroupsAndImplicitReferences();
    return &object_groups_;
  }

  List<ImplicitRefGroup*>* implicit_ref_groups() {
    ComputeObjectGroupsAndImplicitReferences();
    return &implicit_ref_groups_;
  }


  void RemoveObjectGroups();
  void RemoveImplicitRefGroups();


  void TearDown();

  Isolate* isolate() { return isolate_; }


  void PrintStats();
  void Print();


 private:
  explicit GlobalHandles(Isolate* isolate);




  void ComputeObjectGroupsAndImplicitReferences();



  static const int kObjectGroupConnectionsCapacity = 20;

  class PendingPhantomCallback;


  static void InvokeSecondPassPhantomCallbacks(
      List<PendingPhantomCallback>* callbacks, Isolate* isolate);
  int PostScavengeProcessing(int initial_post_gc_processing_count);
  int PostMarkSweepProcessing(int initial_post_gc_processing_count);
  int DispatchPendingPhantomCallbacks(bool synchronous_second_pass);
  void UpdateListOfNewSpaceNodes();


  class Node;
  class NodeBlock;
  class NodeIterator;
  class PendingPhantomCallbacksSecondPassTask;

  Isolate* isolate_;


  int number_of_global_handles_;


  NodeBlock* first_block_;


  NodeBlock* first_used_block_;


  Node* first_free_;



  List<Node*> new_space_nodes_;

  int post_gc_processing_count_;



  List<ObjectGroup*> object_groups_;
  List<ImplicitRefGroup*> implicit_ref_groups_;



  List<ObjectGroupConnection> object_group_connections_;
  List<ObjectGroupRetainerInfo> retainer_infos_;
  List<ObjectGroupConnection> implicit_ref_connections_;

  List<PendingPhantomCallback> pending_phantom_callbacks_;

  friend class Isolate;

  GlobalHandles(const GlobalHandles&) = delete; void operator=(const GlobalHandles&) = delete;
};


class GlobalHandles::PendingPhantomCallback {
 public:
  typedef v8::WeakCallbackInfo<void> Data;
  PendingPhantomCallback(
      Node* node, Data::Callback callback, void* parameter,
      void* internal_fields[v8::kInternalFieldsInWeakCallback])
      : node_(node), callback_(callback), parameter_(parameter) {
    for (int i = 0; i < v8::kInternalFieldsInWeakCallback; ++i) {
      internal_fields_[i] = internal_fields[i];
    }
  }

  void Invoke(Isolate* isolate);

  Node* node() { return node_; }
  Data::Callback callback() { return callback_; }

 private:
  Node* node_;
  Data::Callback callback_;
  void* parameter_;
  void* internal_fields_[v8::kInternalFieldsInWeakCallback];
};


class EternalHandles {
 public:
  enum SingletonHandle {
    I18N_TEMPLATE_ONE,
    I18N_TEMPLATE_TWO,
    DATE_CACHE_VERSION,

    NUMBER_OF_SINGLETON_HANDLES
  };

  EternalHandles();
  ~EternalHandles();

  int NumberOfHandles() { return size_; }


  void Create(Isolate* isolate, Object* object, int* index);


  inline Handle<Object> Get(int index) {
    return Handle<Object>(GetLocation(index));
  }


  inline Handle<Object> GetSingleton(SingletonHandle singleton) {
    do { if ((!(Exists(singleton)))) { V8_Fatal(".././src/global-handles.h", 416, "Check failed: %s.", "Exists(singleton)"); } } while (0);
    return Get(singleton_handles_[singleton]);
  }


  inline bool Exists(SingletonHandle singleton) {
    return singleton_handles_[singleton] != kInvalidIndex;
  }


  Handle<Object> CreateSingleton(Isolate* isolate,
                                 Object* object,
                                 SingletonHandle singleton) {
    Create(isolate, object, &singleton_handles_[singleton]);
    return Get(singleton_handles_[singleton]);
  }


  void IterateAllRoots(ObjectVisitor* visitor);

  void IterateNewSpaceRoots(ObjectVisitor* visitor);

  void PostGarbageCollectionProcessing(Heap* heap);

 private:
  static const int kInvalidIndex = -1;
  static const int kShift = 8;
  static const int kSize = 1 << kShift;
  static const int kMask = 0xff;


  inline Object** GetLocation(int index) {
    do { if ((!(index >= 0 && index < size_))) { V8_Fatal(".././src/global-handles.h", 448, "Check failed: %s.", "index >= 0 && index < size_"); } } while (0);
    return &blocks_[index >> kShift][index & kMask];
  }

  int size_;
  List<Object**> blocks_;
  List<int> new_space_indices_;
  int singleton_handles_[NUMBER_OF_SINGLETON_HANDLES];

  EternalHandles(const EternalHandles&) = delete; void operator=(const EternalHandles&) = delete;
};


}
}



namespace v8 {
namespace internal {


class JSMessageObject;
class LookupIterator;
class SourceInfo;

class MessageLocation {
 public:
  MessageLocation(Handle<Script> script, int start_pos, int end_pos,
                  Handle<JSFunction> function = Handle<JSFunction>())
      : script_(script),
        start_pos_(start_pos),
        end_pos_(end_pos),
        function_(function) {}
  MessageLocation() : start_pos_(-1), end_pos_(-1) { }

  Handle<Script> script() const { return script_; }
  int start_pos() const { return start_pos_; }
  int end_pos() const { return end_pos_; }
  Handle<JSFunction> function() const { return function_; }

 private:
  Handle<Script> script_;
  int start_pos_;
  int end_pos_;
  Handle<JSFunction> function_;
};


class CallSite {
 public:
  CallSite(Isolate* isolate, Handle<JSObject> call_site_obj);

  Handle<Object> GetFileName();
  Handle<Object> GetFunctionName();
  Handle<Object> GetScriptNameOrSourceUrl();
  Handle<Object> GetMethodName();

  int GetLineNumber();

  int GetColumnNumber();
  bool IsNative();
  bool IsToplevel();
  bool IsEval();
  bool IsConstructor();

  bool IsValid() { return !fun_.is_null(); }

 private:
  Isolate* isolate_;
  Handle<Object> receiver_;
  Handle<JSFunction> fun_;
  int32_t pos_;
};
class MessageTemplate {
 public:
  enum Template {

    kNone, kCyclicProto, kDebugger, kDebuggerLoading, kDefaultOptionsMissing, kUncaughtException, kUnsupported, kWrongServiceType, kWrongValueType, kApplyNonFunction, kArrayBufferTooShort, kArrayBufferSpeciesThis, kArrayFunctionsOnFrozen, kArrayFunctionsOnSealed, kArrayNotSubclassable, kCalledNonCallable, kCalledNonCallableInstanceOf, kCalledOnNonObject, kCalledOnNullOrUndefined, kCallSiteExpectsFunction, kCallSiteMethod, kCannotConvertToPrimitive, kCannotPreventExt, kCannotFreezeArrayBufferView, kCircularStructure, kConstructAbstractClass, kConstAssign, kConstructorNonCallable, kConstructorNotFunction, kConstructorNotReceiver, kCurrencyCode, kDataViewNotArrayBuffer, kDateType, kDebuggerFrame, kDebuggerType, kDeclarationMissingInitializer, kDefineDisallowed, kDuplicateTemplateProperty, kExtendsValueGenerator, kExtendsValueNotFunction, kFirstArgumentNotRegExp, kFunctionBind, kGeneratorRunning, kIllegalInvocation, kIncompatibleMethodReceiver, kInstanceofFunctionExpected, kInstanceofNonobjectProto, kInvalidArgument, kInvalidInOperatorUse, kInvalidRegExpExecResult, kInvalidSimdOperation, kIteratorResultNotAnObject, kIteratorValueNotAnObject, kLanguageID, kMethodCalledOnWrongObject, kMethodInvokedOnNullOrUndefined, kMethodInvokedOnWrongType, kNoAccess, kNonCoercible, kNonExtensibleProto, kNonObjectInInstanceOfCheck, kNonObjectPropertyLoad, kNonObjectPropertyStore, kNoSetterInCallback, kNotAnIterator, kNotAPromise, kNotConstructor, kNotDateObject, kNotIntlObject, kNotGeneric, kNotIterable, kNotPropertyName, kNotTypedArray, kNotSharedTypedArray, kNotIntegerSharedTypedArray, kNotInt32SharedTypedArray, kObjectGetterExpectingFunction, kObjectGetterCallable, kObjectNotExtensible, kObjectSetterExpectingFunction, kObjectSetterCallable, kObserveCallbackFrozen, kObserveGlobalProxy, kObserveAccessChecked, kObserveInvalidAccept, kObserveNonFunction, kObserveNonObject, kObserveNotifyNonNotifier, kObservePerformNonFunction, kObservePerformNonString, kObserveTypeNonString, kOrdinaryFunctionCalledAsConstructor, kPromiseCyclic, kPromiseExecutorAlreadyInvoked, kPromiseNonCallable, kPropertyDescObject, kPropertyNotFunction, kProtoObjectOrNull, kPrototypeParentNotAnObject, kProxyConstructNonObject, kProxyDefinePropertyNonConfigurable, kProxyDefinePropertyNonExtensible, kProxyDefinePropertyIncompatible, kProxyDeletePropertyNonConfigurable, kProxyGetNonConfigurableData, kProxyGetNonConfigurableAccessor, kProxyGetOwnPropertyDescriptorIncompatible, kProxyGetOwnPropertyDescriptorInvalid, kProxyGetOwnPropertyDescriptorNonConfigurable, kProxyGetOwnPropertyDescriptorNonExtensible, kProxyGetOwnPropertyDescriptorUndefined, kProxyGetPrototypeOfInvalid, kProxyGetPrototypeOfNonExtensible, kProxyHandlerOrTargetRevoked, kProxyHasNonConfigurable, kProxyHasNonExtensible, kProxyIsExtensibleInconsistent, kProxyNonObject, kProxyOwnKeysMissing, kProxyOwnKeysNonExtensible, kProxyPreventExtensionsExtensible, kProxyPrivate, kProxyRevoked, kProxySetFrozenData, kProxySetFrozenAccessor, kProxySetPrototypeOfNonExtensible, kProxyTrapReturnedFalsish, kProxyTrapReturnedFalsishFor, kReadGlobalReferenceThroughProxy, kRedefineDisallowed, kRedefineExternalArray, kReduceNoInitial, kRegExpFlags, kRegExpNonObject, kRegExpNonRegExp, kReinitializeIntl, kResolvedOptionsCalledOnNonObject, kResolverNotAFunction, kRestrictedFunctionProperties, kReturnMethodNotCallable, kStaticPrototype, kStrictCannotAssign, kStrictDeleteProperty, kStrictPoisonPill, kStrictReadOnlyProperty, kStrictCannotCreateProperty, kSymbolIteratorInvalid, kSymbolKeyFor, kSymbolToNumber, kSymbolToString, kSimdToNumber, kThrowMethodMissing, kUndefinedOrNullToObject, kValueAndAccessor, kVarRedeclaration, kWrongArgs, kNonMethod, kNotDefined, kUnsupportedSuper, kDateRange, kExpectedTimezoneID, kExpectedLocation, kInvalidArrayBufferLength, kArrayBufferAllocationFailed, kInvalidArrayLength, kInvalidAtomicAccessIndex, kInvalidCodePoint, kInvalidCountValue, kInvalidCurrencyCode, kInvalidDataViewAccessorOffset, kInvalidDataViewLength, kInvalidDataViewOffset, kInvalidHint, kInvalidLanguageTag, kInvalidWeakMapKey, kInvalidWeakSetValue, kInvalidStringLength, kInvalidTimeValue, kInvalidTypedArrayAlignment, kInvalidTypedArrayLength, kInvalidTypedArrayOffset, kLetInLexicalBinding, kLocaleMatcher, kNormalizationForm, kNumberFormatRange, kPropertyValueOutOfRange, kStackOverflow, kToPrecisionFormatRange, kToRadixFormatRange, kTypedArraySetNegativeOffset, kTypedArraySetSourceTooLarge, kUnsupportedTimeZone, kValueOutOfRange, kBadGetterArity, kBadSetterArity, kConstructorIsAccessor, kConstructorIsGenerator, kDerivedConstructorReturn, kDuplicateConstructor, kDuplicateExport, kDuplicateProto, kForInOfLoopInitializer, kForInOfLoopMultiBindings, kIllegalBreak, kIllegalContinue, kIllegalLanguageModeDirective, kIllegalReturn, kInvalidEscapedReservedWord, kInvalidEscapedMetaProperty, kInvalidLhsInAssignment, kInvalidCoverInitializedName, kInvalidDestructuringTarget, kInvalidLhsInFor, kInvalidLhsInPostfixOp, kInvalidLhsInPrefixOp, kInvalidRegExpFlags, kInvalidOrUnexpectedToken, kJsonParseUnexpectedEOS, kJsonParseUnexpectedToken, kJsonParseUnexpectedTokenNumber, kJsonParseUnexpectedTokenString, kLabelRedeclaration, kLabelledFunctionDeclaration, kMalformedArrowFunParamList, kMalformedRegExp, kMalformedRegExpFlags, kModuleExportUndefined, kMultipleDefaultsInSwitch, kNewlineAfterThrow, kNoCatchOrFinally, kNotIsvar, kParamAfterRest, kInvalidRestParameter, kPushPastSafeLength, kElementAfterRest, kBadSetterRestParameter, kParamDupe, kParenthesisInArgString, kRuntimeWrongNumArgs, kSingleFunctionLiteral, kSloppyFunction, kSloppyLexical, kSpeciesNotConstructor, kStrictDelete, kStrictEvalArguments, kStrictFunction, kStrictOctalLiteral, kStrictWith, kTemplateOctalLiteral, kThisFormalParameter, kTooManyArguments, kTooManyParameters, kTooManyVariables, kTypedArrayTooShort, kUnexpectedEOS, kUnexpectedFunctionSent, kUnexpectedReserved, kUnexpectedStrictReserved, kUnexpectedSuper, kUnexpectedNewTarget, kUnexpectedTemplateString, kUnexpectedToken, kUnexpectedTokenIdentifier, kUnexpectedTokenNumber, kUnexpectedTokenString, kUnexpectedTokenRegExp, kUnknownLabel, kUnterminatedArgList, kUnterminatedRegExp, kUnterminatedTemplate, kUnterminatedTemplateExpr, kFoundNonCallableHasInstance, kInvalidHexEscapeSequence, kInvalidUnicodeEscapeSequence, kUndefinedUnicodeCodePoint, kCodeGenFromStrings, kURIMalformed,

        kLastMessage
  };

  static const char* TemplateString(int template_index);

  static MaybeHandle<String> FormatMessage(int template_index,
                                           Handle<String> arg0,
                                           Handle<String> arg1,
                                           Handle<String> arg2);

  static Handle<String> FormatMessage(Isolate* isolate, int template_index,
                                      Handle<Object> arg);
};




class MessageHandler {
 public:

  static Handle<JSMessageObject> MakeMessageObject(
      Isolate* isolate, MessageTemplate::Template type,
      MessageLocation* location, Handle<Object> argument,
      Handle<JSArray> stack_frames);


  static void ReportMessage(Isolate* isolate, MessageLocation* loc,
                            Handle<JSMessageObject> message);

  static void DefaultMessageReport(Isolate* isolate, const MessageLocation* loc,
                                   Handle<Object> message_obj);
  static Handle<String> GetMessage(Isolate* isolate, Handle<Object> data);
  static base::SmartArrayPointer<char> GetLocalizedMessage(Isolate* isolate,
                                                           Handle<Object> data);
};


}
}
namespace v8 {
namespace internal {

class HOptimizedGraphBuilder;
class OptimizedCompileJob;
class SharedFunctionInfo;

class OptimizingCompileDispatcher {
 public:
  explicit OptimizingCompileDispatcher(Isolate* isolate)
      : isolate_(isolate),
        input_queue_capacity_(FLAG_concurrent_recompilation_queue_length),
        input_queue_length_(0),
        input_queue_shift_(0),
        blocked_jobs_(0),
        ref_count_(0),
        recompilation_delay_(FLAG_concurrent_recompilation_delay) {
    base::NoBarrier_Store(&mode_, static_cast<base::AtomicWord>(COMPILE));
    input_queue_ = NewArray<OptimizedCompileJob*>(input_queue_capacity_);
  }

  ~OptimizingCompileDispatcher();

  void Run();
  void Stop();
  void Flush();
  void QueueForOptimization(OptimizedCompileJob* optimizing_compiler);
  void Unblock();
  void InstallOptimizedFunctions();

  inline bool IsQueueAvailable() {
    base::LockGuard<base::Mutex> access_input_queue(&input_queue_mutex_);
    return input_queue_length_ < input_queue_capacity_;
  }

  static bool Enabled() { return FLAG_concurrent_recompilation; }

 private:
  class CompileTask;

  enum ModeFlag { COMPILE, FLUSH };

  void FlushOutputQueue(bool restore_function_code);
  void CompileNext(OptimizedCompileJob* job);
  OptimizedCompileJob* NextInput(bool check_if_flushing = false);

  inline int InputQueueIndex(int i) {
    int result = (i + input_queue_shift_) % input_queue_capacity_;
    do { if (std::string* _msg = ::v8::base::CheckLEImpl( (0), (result), "0" " " "<=" " " "result")) { V8_Fatal(".././src/optimizing-compile-dispatcher.h", 65, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    do { if (std::string* _msg = ::v8::base::CheckLTImpl( (result), (input_queue_capacity_), "result" " " "<" " " "input_queue_capacity_")) { V8_Fatal(".././src/optimizing-compile-dispatcher.h", 66, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
    return result;
  }

  Isolate* isolate_;


  OptimizedCompileJob** input_queue_;
  int input_queue_capacity_;
  int input_queue_length_;
  int input_queue_shift_;
  base::Mutex input_queue_mutex_;


  std::queue<OptimizedCompileJob*> output_queue_;


  base::Mutex output_queue_mutex_;

  volatile base::AtomicWord mode_;

  int blocked_jobs_;

  int ref_count_;
  base::Mutex ref_count_mutex_;
  base::ConditionVariable ref_count_zero_;






  int recompilation_delay_;
};
}
}
namespace v8 {
namespace internal {

class RegExpStack;






class RegExpStackScope {
 public:



  explicit RegExpStackScope(Isolate* isolate);
  ~RegExpStackScope();

  RegExpStack* stack() const { return regexp_stack_; }

 private:
  RegExpStack* regexp_stack_;

  RegExpStackScope(const RegExpStackScope&) = delete; void operator=(const RegExpStackScope&) = delete;
};


class RegExpStack {
 public:



  static const int kStackLimitSlack = 32;


  Address stack_base() {
    do { if ((!(thread_local_.memory_size_ != 0))) { V8_Fatal(".././src/regexp/regexp-stack.h", 48, "Check failed: %s.", "thread_local_.memory_size_ != 0"); } } while (0);
    return thread_local_.memory_ + thread_local_.memory_size_;
  }


  size_t stack_capacity() { return thread_local_.memory_size_; }






  Address* limit_address() { return &(thread_local_.limit_); }



  Address EnsureCapacity(size_t size);


  static int ArchiveSpacePerThread() {
    return static_cast<int>(sizeof(ThreadLocal));
  }
  char* ArchiveStack(char* to);
  char* RestoreStack(char* from);
  void FreeThreadResources() { thread_local_.Free(); }

 private:
  RegExpStack();
  ~RegExpStack();


  static const uintptr_t kMemoryTop = static_cast<uintptr_t>(-1);


  static const size_t kMinimumStackSize = 1 * KB;


  static const size_t kMaximumStackSize = 64 * MB;


  struct ThreadLocal {
    ThreadLocal() { Clear(); }

    Address memory_;
    size_t memory_size_;
    Address limit_;
    void Clear() {
      memory_ = 0;
      memory_size_ = 0;
      limit_ = reinterpret_cast<Address>(kMemoryTop);
    }
    void Free();
  };


  Address memory_address() {
    return reinterpret_cast<Address>(&thread_local_.memory_);
  }


  Address memory_size_address() {
    return reinterpret_cast<Address>(&thread_local_.memory_size_);
  }




  void Reset();

  ThreadLocal thread_local_;
  Isolate* isolate_;

  friend class ExternalReference;
  friend class Isolate;
  friend class RegExpStackScope;

  RegExpStack(const RegExpStack&) = delete; void operator=(const RegExpStack&) = delete;
};

}
}
namespace v8 {

namespace base {
class Semaphore;
}

namespace internal {

class Isolate;
class JSFunction;
class Object;

class RuntimeProfiler {
 public:
  explicit RuntimeProfiler(Isolate* isolate);

  void MarkCandidatesForOptimization();

  void NotifyICChanged() { any_ic_changed_ = true; }

  void AttemptOnStackReplacement(JSFunction* function, int nesting_levels = 1);

 private:
  void MaybeOptimizeFullCodegen(JSFunction* function, int frame_count,
                                bool frame_optimized);
  void MaybeOptimizeIgnition(JSFunction* function, bool frame_optimized);
  void Optimize(JSFunction* function, const char* reason);

  bool CodeSizeOKForOSR(Code* shared_code);

  Isolate* isolate_;

  bool any_ic_changed_;
};

}
}








extern "C" {
struct _FILETIME;
struct mach_timespec;
struct timespec;
struct timeval;
}

namespace v8 {
namespace base {

class Time;
class TimeTicks;







class TimeDelta final {
 public:
  TimeDelta() : delta_(0) {}


  static TimeDelta FromDays(int days);
  static TimeDelta FromHours(int hours);
  static TimeDelta FromMinutes(int minutes);
  static TimeDelta FromSeconds(int64_t seconds);
  static TimeDelta FromMilliseconds(int64_t milliseconds);
  static TimeDelta FromMicroseconds(int64_t microseconds) {
    return TimeDelta(microseconds);
  }
  static TimeDelta FromNanoseconds(int64_t nanoseconds);






  int InDays() const;
  int InHours() const;
  int InMinutes() const;
  double InSecondsF() const;
  int64_t InSeconds() const;
  double InMillisecondsF() const;
  int64_t InMilliseconds() const;
  int64_t InMillisecondsRoundedUp() const;
  int64_t InMicroseconds() const { return delta_; }
  int64_t InNanoseconds() const;


  static TimeDelta FromMachTimespec(struct mach_timespec ts);
  struct mach_timespec ToMachTimespec() const;


  static TimeDelta FromTimespec(struct timespec ts);
  struct timespec ToTimespec() const;

  TimeDelta& operator=(const TimeDelta& other) {
    delta_ = other.delta_;
    return *this;
  }


  TimeDelta operator+(const TimeDelta& other) const {
    return TimeDelta(delta_ + other.delta_);
  }
  TimeDelta operator-(const TimeDelta& other) const {
    return TimeDelta(delta_ - other.delta_);
  }

  TimeDelta& operator+=(const TimeDelta& other) {
    delta_ += other.delta_;
    return *this;
  }
  TimeDelta& operator-=(const TimeDelta& other) {
    delta_ -= other.delta_;
    return *this;
  }
  TimeDelta operator-() const {
    return TimeDelta(-delta_);
  }

  double TimesOf(const TimeDelta& other) const {
    return static_cast<double>(delta_) / static_cast<double>(other.delta_);
  }
  double PercentOf(const TimeDelta& other) const {
    return TimesOf(other) * 100.0;
  }



  TimeDelta operator*(int64_t a) const {
    return TimeDelta(delta_ * a);
  }
  TimeDelta operator/(int64_t a) const {
    return TimeDelta(delta_ / a);
  }
  TimeDelta& operator*=(int64_t a) {
    delta_ *= a;
    return *this;
  }
  TimeDelta& operator/=(int64_t a) {
    delta_ /= a;
    return *this;
  }
  int64_t operator/(const TimeDelta& other) const {
    return delta_ / other.delta_;
  }


  bool operator==(const TimeDelta& other) const {
    return delta_ == other.delta_;
  }
  bool operator!=(const TimeDelta& other) const {
    return delta_ != other.delta_;
  }
  bool operator<(const TimeDelta& other) const {
    return delta_ < other.delta_;
  }
  bool operator<=(const TimeDelta& other) const {
    return delta_ <= other.delta_;
  }
  bool operator>(const TimeDelta& other) const {
    return delta_ > other.delta_;
  }
  bool operator>=(const TimeDelta& other) const {
    return delta_ >= other.delta_;
  }

 private:



  explicit TimeDelta(int64_t delta) : delta_(delta) {}


  int64_t delta_;
};
class Time final {
 public:
  static const int64_t kMillisecondsPerSecond = 1000;
  static const int64_t kMicrosecondsPerMillisecond = 1000;
  static const int64_t kMicrosecondsPerSecond = kMicrosecondsPerMillisecond *
                                                kMillisecondsPerSecond;
  static const int64_t kMicrosecondsPerMinute = kMicrosecondsPerSecond * 60;
  static const int64_t kMicrosecondsPerHour = kMicrosecondsPerMinute * 60;
  static const int64_t kMicrosecondsPerDay = kMicrosecondsPerHour * 24;
  static const int64_t kMicrosecondsPerWeek = kMicrosecondsPerDay * 7;
  static const int64_t kNanosecondsPerMicrosecond = 1000;
  static const int64_t kNanosecondsPerSecond = kNanosecondsPerMicrosecond *
                                               kMicrosecondsPerSecond;


  Time() : us_(0) {}


  bool IsNull() const { return us_ == 0; }


  bool IsMax() const { return us_ == std::numeric_limits<int64_t>::max(); }




  static Time Now();





  static Time NowFromSystemTime();


  static Time UnixEpoch() { return Time(0); }



  static Time Max() { return Time(std::numeric_limits<int64_t>::max()); }



  static Time FromInternalValue(int64_t value) {
    return Time(value);
  }
  int64_t ToInternalValue() const {
    return us_;
  }


  static Time FromTimespec(struct timespec ts);
  struct timespec ToTimespec() const;


  static Time FromTimeval(struct timeval tv);
  struct timeval ToTimeval() const;


  static Time FromFiletime(struct _FILETIME ft);
  struct _FILETIME ToFiletime() const;



  static Time FromJsTime(double ms_since_epoch);
  double ToJsTime() const;

  Time& operator=(const Time& other) {
    us_ = other.us_;
    return *this;
  }


  TimeDelta operator-(const Time& other) const {
    return TimeDelta::FromMicroseconds(us_ - other.us_);
  }


  Time& operator+=(const TimeDelta& delta) {
    us_ += delta.InMicroseconds();
    return *this;
  }
  Time& operator-=(const TimeDelta& delta) {
    us_ -= delta.InMicroseconds();
    return *this;
  }


  Time operator+(const TimeDelta& delta) const {
    return Time(us_ + delta.InMicroseconds());
  }
  Time operator-(const TimeDelta& delta) const {
    return Time(us_ - delta.InMicroseconds());
  }


  bool operator==(const Time& other) const {
    return us_ == other.us_;
  }
  bool operator!=(const Time& other) const {
    return us_ != other.us_;
  }
  bool operator<(const Time& other) const {
    return us_ < other.us_;
  }
  bool operator<=(const Time& other) const {
    return us_ <= other.us_;
  }
  bool operator>(const Time& other) const {
    return us_ > other.us_;
  }
  bool operator>=(const Time& other) const {
    return us_ >= other.us_;
  }

 private:
  explicit Time(int64_t us) : us_(us) {}


  int64_t us_;
};

std::ostream& operator<<(std::ostream&, const Time&);

inline Time operator+(const TimeDelta& delta, const Time& time) {
  return time + delta;
}
class TimeTicks final {
 public:
  TimeTicks() : ticks_(0) {}





  static TimeTicks Now();






  static TimeTicks HighResolutionNow();


  static bool IsHighResolutionClockWorking();


  bool IsNull() const { return ticks_ == 0; }



  static TimeTicks FromInternalValue(int64_t value) {
    return TimeTicks(value);
  }
  int64_t ToInternalValue() const {
    return ticks_;
  }

  TimeTicks& operator=(const TimeTicks other) {
    ticks_ = other.ticks_;
    return *this;
  }


  TimeDelta operator-(const TimeTicks other) const {
    return TimeDelta::FromMicroseconds(ticks_ - other.ticks_);
  }


  TimeTicks& operator+=(const TimeDelta& delta) {
    ticks_ += delta.InMicroseconds();
    return *this;
  }
  TimeTicks& operator-=(const TimeDelta& delta) {
    ticks_ -= delta.InMicroseconds();
    return *this;
  }


  TimeTicks operator+(const TimeDelta& delta) const {
    return TimeTicks(ticks_ + delta.InMicroseconds());
  }
  TimeTicks operator-(const TimeDelta& delta) const {
    return TimeTicks(ticks_ - delta.InMicroseconds());
  }


  bool operator==(const TimeTicks& other) const {
    return ticks_ == other.ticks_;
  }
  bool operator!=(const TimeTicks& other) const {
    return ticks_ != other.ticks_;
  }
  bool operator<(const TimeTicks& other) const {
    return ticks_ < other.ticks_;
  }
  bool operator<=(const TimeTicks& other) const {
    return ticks_ <= other.ticks_;
  }
  bool operator>(const TimeTicks& other) const {
    return ticks_ > other.ticks_;
  }
  bool operator>=(const TimeTicks& other) const {
    return ticks_ >= other.ticks_;
  }

 private:


  explicit TimeTicks(int64_t ticks) : ticks_(ticks) {}


  int64_t ticks_;
};

inline TimeTicks operator+(const TimeDelta& delta, const TimeTicks& ticks) {
  return ticks + delta;
}

}
}




namespace v8 {
namespace internal {
Object* Runtime_BinaryOpIC_Miss(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_BinaryOpIC_MissWithAllocationSite(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallIC_Miss(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CompareIC_Miss(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ElementsTransitionAndStoreIC_Miss(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_KeyedLoadIC_Miss(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_KeyedLoadIC_MissFromStubFailure(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_KeyedStoreIC_Miss(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_KeyedStoreIC_MissFromStubFailure(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_KeyedStoreIC_Slow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadElementWithInterceptor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadIC_Miss(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadIC_MissFromStubFailure(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadPropertyWithInterceptor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadPropertyWithInterceptorOnly(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreCallbackProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreIC_Miss(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreIC_MissFromStubFailure(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreIC_Slow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StorePropertyWithInterceptor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToBooleanIC_Miss(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Unreachable(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FinishArrayPrototypeSetup(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SpecialArrayFunctions(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TransitionElementsKind(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RemoveArrayHoles(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MoveArrayContents(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_EstimateNumberOfElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetArrayKeys(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ArrayConstructor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewArray(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InternalArrayConstructor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ArrayPush(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NormalizeElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GrowArrayElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasComplexElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsArray(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasCachedArrayIndex(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetCachedArrayIndex(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FixedArrayGet(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FixedArraySet(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ArraySpeciesConstructor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsCompareExchange(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsLoad(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsStore(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsAdd(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsSub(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsAnd(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsOr(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsXor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsExchange(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsIsLockFree(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowNonMethodError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowUnsupportedSuperError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowConstructorNonCallableError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowArrayNotSubclassableError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowStaticPrototypeError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowIfStaticPrototype(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HomeObjectSymbol(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DefineClass(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FinalizeClassDefinition(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadFromSuper(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadKeyedFromSuper(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreToSuper_Strict(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreToSuper_Sloppy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreKeyedToSuper_Strict(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreKeyedToSuper_Sloppy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetSuperConstructor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringGetRawHashField(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TheHole(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_JSCollectionGetTable(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GenericHash(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetInitialize(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetGrow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetShrink(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetClear(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetIteratorInitialize(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetIteratorClone(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetIteratorNext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetIteratorDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MapInitialize(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MapShrink(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MapClear(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MapGrow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MapIteratorInitialize(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MapIteratorClone(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MapIteratorDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetWeakMapEntries(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MapIteratorNext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_WeakCollectionInitialize(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_WeakCollectionGet(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_WeakCollectionHas(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_WeakCollectionDelete(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_WeakCollectionSet(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetWeakSetValues(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ObservationWeakMapCreate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CompileLazy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CompileOptimized_Concurrent(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CompileOptimized_NotConcurrent(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NotifyStubFailure(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NotifyDeoptimized(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CompileForOnStackReplacement(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TryInstallOptimizedCode(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ResolvePossiblyDirectEval(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsDate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DateCurrentTime(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowNotDateError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HandleDebuggerStatement(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugBreak(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugBreakOnBytecode(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetDebugEventListener(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ScheduleBreak(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugGetInternalProperties(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugGetPropertyDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugGetProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugPropertyTypeFromDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugPropertyAttributesFromDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugPropertyIndexFromDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugNamedInterceptorPropertyValue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugIndexedInterceptorElementValue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CheckExecutionState(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetFrameCount(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetFrameDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetScopeCount(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetScopeDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetAllScopesDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetFunctionScopeCount(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetFunctionScopeDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetScopeVariableValue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugPrintScopes(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetThreadCount(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetThreadDetails(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetBreakPointsActive(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetBreakLocations(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetFunctionBreakPoint(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetScriptBreakPoint(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ClearBreakPoint(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ChangeBreakOnException(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsBreakOnException(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_PrepareStep(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ClearStepping(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugEvaluate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugEvaluateGlobal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugGetLoadedScripts(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugReferencedBy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugConstructedBy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugGetPrototype(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugSetScriptSource(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionGetInferredName(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionGetDebugName(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetFunctionCodePositionFromSource(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ExecuteInDebugContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetDebugContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CollectGarbage(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetHeapUsage(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetScript(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugPrepareStepInIfStepping(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugPushPromise(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugPopPromise(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugAsyncTaskEvent(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugIsActive(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugBreakInOptimizedCode(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ForInDone(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ForInEnumerate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ForInFilter(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ForInNext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ForInStep(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InterpreterNewClosure(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InterpreterTraceBytecodeEntry(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InterpreterTraceBytecodeExit(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InterpreterClearPendingMessage(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InterpreterSetPendingMessage(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionGetName(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionSetName(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionRemovePrototype(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionGetScript(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionGetSourceCode(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionGetScriptSourcePosition(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionGetPositionForOffset(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionGetContextData(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionSetInstanceClassName(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionSetLength(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionSetPrototype(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionIsAPIFunction(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetCode(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetNativeFlag(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsConstructor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetForceInlineFlag(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Call(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ConvertReceiver(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsFunction(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FunctionToString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsFutexWait(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsFutexWake(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsFutexWakeOrRequeue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AtomicsFutexNumWaitersForTesting(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateJSGeneratorObject(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SuspendJSGeneratorObject(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ResumeJSGeneratorObject(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GeneratorClose(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GeneratorGetFunction(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GeneratorGetReceiver(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GeneratorGetInput(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GeneratorGetContinuation(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GeneratorGetSourcePosition(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GeneratorNext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GeneratorReturn(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GeneratorThrow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CheckIsBootstrapping(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ExportFromRuntime(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ExportExperimentalFromRuntime(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InstallToContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Throw(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ReThrow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_UnwindAndFindExceptionHandler(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_PromoteScheduledException(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowReferenceError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowApplyNonFunction(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewTypeError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewSyntaxError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewReferenceError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowIllegalInvocation(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowIteratorResultNotAnObject(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowStackOverflow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_PromiseRejectEvent(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_PromiseRevokeReject(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StackGuard(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Interrupt(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AllocateInNewSpace(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AllocateInTargetSpace(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CollectStackTrace(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MessageGetStartPosition(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MessageGetScript(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FormatMessageString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteGetFileNameRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteGetFunctionNameRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteGetScriptNameOrSourceUrlRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteGetMethodNameRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteGetLineNumberRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteGetColumnNumberRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteIsNativeRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteIsToplevelRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteIsEvalRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CallSiteIsConstructorRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IS_VAR(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowConstructedNonConstructable(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowDerivedConstructorReturnedNonObject(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowCalledNonCallable(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateListFromArrayLike(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IncrementUseCounter(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetOrdinaryHasInstance(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetAndResetRuntimeCallStats(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_QuoteJSONString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_BasicJSONStringify(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ParseJson(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateRegExpLiteral(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateObjectLiteral(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateArrayLiteral(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateArrayLiteralStubBailout(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditFindSharedFunctionInfosForScript(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditGatherCompileInfo(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditReplaceScript(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditFunctionSourceUpdated(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditReplaceFunctionCode(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditFunctionSetScript(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditReplaceRefToNestedFunction(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditPatchFunctionPositions(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditCheckAndDropActivations(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditCompareStrings(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LiveEditRestartFrame(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MathLogRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DoubleHi(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DoubleLo(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ConstructDouble(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RemPiO2(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MathAtan2(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MathExpRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MathPow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MathPowRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GenerateRandomNumbers(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NumberToRadixString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NumberToFixed(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NumberToExponential(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NumberToPrecision(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsValidSmi(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringToNumber(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringParseInt(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringParseFloat(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NumberToString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NumberToStringSkipCache(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NumberToIntegerMapMinusZero(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NumberToSmi(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SmiLexicographicCompare(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_MaxSmi(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsSmi(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetRootNaN(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetHoleNaNUpper(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetHoleNaNLower(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetPrototype(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ObjectHasOwnProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InternalSetPrototype(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetPrototype(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetOwnProperty_Legacy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_OptimizeObjectForAddingMultipleProperties(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_KeyedGetProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadGlobalViaContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreGlobalViaContext_Sloppy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreGlobalViaContext_Strict(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AddNamedProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AddElement(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AppendElement(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DeleteProperty_Sloppy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DeleteProperty_Strict(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_PropertyIsEnumerable(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetOwnPropertyKeys(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetInterceptorInfo(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToFastProperties(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AllocateHeapNumber(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewObject(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FinalizeInstanceSize(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GlobalProxy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LookupAccessor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadMutableDouble(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TryMigrateInstance(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsJSGlobalProxy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DefineAccessorPropertyUnchecked(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DefineDataPropertyUnchecked(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DefineDataPropertyInLiteral(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetDataProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFastPackedElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ValueOf(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsJSReceiver(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ClassOf(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DefineGetterPropertyUnchecked(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DefineSetterPropertyUnchecked(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToObject(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToPrimitive(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToPrimitive_Number(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToPrimitive_String(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToNumber(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToInteger(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToLength(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ToName(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SameValue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SameValueZero(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Compare(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InstanceOf(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_OrdinaryHasInstance(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasInPrototypeChain(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateIterResultObject(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsAccessCheckNeeded(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ObjectDefineProperties(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ObjectDefineProperty(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsObserved(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetIsObserved(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_EnqueueMicrotask(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RunMicrotasks(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DeliverObservationChangeRecords(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetObservationState(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ObserverObjectAndRecordHaveSameOrigin(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ObjectWasCreatedInCurrentOrigin(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetObjectContextObjectObserve(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetObjectContextObjectGetNotifier(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetObjectContextNotifierPerformChange(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Multiply(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Divide(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Modulus(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Add(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Subtract(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ShiftLeft(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ShiftRight(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ShiftRightLogical(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_BitwiseAnd(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_BitwiseOr(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_BitwiseXor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StrictEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StrictNotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LessThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GreaterThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LessThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GreaterThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsJSProxy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_JSProxyCall(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_JSProxyConstruct(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_JSProxyGetTarget(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_JSProxyGetHandler(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_JSProxyRevoke(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringReplaceGlobalRegExpWithString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringSplit(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RegExpExec(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RegExpFlags(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RegExpSource(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RegExpConstructResult(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RegExpInitializeAndCompile(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RegExpExecMultiple(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RegExpExecReThrow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsRegExp(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ThrowConstAssignError(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DeclareGlobals(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InitializeVarGlobal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InitializeConstGlobal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DeclareLookupSlot(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InitializeLegacyConstLookupSlot(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewSloppyArguments_Generic(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewStrictArguments(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewRestParameter(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewSloppyArguments(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewClosure(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewClosure_Tenured(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewScriptContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewFunctionContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_PushWithContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_PushCatchContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_PushBlockContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsJSModule(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_PushModuleContext(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DeclareModules(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DeleteLookupSlot(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadLookupSlot(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_LoadLookupSlotInsideTypeof(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreLookupSlot_Sloppy(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StoreLookupSlot_Strict(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsSimdValue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateFloat32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateInt32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateUint32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateBool32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateInt16x8(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateUint16x8(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateBool16x8(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateInt8x16(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateUint8x16(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateBool8x16(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Abs(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Neg(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Sqrt(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4RecipApprox(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4RecipSqrtApprox(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Add(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Sub(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Mul(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Div(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Min(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Max(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4MinNum(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4MaxNum(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4LessThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4LessThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4GreaterThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4GreaterThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Select(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4FromInt32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4FromUint32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4FromInt32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4FromUint32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4FromInt16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4FromUint16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4FromInt8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4FromUint8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Load(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Load1(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Load2(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Load3(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Store(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Store1(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Store2(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Float32x4Store3(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Neg(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Add(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Sub(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Mul(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Min(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Max(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4And(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Or(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Xor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Not(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4ShiftLeftByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4ShiftRightByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4LessThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4LessThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4GreaterThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4GreaterThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Select(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4FromFloat32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4FromUint32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4FromFloat32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4FromUint32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4FromInt16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4FromUint16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4FromInt8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4FromUint8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Load(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Load1(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Load2(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Load3(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Store(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Store1(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Store2(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int32x4Store3(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Add(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Sub(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Mul(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Min(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Max(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4And(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Or(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Xor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Not(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4ShiftLeftByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4ShiftRightByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4LessThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4LessThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4GreaterThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4GreaterThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Select(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4FromFloat32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4FromInt32x4(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4FromFloat32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4FromInt32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4FromInt16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4FromUint16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4FromInt8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4FromUint8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Load(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Load1(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Load2(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Load3(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Store(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Store1(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Store2(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint32x4Store3(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4And(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4Or(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4Xor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4Not(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4AnyTrue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4AllTrue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool32x4NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Neg(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Add(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8AddSaturate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Sub(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8SubSaturate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Mul(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Min(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Max(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8And(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Or(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Xor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Not(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8ShiftLeftByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8ShiftRightByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8LessThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8LessThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8GreaterThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8GreaterThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Select(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8FromUint16x8(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8FromFloat32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8FromInt32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8FromUint32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8FromUint16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8FromInt8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8FromUint8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Load(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int16x8Store(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Add(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8AddSaturate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Sub(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8SubSaturate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Mul(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Min(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Max(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8And(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Or(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Xor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Not(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8ShiftLeftByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8ShiftRightByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8LessThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8LessThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8GreaterThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8GreaterThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Select(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8FromInt16x8(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8FromFloat32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8FromInt32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8FromUint32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8FromInt16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8FromInt8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8FromUint8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Load(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint16x8Store(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8And(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8Or(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8Xor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8Not(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8AnyTrue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8AllTrue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool16x8NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Neg(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Add(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16AddSaturate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Sub(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16SubSaturate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Mul(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Min(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Max(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16And(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Or(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Xor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Not(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16ShiftLeftByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16ShiftRightByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16LessThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16LessThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16GreaterThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16GreaterThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Select(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16FromUint8x16(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16FromFloat32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16FromInt32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16FromUint32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16FromInt16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16FromUint16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16FromUint8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Load(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Int8x16Store(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Add(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16AddSaturate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Sub(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16SubSaturate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Mul(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Min(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Max(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16And(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Or(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Xor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Not(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16ShiftLeftByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16ShiftRightByScalar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16LessThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16LessThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16GreaterThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16GreaterThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Select(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16FromInt8x16(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16FromFloat32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16FromInt32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16FromUint32x4Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16FromInt16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16FromUint16x8Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16FromInt8x16Bits(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Load(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Uint8x16Store(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16Check(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16ExtractLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16ReplaceLane(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16And(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16Or(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16Xor(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16Not(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16AnyTrue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16AllTrue(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16Swizzle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16Shuffle(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16Equal(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Bool8x16NotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringReplaceOneCharWithString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringIndexOf(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringLastIndexOf(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringLocaleCompare(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SubString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringAdd(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InternalizeString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringMatch(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringCharCodeAtRT(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringCompare(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringBuilderConcat(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringBuilderJoin(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SparseJoinWithSeparator(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringToArray(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringToLowerCase(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringToUpperCase(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringTrim(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TruncateString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NewString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringLessThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringLessThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringGreaterThan(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringGreaterThanOrEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringNotEqual(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_FlattenString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringCharFromCode(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringCharAt(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_OneByteSeqStringGetChar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_OneByteSeqStringSetChar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TwoByteSeqStringGetChar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TwoByteSeqStringSetChar(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_StringCharCodeAt(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreateSymbol(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_CreatePrivateSymbol(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SymbolDescription(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SymbolDescriptiveString(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SymbolRegistry(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SymbolIsPrivate(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DeoptimizeFunction(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DeoptimizeNow(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_RunningInSimulator(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsConcurrentRecompilationSupported(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_OptimizeFunctionOnNextCall(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_OptimizeOsr(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NeverOptimizeFunction(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetOptimizationStatus(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_UnblockConcurrentRecompilation(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetOptimizationCount(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetUndetectable(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ClearFunctionTypeFeedback(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NotifyContextDisposed(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetAllocationTimeout(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugPrint(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DebugTrace(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GlobalPrint(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SystemBreak(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_SetFlags(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_Abort(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_AbortJS(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_NativeScriptsCount(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_GetV8Version(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DisassembleFunction(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TraceEnter(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TraceExit(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TraceTailCall(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HaveSameMap(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_InNewSpace(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFastSmiElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFastObjectElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFastSmiOrObjectElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFastDoubleElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFastHoleyElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasDictionaryElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasSloppyArgumentsElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedTypedArrayElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFastProperties(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedUint8Elements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedInt8Elements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedUint16Elements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedInt16Elements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedUint32Elements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedInt32Elements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedFloat32Elements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedFloat64Elements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_HasFixedUint8ClampedElements(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ArrayBufferGetByteLength(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ArrayBufferSliceImpl(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ArrayBufferNeuter(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TypedArrayInitialize(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TypedArrayInitializeFromArrayLike(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ArrayBufferViewGetByteLength(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_ArrayBufferViewGetByteOffset(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TypedArrayGetLength(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewGetBuffer(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TypedArrayGetBuffer(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TypedArraySetFastCases(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_TypedArrayMaxSizeInHeap(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsTypedArray(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsSharedTypedArray(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsSharedIntegerTypedArray(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_IsSharedInteger32TypedArray(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewGetUint8(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewGetInt8(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewGetUint16(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewGetInt16(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewGetUint32(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewGetInt32(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewGetFloat32(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewGetFloat64(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewSetUint8(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewSetInt8(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewSetUint16(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewSetInt16(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewSetUint32(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewSetInt32(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewSetFloat32(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_DataViewSetFloat64(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_URIEscape(int args_length, Object** args_object, Isolate* isolate); Object* Runtime_URIUnescape(int args_length, Object** args_object, Isolate* isolate);





class Runtime : public AllStatic {
 public:
  enum FunctionId {


  kForInPrepare, kLoadLookupSlotForCall, kBinaryOpIC_Miss, kBinaryOpIC_MissWithAllocationSite, kCallIC_Miss, kCompareIC_Miss, kElementsTransitionAndStoreIC_Miss, kKeyedLoadIC_Miss, kKeyedLoadIC_MissFromStubFailure, kKeyedStoreIC_Miss, kKeyedStoreIC_MissFromStubFailure, kKeyedStoreIC_Slow, kLoadElementWithInterceptor, kLoadIC_Miss, kLoadIC_MissFromStubFailure, kLoadPropertyWithInterceptor, kLoadPropertyWithInterceptorOnly, kStoreCallbackProperty, kStoreIC_Miss, kStoreIC_MissFromStubFailure, kStoreIC_Slow, kStorePropertyWithInterceptor, kToBooleanIC_Miss, kUnreachable, kFinishArrayPrototypeSetup, kSpecialArrayFunctions, kTransitionElementsKind, kRemoveArrayHoles, kMoveArrayContents, kEstimateNumberOfElements, kGetArrayKeys, kArrayConstructor, kNewArray, kInternalArrayConstructor, kArrayPush, kNormalizeElements, kGrowArrayElements, kHasComplexElements, kIsArray, kHasCachedArrayIndex, kGetCachedArrayIndex, kFixedArrayGet, kFixedArraySet, kArraySpeciesConstructor, kAtomicsCompareExchange, kAtomicsLoad, kAtomicsStore, kAtomicsAdd, kAtomicsSub, kAtomicsAnd, kAtomicsOr, kAtomicsXor, kAtomicsExchange, kAtomicsIsLockFree, kThrowNonMethodError, kThrowUnsupportedSuperError, kThrowConstructorNonCallableError, kThrowArrayNotSubclassableError, kThrowStaticPrototypeError, kThrowIfStaticPrototype, kHomeObjectSymbol, kDefineClass, kFinalizeClassDefinition, kLoadFromSuper, kLoadKeyedFromSuper, kStoreToSuper_Strict, kStoreToSuper_Sloppy, kStoreKeyedToSuper_Strict, kStoreKeyedToSuper_Sloppy, kGetSuperConstructor, kStringGetRawHashField, kTheHole, kJSCollectionGetTable, kGenericHash, kSetInitialize, kSetGrow, kSetShrink, kSetClear, kSetIteratorInitialize, kSetIteratorClone, kSetIteratorNext, kSetIteratorDetails, kMapInitialize, kMapShrink, kMapClear, kMapGrow, kMapIteratorInitialize, kMapIteratorClone, kMapIteratorDetails, kGetWeakMapEntries, kMapIteratorNext, kWeakCollectionInitialize, kWeakCollectionGet, kWeakCollectionHas, kWeakCollectionDelete, kWeakCollectionSet, kGetWeakSetValues, kObservationWeakMapCreate, kCompileLazy, kCompileOptimized_Concurrent, kCompileOptimized_NotConcurrent, kNotifyStubFailure, kNotifyDeoptimized, kCompileForOnStackReplacement, kTryInstallOptimizedCode, kResolvePossiblyDirectEval, kIsDate, kDateCurrentTime, kThrowNotDateError, kHandleDebuggerStatement, kDebugBreak, kDebugBreakOnBytecode, kSetDebugEventListener, kScheduleBreak, kDebugGetInternalProperties, kDebugGetPropertyDetails, kDebugGetProperty, kDebugPropertyTypeFromDetails, kDebugPropertyAttributesFromDetails, kDebugPropertyIndexFromDetails, kDebugNamedInterceptorPropertyValue, kDebugIndexedInterceptorElementValue, kCheckExecutionState, kGetFrameCount, kGetFrameDetails, kGetScopeCount, kGetScopeDetails, kGetAllScopesDetails, kGetFunctionScopeCount, kGetFunctionScopeDetails, kSetScopeVariableValue, kDebugPrintScopes, kGetThreadCount, kGetThreadDetails, kSetBreakPointsActive, kGetBreakLocations, kSetFunctionBreakPoint, kSetScriptBreakPoint, kClearBreakPoint, kChangeBreakOnException, kIsBreakOnException, kPrepareStep, kClearStepping, kDebugEvaluate, kDebugEvaluateGlobal, kDebugGetLoadedScripts, kDebugReferencedBy, kDebugConstructedBy, kDebugGetPrototype, kDebugSetScriptSource, kFunctionGetInferredName, kFunctionGetDebugName, kGetFunctionCodePositionFromSource, kExecuteInDebugContext, kGetDebugContext, kCollectGarbage, kGetHeapUsage, kGetScript, kDebugPrepareStepInIfStepping, kDebugPushPromise, kDebugPopPromise, kDebugAsyncTaskEvent, kDebugIsActive, kDebugBreakInOptimizedCode, kForInDone, kForInEnumerate, kForInFilter, kForInNext, kForInStep, kInterpreterNewClosure, kInterpreterTraceBytecodeEntry, kInterpreterTraceBytecodeExit, kInterpreterClearPendingMessage, kInterpreterSetPendingMessage, kFunctionGetName, kFunctionSetName, kFunctionRemovePrototype, kFunctionGetScript, kFunctionGetSourceCode, kFunctionGetScriptSourcePosition, kFunctionGetPositionForOffset, kFunctionGetContextData, kFunctionSetInstanceClassName, kFunctionSetLength, kFunctionSetPrototype, kFunctionIsAPIFunction, kSetCode, kSetNativeFlag, kIsConstructor, kSetForceInlineFlag, kCall, kConvertReceiver, kIsFunction, kFunctionToString, kAtomicsFutexWait, kAtomicsFutexWake, kAtomicsFutexWakeOrRequeue, kAtomicsFutexNumWaitersForTesting, kCreateJSGeneratorObject, kSuspendJSGeneratorObject, kResumeJSGeneratorObject, kGeneratorClose, kGeneratorGetFunction, kGeneratorGetReceiver, kGeneratorGetInput, kGeneratorGetContinuation, kGeneratorGetSourcePosition, kGeneratorNext, kGeneratorReturn, kGeneratorThrow, kCheckIsBootstrapping, kExportFromRuntime, kExportExperimentalFromRuntime, kInstallToContext, kThrow, kReThrow, kUnwindAndFindExceptionHandler, kPromoteScheduledException, kThrowReferenceError, kThrowApplyNonFunction, kNewTypeError, kNewSyntaxError, kNewReferenceError, kThrowIllegalInvocation, kThrowIteratorResultNotAnObject, kThrowStackOverflow, kPromiseRejectEvent, kPromiseRevokeReject, kStackGuard, kInterrupt, kAllocateInNewSpace, kAllocateInTargetSpace, kCollectStackTrace, kMessageGetStartPosition, kMessageGetScript, kFormatMessageString, kCallSiteGetFileNameRT, kCallSiteGetFunctionNameRT, kCallSiteGetScriptNameOrSourceUrlRT, kCallSiteGetMethodNameRT, kCallSiteGetLineNumberRT, kCallSiteGetColumnNumberRT, kCallSiteIsNativeRT, kCallSiteIsToplevelRT, kCallSiteIsEvalRT, kCallSiteIsConstructorRT, kIS_VAR, kThrowConstructedNonConstructable, kThrowDerivedConstructorReturnedNonObject, kThrowCalledNonCallable, kCreateListFromArrayLike, kIncrementUseCounter, kGetOrdinaryHasInstance, kGetAndResetRuntimeCallStats, kQuoteJSONString, kBasicJSONStringify, kParseJson, kCreateRegExpLiteral, kCreateObjectLiteral, kCreateArrayLiteral, kCreateArrayLiteralStubBailout, kLiveEditFindSharedFunctionInfosForScript, kLiveEditGatherCompileInfo, kLiveEditReplaceScript, kLiveEditFunctionSourceUpdated, kLiveEditReplaceFunctionCode, kLiveEditFunctionSetScript, kLiveEditReplaceRefToNestedFunction, kLiveEditPatchFunctionPositions, kLiveEditCheckAndDropActivations, kLiveEditCompareStrings, kLiveEditRestartFrame, kMathLogRT, kDoubleHi, kDoubleLo, kConstructDouble, kRemPiO2, kMathAtan2, kMathExpRT, kMathPow, kMathPowRT, kGenerateRandomNumbers, kNumberToRadixString, kNumberToFixed, kNumberToExponential, kNumberToPrecision, kIsValidSmi, kStringToNumber, kStringParseInt, kStringParseFloat, kNumberToString, kNumberToStringSkipCache, kNumberToIntegerMapMinusZero, kNumberToSmi, kSmiLexicographicCompare, kMaxSmi, kIsSmi, kGetRootNaN, kGetHoleNaNUpper, kGetHoleNaNLower, kGetPrototype, kObjectHasOwnProperty, kInternalSetPrototype, kSetPrototype, kGetOwnProperty_Legacy, kOptimizeObjectForAddingMultipleProperties, kGetProperty, kKeyedGetProperty, kLoadGlobalViaContext, kStoreGlobalViaContext_Sloppy, kStoreGlobalViaContext_Strict, kAddNamedProperty, kSetProperty, kAddElement, kAppendElement, kDeleteProperty_Sloppy, kDeleteProperty_Strict, kHasProperty, kPropertyIsEnumerable, kGetOwnPropertyKeys, kGetInterceptorInfo, kToFastProperties, kAllocateHeapNumber, kNewObject, kFinalizeInstanceSize, kGlobalProxy, kLookupAccessor, kLoadMutableDouble, kTryMigrateInstance, kIsJSGlobalProxy, kDefineAccessorPropertyUnchecked, kDefineDataPropertyUnchecked, kDefineDataPropertyInLiteral, kGetDataProperty, kHasFastPackedElements, kValueOf, kIsJSReceiver, kClassOf, kDefineGetterPropertyUnchecked, kDefineSetterPropertyUnchecked, kToObject, kToPrimitive, kToPrimitive_Number, kToPrimitive_String, kToNumber, kToInteger, kToLength, kToString, kToName, kSameValue, kSameValueZero, kCompare, kInstanceOf, kOrdinaryHasInstance, kHasInPrototypeChain, kCreateIterResultObject, kIsAccessCheckNeeded, kObjectDefineProperties, kObjectDefineProperty, kIsObserved, kSetIsObserved, kEnqueueMicrotask, kRunMicrotasks, kDeliverObservationChangeRecords, kGetObservationState, kObserverObjectAndRecordHaveSameOrigin, kObjectWasCreatedInCurrentOrigin, kGetObjectContextObjectObserve, kGetObjectContextObjectGetNotifier, kGetObjectContextNotifierPerformChange, kMultiply, kDivide, kModulus, kAdd, kSubtract, kShiftLeft, kShiftRight, kShiftRightLogical, kBitwiseAnd, kBitwiseOr, kBitwiseXor, kEqual, kNotEqual, kStrictEqual, kStrictNotEqual, kLessThan, kGreaterThan, kLessThanOrEqual, kGreaterThanOrEqual, kIsJSProxy, kJSProxyCall, kJSProxyConstruct, kJSProxyGetTarget, kJSProxyGetHandler, kJSProxyRevoke, kStringReplaceGlobalRegExpWithString, kStringSplit, kRegExpExec, kRegExpFlags, kRegExpSource, kRegExpConstructResult, kRegExpInitializeAndCompile, kRegExpExecMultiple, kRegExpExecReThrow, kIsRegExp, kThrowConstAssignError, kDeclareGlobals, kInitializeVarGlobal, kInitializeConstGlobal, kDeclareLookupSlot, kInitializeLegacyConstLookupSlot, kNewSloppyArguments_Generic, kNewStrictArguments, kNewRestParameter, kNewSloppyArguments, kNewClosure, kNewClosure_Tenured, kNewScriptContext, kNewFunctionContext, kPushWithContext, kPushCatchContext, kPushBlockContext, kIsJSModule, kPushModuleContext, kDeclareModules, kDeleteLookupSlot, kLoadLookupSlot, kLoadLookupSlotInsideTypeof, kStoreLookupSlot_Sloppy, kStoreLookupSlot_Strict, kIsSimdValue, kCreateFloat32x4, kCreateInt32x4, kCreateUint32x4, kCreateBool32x4, kCreateInt16x8, kCreateUint16x8, kCreateBool16x8, kCreateInt8x16, kCreateUint8x16, kCreateBool8x16, kFloat32x4Check, kFloat32x4ExtractLane, kFloat32x4ReplaceLane, kFloat32x4Abs, kFloat32x4Neg, kFloat32x4Sqrt, kFloat32x4RecipApprox, kFloat32x4RecipSqrtApprox, kFloat32x4Add, kFloat32x4Sub, kFloat32x4Mul, kFloat32x4Div, kFloat32x4Min, kFloat32x4Max, kFloat32x4MinNum, kFloat32x4MaxNum, kFloat32x4Equal, kFloat32x4NotEqual, kFloat32x4LessThan, kFloat32x4LessThanOrEqual, kFloat32x4GreaterThan, kFloat32x4GreaterThanOrEqual, kFloat32x4Select, kFloat32x4Swizzle, kFloat32x4Shuffle, kFloat32x4FromInt32x4, kFloat32x4FromUint32x4, kFloat32x4FromInt32x4Bits, kFloat32x4FromUint32x4Bits, kFloat32x4FromInt16x8Bits, kFloat32x4FromUint16x8Bits, kFloat32x4FromInt8x16Bits, kFloat32x4FromUint8x16Bits, kFloat32x4Load, kFloat32x4Load1, kFloat32x4Load2, kFloat32x4Load3, kFloat32x4Store, kFloat32x4Store1, kFloat32x4Store2, kFloat32x4Store3, kInt32x4Check, kInt32x4ExtractLane, kInt32x4ReplaceLane, kInt32x4Neg, kInt32x4Add, kInt32x4Sub, kInt32x4Mul, kInt32x4Min, kInt32x4Max, kInt32x4And, kInt32x4Or, kInt32x4Xor, kInt32x4Not, kInt32x4ShiftLeftByScalar, kInt32x4ShiftRightByScalar, kInt32x4Equal, kInt32x4NotEqual, kInt32x4LessThan, kInt32x4LessThanOrEqual, kInt32x4GreaterThan, kInt32x4GreaterThanOrEqual, kInt32x4Select, kInt32x4Swizzle, kInt32x4Shuffle, kInt32x4FromFloat32x4, kInt32x4FromUint32x4, kInt32x4FromFloat32x4Bits, kInt32x4FromUint32x4Bits, kInt32x4FromInt16x8Bits, kInt32x4FromUint16x8Bits, kInt32x4FromInt8x16Bits, kInt32x4FromUint8x16Bits, kInt32x4Load, kInt32x4Load1, kInt32x4Load2, kInt32x4Load3, kInt32x4Store, kInt32x4Store1, kInt32x4Store2, kInt32x4Store3, kUint32x4Check, kUint32x4ExtractLane, kUint32x4ReplaceLane, kUint32x4Add, kUint32x4Sub, kUint32x4Mul, kUint32x4Min, kUint32x4Max, kUint32x4And, kUint32x4Or, kUint32x4Xor, kUint32x4Not, kUint32x4ShiftLeftByScalar, kUint32x4ShiftRightByScalar, kUint32x4Equal, kUint32x4NotEqual, kUint32x4LessThan, kUint32x4LessThanOrEqual, kUint32x4GreaterThan, kUint32x4GreaterThanOrEqual, kUint32x4Select, kUint32x4Swizzle, kUint32x4Shuffle, kUint32x4FromFloat32x4, kUint32x4FromInt32x4, kUint32x4FromFloat32x4Bits, kUint32x4FromInt32x4Bits, kUint32x4FromInt16x8Bits, kUint32x4FromUint16x8Bits, kUint32x4FromInt8x16Bits, kUint32x4FromUint8x16Bits, kUint32x4Load, kUint32x4Load1, kUint32x4Load2, kUint32x4Load3, kUint32x4Store, kUint32x4Store1, kUint32x4Store2, kUint32x4Store3, kBool32x4Check, kBool32x4ExtractLane, kBool32x4ReplaceLane, kBool32x4And, kBool32x4Or, kBool32x4Xor, kBool32x4Not, kBool32x4AnyTrue, kBool32x4AllTrue, kBool32x4Swizzle, kBool32x4Shuffle, kBool32x4Equal, kBool32x4NotEqual, kInt16x8Check, kInt16x8ExtractLane, kInt16x8ReplaceLane, kInt16x8Neg, kInt16x8Add, kInt16x8AddSaturate, kInt16x8Sub, kInt16x8SubSaturate, kInt16x8Mul, kInt16x8Min, kInt16x8Max, kInt16x8And, kInt16x8Or, kInt16x8Xor, kInt16x8Not, kInt16x8ShiftLeftByScalar, kInt16x8ShiftRightByScalar, kInt16x8Equal, kInt16x8NotEqual, kInt16x8LessThan, kInt16x8LessThanOrEqual, kInt16x8GreaterThan, kInt16x8GreaterThanOrEqual, kInt16x8Select, kInt16x8Swizzle, kInt16x8Shuffle, kInt16x8FromUint16x8, kInt16x8FromFloat32x4Bits, kInt16x8FromInt32x4Bits, kInt16x8FromUint32x4Bits, kInt16x8FromUint16x8Bits, kInt16x8FromInt8x16Bits, kInt16x8FromUint8x16Bits, kInt16x8Load, kInt16x8Store, kUint16x8Check, kUint16x8ExtractLane, kUint16x8ReplaceLane, kUint16x8Add, kUint16x8AddSaturate, kUint16x8Sub, kUint16x8SubSaturate, kUint16x8Mul, kUint16x8Min, kUint16x8Max, kUint16x8And, kUint16x8Or, kUint16x8Xor, kUint16x8Not, kUint16x8ShiftLeftByScalar, kUint16x8ShiftRightByScalar, kUint16x8Equal, kUint16x8NotEqual, kUint16x8LessThan, kUint16x8LessThanOrEqual, kUint16x8GreaterThan, kUint16x8GreaterThanOrEqual, kUint16x8Select, kUint16x8Swizzle, kUint16x8Shuffle, kUint16x8FromInt16x8, kUint16x8FromFloat32x4Bits, kUint16x8FromInt32x4Bits, kUint16x8FromUint32x4Bits, kUint16x8FromInt16x8Bits, kUint16x8FromInt8x16Bits, kUint16x8FromUint8x16Bits, kUint16x8Load, kUint16x8Store, kBool16x8Check, kBool16x8ExtractLane, kBool16x8ReplaceLane, kBool16x8And, kBool16x8Or, kBool16x8Xor, kBool16x8Not, kBool16x8AnyTrue, kBool16x8AllTrue, kBool16x8Swizzle, kBool16x8Shuffle, kBool16x8Equal, kBool16x8NotEqual, kInt8x16Check, kInt8x16ExtractLane, kInt8x16ReplaceLane, kInt8x16Neg, kInt8x16Add, kInt8x16AddSaturate, kInt8x16Sub, kInt8x16SubSaturate, kInt8x16Mul, kInt8x16Min, kInt8x16Max, kInt8x16And, kInt8x16Or, kInt8x16Xor, kInt8x16Not, kInt8x16ShiftLeftByScalar, kInt8x16ShiftRightByScalar, kInt8x16Equal, kInt8x16NotEqual, kInt8x16LessThan, kInt8x16LessThanOrEqual, kInt8x16GreaterThan, kInt8x16GreaterThanOrEqual, kInt8x16Select, kInt8x16Swizzle, kInt8x16Shuffle, kInt8x16FromUint8x16, kInt8x16FromFloat32x4Bits, kInt8x16FromInt32x4Bits, kInt8x16FromUint32x4Bits, kInt8x16FromInt16x8Bits, kInt8x16FromUint16x8Bits, kInt8x16FromUint8x16Bits, kInt8x16Load, kInt8x16Store, kUint8x16Check, kUint8x16ExtractLane, kUint8x16ReplaceLane, kUint8x16Add, kUint8x16AddSaturate, kUint8x16Sub, kUint8x16SubSaturate, kUint8x16Mul, kUint8x16Min, kUint8x16Max, kUint8x16And, kUint8x16Or, kUint8x16Xor, kUint8x16Not, kUint8x16ShiftLeftByScalar, kUint8x16ShiftRightByScalar, kUint8x16Equal, kUint8x16NotEqual, kUint8x16LessThan, kUint8x16LessThanOrEqual, kUint8x16GreaterThan, kUint8x16GreaterThanOrEqual, kUint8x16Select, kUint8x16Swizzle, kUint8x16Shuffle, kUint8x16FromInt8x16, kUint8x16FromFloat32x4Bits, kUint8x16FromInt32x4Bits, kUint8x16FromUint32x4Bits, kUint8x16FromInt16x8Bits, kUint8x16FromUint16x8Bits, kUint8x16FromInt8x16Bits, kUint8x16Load, kUint8x16Store, kBool8x16Check, kBool8x16ExtractLane, kBool8x16ReplaceLane, kBool8x16And, kBool8x16Or, kBool8x16Xor, kBool8x16Not, kBool8x16AnyTrue, kBool8x16AllTrue, kBool8x16Swizzle, kBool8x16Shuffle, kBool8x16Equal, kBool8x16NotEqual, kStringReplaceOneCharWithString, kStringIndexOf, kStringLastIndexOf, kStringLocaleCompare, kSubString, kStringAdd, kInternalizeString, kStringMatch, kStringCharCodeAtRT, kStringCompare, kStringBuilderConcat, kStringBuilderJoin, kSparseJoinWithSeparator, kStringToArray, kStringToLowerCase, kStringToUpperCase, kStringTrim, kTruncateString, kNewString, kStringLessThan, kStringLessThanOrEqual, kStringGreaterThan, kStringGreaterThanOrEqual, kStringEqual, kStringNotEqual, kFlattenString, kStringCharFromCode, kStringCharAt, kOneByteSeqStringGetChar, kOneByteSeqStringSetChar, kTwoByteSeqStringGetChar, kTwoByteSeqStringSetChar, kStringCharCodeAt, kCreateSymbol, kCreatePrivateSymbol, kSymbolDescription, kSymbolDescriptiveString, kSymbolRegistry, kSymbolIsPrivate, kDeoptimizeFunction, kDeoptimizeNow, kRunningInSimulator, kIsConcurrentRecompilationSupported, kOptimizeFunctionOnNextCall, kOptimizeOsr, kNeverOptimizeFunction, kGetOptimizationStatus, kUnblockConcurrentRecompilation, kGetOptimizationCount, kGetUndetectable, kClearFunctionTypeFeedback, kNotifyContextDisposed, kSetAllocationTimeout, kDebugPrint, kDebugTrace, kGlobalPrint, kSystemBreak, kSetFlags, kAbort, kAbortJS, kNativeScriptsCount, kGetV8Version, kDisassembleFunction, kTraceEnter, kTraceExit, kTraceTailCall, kHaveSameMap, kInNewSpace, kHasFastSmiElements, kHasFastObjectElements, kHasFastSmiOrObjectElements, kHasFastDoubleElements, kHasFastHoleyElements, kHasDictionaryElements, kHasSloppyArgumentsElements, kHasFixedTypedArrayElements, kHasFastProperties, kHasFixedUint8Elements, kHasFixedInt8Elements, kHasFixedUint16Elements, kHasFixedInt16Elements, kHasFixedUint32Elements, kHasFixedInt32Elements, kHasFixedFloat32Elements, kHasFixedFloat64Elements, kHasFixedUint8ClampedElements, kArrayBufferGetByteLength, kArrayBufferSliceImpl, kArrayBufferNeuter, kTypedArrayInitialize, kTypedArrayInitializeFromArrayLike, kArrayBufferViewGetByteLength, kArrayBufferViewGetByteOffset, kTypedArrayGetLength, kDataViewGetBuffer, kTypedArrayGetBuffer, kTypedArraySetFastCases, kTypedArrayMaxSizeInHeap, kIsTypedArray, kIsSharedTypedArray, kIsSharedIntegerTypedArray, kIsSharedInteger32TypedArray, kDataViewGetUint8, kDataViewGetInt8, kDataViewGetUint16, kDataViewGetInt16, kDataViewGetUint32, kDataViewGetInt32, kDataViewGetFloat32, kDataViewGetFloat64, kDataViewSetUint8, kDataViewSetInt8, kDataViewSetUint16, kDataViewSetInt16, kDataViewSetUint32, kDataViewSetInt32, kDataViewSetFloat32, kDataViewSetFloat64, kURIEscape, kURIUnescape,
  kInlineForInPrepare, kInlineLoadLookupSlotForCall, kInlineBinaryOpIC_Miss, kInlineBinaryOpIC_MissWithAllocationSite, kInlineCallIC_Miss, kInlineCompareIC_Miss, kInlineElementsTransitionAndStoreIC_Miss, kInlineKeyedLoadIC_Miss, kInlineKeyedLoadIC_MissFromStubFailure, kInlineKeyedStoreIC_Miss, kInlineKeyedStoreIC_MissFromStubFailure, kInlineKeyedStoreIC_Slow, kInlineLoadElementWithInterceptor, kInlineLoadIC_Miss, kInlineLoadIC_MissFromStubFailure, kInlineLoadPropertyWithInterceptor, kInlineLoadPropertyWithInterceptorOnly, kInlineStoreCallbackProperty, kInlineStoreIC_Miss, kInlineStoreIC_MissFromStubFailure, kInlineStoreIC_Slow, kInlineStorePropertyWithInterceptor, kInlineToBooleanIC_Miss, kInlineUnreachable, kInlineFinishArrayPrototypeSetup, kInlineSpecialArrayFunctions, kInlineTransitionElementsKind, kInlineRemoveArrayHoles, kInlineMoveArrayContents, kInlineEstimateNumberOfElements, kInlineGetArrayKeys, kInlineArrayConstructor, kInlineNewArray, kInlineInternalArrayConstructor, kInlineArrayPush, kInlineNormalizeElements, kInlineGrowArrayElements, kInlineHasComplexElements, kInlineIsArray, kInlineHasCachedArrayIndex, kInlineGetCachedArrayIndex, kInlineFixedArrayGet, kInlineFixedArraySet, kInlineArraySpeciesConstructor, kInlineAtomicsCompareExchange, kInlineAtomicsLoad, kInlineAtomicsStore, kInlineAtomicsAdd, kInlineAtomicsSub, kInlineAtomicsAnd, kInlineAtomicsOr, kInlineAtomicsXor, kInlineAtomicsExchange, kInlineAtomicsIsLockFree, kInlineThrowNonMethodError, kInlineThrowUnsupportedSuperError, kInlineThrowConstructorNonCallableError, kInlineThrowArrayNotSubclassableError, kInlineThrowStaticPrototypeError, kInlineThrowIfStaticPrototype, kInlineHomeObjectSymbol, kInlineDefineClass, kInlineFinalizeClassDefinition, kInlineLoadFromSuper, kInlineLoadKeyedFromSuper, kInlineStoreToSuper_Strict, kInlineStoreToSuper_Sloppy, kInlineStoreKeyedToSuper_Strict, kInlineStoreKeyedToSuper_Sloppy, kInlineGetSuperConstructor, kInlineStringGetRawHashField, kInlineTheHole, kInlineJSCollectionGetTable, kInlineGenericHash, kInlineSetInitialize, kInlineSetGrow, kInlineSetShrink, kInlineSetClear, kInlineSetIteratorInitialize, kInlineSetIteratorClone, kInlineSetIteratorNext, kInlineSetIteratorDetails, kInlineMapInitialize, kInlineMapShrink, kInlineMapClear, kInlineMapGrow, kInlineMapIteratorInitialize, kInlineMapIteratorClone, kInlineMapIteratorDetails, kInlineGetWeakMapEntries, kInlineMapIteratorNext, kInlineWeakCollectionInitialize, kInlineWeakCollectionGet, kInlineWeakCollectionHas, kInlineWeakCollectionDelete, kInlineWeakCollectionSet, kInlineGetWeakSetValues, kInlineObservationWeakMapCreate, kInlineCompileLazy, kInlineCompileOptimized_Concurrent, kInlineCompileOptimized_NotConcurrent, kInlineNotifyStubFailure, kInlineNotifyDeoptimized, kInlineCompileForOnStackReplacement, kInlineTryInstallOptimizedCode, kInlineResolvePossiblyDirectEval, kInlineIsDate, kInlineDateCurrentTime, kInlineThrowNotDateError, kInlineHandleDebuggerStatement, kInlineDebugBreak, kInlineDebugBreakOnBytecode, kInlineSetDebugEventListener, kInlineScheduleBreak, kInlineDebugGetInternalProperties, kInlineDebugGetPropertyDetails, kInlineDebugGetProperty, kInlineDebugPropertyTypeFromDetails, kInlineDebugPropertyAttributesFromDetails, kInlineDebugPropertyIndexFromDetails, kInlineDebugNamedInterceptorPropertyValue, kInlineDebugIndexedInterceptorElementValue, kInlineCheckExecutionState, kInlineGetFrameCount, kInlineGetFrameDetails, kInlineGetScopeCount, kInlineGetScopeDetails, kInlineGetAllScopesDetails, kInlineGetFunctionScopeCount, kInlineGetFunctionScopeDetails, kInlineSetScopeVariableValue, kInlineDebugPrintScopes, kInlineGetThreadCount, kInlineGetThreadDetails, kInlineSetBreakPointsActive, kInlineGetBreakLocations, kInlineSetFunctionBreakPoint, kInlineSetScriptBreakPoint, kInlineClearBreakPoint, kInlineChangeBreakOnException, kInlineIsBreakOnException, kInlinePrepareStep, kInlineClearStepping, kInlineDebugEvaluate, kInlineDebugEvaluateGlobal, kInlineDebugGetLoadedScripts, kInlineDebugReferencedBy, kInlineDebugConstructedBy, kInlineDebugGetPrototype, kInlineDebugSetScriptSource, kInlineFunctionGetInferredName, kInlineFunctionGetDebugName, kInlineGetFunctionCodePositionFromSource, kInlineExecuteInDebugContext, kInlineGetDebugContext, kInlineCollectGarbage, kInlineGetHeapUsage, kInlineGetScript, kInlineDebugPrepareStepInIfStepping, kInlineDebugPushPromise, kInlineDebugPopPromise, kInlineDebugAsyncTaskEvent, kInlineDebugIsActive, kInlineDebugBreakInOptimizedCode, kInlineForInDone, kInlineForInEnumerate, kInlineForInFilter, kInlineForInNext, kInlineForInStep, kInlineInterpreterNewClosure, kInlineInterpreterTraceBytecodeEntry, kInlineInterpreterTraceBytecodeExit, kInlineInterpreterClearPendingMessage, kInlineInterpreterSetPendingMessage, kInlineFunctionGetName, kInlineFunctionSetName, kInlineFunctionRemovePrototype, kInlineFunctionGetScript, kInlineFunctionGetSourceCode, kInlineFunctionGetScriptSourcePosition, kInlineFunctionGetPositionForOffset, kInlineFunctionGetContextData, kInlineFunctionSetInstanceClassName, kInlineFunctionSetLength, kInlineFunctionSetPrototype, kInlineFunctionIsAPIFunction, kInlineSetCode, kInlineSetNativeFlag, kInlineIsConstructor, kInlineSetForceInlineFlag, kInlineCall, kInlineConvertReceiver, kInlineIsFunction, kInlineFunctionToString, kInlineAtomicsFutexWait, kInlineAtomicsFutexWake, kInlineAtomicsFutexWakeOrRequeue, kInlineAtomicsFutexNumWaitersForTesting, kInlineCreateJSGeneratorObject, kInlineSuspendJSGeneratorObject, kInlineResumeJSGeneratorObject, kInlineGeneratorClose, kInlineGeneratorGetFunction, kInlineGeneratorGetReceiver, kInlineGeneratorGetInput, kInlineGeneratorGetContinuation, kInlineGeneratorGetSourcePosition, kInlineGeneratorNext, kInlineGeneratorReturn, kInlineGeneratorThrow, kInlineCheckIsBootstrapping, kInlineExportFromRuntime, kInlineExportExperimentalFromRuntime, kInlineInstallToContext, kInlineThrow, kInlineReThrow, kInlineUnwindAndFindExceptionHandler, kInlinePromoteScheduledException, kInlineThrowReferenceError, kInlineThrowApplyNonFunction, kInlineNewTypeError, kInlineNewSyntaxError, kInlineNewReferenceError, kInlineThrowIllegalInvocation, kInlineThrowIteratorResultNotAnObject, kInlineThrowStackOverflow, kInlinePromiseRejectEvent, kInlinePromiseRevokeReject, kInlineStackGuard, kInlineInterrupt, kInlineAllocateInNewSpace, kInlineAllocateInTargetSpace, kInlineCollectStackTrace, kInlineMessageGetStartPosition, kInlineMessageGetScript, kInlineFormatMessageString, kInlineCallSiteGetFileNameRT, kInlineCallSiteGetFunctionNameRT, kInlineCallSiteGetScriptNameOrSourceUrlRT, kInlineCallSiteGetMethodNameRT, kInlineCallSiteGetLineNumberRT, kInlineCallSiteGetColumnNumberRT, kInlineCallSiteIsNativeRT, kInlineCallSiteIsToplevelRT, kInlineCallSiteIsEvalRT, kInlineCallSiteIsConstructorRT, kInlineIS_VAR, kInlineThrowConstructedNonConstructable, kInlineThrowDerivedConstructorReturnedNonObject, kInlineThrowCalledNonCallable, kInlineCreateListFromArrayLike, kInlineIncrementUseCounter, kInlineGetOrdinaryHasInstance, kInlineGetAndResetRuntimeCallStats, kInlineQuoteJSONString, kInlineBasicJSONStringify, kInlineParseJson, kInlineCreateRegExpLiteral, kInlineCreateObjectLiteral, kInlineCreateArrayLiteral, kInlineCreateArrayLiteralStubBailout, kInlineLiveEditFindSharedFunctionInfosForScript, kInlineLiveEditGatherCompileInfo, kInlineLiveEditReplaceScript, kInlineLiveEditFunctionSourceUpdated, kInlineLiveEditReplaceFunctionCode, kInlineLiveEditFunctionSetScript, kInlineLiveEditReplaceRefToNestedFunction, kInlineLiveEditPatchFunctionPositions, kInlineLiveEditCheckAndDropActivations, kInlineLiveEditCompareStrings, kInlineLiveEditRestartFrame, kInlineMathLogRT, kInlineDoubleHi, kInlineDoubleLo, kInlineConstructDouble, kInlineRemPiO2, kInlineMathAtan2, kInlineMathExpRT, kInlineMathPow, kInlineMathPowRT, kInlineGenerateRandomNumbers, kInlineNumberToRadixString, kInlineNumberToFixed, kInlineNumberToExponential, kInlineNumberToPrecision, kInlineIsValidSmi, kInlineStringToNumber, kInlineStringParseInt, kInlineStringParseFloat, kInlineNumberToString, kInlineNumberToStringSkipCache, kInlineNumberToIntegerMapMinusZero, kInlineNumberToSmi, kInlineSmiLexicographicCompare, kInlineMaxSmi, kInlineIsSmi, kInlineGetRootNaN, kInlineGetHoleNaNUpper, kInlineGetHoleNaNLower, kInlineGetPrototype, kInlineObjectHasOwnProperty, kInlineInternalSetPrototype, kInlineSetPrototype, kInlineGetOwnProperty_Legacy, kInlineOptimizeObjectForAddingMultipleProperties, kInlineGetProperty, kInlineKeyedGetProperty, kInlineLoadGlobalViaContext, kInlineStoreGlobalViaContext_Sloppy, kInlineStoreGlobalViaContext_Strict, kInlineAddNamedProperty, kInlineSetProperty, kInlineAddElement, kInlineAppendElement, kInlineDeleteProperty_Sloppy, kInlineDeleteProperty_Strict, kInlineHasProperty, kInlinePropertyIsEnumerable, kInlineGetOwnPropertyKeys, kInlineGetInterceptorInfo, kInlineToFastProperties, kInlineAllocateHeapNumber, kInlineNewObject, kInlineFinalizeInstanceSize, kInlineGlobalProxy, kInlineLookupAccessor, kInlineLoadMutableDouble, kInlineTryMigrateInstance, kInlineIsJSGlobalProxy, kInlineDefineAccessorPropertyUnchecked, kInlineDefineDataPropertyUnchecked, kInlineDefineDataPropertyInLiteral, kInlineGetDataProperty, kInlineHasFastPackedElements, kInlineValueOf, kInlineIsJSReceiver, kInlineClassOf, kInlineDefineGetterPropertyUnchecked, kInlineDefineSetterPropertyUnchecked, kInlineToObject, kInlineToPrimitive, kInlineToPrimitive_Number, kInlineToPrimitive_String, kInlineToNumber, kInlineToInteger, kInlineToLength, kInlineToString, kInlineToName, kInlineSameValue, kInlineSameValueZero, kInlineCompare, kInlineInstanceOf, kInlineOrdinaryHasInstance, kInlineHasInPrototypeChain, kInlineCreateIterResultObject, kInlineIsAccessCheckNeeded, kInlineObjectDefineProperties, kInlineObjectDefineProperty, kInlineIsObserved, kInlineSetIsObserved, kInlineEnqueueMicrotask, kInlineRunMicrotasks, kInlineDeliverObservationChangeRecords, kInlineGetObservationState, kInlineObserverObjectAndRecordHaveSameOrigin, kInlineObjectWasCreatedInCurrentOrigin, kInlineGetObjectContextObjectObserve, kInlineGetObjectContextObjectGetNotifier, kInlineGetObjectContextNotifierPerformChange, kInlineMultiply, kInlineDivide, kInlineModulus, kInlineAdd, kInlineSubtract, kInlineShiftLeft, kInlineShiftRight, kInlineShiftRightLogical, kInlineBitwiseAnd, kInlineBitwiseOr, kInlineBitwiseXor, kInlineEqual, kInlineNotEqual, kInlineStrictEqual, kInlineStrictNotEqual, kInlineLessThan, kInlineGreaterThan, kInlineLessThanOrEqual, kInlineGreaterThanOrEqual, kInlineIsJSProxy, kInlineJSProxyCall, kInlineJSProxyConstruct, kInlineJSProxyGetTarget, kInlineJSProxyGetHandler, kInlineJSProxyRevoke, kInlineStringReplaceGlobalRegExpWithString, kInlineStringSplit, kInlineRegExpExec, kInlineRegExpFlags, kInlineRegExpSource, kInlineRegExpConstructResult, kInlineRegExpInitializeAndCompile, kInlineRegExpExecMultiple, kInlineRegExpExecReThrow, kInlineIsRegExp, kInlineThrowConstAssignError, kInlineDeclareGlobals, kInlineInitializeVarGlobal, kInlineInitializeConstGlobal, kInlineDeclareLookupSlot, kInlineInitializeLegacyConstLookupSlot, kInlineNewSloppyArguments_Generic, kInlineNewStrictArguments, kInlineNewRestParameter, kInlineNewSloppyArguments, kInlineNewClosure, kInlineNewClosure_Tenured, kInlineNewScriptContext, kInlineNewFunctionContext, kInlinePushWithContext, kInlinePushCatchContext, kInlinePushBlockContext, kInlineIsJSModule, kInlinePushModuleContext, kInlineDeclareModules, kInlineDeleteLookupSlot, kInlineLoadLookupSlot, kInlineLoadLookupSlotInsideTypeof, kInlineStoreLookupSlot_Sloppy, kInlineStoreLookupSlot_Strict, kInlineIsSimdValue, kInlineCreateFloat32x4, kInlineCreateInt32x4, kInlineCreateUint32x4, kInlineCreateBool32x4, kInlineCreateInt16x8, kInlineCreateUint16x8, kInlineCreateBool16x8, kInlineCreateInt8x16, kInlineCreateUint8x16, kInlineCreateBool8x16, kInlineFloat32x4Check, kInlineFloat32x4ExtractLane, kInlineFloat32x4ReplaceLane, kInlineFloat32x4Abs, kInlineFloat32x4Neg, kInlineFloat32x4Sqrt, kInlineFloat32x4RecipApprox, kInlineFloat32x4RecipSqrtApprox, kInlineFloat32x4Add, kInlineFloat32x4Sub, kInlineFloat32x4Mul, kInlineFloat32x4Div, kInlineFloat32x4Min, kInlineFloat32x4Max, kInlineFloat32x4MinNum, kInlineFloat32x4MaxNum, kInlineFloat32x4Equal, kInlineFloat32x4NotEqual, kInlineFloat32x4LessThan, kInlineFloat32x4LessThanOrEqual, kInlineFloat32x4GreaterThan, kInlineFloat32x4GreaterThanOrEqual, kInlineFloat32x4Select, kInlineFloat32x4Swizzle, kInlineFloat32x4Shuffle, kInlineFloat32x4FromInt32x4, kInlineFloat32x4FromUint32x4, kInlineFloat32x4FromInt32x4Bits, kInlineFloat32x4FromUint32x4Bits, kInlineFloat32x4FromInt16x8Bits, kInlineFloat32x4FromUint16x8Bits, kInlineFloat32x4FromInt8x16Bits, kInlineFloat32x4FromUint8x16Bits, kInlineFloat32x4Load, kInlineFloat32x4Load1, kInlineFloat32x4Load2, kInlineFloat32x4Load3, kInlineFloat32x4Store, kInlineFloat32x4Store1, kInlineFloat32x4Store2, kInlineFloat32x4Store3, kInlineInt32x4Check, kInlineInt32x4ExtractLane, kInlineInt32x4ReplaceLane, kInlineInt32x4Neg, kInlineInt32x4Add, kInlineInt32x4Sub, kInlineInt32x4Mul, kInlineInt32x4Min, kInlineInt32x4Max, kInlineInt32x4And, kInlineInt32x4Or, kInlineInt32x4Xor, kInlineInt32x4Not, kInlineInt32x4ShiftLeftByScalar, kInlineInt32x4ShiftRightByScalar, kInlineInt32x4Equal, kInlineInt32x4NotEqual, kInlineInt32x4LessThan, kInlineInt32x4LessThanOrEqual, kInlineInt32x4GreaterThan, kInlineInt32x4GreaterThanOrEqual, kInlineInt32x4Select, kInlineInt32x4Swizzle, kInlineInt32x4Shuffle, kInlineInt32x4FromFloat32x4, kInlineInt32x4FromUint32x4, kInlineInt32x4FromFloat32x4Bits, kInlineInt32x4FromUint32x4Bits, kInlineInt32x4FromInt16x8Bits, kInlineInt32x4FromUint16x8Bits, kInlineInt32x4FromInt8x16Bits, kInlineInt32x4FromUint8x16Bits, kInlineInt32x4Load, kInlineInt32x4Load1, kInlineInt32x4Load2, kInlineInt32x4Load3, kInlineInt32x4Store, kInlineInt32x4Store1, kInlineInt32x4Store2, kInlineInt32x4Store3, kInlineUint32x4Check, kInlineUint32x4ExtractLane, kInlineUint32x4ReplaceLane, kInlineUint32x4Add, kInlineUint32x4Sub, kInlineUint32x4Mul, kInlineUint32x4Min, kInlineUint32x4Max, kInlineUint32x4And, kInlineUint32x4Or, kInlineUint32x4Xor, kInlineUint32x4Not, kInlineUint32x4ShiftLeftByScalar, kInlineUint32x4ShiftRightByScalar, kInlineUint32x4Equal, kInlineUint32x4NotEqual, kInlineUint32x4LessThan, kInlineUint32x4LessThanOrEqual, kInlineUint32x4GreaterThan, kInlineUint32x4GreaterThanOrEqual, kInlineUint32x4Select, kInlineUint32x4Swizzle, kInlineUint32x4Shuffle, kInlineUint32x4FromFloat32x4, kInlineUint32x4FromInt32x4, kInlineUint32x4FromFloat32x4Bits, kInlineUint32x4FromInt32x4Bits, kInlineUint32x4FromInt16x8Bits, kInlineUint32x4FromUint16x8Bits, kInlineUint32x4FromInt8x16Bits, kInlineUint32x4FromUint8x16Bits, kInlineUint32x4Load, kInlineUint32x4Load1, kInlineUint32x4Load2, kInlineUint32x4Load3, kInlineUint32x4Store, kInlineUint32x4Store1, kInlineUint32x4Store2, kInlineUint32x4Store3, kInlineBool32x4Check, kInlineBool32x4ExtractLane, kInlineBool32x4ReplaceLane, kInlineBool32x4And, kInlineBool32x4Or, kInlineBool32x4Xor, kInlineBool32x4Not, kInlineBool32x4AnyTrue, kInlineBool32x4AllTrue, kInlineBool32x4Swizzle, kInlineBool32x4Shuffle, kInlineBool32x4Equal, kInlineBool32x4NotEqual, kInlineInt16x8Check, kInlineInt16x8ExtractLane, kInlineInt16x8ReplaceLane, kInlineInt16x8Neg, kInlineInt16x8Add, kInlineInt16x8AddSaturate, kInlineInt16x8Sub, kInlineInt16x8SubSaturate, kInlineInt16x8Mul, kInlineInt16x8Min, kInlineInt16x8Max, kInlineInt16x8And, kInlineInt16x8Or, kInlineInt16x8Xor, kInlineInt16x8Not, kInlineInt16x8ShiftLeftByScalar, kInlineInt16x8ShiftRightByScalar, kInlineInt16x8Equal, kInlineInt16x8NotEqual, kInlineInt16x8LessThan, kInlineInt16x8LessThanOrEqual, kInlineInt16x8GreaterThan, kInlineInt16x8GreaterThanOrEqual, kInlineInt16x8Select, kInlineInt16x8Swizzle, kInlineInt16x8Shuffle, kInlineInt16x8FromUint16x8, kInlineInt16x8FromFloat32x4Bits, kInlineInt16x8FromInt32x4Bits, kInlineInt16x8FromUint32x4Bits, kInlineInt16x8FromUint16x8Bits, kInlineInt16x8FromInt8x16Bits, kInlineInt16x8FromUint8x16Bits, kInlineInt16x8Load, kInlineInt16x8Store, kInlineUint16x8Check, kInlineUint16x8ExtractLane, kInlineUint16x8ReplaceLane, kInlineUint16x8Add, kInlineUint16x8AddSaturate, kInlineUint16x8Sub, kInlineUint16x8SubSaturate, kInlineUint16x8Mul, kInlineUint16x8Min, kInlineUint16x8Max, kInlineUint16x8And, kInlineUint16x8Or, kInlineUint16x8Xor, kInlineUint16x8Not, kInlineUint16x8ShiftLeftByScalar, kInlineUint16x8ShiftRightByScalar, kInlineUint16x8Equal, kInlineUint16x8NotEqual, kInlineUint16x8LessThan, kInlineUint16x8LessThanOrEqual, kInlineUint16x8GreaterThan, kInlineUint16x8GreaterThanOrEqual, kInlineUint16x8Select, kInlineUint16x8Swizzle, kInlineUint16x8Shuffle, kInlineUint16x8FromInt16x8, kInlineUint16x8FromFloat32x4Bits, kInlineUint16x8FromInt32x4Bits, kInlineUint16x8FromUint32x4Bits, kInlineUint16x8FromInt16x8Bits, kInlineUint16x8FromInt8x16Bits, kInlineUint16x8FromUint8x16Bits, kInlineUint16x8Load, kInlineUint16x8Store, kInlineBool16x8Check, kInlineBool16x8ExtractLane, kInlineBool16x8ReplaceLane, kInlineBool16x8And, kInlineBool16x8Or, kInlineBool16x8Xor, kInlineBool16x8Not, kInlineBool16x8AnyTrue, kInlineBool16x8AllTrue, kInlineBool16x8Swizzle, kInlineBool16x8Shuffle, kInlineBool16x8Equal, kInlineBool16x8NotEqual, kInlineInt8x16Check, kInlineInt8x16ExtractLane, kInlineInt8x16ReplaceLane, kInlineInt8x16Neg, kInlineInt8x16Add, kInlineInt8x16AddSaturate, kInlineInt8x16Sub, kInlineInt8x16SubSaturate, kInlineInt8x16Mul, kInlineInt8x16Min, kInlineInt8x16Max, kInlineInt8x16And, kInlineInt8x16Or, kInlineInt8x16Xor, kInlineInt8x16Not, kInlineInt8x16ShiftLeftByScalar, kInlineInt8x16ShiftRightByScalar, kInlineInt8x16Equal, kInlineInt8x16NotEqual, kInlineInt8x16LessThan, kInlineInt8x16LessThanOrEqual, kInlineInt8x16GreaterThan, kInlineInt8x16GreaterThanOrEqual, kInlineInt8x16Select, kInlineInt8x16Swizzle, kInlineInt8x16Shuffle, kInlineInt8x16FromUint8x16, kInlineInt8x16FromFloat32x4Bits, kInlineInt8x16FromInt32x4Bits, kInlineInt8x16FromUint32x4Bits, kInlineInt8x16FromInt16x8Bits, kInlineInt8x16FromUint16x8Bits, kInlineInt8x16FromUint8x16Bits, kInlineInt8x16Load, kInlineInt8x16Store, kInlineUint8x16Check, kInlineUint8x16ExtractLane, kInlineUint8x16ReplaceLane, kInlineUint8x16Add, kInlineUint8x16AddSaturate, kInlineUint8x16Sub, kInlineUint8x16SubSaturate, kInlineUint8x16Mul, kInlineUint8x16Min, kInlineUint8x16Max, kInlineUint8x16And, kInlineUint8x16Or, kInlineUint8x16Xor, kInlineUint8x16Not, kInlineUint8x16ShiftLeftByScalar, kInlineUint8x16ShiftRightByScalar, kInlineUint8x16Equal, kInlineUint8x16NotEqual, kInlineUint8x16LessThan, kInlineUint8x16LessThanOrEqual, kInlineUint8x16GreaterThan, kInlineUint8x16GreaterThanOrEqual, kInlineUint8x16Select, kInlineUint8x16Swizzle, kInlineUint8x16Shuffle, kInlineUint8x16FromInt8x16, kInlineUint8x16FromFloat32x4Bits, kInlineUint8x16FromInt32x4Bits, kInlineUint8x16FromUint32x4Bits, kInlineUint8x16FromInt16x8Bits, kInlineUint8x16FromUint16x8Bits, kInlineUint8x16FromInt8x16Bits, kInlineUint8x16Load, kInlineUint8x16Store, kInlineBool8x16Check, kInlineBool8x16ExtractLane, kInlineBool8x16ReplaceLane, kInlineBool8x16And, kInlineBool8x16Or, kInlineBool8x16Xor, kInlineBool8x16Not, kInlineBool8x16AnyTrue, kInlineBool8x16AllTrue, kInlineBool8x16Swizzle, kInlineBool8x16Shuffle, kInlineBool8x16Equal, kInlineBool8x16NotEqual, kInlineStringReplaceOneCharWithString, kInlineStringIndexOf, kInlineStringLastIndexOf, kInlineStringLocaleCompare, kInlineSubString, kInlineStringAdd, kInlineInternalizeString, kInlineStringMatch, kInlineStringCharCodeAtRT, kInlineStringCompare, kInlineStringBuilderConcat, kInlineStringBuilderJoin, kInlineSparseJoinWithSeparator, kInlineStringToArray, kInlineStringToLowerCase, kInlineStringToUpperCase, kInlineStringTrim, kInlineTruncateString, kInlineNewString, kInlineStringLessThan, kInlineStringLessThanOrEqual, kInlineStringGreaterThan, kInlineStringGreaterThanOrEqual, kInlineStringEqual, kInlineStringNotEqual, kInlineFlattenString, kInlineStringCharFromCode, kInlineStringCharAt, kInlineOneByteSeqStringGetChar, kInlineOneByteSeqStringSetChar, kInlineTwoByteSeqStringGetChar, kInlineTwoByteSeqStringSetChar, kInlineStringCharCodeAt, kInlineCreateSymbol, kInlineCreatePrivateSymbol, kInlineSymbolDescription, kInlineSymbolDescriptiveString, kInlineSymbolRegistry, kInlineSymbolIsPrivate, kInlineDeoptimizeFunction, kInlineDeoptimizeNow, kInlineRunningInSimulator, kInlineIsConcurrentRecompilationSupported, kInlineOptimizeFunctionOnNextCall, kInlineOptimizeOsr, kInlineNeverOptimizeFunction, kInlineGetOptimizationStatus, kInlineUnblockConcurrentRecompilation, kInlineGetOptimizationCount, kInlineGetUndetectable, kInlineClearFunctionTypeFeedback, kInlineNotifyContextDisposed, kInlineSetAllocationTimeout, kInlineDebugPrint, kInlineDebugTrace, kInlineGlobalPrint, kInlineSystemBreak, kInlineSetFlags, kInlineAbort, kInlineAbortJS, kInlineNativeScriptsCount, kInlineGetV8Version, kInlineDisassembleFunction, kInlineTraceEnter, kInlineTraceExit, kInlineTraceTailCall, kInlineHaveSameMap, kInlineInNewSpace, kInlineHasFastSmiElements, kInlineHasFastObjectElements, kInlineHasFastSmiOrObjectElements, kInlineHasFastDoubleElements, kInlineHasFastHoleyElements, kInlineHasDictionaryElements, kInlineHasSloppyArgumentsElements, kInlineHasFixedTypedArrayElements, kInlineHasFastProperties, kInlineHasFixedUint8Elements, kInlineHasFixedInt8Elements, kInlineHasFixedUint16Elements, kInlineHasFixedInt16Elements, kInlineHasFixedUint32Elements, kInlineHasFixedInt32Elements, kInlineHasFixedFloat32Elements, kInlineHasFixedFloat64Elements, kInlineHasFixedUint8ClampedElements, kInlineArrayBufferGetByteLength, kInlineArrayBufferSliceImpl, kInlineArrayBufferNeuter, kInlineTypedArrayInitialize, kInlineTypedArrayInitializeFromArrayLike, kInlineArrayBufferViewGetByteLength, kInlineArrayBufferViewGetByteOffset, kInlineTypedArrayGetLength, kInlineDataViewGetBuffer, kInlineTypedArrayGetBuffer, kInlineTypedArraySetFastCases, kInlineTypedArrayMaxSizeInHeap, kInlineIsTypedArray, kInlineIsSharedTypedArray, kInlineIsSharedIntegerTypedArray, kInlineIsSharedInteger32TypedArray, kInlineDataViewGetUint8, kInlineDataViewGetInt8, kInlineDataViewGetUint16, kInlineDataViewGetInt16, kInlineDataViewGetUint32, kInlineDataViewGetInt32, kInlineDataViewGetFloat32, kInlineDataViewGetFloat64, kInlineDataViewSetUint8, kInlineDataViewSetInt8, kInlineDataViewSetUint16, kInlineDataViewSetInt16, kInlineDataViewSetUint32, kInlineDataViewSetInt32, kInlineDataViewSetFloat32, kInlineDataViewSetFloat64, kInlineURIEscape, kInlineURIUnescape,


    kNumFunctions,
  };

  enum IntrinsicType { RUNTIME, INLINE };


  struct Function {
    FunctionId function_id;
    IntrinsicType intrinsic_type;

    const char* name;



    Address entry;



    int8_t nargs;

    int8_t result_size;
  };

  static const int kNotFound = -1;



  static void InitializeIntrinsicFunctionNames(Isolate* isolate,
                                               Handle<NameDictionary> dict);


  static const Function* FunctionForName(Handle<String> name);


  static const Function* FunctionForId(FunctionId id);


  static const Function* FunctionForEntry(Address ref);


  static const Function* RuntimeFunctionTable(Isolate* isolate);

  __attribute__((warn_unused_result)) static Maybe<bool> DeleteObjectProperty(
      Isolate* isolate, Handle<JSReceiver> receiver, Handle<Object> key,
      LanguageMode language_mode);

  __attribute__((warn_unused_result)) static MaybeHandle<Object> SetObjectProperty(
      Isolate* isolate, Handle<Object> object, Handle<Object> key,
      Handle<Object> value, LanguageMode language_mode);

  __attribute__((warn_unused_result)) static MaybeHandle<Object> GetObjectProperty(
      Isolate* isolate, Handle<Object> object, Handle<Object> key);

  enum TypedArrayId {

    ARRAY_ID_UINT8 = 1,
    ARRAY_ID_INT8 = 2,
    ARRAY_ID_UINT16 = 3,
    ARRAY_ID_INT16 = 4,
    ARRAY_ID_UINT32 = 5,
    ARRAY_ID_INT32 = 6,
    ARRAY_ID_FLOAT32 = 7,
    ARRAY_ID_FLOAT64 = 8,
    ARRAY_ID_UINT8_CLAMPED = 9,
    ARRAY_ID_FIRST = ARRAY_ID_UINT8,
    ARRAY_ID_LAST = ARRAY_ID_UINT8_CLAMPED
  };

  static void ArrayIdToTypeAndSize(int array_id, ExternalArrayType* type,
                                   ElementsKind* fixed_elements_kind,
                                   size_t* element_size);


  __attribute__((warn_unused_result)) static MaybeHandle<Object> CreateArrayLiteralBoilerplate(
      Isolate* isolate, Handle<LiteralsArray> literals,
      Handle<FixedArray> elements);

  static MaybeHandle<JSArray> GetInternalProperties(Isolate* isolate,
                                                    Handle<Object>);
};


class RuntimeState {
 public:
  unibrow::Mapping<unibrow::ToUppercase, 128>* to_upper_mapping() {
    return &to_upper_mapping_;
  }
  unibrow::Mapping<unibrow::ToLowercase, 128>* to_lower_mapping() {
    return &to_lower_mapping_;
  }

  Runtime::Function* redirected_intrinsic_functions() {
    return redirected_intrinsic_functions_.get();
  }

  void set_redirected_intrinsic_functions(
      Runtime::Function* redirected_intrinsic_functions) {
    redirected_intrinsic_functions_.Reset(redirected_intrinsic_functions);
  }

 private:
  RuntimeState() {}
  unibrow::Mapping<unibrow::ToUppercase, 128> to_upper_mapping_;
  unibrow::Mapping<unibrow::ToLowercase, 128> to_lower_mapping_;


  base::SmartArrayPointer<Runtime::Function> redirected_intrinsic_functions_;

  friend class Isolate;
  friend class Runtime;

  RuntimeState(const RuntimeState&) = delete; void operator=(const RuntimeState&) = delete;
};


std::ostream& operator<<(std::ostream&, Runtime::FunctionId);




class AllocateDoubleAlignFlag : public BitField<bool, 0, 1> {};
class AllocateTargetSpace : public BitField<AllocationSpace, 1, 3> {};

class DeclareGlobalsEvalFlag : public BitField<bool, 0, 1> {};
class DeclareGlobalsNativeFlag : public BitField<bool, 1, 1> {};
static_assert(LANGUAGE_END == 3, "LANGUAGE_END == 3");
class DeclareGlobalsLanguageMode : public BitField<LanguageMode, 2, 2> {};

}
}


namespace v8 {

namespace base {
class RandomNumberGenerator;
}

namespace internal {

class BasicBlockProfiler;
class Bootstrapper;
class CallInterfaceDescriptorData;
class CodeGenerator;
class CodeRange;
class CodeStubDescriptor;
class CodeTracer;
class CompilationCache;
class CompilationStatistics;
class ContextSlotCache;
class Counters;
class CpuFeatures;
class CpuProfiler;
class DeoptimizerData;
class Deserializer;
class EmptyStatement;
class ExternalCallbackScope;
class ExternalReferenceTable;
class Factory;
class FunctionInfoListener;
class HandleScopeImplementer;
class HeapProfiler;
class HStatistics;
class HTracer;
class InlineRuntimeFunctionsTable;
class InnerPointerToCodeCache;
class Logger;
class MaterializedObjectStore;
class CodeAgingHelper;
class RegExpStack;
class SaveContext;
class StatsTable;
class StringTracker;
class StubCache;
class SweeperThread;
class ThreadManager;
class ThreadState;
class ThreadVisitor;
class UnicodeCache;
template <StateTag Tag> class VMState;




typedef void* ExternalReferenceRedirectorPointer();


class Debug;
class PromiseOnStack;
class Redirection;
class Simulator;

namespace interpreter {
class Interpreter;
}







typedef ZoneList<Handle<Object> > ZoneObjectList;
class ThreadId {
 public:

  ThreadId() { base::NoBarrier_Store(&id_, kInvalidId); }

  ThreadId& operator=(const ThreadId& other) {
    base::NoBarrier_Store(&id_, base::NoBarrier_Load(&other.id_));
    return *this;
  }


  static ThreadId Current() { return ThreadId(GetCurrentThreadId()); }


  static ThreadId Invalid() { return ThreadId(kInvalidId); }


  inline bool Equals(const ThreadId& other) const {
    return base::NoBarrier_Load(&id_) == base::NoBarrier_Load(&other.id_);
  }


  inline bool IsValid() const {
    return base::NoBarrier_Load(&id_) != kInvalidId;
  }



  int ToInteger() const { return static_cast<int>(base::NoBarrier_Load(&id_)); }



  static ThreadId FromInteger(int id) { return ThreadId(id); }

 private:
  static const int kInvalidId = -1;

  explicit ThreadId(int id) { base::NoBarrier_Store(&id_, id); }

  static int AllocateThreadId();

  static int GetCurrentThreadId();

  base::Atomic32 id_;

  static base::Atomic32 highest_thread_id_;

  friend class Isolate;
};







class ThreadLocalTop : public Embedded {
 public:


  ThreadLocalTop();


  void Initialize();






  inline void set_try_catch_handler(v8::TryCatch* v) { try_catch_handler_ = v; } inline v8::TryCatch* try_catch_handler() const { return try_catch_handler_; }
  Address try_catch_handler_address() {
    return reinterpret_cast<Address>(
        v8::TryCatch::JSStackComparableAddress(try_catch_handler()));
  }

  void Free();

  Isolate* isolate_;


  Context* context_;
  ThreadId thread_id_;
  Object* pending_exception_;


  Context* pending_handler_context_;
  Code* pending_handler_code_;
  intptr_t pending_handler_offset_;
  Address pending_handler_fp_;
  Address pending_handler_sp_;


  bool rethrowing_message_;
  Object* pending_message_obj_;




  Object* scheduled_exception_;
  bool external_caught_exception_;
  SaveContext* save_context_;


  Address c_entry_fp_;
  Address handler_;
  Address c_function_;




  PromiseOnStack* promise_on_stack_;





  Address js_entry_sp_;

  ExternalCallbackScope* external_callback_scope_;
  StateTag current_vm_state_;


  v8::FailedAccessCheckCallback failed_access_check_callback_;

 private:
  void InitializeInternal();

  v8::TryCatch* try_catch_handler_;
};
typedef List<HeapObject*> DebugObjectCache;
class Isolate {


  class ThreadDataTable;
  class EntryStackItem;
 public:
  ~Isolate();




  class PerIsolateThreadData {
   public:
    PerIsolateThreadData(Isolate* isolate, ThreadId thread_id)
        : isolate_(isolate),
          thread_id_(thread_id),
          stack_limit_(0),
          thread_state_(0),



          next_(0),
          prev_(0) { }
    ~PerIsolateThreadData();
    Isolate* isolate() const { return isolate_; }
    ThreadId thread_id() const { return thread_id_; }

    inline void set_stack_limit(uintptr_t v) { stack_limit_ = v; } inline uintptr_t stack_limit() const { return stack_limit_; }
    inline void set_thread_state(ThreadState* v) { thread_state_ = v; } inline ThreadState* thread_state() const { return thread_state_; }





    bool Matches(Isolate* isolate, ThreadId thread_id) const {
      return isolate_ == isolate && thread_id_.Equals(thread_id);
    }

   private:
    Isolate* isolate_;
    ThreadId thread_id_;
    uintptr_t stack_limit_;
    ThreadState* thread_state_;





    PerIsolateThreadData* next_;
    PerIsolateThreadData* prev_;

    friend class Isolate;
    friend class ThreadDataTable;
    friend class EntryStackItem;

    PerIsolateThreadData(const PerIsolateThreadData&) = delete; void operator=(const PerIsolateThreadData&) = delete;
  };


  enum AddressId {

    kHandlerAddress, kCEntryFPAddress, kCFunctionAddress, kContextAddress, kPendingExceptionAddress, kPendingHandlerContextAddress, kPendingHandlerCodeAddress, kPendingHandlerOffsetAddress, kPendingHandlerFPAddress, kPendingHandlerSPAddress, kExternalCaughtExceptionAddress, kJSEntrySPAddress,

    kIsolateAddressCount
  };

  static void InitializeOncePerProcess();



  static PerIsolateThreadData* CurrentPerIsolateThreadData() {
    return reinterpret_cast<PerIsolateThreadData*>(
        base::Thread::GetThreadLocal(per_isolate_thread_data_key_));
  }


  inline static Isolate* Current() {
    do { if ((!(base::NoBarrier_Load(&isolate_key_created_) == 1))) { V8_Fatal(".././src/isolate.h", 491, "Check failed: %s.", "base::NoBarrier_Load(&isolate_key_created_) == 1"); } } while (0);
    Isolate* isolate = reinterpret_cast<Isolate*>(
        base::Thread::GetExistingThreadLocal(isolate_key_));
    do { if ((!(isolate != 0))) { V8_Fatal(".././src/isolate.h", 494, "Check failed: %s.", "isolate != 0"); } } while (0);
    return isolate;
  }




  inline static Isolate* UnsafeCurrent() {
    return reinterpret_cast<Isolate*>(
        base::Thread::GetThreadLocal(isolate_key_));
  }






  void InitializeLoggingAndCounters();

  bool Init(Deserializer* des);


  bool IsInUse() { return entry_stack_ != 0; }




  void TearDown();

  static void GlobalTearDown();

  void ClearSerializerData();



  PerIsolateThreadData* FindPerThreadDataForThisThread();



  PerIsolateThreadData* FindPerThreadDataForThread(ThreadId thread_id);



  void DiscardPerThreadDataForThisThread();




  static base::Thread::LocalStorageKey isolate_key() {
    return isolate_key_;
  }


  static base::Thread::LocalStorageKey thread_id_key() {
    return thread_id_key_;
  }

  static base::Thread::LocalStorageKey per_isolate_thread_data_key();


  base::RecursiveMutex* break_access() { return &break_access_; }

  Address get_address_from_id(AddressId id);


  Context* context() { return thread_local_top_.context_; }
  inline void set_context(Context* context);
  Context** context_address() { return &thread_local_top_.context_; }

  inline void set_save_context(SaveContext* v) { thread_local_top_. save_context_ = v; } inline SaveContext* save_context() const { return thread_local_top_. save_context_; }


  inline void set_thread_id(ThreadId v) { thread_local_top_. thread_id_ = v; } inline ThreadId thread_id() const { return thread_local_top_. thread_id_; }


  inline Object* pending_exception();
  inline void set_pending_exception(Object* exception_obj);
  inline void clear_pending_exception();

  Object** pending_exception_address() { return &thread_local_top_. pending_exception_; }

  inline bool has_pending_exception();

  Context** pending_handler_context_address() { return &thread_local_top_. pending_handler_context_; }
  Code** pending_handler_code_address() { return &thread_local_top_. pending_handler_code_; }
  intptr_t* pending_handler_offset_address() { return &thread_local_top_. pending_handler_offset_; }
  Address* pending_handler_fp_address() { return &thread_local_top_. pending_handler_fp_; }
  Address* pending_handler_sp_address() { return &thread_local_top_. pending_handler_sp_; }

  inline void set_external_caught_exception(bool v) { thread_local_top_. external_caught_exception_ = v; } inline bool external_caught_exception() const { return thread_local_top_. external_caught_exception_; }

  v8::TryCatch* try_catch_handler() {
    return thread_local_top_.try_catch_handler();
  }
  bool* external_caught_exception_address() {
    return &thread_local_top_.external_caught_exception_;
  }

  Object** scheduled_exception_address() { return &thread_local_top_. scheduled_exception_; }

  inline void clear_pending_message();
  Address pending_message_obj_address() {
    return reinterpret_cast<Address>(&thread_local_top_.pending_message_obj_);
  }

  inline Object* scheduled_exception();
  inline bool has_scheduled_exception();
  inline void clear_scheduled_exception();

  bool IsJavaScriptHandlerOnTop(Object* exception);
  bool IsExternalHandlerOnTop(Object* exception);

  inline bool is_catchable_by_javascript(Object* exception);


  static Address c_entry_fp(ThreadLocalTop* thread) {
    return thread->c_entry_fp_;
  }
  static Address handler(ThreadLocalTop* thread) { return thread->handler_; }
  Address c_function() { return thread_local_top_.c_function_; }

  inline Address* c_entry_fp_address() {
    return &thread_local_top_.c_entry_fp_;
  }
  inline Address* handler_address() { return &thread_local_top_.handler_; }
  inline Address* c_function_address() {
    return &thread_local_top_.c_function_;
  }


  Address js_entry_sp() {
    return thread_local_top_.js_entry_sp_;
  }
  inline Address* js_entry_sp_address() {
    return &thread_local_top_.js_entry_sp_;
  }



  inline Handle<JSGlobalObject> global_object();


  JSObject* global_proxy() {
    return context()->global_proxy();
  }

  static int ArchiveSpacePerThread() { return sizeof(ThreadLocalTop); }
  void FreeThreadResources() { thread_local_top_.Free(); }





  bool OptionalRescheduleException(bool is_bottom_call);


  void PushPromise(Handle<JSObject> promise, Handle<JSFunction> function);
  void PopPromise();
  Handle<Object> GetPromiseOnStackOnThrow();

  class ExceptionScope {
   public:


    inline explicit ExceptionScope(Isolate* isolate);
    inline ~ExceptionScope();

   private:
    Isolate* isolate_;
    Handle<Object> pending_exception_;
  };

  void SetCaptureStackTraceForUncaughtExceptions(
      bool capture,
      int frame_limit,
      StackTrace::StackTraceOptions options);

  void SetAbortOnUncaughtExceptionCallback(
      v8::Isolate::AbortOnUncaughtExceptionCallback callback);

  enum PrintStackMode { kPrintStackConcise, kPrintStackVerbose };
  void PrintCurrentStackTrace(FILE* out);
  void PrintStack(StringStream* accumulator,
                  PrintStackMode mode = kPrintStackVerbose);
  void PrintStack(FILE* out, PrintStackMode mode = kPrintStackVerbose);
  Handle<String> StackTraceString();
  void PushStackTraceAndDie(unsigned int magic, void* ptr1, void* ptr2, unsigned int magic2);

  Handle<JSArray> CaptureCurrentStackTrace(
      int frame_limit,
      StackTrace::StackTraceOptions options);
  Handle<Object> CaptureSimpleStackTrace(Handle<JSReceiver> error_object,
                                         Handle<Object> caller);
  MaybeHandle<JSReceiver> CaptureAndSetDetailedStackTrace(
      Handle<JSReceiver> error_object);
  MaybeHandle<JSReceiver> CaptureAndSetSimpleStackTrace(
      Handle<JSReceiver> error_object, Handle<Object> caller);
  Handle<JSArray> GetDetailedStackTrace(Handle<JSObject> error_object);
  Handle<JSArray> GetDetailedFromSimpleStackTrace(
      Handle<JSObject> error_object);




  bool MayAccess(Handle<Context> accessing_context, Handle<JSObject> receiver);

  void SetFailedAccessCheckCallback(v8::FailedAccessCheckCallback callback);
  void ReportFailedAccessCheck(Handle<JSObject> receiver);



  Object* Throw(Object* exception, MessageLocation* location = 0);
  Object* ThrowIllegalOperation();

  template <typename T>
  __attribute__((warn_unused_result)) MaybeHandle<T> Throw(Handle<Object> exception,
                                       MessageLocation* location = 0) {
    Throw(*exception, location);
    return MaybeHandle<T>();
  }



  Object* ReThrow(Object* exception);



  Object* UnwindAndFindHandler();





  enum CatchType { NOT_CAUGHT, CAUGHT_BY_JAVASCRIPT, CAUGHT_BY_EXTERNAL };
  CatchType PredictExceptionCatcher();

  void ScheduleThrow(Object* exception);


  void RestorePendingMessageFromTryCatch(v8::TryCatch* handler);

  void CancelScheduledExceptionFromTryCatch(v8::TryCatch* handler);
  void ReportPendingMessages();

  MessageLocation GetMessageLocation();


  Object* PromoteScheduledException();



  bool ComputeLocation(MessageLocation* target);
  bool ComputeLocationFromException(MessageLocation* target,
                                    Handle<Object> exception);
  bool ComputeLocationFromStackTrace(MessageLocation* target,
                                     Handle<Object> exception);

  Handle<JSMessageObject> CreateMessage(Handle<Object> exception,
                                        MessageLocation* location);


  Object* StackOverflow();
  Object* TerminateExecution();
  void CancelTerminateExecution();

  void RequestInterrupt(InterruptCallback callback, void* data);
  void InvokeApiInterruptCallbacks();


  void Iterate(ObjectVisitor* v);
  void Iterate(ObjectVisitor* v, ThreadLocalTop* t);
  char* Iterate(ObjectVisitor* v, char* t);
  void IterateThread(ThreadVisitor* v, char* t);


  Handle<Context> native_context();



  Handle<Context> GetCallingNativeContext();

  void RegisterTryCatchHandler(v8::TryCatch* that);
  void UnregisterTryCatchHandler(v8::TryCatch* that);

  char* ArchiveThread(char* to);
  char* RestoreThread(char* from);

  static const char* const kStackOverflowMessage;

  static const int kUC16AlphabetSize = 256;
  static const int kBMMaxShift = 250;
  inline FatalErrorCallback exception_behavior() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->exception_behavior_)) - 16) == exception_behavior_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->exception_behavior_)) - 16) == exception_behavior_debug_offset_"); } } while (0); return exception_behavior_; } inline void set_exception_behavior(FatalErrorCallback value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->exception_behavior_)) - 16) == exception_behavior_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->exception_behavior_)) - 16) == exception_behavior_debug_offset_"); } } while (0); exception_behavior_ = value; } inline LogEventCallback event_logger() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->event_logger_)) - 16) == event_logger_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->event_logger_)) - 16) == event_logger_debug_offset_"); } } while (0); return event_logger_; } inline void set_event_logger(LogEventCallback value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->event_logger_)) - 16) == event_logger_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->event_logger_)) - 16) == event_logger_debug_offset_"); } } while (0); event_logger_ = value; } inline AllowCodeGenerationFromStringsCallback allow_code_gen_callback() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->allow_code_gen_callback_)) - 16) == allow_code_gen_callback_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->allow_code_gen_callback_)) - 16) == allow_code_gen_callback_debug_offset_"); } } while (0); return allow_code_gen_callback_; } inline void set_allow_code_gen_callback(AllowCodeGenerationFromStringsCallback value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->allow_code_gen_callback_)) - 16) == allow_code_gen_callback_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->allow_code_gen_callback_)) - 16) == allow_code_gen_callback_debug_offset_"); } } while (0); allow_code_gen_callback_ = value; } inline int next_serial_number() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->next_serial_number_)) - 16) == next_serial_number_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->next_serial_number_)) - 16) == next_serial_number_debug_offset_"); } } while (0); return next_serial_number_; } inline void set_next_serial_number(int value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->next_serial_number_)) - 16) == next_serial_number_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->next_serial_number_)) - 16) == next_serial_number_debug_offset_"); } } while (0); next_serial_number_ = value; } inline ExternalReferenceRedirectorPointer* external_reference_redirector() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_redirector_)) - 16) == external_reference_redirector_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_redirector_)) - 16) == external_reference_redirector_debug_offset_"); } } while (0); return external_reference_redirector_; } inline void set_external_reference_redirector(ExternalReferenceRedirectorPointer* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_redirector_)) - 16) == external_reference_redirector_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_redirector_)) - 16) == external_reference_redirector_debug_offset_"); } } while (0); external_reference_redirector_ = value; } inline FunctionInfoListener* active_function_info_listener() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->active_function_info_listener_)) - 16) == active_function_info_listener_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->active_function_info_listener_)) - 16) == active_function_info_listener_debug_offset_"); } } while (0); return active_function_info_listener_; } inline void set_active_function_info_listener(FunctionInfoListener* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->active_function_info_listener_)) - 16) == active_function_info_listener_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->active_function_info_listener_)) - 16) == active_function_info_listener_debug_offset_"); } } while (0); active_function_info_listener_ = value; } inline Relocatable* relocatable_top() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->relocatable_top_)) - 16) == relocatable_top_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->relocatable_top_)) - 16) == relocatable_top_debug_offset_"); } } while (0); return relocatable_top_; } inline void set_relocatable_top(Relocatable* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->relocatable_top_)) - 16) == relocatable_top_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->relocatable_top_)) - 16) == relocatable_top_debug_offset_"); } } while (0); relocatable_top_ = value; } inline DebugObjectCache* string_stream_debug_object_cache() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->string_stream_debug_object_cache_)) - 16) == string_stream_debug_object_cache_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->string_stream_debug_object_cache_)) - 16) == string_stream_debug_object_cache_debug_offset_"); } } while (0); return string_stream_debug_object_cache_; } inline void set_string_stream_debug_object_cache(DebugObjectCache* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->string_stream_debug_object_cache_)) - 16) == string_stream_debug_object_cache_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->string_stream_debug_object_cache_)) - 16) == string_stream_debug_object_cache_debug_offset_"); } } while (0); string_stream_debug_object_cache_ = value; } inline Object* string_stream_current_security_token() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->string_stream_current_security_token_)) - 16) == string_stream_current_security_token_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->string_stream_current_security_token_)) - 16) == string_stream_current_security_token_debug_offset_"); } } while (0); return string_stream_current_security_token_; } inline void set_string_stream_current_security_token(Object* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->string_stream_current_security_token_)) - 16) == string_stream_current_security_token_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->string_stream_current_security_token_)) - 16) == string_stream_current_security_token_debug_offset_"); } } while (0); string_stream_current_security_token_ = value; } inline ExternalReferenceTable* external_reference_table() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_table_)) - 16) == external_reference_table_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_table_)) - 16) == external_reference_table_debug_offset_"); } } while (0); return external_reference_table_; } inline void set_external_reference_table(ExternalReferenceTable* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_table_)) - 16) == external_reference_table_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_table_)) - 16) == external_reference_table_debug_offset_"); } } while (0); external_reference_table_ = value; } inline HashMap* external_reference_map() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_map_)) - 16) == external_reference_map_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_map_)) - 16) == external_reference_map_debug_offset_"); } } while (0); return external_reference_map_; } inline void set_external_reference_map(HashMap* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_map_)) - 16) == external_reference_map_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->external_reference_map_)) - 16) == external_reference_map_debug_offset_"); } } while (0); external_reference_map_ = value; } inline HashMap* root_index_map() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->root_index_map_)) - 16) == root_index_map_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->root_index_map_)) - 16) == root_index_map_debug_offset_"); } } while (0); return root_index_map_; } inline void set_root_index_map(HashMap* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->root_index_map_)) - 16) == root_index_map_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->root_index_map_)) - 16) == root_index_map_debug_offset_"); } } while (0); root_index_map_ = value; } inline int pending_microtask_count() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->pending_microtask_count_)) - 16) == pending_microtask_count_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->pending_microtask_count_)) - 16) == pending_microtask_count_debug_offset_"); } } while (0); return pending_microtask_count_; } inline void set_pending_microtask_count(int value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->pending_microtask_count_)) - 16) == pending_microtask_count_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->pending_microtask_count_)) - 16) == pending_microtask_count_debug_offset_"); } } while (0); pending_microtask_count_ = value; } inline HStatistics* hstatistics() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->hstatistics_)) - 16) == hstatistics_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->hstatistics_)) - 16) == hstatistics_debug_offset_"); } } while (0); return hstatistics_; } inline void set_hstatistics(HStatistics* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->hstatistics_)) - 16) == hstatistics_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->hstatistics_)) - 16) == hstatistics_debug_offset_"); } } while (0); hstatistics_ = value; } inline CompilationStatistics* turbo_statistics() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->turbo_statistics_)) - 16) == turbo_statistics_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->turbo_statistics_)) - 16) == turbo_statistics_debug_offset_"); } } while (0); return turbo_statistics_; } inline void set_turbo_statistics(CompilationStatistics* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->turbo_statistics_)) - 16) == turbo_statistics_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->turbo_statistics_)) - 16) == turbo_statistics_debug_offset_"); } } while (0); turbo_statistics_ = value; } inline HTracer* htracer() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->htracer_)) - 16) == htracer_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->htracer_)) - 16) == htracer_debug_offset_"); } } while (0); return htracer_; } inline void set_htracer(HTracer* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->htracer_)) - 16) == htracer_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->htracer_)) - 16) == htracer_debug_offset_"); } } while (0); htracer_ = value; } inline CodeTracer* code_tracer() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->code_tracer_)) - 16) == code_tracer_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->code_tracer_)) - 16) == code_tracer_debug_offset_"); } } while (0); return code_tracer_; } inline void set_code_tracer(CodeTracer* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->code_tracer_)) - 16) == code_tracer_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->code_tracer_)) - 16) == code_tracer_debug_offset_"); } } while (0); code_tracer_ = value; } inline bool fp_stubs_generated() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->fp_stubs_generated_)) - 16) == fp_stubs_generated_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->fp_stubs_generated_)) - 16) == fp_stubs_generated_debug_offset_"); } } while (0); return fp_stubs_generated_; } inline void set_fp_stubs_generated(bool value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->fp_stubs_generated_)) - 16) == fp_stubs_generated_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->fp_stubs_generated_)) - 16) == fp_stubs_generated_debug_offset_"); } } while (0); fp_stubs_generated_ = value; } inline uint32_t per_isolate_assert_data() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->per_isolate_assert_data_)) - 16) == per_isolate_assert_data_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->per_isolate_assert_data_)) - 16) == per_isolate_assert_data_debug_offset_"); } } while (0); return per_isolate_assert_data_; } inline void set_per_isolate_assert_data(uint32_t value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->per_isolate_assert_data_)) - 16) == per_isolate_assert_data_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->per_isolate_assert_data_)) - 16) == per_isolate_assert_data_debug_offset_"); } } while (0); per_isolate_assert_data_ = value; } inline PromiseRejectCallback promise_reject_callback() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->promise_reject_callback_)) - 16) == promise_reject_callback_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->promise_reject_callback_)) - 16) == promise_reject_callback_debug_offset_"); } } while (0); return promise_reject_callback_; } inline void set_promise_reject_callback(PromiseRejectCallback value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->promise_reject_callback_)) - 16) == promise_reject_callback_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->promise_reject_callback_)) - 16) == promise_reject_callback_debug_offset_"); } } while (0); promise_reject_callback_ = value; } inline const v8::StartupData* snapshot_blob() const { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->snapshot_blob_)) - 16) == snapshot_blob_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->snapshot_blob_)) - 16) == snapshot_blob_debug_offset_"); } } while (0); return snapshot_blob_; } inline void set_snapshot_blob(const v8::StartupData* value) { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->snapshot_blob_)) - 16) == snapshot_blob_debug_offset_))) { V8_Fatal(".././src/isolate.h", 796, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->snapshot_blob_)) - 16) == snapshot_blob_debug_offset_"); } } while (0); snapshot_blob_ = value; }







  inline int32_t* jsregexp_static_offsets_vector() { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->jsregexp_static_offsets_vector_)) - 16) == jsregexp_static_offsets_vector_debug_offset_))) { V8_Fatal(".././src/isolate.h", 804, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->jsregexp_static_offsets_vector_)) - 16) == jsregexp_static_offsets_vector_debug_offset_"); } } while (0); return &( jsregexp_static_offsets_vector_)[0]; } inline int* bad_char_shift_table() { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->bad_char_shift_table_)) - 16) == bad_char_shift_table_debug_offset_))) { V8_Fatal(".././src/isolate.h", 804, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->bad_char_shift_table_)) - 16) == bad_char_shift_table_debug_offset_"); } } while (0); return &( bad_char_shift_table_)[0]; } inline int* good_suffix_shift_table() { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->good_suffix_shift_table_)) - 16) == good_suffix_shift_table_debug_offset_))) { V8_Fatal(".././src/isolate.h", 804, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->good_suffix_shift_table_)) - 16) == good_suffix_shift_table_debug_offset_"); } } while (0); return &( good_suffix_shift_table_)[0]; } inline int* suffix_table() { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->suffix_table_)) - 16) == suffix_table_debug_offset_))) { V8_Fatal(".././src/isolate.h", 804, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->suffix_table_)) - 16) == suffix_table_debug_offset_"); } } while (0); return &( suffix_table_)[0]; } inline uint32_t* private_random_seed() { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->private_random_seed_)) - 16) == private_random_seed_debug_offset_))) { V8_Fatal(".././src/isolate.h", 804, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->private_random_seed_)) - 16) == private_random_seed_debug_offset_"); } } while (0); return &( private_random_seed_)[0]; } inline CommentStatistic* paged_space_comments_statistics() { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->paged_space_comments_statistics_)) - 16) == paged_space_comments_statistics_debug_offset_))) { V8_Fatal(".././src/isolate.h", 804, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->paged_space_comments_statistics_)) - 16) == paged_space_comments_statistics_debug_offset_"); } } while (0); return &( paged_space_comments_statistics_)[0]; } inline int* code_kind_statistics() { do { if ((!((reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->code_kind_statistics_)) - 16) == code_kind_statistics_debug_offset_))) { V8_Fatal(".././src/isolate.h", 804, "Check failed: %s.", "(reinterpret_cast<intptr_t>(&(reinterpret_cast<Isolate*>(16)->code_kind_statistics_)) - 16) == code_kind_statistics_debug_offset_"); } } while (0); return &( code_kind_statistics_)[0]; }





  inline Handle<JSObject> global_proxy_object(); inline bool is_global_proxy_object(JSObject* value); inline Handle<FixedArray> embedder_data(); inline bool is_embedder_data(FixedArray* value); inline Handle<Map> accessor_property_descriptor_map(); inline bool is_accessor_property_descriptor_map(Map* value); inline Handle<Object> allow_code_gen_from_strings(); inline bool is_allow_code_gen_from_strings(Object* value); inline Handle<JSFunction> array_buffer_fun(); inline bool is_array_buffer_fun(JSFunction* value); inline Handle<Map> array_buffer_map(); inline bool is_array_buffer_map(Map* value); inline Handle<JSFunction> array_function(); inline bool is_array_function(JSFunction* value); inline Handle<JSFunction> bool16x8_function(); inline bool is_bool16x8_function(JSFunction* value); inline Handle<JSFunction> bool32x4_function(); inline bool is_bool32x4_function(JSFunction* value); inline Handle<JSFunction> bool8x16_function(); inline bool is_bool8x16_function(JSFunction* value); inline Handle<JSFunction> boolean_function(); inline bool is_boolean_function(JSFunction* value); inline Handle<Map> bound_function_with_constructor_map(); inline bool is_bound_function_with_constructor_map(Map* value); inline Handle<Map> bound_function_without_constructor_map(); inline bool is_bound_function_without_constructor_map(Map* value); inline Handle<JSFunction> call_as_constructor_delegate(); inline bool is_call_as_constructor_delegate(JSFunction* value); inline Handle<JSFunction> call_as_function_delegate(); inline bool is_call_as_function_delegate(JSFunction* value); inline Handle<JSFunction> context_extension_function(); inline bool is_context_extension_function(JSFunction* value); inline Handle<Map> data_property_descriptor_map(); inline bool is_data_property_descriptor_map(Map* value); inline Handle<JSFunction> data_view_fun(); inline bool is_data_view_fun(JSFunction* value); inline Handle<JSFunction> date_function(); inline bool is_date_function(JSFunction* value); inline Handle<Object> error_message_for_code_gen_from_strings(); inline bool is_error_message_for_code_gen_from_strings(Object* value); inline Handle<Smi> errors_thrown(); inline bool is_errors_thrown(Smi* value); inline Handle<JSObject> extras_binding_object(); inline bool is_extras_binding_object(JSObject* value); inline Handle<JSObject> extras_utils_object(); inline bool is_extras_utils_object(JSObject* value); inline Handle<Map> fast_aliased_arguments_map(); inline bool is_fast_aliased_arguments_map(Map* value); inline Handle<JSFunction> float32_array_fun(); inline bool is_float32_array_fun(JSFunction* value); inline Handle<JSFunction> float32x4_function(); inline bool is_float32x4_function(JSFunction* value); inline Handle<JSFunction> float64_array_fun(); inline bool is_float64_array_fun(JSFunction* value); inline Handle<UnseededNumberDictionary> template_instantiations_cache(); inline bool is_template_instantiations_cache(UnseededNumberDictionary* value); inline Handle<JSFunction> function_function(); inline bool is_function_function(JSFunction* value); inline Handle<JSFunction> generator_function_function(); inline bool is_generator_function_function(JSFunction* value); inline Handle<Map> generator_object_prototype_map(); inline bool is_generator_object_prototype_map(Map* value); inline Handle<JSObject> initial_array_prototype(); inline bool is_initial_array_prototype(JSObject* value); inline Handle<JSObject> initial_object_prototype(); inline bool is_initial_object_prototype(JSObject* value); inline Handle<JSFunction> int16_array_fun(); inline bool is_int16_array_fun(JSFunction* value); inline Handle<JSFunction> int16x8_function(); inline bool is_int16x8_function(JSFunction* value); inline Handle<JSFunction> int32_array_fun(); inline bool is_int32_array_fun(JSFunction* value); inline Handle<JSFunction> int32x4_function(); inline bool is_int32x4_function(JSFunction* value); inline Handle<JSFunction> int8_array_fun(); inline bool is_int8_array_fun(JSFunction* value); inline Handle<JSFunction> int8x16_function(); inline bool is_int8x16_function(JSFunction* value); inline Handle<JSFunction> internal_array_function(); inline bool is_internal_array_function(JSFunction* value); inline Handle<Map> iterator_result_map(); inline bool is_iterator_result_map(Map* value); inline Handle<Map> js_array_fast_smi_elements_map_index(); inline bool is_js_array_fast_smi_elements_map_index(Map* value); inline Handle<Map> js_array_fast_holey_smi_elements_map_index(); inline bool is_js_array_fast_holey_smi_elements_map_index(Map* value); inline Handle<Map> js_array_fast_elements_map_index(); inline bool is_js_array_fast_elements_map_index(Map* value); inline Handle<Map> js_array_fast_holey_elements_map_index(); inline bool is_js_array_fast_holey_elements_map_index(Map* value); inline Handle<Map> js_array_fast_double_elements_map_index(); inline bool is_js_array_fast_double_elements_map_index(Map* value); inline Handle<Map> js_array_fast_holey_double_elements_map_index(); inline bool is_js_array_fast_holey_double_elements_map_index(Map* value); inline Handle<JSFunction> js_map_fun(); inline bool is_js_map_fun(JSFunction* value); inline Handle<Map> js_map_map(); inline bool is_js_map_map(Map* value); inline Handle<JSFunction> js_set_fun(); inline bool is_js_set_fun(JSFunction* value); inline Handle<Map> js_set_map(); inline bool is_js_set_map(Map* value); inline Handle<JSFunction> js_weak_map_fun(); inline bool is_js_weak_map_fun(JSFunction* value); inline Handle<JSFunction> js_weak_set_fun(); inline bool is_js_weak_set_fun(JSFunction* value); inline Handle<Object> map_cache(); inline bool is_map_cache(Object* value); inline Handle<Map> map_iterator_map(); inline bool is_map_iterator_map(Map* value); inline Handle<Map> string_iterator_map(); inline bool is_string_iterator_map(Map* value); inline Handle<JSObject> message_listeners(); inline bool is_message_listeners(JSObject* value); inline Handle<Object> natives_utils_object(); inline bool is_natives_utils_object(Object* value); inline Handle<Object> normalized_map_cache(); inline bool is_normalized_map_cache(Object* value); inline Handle<JSFunction> number_function(); inline bool is_number_function(JSFunction* value); inline Handle<JSFunction> object_function(); inline bool is_object_function(JSFunction* value); inline Handle<Map> object_function_prototype_map(); inline bool is_object_function_prototype_map(Map* value); inline Handle<JSFunction> opaque_reference_function(); inline bool is_opaque_reference_function(JSFunction* value); inline Handle<Map> proxy_callable_map(); inline bool is_proxy_callable_map(Map* value); inline Handle<Map> proxy_constructor_map(); inline bool is_proxy_constructor_map(Map* value); inline Handle<JSFunction> proxy_function(); inline bool is_proxy_function(JSFunction* value); inline Handle<Map> proxy_function_map(); inline bool is_proxy_function_map(Map* value); inline Handle<Map> proxy_map(); inline bool is_proxy_map(Map* value); inline Handle<JSFunction> regexp_function(); inline bool is_regexp_function(JSFunction* value); inline Handle<Map> regexp_result_map(); inline bool is_regexp_result_map(Map* value); inline Handle<ScriptContextTable> script_context_table(); inline bool is_script_context_table(ScriptContextTable* value); inline Handle<JSFunction> script_function(); inline bool is_script_function(JSFunction* value); inline Handle<Object> security_token(); inline bool is_security_token(Object* value); inline Handle<WeakCell> self_weak_cell(); inline bool is_self_weak_cell(WeakCell* value); inline Handle<Map> set_iterator_map(); inline bool is_set_iterator_map(Map* value); inline Handle<JSFunction> shared_array_buffer_fun(); inline bool is_shared_array_buffer_fun(JSFunction* value); inline Handle<Map> sloppy_arguments_map(); inline bool is_sloppy_arguments_map(Map* value); inline Handle<Map> sloppy_function_map(); inline bool is_sloppy_function_map(Map* value); inline Handle<Map> sloppy_function_without_prototype_map(); inline bool is_sloppy_function_without_prototype_map(Map* value); inline Handle<Map> sloppy_function_with_readonly_prototype_map(); inline bool is_sloppy_function_with_readonly_prototype_map(Map* value); inline Handle<Map> wasm_function_map(); inline bool is_wasm_function_map(Map* value); inline Handle<Map> sloppy_generator_function_map(); inline bool is_sloppy_generator_function_map(Map* value); inline Handle<Map> slow_aliased_arguments_map(); inline bool is_slow_aliased_arguments_map(Map* value); inline Handle<Map> strict_arguments_map(); inline bool is_strict_arguments_map(Map* value); inline Handle<Map> strict_function_map(); inline bool is_strict_function_map(Map* value); inline Handle<Map> strict_function_without_prototype_map(); inline bool is_strict_function_without_prototype_map(Map* value); inline Handle<Map> strict_generator_function_map(); inline bool is_strict_generator_function_map(Map* value); inline Handle<JSFunction> string_function(); inline bool is_string_function(JSFunction* value); inline Handle<Map> string_function_prototype_map(); inline bool is_string_function_prototype_map(Map* value); inline Handle<JSFunction> symbol_function(); inline bool is_symbol_function(JSFunction* value); inline Handle<JSFunction> uint16_array_fun(); inline bool is_uint16_array_fun(JSFunction* value); inline Handle<JSFunction> uint16x8_function(); inline bool is_uint16x8_function(JSFunction* value); inline Handle<JSFunction> uint32_array_fun(); inline bool is_uint32_array_fun(JSFunction* value); inline Handle<JSFunction> uint32x4_function(); inline bool is_uint32x4_function(JSFunction* value); inline Handle<JSFunction> uint8_array_fun(); inline bool is_uint8_array_fun(JSFunction* value); inline Handle<JSFunction> uint8_clamped_array_fun(); inline bool is_uint8_clamped_array_fun(JSFunction* value); inline Handle<JSFunction> uint8x16_function(); inline bool is_uint8x16_function(JSFunction* value); inline Handle<JSFunction> is_arraylike(); inline bool is_is_arraylike(JSFunction* value); inline Handle<JSFunction> get_template_call_site(); inline bool is_get_template_call_site(JSFunction* value); inline Handle<JSFunction> make_range_error(); inline bool is_make_range_error(JSFunction* value); inline Handle<JSFunction> make_type_error(); inline bool is_make_type_error(JSFunction* value); inline Handle<JSFunction> object_freeze(); inline bool is_object_freeze(JSFunction* value); inline Handle<JSFunction> object_is_extensible(); inline bool is_object_is_extensible(JSFunction* value); inline Handle<JSFunction> object_is_frozen(); inline bool is_object_is_frozen(JSFunction* value); inline Handle<JSFunction> object_is_sealed(); inline bool is_object_is_sealed(JSFunction* value); inline Handle<JSFunction> object_keys(); inline bool is_object_keys(JSFunction* value); inline Handle<JSFunction> reflect_apply(); inline bool is_reflect_apply(JSFunction* value); inline Handle<JSFunction> reflect_construct(); inline bool is_reflect_construct(JSFunction* value); inline Handle<JSFunction> reflect_define_property(); inline bool is_reflect_define_property(JSFunction* value); inline Handle<JSFunction> reflect_delete_property(); inline bool is_reflect_delete_property(JSFunction* value); inline Handle<JSFunction> spread_arguments(); inline bool is_spread_arguments(JSFunction* value); inline Handle<JSFunction> spread_iterable(); inline bool is_spread_iterable(JSFunction* value); inline Handle<JSFunction> ordinary_has_instance(); inline bool is_ordinary_has_instance(JSFunction* value); inline Handle<JSFunction> math_floor(); inline bool is_math_floor(JSFunction* value); inline Handle<JSFunction> math_sqrt(); inline bool is_math_sqrt(JSFunction* value); inline Handle<JSFunction> array_concat(); inline bool is_array_concat(JSFunction* value); inline Handle<JSFunction> array_pop(); inline bool is_array_pop(JSFunction* value); inline Handle<JSFunction> array_push(); inline bool is_array_push(JSFunction* value); inline Handle<JSFunction> array_shift(); inline bool is_array_shift(JSFunction* value); inline Handle<JSFunction> array_splice(); inline bool is_array_splice(JSFunction* value); inline Handle<JSFunction> array_slice(); inline bool is_array_slice(JSFunction* value); inline Handle<JSFunction> array_unshift(); inline bool is_array_unshift(JSFunction* value); inline Handle<JSFunction> array_values_iterator(); inline bool is_array_values_iterator(JSFunction* value); inline Handle<JSFunction> derived_get_trap(); inline bool is_derived_get_trap(JSFunction* value); inline Handle<JSFunction> error_function(); inline bool is_error_function(JSFunction* value); inline Handle<JSFunction> eval_error_function(); inline bool is_eval_error_function(JSFunction* value); inline Handle<JSFunction> get_stack_trace_line_fun(); inline bool is_get_stack_trace_line_fun(JSFunction* value); inline Handle<JSFunction> global_eval_fun(); inline bool is_global_eval_fun(JSFunction* value); inline Handle<JSFunction> json_serialize_adapter(); inline bool is_json_serialize_adapter(JSFunction* value); inline Handle<JSFunction> make_error_function(); inline bool is_make_error_function(JSFunction* value); inline Handle<JSFunction> map_delete(); inline bool is_map_delete(JSFunction* value); inline Handle<JSFunction> map_get(); inline bool is_map_get(JSFunction* value); inline Handle<JSFunction> map_has(); inline bool is_map_has(JSFunction* value); inline Handle<JSFunction> map_set(); inline bool is_map_set(JSFunction* value); inline Handle<JSFunction> math_pow(); inline bool is_math_pow(JSFunction* value); inline Handle<JSFunction> message_get_column_number(); inline bool is_message_get_column_number(JSFunction* value); inline Handle<JSFunction> message_get_line_number(); inline bool is_message_get_line_number(JSFunction* value); inline Handle<JSFunction> message_get_source_line(); inline bool is_message_get_source_line(JSFunction* value); inline Handle<JSFunction> native_object_get_notifier(); inline bool is_native_object_get_notifier(JSFunction* value); inline Handle<JSFunction> native_object_notifier_perform_change(); inline bool is_native_object_notifier_perform_change(JSFunction* value); inline Handle<JSFunction> native_object_observe(); inline bool is_native_object_observe(JSFunction* value); inline Handle<JSFunction> no_side_effects_to_string_fun(); inline bool is_no_side_effects_to_string_fun(JSFunction* value); inline Handle<JSFunction> object_value_of(); inline bool is_object_value_of(JSFunction* value); inline Handle<JSFunction> object_to_string(); inline bool is_object_to_string(JSFunction* value); inline Handle<JSFunction> observers_begin_perform_splice(); inline bool is_observers_begin_perform_splice(JSFunction* value); inline Handle<JSFunction> observers_end_perform_splice(); inline bool is_observers_end_perform_splice(JSFunction* value); inline Handle<JSFunction> observers_enqueue_splice(); inline bool is_observers_enqueue_splice(JSFunction* value); inline Handle<JSFunction> observers_notify_change(); inline bool is_observers_notify_change(JSFunction* value); inline Handle<JSFunction> promise_catch(); inline bool is_promise_catch(JSFunction* value); inline Handle<JSFunction> promise_chain(); inline bool is_promise_chain(JSFunction* value); inline Handle<JSFunction> promise_create(); inline bool is_promise_create(JSFunction* value); inline Handle<JSFunction> promise_function(); inline bool is_promise_function(JSFunction* value); inline Handle<JSFunction> promise_has_user_defined_reject_handler(); inline bool is_promise_has_user_defined_reject_handler(JSFunction* value); inline Handle<JSFunction> promise_reject(); inline bool is_promise_reject(JSFunction* value); inline Handle<JSFunction> promise_resolve(); inline bool is_promise_resolve(JSFunction* value); inline Handle<JSFunction> promise_then(); inline bool is_promise_then(JSFunction* value); inline Handle<JSFunction> range_error_function(); inline bool is_range_error_function(JSFunction* value); inline Handle<JSFunction> reference_error_function(); inline bool is_reference_error_function(JSFunction* value); inline Handle<JSFunction> set_add(); inline bool is_set_add(JSFunction* value); inline Handle<JSFunction> set_delete(); inline bool is_set_delete(JSFunction* value); inline Handle<JSFunction> set_has(); inline bool is_set_has(JSFunction* value); inline Handle<JSObject> stack_overflow_boilerplate(); inline bool is_stack_overflow_boilerplate(JSObject* value); inline Handle<JSFunction> syntax_error_function(); inline bool is_syntax_error_function(JSFunction* value); inline Handle<JSFunction> type_error_function(); inline bool is_type_error_function(JSFunction* value); inline Handle<JSFunction> uri_error_function(); inline bool is_uri_error_function(JSFunction* value);


  Bootstrapper* bootstrapper() { return bootstrapper_; }
  Counters* counters() {


    do { if ((!(counters_ != 0))) { V8_Fatal(".././src/isolate.h", 817, "Check failed: %s.", "counters_ != 0"); } } while (0);
    return counters_;
  }
  CodeRange* code_range() { return code_range_; }
  RuntimeProfiler* runtime_profiler() { return runtime_profiler_; }
  CompilationCache* compilation_cache() { return compilation_cache_; }
  Logger* logger() {


    do { if ((!(logger_ != 0))) { V8_Fatal(".././src/isolate.h", 826, "Check failed: %s.", "logger_ != 0"); } } while (0);
    return logger_;
  }
  StackGuard* stack_guard() { return &stack_guard_; }
  Heap* heap() { return &heap_; }
  StatsTable* stats_table();
  StubCache* stub_cache() { return stub_cache_; }
  CodeAgingHelper* code_aging_helper() { return code_aging_helper_; }
  DeoptimizerData* deoptimizer_data() { return deoptimizer_data_; }
  bool deoptimizer_lazy_throw() const { return deoptimizer_lazy_throw_; }
  void set_deoptimizer_lazy_throw(bool value) {
    deoptimizer_lazy_throw_ = value;
  }
  ThreadLocalTop* thread_local_top() { return &thread_local_top_; }
  MaterializedObjectStore* materialized_object_store() {
    return materialized_object_store_;
  }

  MemoryAllocator* memory_allocator() {
    return memory_allocator_;
  }

  KeyedLookupCache* keyed_lookup_cache() {
    return keyed_lookup_cache_;
  }

  ContextSlotCache* context_slot_cache() {
    return context_slot_cache_;
  }

  DescriptorLookupCache* descriptor_lookup_cache() {
    return descriptor_lookup_cache_;
  }

  HandleScopeData* handle_scope_data() { return &handle_scope_data_; }

  HandleScopeImplementer* handle_scope_implementer() {
    do { if ((!(handle_scope_implementer_))) { V8_Fatal(".././src/isolate.h", 863, "Check failed: %s.", "handle_scope_implementer_"); } } while (0);
    return handle_scope_implementer_;
  }
  Zone* runtime_zone() { return &runtime_zone_; }
  Zone* interface_descriptor_zone() { return &interface_descriptor_zone_; }

  UnicodeCache* unicode_cache() {
    return unicode_cache_;
  }

  InnerPointerToCodeCache* inner_pointer_to_code_cache() {
    return inner_pointer_to_code_cache_;
  }

  GlobalHandles* global_handles() { return global_handles_; }

  EternalHandles* eternal_handles() { return eternal_handles_; }

  ThreadManager* thread_manager() { return thread_manager_; }

  unibrow::Mapping<unibrow::Ecma262UnCanonicalize>* jsregexp_uncanonicalize() {
    return &jsregexp_uncanonicalize_;
  }

  unibrow::Mapping<unibrow::CanonicalizationRange>* jsregexp_canonrange() {
    return &jsregexp_canonrange_;
  }

  RuntimeState* runtime_state() { return &runtime_state_; }

  Builtins* builtins() { return &builtins_; }

  void NotifyExtensionInstalled() {
    has_installed_extensions_ = true;
  }

  bool has_installed_extensions() { return has_installed_extensions_; }

  unibrow::Mapping<unibrow::Ecma262Canonicalize>*
      regexp_macro_assembler_canonicalize() {
    return &regexp_macro_assembler_canonicalize_;
  }

  RegExpStack* regexp_stack() { return regexp_stack_; }

  unibrow::Mapping<unibrow::Ecma262Canonicalize>*
      interp_canonicalize_mapping() {
    return &regexp_macro_assembler_canonicalize_;
  }

  Debug* debug() { return debug_; }

  CpuProfiler* cpu_profiler() const { return cpu_profiler_; }
  HeapProfiler* heap_profiler() const { return heap_profiler_; }


  HistogramInfo* heap_histograms() { return heap_histograms_; }

  JSObject::SpillInformation* js_spill_information() {
    return &js_spill_information_;
  }


  Factory* factory() { return reinterpret_cast<Factory*>(this); }

  static const int kJSRegexpStaticOffsetsVectorSize = 128;

  inline void set_external_callback_scope(ExternalCallbackScope* v) { thread_local_top_. external_callback_scope_ = v; } inline ExternalCallbackScope* external_callback_scope() const { return thread_local_top_. external_callback_scope_; }

  inline void set_current_vm_state(StateTag v) { thread_local_top_. current_vm_state_ = v; } inline StateTag current_vm_state() const { return thread_local_top_. current_vm_state_; }

  void SetData(uint32_t slot, void* data) {
    do { if ((!(slot < Internals::kNumIsolateDataSlots))) { V8_Fatal(".././src/isolate.h", 935, "Check failed: %s.", "slot < Internals::kNumIsolateDataSlots"); } } while (0);
    embedder_data_[slot] = data;
  }
  void* GetData(uint32_t slot) {
    do { if ((!(slot < Internals::kNumIsolateDataSlots))) { V8_Fatal(".././src/isolate.h", 939, "Check failed: %s.", "slot < Internals::kNumIsolateDataSlots"); } } while (0);
    return embedder_data_[slot];
  }

  bool serializer_enabled() const { return serializer_enabled_; }
  bool snapshot_available() const {
    return snapshot_blob_ != 0 && snapshot_blob_->raw_size != 0;
  }

  bool IsDead() { return has_fatal_error_; }
  void SignalFatalError() { has_fatal_error_ = true; }

  bool use_crankshaft() const;

  bool initialized_from_snapshot() { return initialized_from_snapshot_; }

  double time_millis_since_init() {
    return heap_.MonotonicallyIncreasingTimeInMs() - time_millis_at_init_;
  }

  DateCache* date_cache() {
    return date_cache_;
  }

  void set_date_cache(DateCache* date_cache) {
    if (date_cache != date_cache_) {
      delete date_cache_;
    }
    date_cache_ = date_cache;
  }

  Map* get_initial_js_array_map(ElementsKind kind);

  static const int kArrayProtectorValid = 1;
  static const int kArrayProtectorInvalid = 0;

  bool IsFastArrayConstructorPrototypeChainIntact();
  bool IsArraySpeciesLookupChainIntact();





  void UpdateArrayProtectorOnSetElement(Handle<JSObject> object);
  void UpdateArrayProtectorOnSetLength(Handle<JSObject> object) {
    UpdateArrayProtectorOnSetElement(object);
  }
  void UpdateArrayProtectorOnSetPrototype(Handle<JSObject> object) {
    UpdateArrayProtectorOnSetElement(object);
  }
  void UpdateArrayProtectorOnNormalizeElements(Handle<JSObject> object) {
    UpdateArrayProtectorOnSetElement(object);
  }
  void InvalidateArraySpeciesProtector();


  bool IsAnyInitialArrayPrototype(Handle<JSArray> array);

  CallInterfaceDescriptorData* call_descriptor_data(int index);

  void IterateDeferredHandles(ObjectVisitor* visitor);
  void LinkDeferredHandles(DeferredHandles* deferred_handles);
  void UnlinkDeferredHandles(DeferredHandles* deferred_handles);


  bool IsDeferredHandle(Object** location);


  bool concurrent_recompilation_enabled() {

    do { if ((!(optimizing_compile_dispatcher_ == 0 || FLAG_concurrent_recompilation))) { V8_Fatal(".././src/isolate.h", 1010, "Check failed: %s.", "optimizing_compile_dispatcher_ == 0 || FLAG_concurrent_recompilation"); } } while (0);

    return optimizing_compile_dispatcher_ != 0;
  }

  OptimizingCompileDispatcher* optimizing_compile_dispatcher() {
    return optimizing_compile_dispatcher_;
  }

  int id() const { return static_cast<int>(id_); }

  HStatistics* GetHStatistics();
  CompilationStatistics* GetTurboStatistics();
  HTracer* GetHTracer();
  CodeTracer* GetCodeTracer();

  void DumpAndResetCompilationStats();

  FunctionEntryHook function_entry_hook() { return function_entry_hook_; }
  void set_function_entry_hook(FunctionEntryHook function_entry_hook) {
    function_entry_hook_ = function_entry_hook;
  }

  void* stress_deopt_count_address() { return &stress_deopt_count_; }

  void* virtual_handler_register_address() {
    return &virtual_handler_register_;
  }

  void* virtual_slot_register_address() { return &virtual_slot_register_; }

  base::RandomNumberGenerator* random_number_generator();


  Object* FindCodeObject(Address a);

  int NextOptimizationId() {
    int id = next_optimization_id_++;
    if (!Smi::IsValid(next_optimization_id_)) {
      next_optimization_id_ = 0;
    }
    return id;
  }

  void IncrementJsCallsFromApiCounter() { ++js_calls_from_api_counter_; }

  unsigned int js_calls_from_api_counter() {
    return js_calls_from_api_counter_;
  }


  Handle<JSObject> GetSymbolRegistry();

  void AddCallCompletedCallback(CallCompletedCallback callback);
  void RemoveCallCompletedCallback(CallCompletedCallback callback);
  void FireCallCompletedCallback();

  void AddBeforeCallEnteredCallback(BeforeCallEnteredCallback callback);
  void RemoveBeforeCallEnteredCallback(BeforeCallEnteredCallback callback);
  void FireBeforeCallEnteredCallback();

  void AddMicrotasksCompletedCallback(MicrotasksCompletedCallback callback);
  void RemoveMicrotasksCompletedCallback(MicrotasksCompletedCallback callback);
  void FireMicrotasksCompletedCallback();

  void SetPromiseRejectCallback(PromiseRejectCallback callback);
  void ReportPromiseReject(Handle<JSObject> promise, Handle<Object> value,
                           v8::PromiseRejectEvent event);

  void EnqueueMicrotask(Handle<Object> microtask);
  void RunMicrotasks();

  void SetUseCounterCallback(v8::Isolate::UseCounterCallback callback);
  void CountUsage(v8::Isolate::UseCounterFeature feature);

  BasicBlockProfiler* GetOrCreateBasicBlockProfiler();
  BasicBlockProfiler* basic_block_profiler() { return basic_block_profiler_; }

  std::string GetTurboCfgFileName();


  int GetNextUniqueSharedFunctionInfoId() { return next_unique_sfi_id_++; }



  Address is_tail_call_elimination_enabled_address() {
    return reinterpret_cast<Address>(&is_tail_call_elimination_enabled_);
  }
  bool is_tail_call_elimination_enabled() const {
    return is_tail_call_elimination_enabled_;
  }
  void SetTailCallEliminationEnabled(bool enabled);

  void AddDetachedContext(Handle<Context> context);
  void CheckDetachedContextsAfterGC();

  List<Object*>* partial_snapshot_cache() { return &partial_snapshot_cache_; }

  void set_array_buffer_allocator(v8::ArrayBuffer::Allocator* allocator) {
    array_buffer_allocator_ = allocator;
  }
  v8::ArrayBuffer::Allocator* array_buffer_allocator() const {
    return array_buffer_allocator_;
  }

  FutexWaitListNode* futex_wait_list_node() { return &futex_wait_list_node_; }

  CancelableTaskManager* cancelable_task_manager() {
    return cancelable_task_manager_;
  }

  interpreter::Interpreter* interpreter() const { return interpreter_; }

  base::AccountingAllocator* allocator() { return &allocator_; }

 protected:
  explicit Isolate(bool enable_serializer);

 private:
  friend struct GlobalState;
  friend struct InitializeGlobalState;
  Handle<JSObject> SetUpSubregistry(Handle<JSObject> registry, Handle<Map> map,
                                    const char* name);




  void* embedder_data_[Internals::kNumIsolateDataSlots];
  Heap heap_;



  class ThreadDataTable {
   public:
    ThreadDataTable();
    ~ThreadDataTable();

    PerIsolateThreadData* Lookup(Isolate* isolate, ThreadId thread_id);
    void Insert(PerIsolateThreadData* data);
    void Remove(PerIsolateThreadData* data);
    void RemoveAllThreads(Isolate* isolate);

   private:
    PerIsolateThreadData* list_;
  };







  class EntryStackItem {
   public:
    EntryStackItem(PerIsolateThreadData* previous_thread_data,
                   Isolate* previous_isolate,
                   EntryStackItem* previous_item)
        : entry_count(1),
          previous_thread_data(previous_thread_data),
          previous_isolate(previous_isolate),
          previous_item(previous_item) { }

    int entry_count;
    PerIsolateThreadData* previous_thread_data;
    Isolate* previous_isolate;
    EntryStackItem* previous_item;

   private:
    EntryStackItem(const EntryStackItem&) = delete; void operator=(const EntryStackItem&) = delete;
  };

  static base::LazyMutex thread_data_table_mutex_;

  static base::Thread::LocalStorageKey per_isolate_thread_data_key_;
  static base::Thread::LocalStorageKey isolate_key_;
  static base::Thread::LocalStorageKey thread_id_key_;
  static ThreadDataTable* thread_data_table_;


  static base::Atomic32 isolate_counter_;


  static base::Atomic32 isolate_key_created_;


  void Deinit();

  static void SetIsolateThreadLocals(Isolate* isolate,
                                     PerIsolateThreadData* data);



  PerIsolateThreadData* FindOrAllocatePerThreadDataForThisThread();




  void Enter();





  void Exit();

  void InitializeThreadLocal();

  void MarkCompactPrologue(bool is_compacting,
                           ThreadLocalTop* archived_thread_data);
  void MarkCompactEpilogue(bool is_compacting,
                           ThreadLocalTop* archived_thread_data);

  void FillCache();




  bool PropagatePendingExceptionToExternalTryCatch();



  void RemoveMaterializedObjectsOnUnwind(StackFrame* frame);

  void RunMicrotasksInternal();

  base::Atomic32 id_;
  EntryStackItem* entry_stack_;
  int stack_trace_nesting_level_;
  StringStream* incomplete_message_;
  Address isolate_addresses_[kIsolateAddressCount + 1];
  Bootstrapper* bootstrapper_;
  RuntimeProfiler* runtime_profiler_;
  CompilationCache* compilation_cache_;
  Counters* counters_;
  CodeRange* code_range_;
  base::RecursiveMutex break_access_;
  Logger* logger_;
  StackGuard stack_guard_;
  StatsTable* stats_table_;
  StubCache* stub_cache_;
  CodeAgingHelper* code_aging_helper_;
  DeoptimizerData* deoptimizer_data_;
  bool deoptimizer_lazy_throw_;
  MaterializedObjectStore* materialized_object_store_;
  ThreadLocalTop thread_local_top_;
  bool capture_stack_trace_for_uncaught_exceptions_;
  int stack_trace_for_uncaught_exceptions_frame_limit_;
  StackTrace::StackTraceOptions stack_trace_for_uncaught_exceptions_options_;
  MemoryAllocator* memory_allocator_;
  KeyedLookupCache* keyed_lookup_cache_;
  ContextSlotCache* context_slot_cache_;
  DescriptorLookupCache* descriptor_lookup_cache_;
  HandleScopeData handle_scope_data_;
  HandleScopeImplementer* handle_scope_implementer_;
  UnicodeCache* unicode_cache_;
  base::AccountingAllocator allocator_;
  Zone runtime_zone_;
  Zone interface_descriptor_zone_;
  InnerPointerToCodeCache* inner_pointer_to_code_cache_;
  GlobalHandles* global_handles_;
  EternalHandles* eternal_handles_;
  ThreadManager* thread_manager_;
  RuntimeState runtime_state_;
  Builtins builtins_;
  bool has_installed_extensions_;
  unibrow::Mapping<unibrow::Ecma262UnCanonicalize> jsregexp_uncanonicalize_;
  unibrow::Mapping<unibrow::CanonicalizationRange> jsregexp_canonrange_;
  unibrow::Mapping<unibrow::Ecma262Canonicalize>
      regexp_macro_assembler_canonicalize_;
  RegExpStack* regexp_stack_;
  DateCache* date_cache_;
  CallInterfaceDescriptorData* call_descriptor_data_;
  base::RandomNumberGenerator* random_number_generator_;


  bool serializer_enabled_;


  bool has_fatal_error_;


  bool initialized_from_snapshot_;


  bool is_tail_call_elimination_enabled_;


  double time_millis_at_init_;



  HistogramInfo heap_histograms_[LAST_TYPE + 1];
  JSObject::SpillInformation js_spill_information_;


  Debug* debug_;
  CpuProfiler* cpu_profiler_;
  HeapProfiler* heap_profiler_;
  FunctionEntryHook function_entry_hook_;

  interpreter::Interpreter* interpreter_;

  typedef std::pair<InterruptCallback, void*> InterruptEntry;
  std::queue<InterruptEntry> api_interrupts_queue_;



  FatalErrorCallback exception_behavior_; LogEventCallback event_logger_; AllowCodeGenerationFromStringsCallback allow_code_gen_callback_; int next_serial_number_; ExternalReferenceRedirectorPointer* external_reference_redirector_; FunctionInfoListener* active_function_info_listener_; Relocatable* relocatable_top_; DebugObjectCache* string_stream_debug_object_cache_; Object* string_stream_current_security_token_; ExternalReferenceTable* external_reference_table_; HashMap* external_reference_map_; HashMap* root_index_map_; int pending_microtask_count_; HStatistics* hstatistics_; CompilationStatistics* turbo_statistics_; HTracer* htracer_; CodeTracer* code_tracer_; bool fp_stubs_generated_; uint32_t per_isolate_assert_data_; PromiseRejectCallback promise_reject_callback_; const v8::StartupData* snapshot_blob_;




  int32_t jsregexp_static_offsets_vector_[kJSRegexpStaticOffsetsVectorSize]; int bad_char_shift_table_[kUC16AlphabetSize]; int good_suffix_shift_table_[(kBMMaxShift + 1)]; int suffix_table_[(kBMMaxShift + 1)]; uint32_t private_random_seed_[2]; CommentStatistic paged_space_comments_statistics_[CommentStatistic::kMaxComments + 1]; int code_kind_statistics_[Code::NUMBER_OF_KINDS];
  static const intptr_t exception_behavior_debug_offset_; static const intptr_t event_logger_debug_offset_; static const intptr_t allow_code_gen_callback_debug_offset_; static const intptr_t next_serial_number_debug_offset_; static const intptr_t external_reference_redirector_debug_offset_; static const intptr_t active_function_info_listener_debug_offset_; static const intptr_t relocatable_top_debug_offset_; static const intptr_t string_stream_debug_object_cache_debug_offset_; static const intptr_t string_stream_current_security_token_debug_offset_; static const intptr_t external_reference_table_debug_offset_; static const intptr_t external_reference_map_debug_offset_; static const intptr_t root_index_map_debug_offset_; static const intptr_t pending_microtask_count_debug_offset_; static const intptr_t hstatistics_debug_offset_; static const intptr_t turbo_statistics_debug_offset_; static const intptr_t htracer_debug_offset_; static const intptr_t code_tracer_debug_offset_; static const intptr_t fp_stubs_generated_debug_offset_; static const intptr_t per_isolate_assert_data_debug_offset_; static const intptr_t promise_reject_callback_debug_offset_; static const intptr_t snapshot_blob_debug_offset_;
  static const intptr_t jsregexp_static_offsets_vector_debug_offset_; static const intptr_t bad_char_shift_table_debug_offset_; static const intptr_t good_suffix_shift_table_debug_offset_; static const intptr_t suffix_table_debug_offset_; static const intptr_t private_random_seed_debug_offset_; static const intptr_t paged_space_comments_statistics_debug_offset_; static const intptr_t code_kind_statistics_debug_offset_;



  DeferredHandles* deferred_handles_head_;
  OptimizingCompileDispatcher* optimizing_compile_dispatcher_;


  unsigned int stress_deopt_count_;

  Address virtual_handler_register_;
  Address virtual_slot_register_;

  int next_optimization_id_;


  unsigned int js_calls_from_api_counter_;


  int next_unique_sfi_id_;



  List<BeforeCallEnteredCallback> before_call_entered_callbacks_;


  List<CallCompletedCallback> call_completed_callbacks_;


  List<MicrotasksCompletedCallback> microtasks_completed_callbacks_;

  v8::Isolate::UseCounterCallback use_counter_callback_;
  BasicBlockProfiler* basic_block_profiler_;

  List<Object*> partial_snapshot_cache_;

  v8::ArrayBuffer::Allocator* array_buffer_allocator_;

  FutexWaitListNode futex_wait_list_node_;

  CancelableTaskManager* cancelable_task_manager_;

  v8::Isolate::AbortOnUncaughtExceptionCallback
      abort_on_uncaught_exception_callback_;

  friend class ExecutionAccess;
  friend class HandleScopeImplementer;
  friend class OptimizingCompileDispatcher;
  friend class SweeperThread;
  friend class ThreadManager;
  friend class Simulator;
  friend class StackGuard;
  friend class ThreadId;
  friend class TestMemoryAllocatorScope;
  friend class TestCodeRangeScope;
  friend class v8::Isolate;
  friend class v8::Locker;
  friend class v8::Unlocker;
  friend v8::StartupData v8::V8::CreateSnapshotDataBlob(const char*);
  friend v8::StartupData v8::V8::WarmUpSnapshotDataBlob(v8::StartupData,
                                                        const char*);

  Isolate(const Isolate&) = delete; void operator=(const Isolate&) = delete;
};






class PromiseOnStack {
 public:
  PromiseOnStack(Handle<JSFunction> function, Handle<JSObject> promise,
                 PromiseOnStack* prev)
      : function_(function), promise_(promise), prev_(prev) {}
  Handle<JSFunction> function() { return function_; }
  Handle<JSObject> promise() { return promise_; }
  PromiseOnStack* prev() { return prev_; }

 private:
  Handle<JSFunction> function_;
  Handle<JSObject> promise_;
  PromiseOnStack* prev_;
};





class SaveContext : public Embedded {
 public:
  explicit SaveContext(Isolate* isolate);
  ~SaveContext();

  Handle<Context> context() { return context_; }
  SaveContext* prev() { return prev_; }


  bool IsBelowFrame(JavaScriptFrame* frame) {
    return (c_entry_fp_ == 0) || (c_entry_fp_ > frame->sp());
  }

 private:
  Isolate* isolate_;
  Handle<Context> context_;
  SaveContext* prev_;
  Address c_entry_fp_;
};


class AssertNoContextChange : public Embedded {

 public:
  explicit AssertNoContextChange(Isolate* isolate);
  ~AssertNoContextChange() {
    do { if ((!(isolate_->context() == *context_))) { V8_Fatal(".././src/isolate.h", 1446, "Check failed: %s.", "isolate_->context() == *context_"); } } while (0);
  }

 private:
  Isolate* isolate_;
  Handle<Context> context_;




};


class ExecutionAccess : public Embedded {
 public:
  explicit ExecutionAccess(Isolate* isolate) : isolate_(isolate) {
    Lock(isolate);
  }
  ~ExecutionAccess() { Unlock(isolate_); }

  static void Lock(Isolate* isolate) { isolate->break_access()->Lock(); }
  static void Unlock(Isolate* isolate) { isolate->break_access()->Unlock(); }

  static bool TryLock(Isolate* isolate) {
    return isolate->break_access()->TryLock();
  }

 private:
  Isolate* isolate_;
};



class StackLimitCheck : public Embedded {
 public:
  explicit StackLimitCheck(Isolate* isolate) : isolate_(isolate) { }


  bool HasOverflowed() const {
    StackGuard* stack_guard = isolate_->stack_guard();
    return GetCurrentStackPosition() < stack_guard->real_climit();
  }


  bool InterruptRequested() {
    StackGuard* stack_guard = isolate_->stack_guard();
    return GetCurrentStackPosition() < stack_guard->climit();
  }


  bool JsHasOverflowed(uintptr_t gap = 0) const;

 private:
  Isolate* isolate_;
};






class PostponeInterruptsScope : public Embedded {
 public:
  PostponeInterruptsScope(Isolate* isolate,
                          int intercept_mask = StackGuard::ALL_INTERRUPTS)
      : stack_guard_(isolate->stack_guard()),
        intercept_mask_(intercept_mask),
        intercepted_flags_(0) {
    stack_guard_->PushPostponeInterruptsScope(this);
  }

  ~PostponeInterruptsScope() {
    stack_guard_->PopPostponeInterruptsScope();
  }



  bool Intercept(StackGuard::InterruptFlag flag);

 private:
  StackGuard* stack_guard_;
  int intercept_mask_;
  int intercepted_flags_;
  PostponeInterruptsScope* prev_;

  friend class StackGuard;
};


class CodeTracer final : public Malloced {
 public:
  explicit CodeTracer(int isolate_id)
      : file_(0),
        scope_depth_(0) {
    if (!ShouldRedirect()) {
      file_ = ( *((__FILEP * const) (*(_Gtab(3))) ) );
      return;
    }

    if (FLAG_redirect_code_traces_to == 0) {
      SNPrintF(filename_,
               "code-%d-%d.asm",
               base::OS::GetCurrentProcessId(),
               isolate_id);
    } else {
      StrNCpy(filename_, FLAG_redirect_code_traces_to, filename_.length());
    }

    WriteChars(filename_.start(), "", 0, false);
  }

  class Scope {
   public:
    explicit Scope(CodeTracer* tracer) : tracer_(tracer) { tracer->OpenFile(); }
    ~Scope() { tracer_->CloseFile(); }

    FILE* file() const { return tracer_->file(); }

   private:
    CodeTracer* tracer_;
  };

  void OpenFile() {
    if (!ShouldRedirect()) {
      return;
    }

    if (file_ == 0) {
      file_ = base::OS::FOpen(filename_.start(), "ab");
    }

    scope_depth_++;
  }

  void CloseFile() {
    if (!ShouldRedirect()) {
      return;
    }

    if (--scope_depth_ == 0) {
      fclose(file_);
      file_ = 0;
    }
  }

  FILE* file() const { return file_; }

 private:
  static bool ShouldRedirect() {
    return FLAG_redirect_code_traces;
  }

  EmbeddedVector<char, 128> filename_;
  FILE* file_;
  int scope_depth_;
};

}
}
namespace v8 {
namespace base {

class ElapsedTimer final {
 public:

  ElapsedTimer() : started_(false) {}





  void Start() {
    do { if ((!(!IsStarted()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 24, "Check failed: %s.", "!IsStarted()"); } } while (0);
    start_ticks_ = Now();

    started_ = true;

    do { if ((!(IsStarted()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 29, "Check failed: %s.", "IsStarted()"); } } while (0);
  }



  void Stop() {
    do { if ((!(IsStarted()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 35, "Check failed: %s.", "IsStarted()"); } } while (0);
    start_ticks_ = TimeTicks();

    started_ = false;

    do { if ((!(!IsStarted()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 40, "Check failed: %s.", "!IsStarted()"); } } while (0);
  }


  bool IsStarted() const {
    do { if ((!(started_ || start_ticks_.IsNull()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 45, "Check failed: %s.", "started_ || start_ticks_.IsNull()"); } } while (0);
    do { if ((!(!started_ || !start_ticks_.IsNull()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 46, "Check failed: %s.", "!started_ || !start_ticks_.IsNull()"); } } while (0);
    return !start_ticks_.IsNull();
  }






  TimeDelta Restart() {
    do { if ((!(IsStarted()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 56, "Check failed: %s.", "IsStarted()"); } } while (0);
    TimeTicks ticks = Now();
    TimeDelta elapsed = ticks - start_ticks_;
    do { if ((!(elapsed.InMicroseconds() >= 0))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 59, "Check failed: %s.", "elapsed.InMicroseconds() >= 0"); } } while (0);
    start_ticks_ = ticks;
    do { if ((!(IsStarted()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 61, "Check failed: %s.", "IsStarted()"); } } while (0);
    return elapsed;
  }



  TimeDelta Elapsed() const {
    do { if ((!(IsStarted()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 68, "Check failed: %s.", "IsStarted()"); } } while (0);
    TimeDelta elapsed = Now() - start_ticks_;
    do { if ((!(elapsed.InMicroseconds() >= 0))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 70, "Check failed: %s.", "elapsed.InMicroseconds() >= 0"); } } while (0);
    return elapsed;
  }




  bool HasExpired(TimeDelta time_delta) const {
    do { if ((!(IsStarted()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 78, "Check failed: %s.", "IsStarted()"); } } while (0);
    return Elapsed() >= time_delta;
  }

 private:
  static inline TimeTicks Now() {
    TimeTicks now = TimeTicks::HighResolutionNow();
    do { if ((!(!now.IsNull()))) { V8_Fatal(".././src/base/platform/elapsed-timer.h", 85, "Check failed: %s.", "!now.IsNull()"); } } while (0);
    return now;
  }

  TimeTicks start_ticks_;

  bool started_;

};

}
}



namespace v8 {

namespace base {
class Semaphore;
}

namespace internal {
class CodeEventListener;
class CompilationInfo;
class CpuProfiler;
class Isolate;
class Log;
class PositionsRecorder;
class Profiler;
class Ticker;
struct TickSample;
class JitLogger;
class PerfBasicLogger;
class LowLevelLogger;
class PerfJitLogger;
class Sampler;

class Logger {
 public:
  enum StartEnd { START = 0, END = 1 };


  enum LogEventsAndTags {
    CODE_CREATION_EVENT, CODE_DISABLE_OPT_EVENT, CODE_MOVE_EVENT, CODE_DELETE_EVENT, CODE_MOVING_GC, SHARED_FUNC_MOVE_EVENT, SNAPSHOT_CODE_NAME_EVENT, TICK_EVENT, REPEAT_META_EVENT, BUILTIN_TAG, CALL_DEBUG_BREAK_TAG, CALL_DEBUG_PREPARE_STEP_IN_TAG, CALL_INITIALIZE_TAG, CALL_MEGAMORPHIC_TAG, CALL_MISS_TAG, CALL_NORMAL_TAG, CALL_PRE_MONOMORPHIC_TAG, LOAD_INITIALIZE_TAG, LOAD_PREMONOMORPHIC_TAG, LOAD_MEGAMORPHIC_TAG, STORE_INITIALIZE_TAG, STORE_PREMONOMORPHIC_TAG, STORE_GENERIC_TAG, STORE_MEGAMORPHIC_TAG, KEYED_CALL_DEBUG_BREAK_TAG, KEYED_CALL_DEBUG_PREPARE_STEP_IN_TAG, KEYED_CALL_INITIALIZE_TAG, KEYED_CALL_MEGAMORPHIC_TAG, KEYED_CALL_MISS_TAG, KEYED_CALL_NORMAL_TAG, KEYED_CALL_PRE_MONOMORPHIC_TAG, CALLBACK_TAG, EVAL_TAG, FUNCTION_TAG, HANDLER_TAG, BYTECODE_HANDLER_TAG, KEYED_LOAD_IC_TAG, KEYED_LOAD_POLYMORPHIC_IC_TAG, KEYED_EXTERNAL_ARRAY_LOAD_IC_TAG, KEYED_STORE_IC_TAG, KEYED_STORE_POLYMORPHIC_IC_TAG, KEYED_EXTERNAL_ARRAY_STORE_IC_TAG, LAZY_COMPILE_TAG, CALL_IC_TAG, LOAD_IC_TAG, LOAD_POLYMORPHIC_IC_TAG, REG_EXP_TAG, SCRIPT_TAG, STORE_IC_TAG, STORE_POLYMORPHIC_IC_TAG, STUB_TAG, NATIVE_FUNCTION_TAG, NATIVE_LAZY_COMPILE_TAG, NATIVE_SCRIPT_TAG,
    NUMBER_OF_LOG_EVENTS
  };



  bool SetUp(Isolate* isolate);


  void SetCodeEventHandler(uint32_t options,
                           JitCodeEventHandler event_handler);

  Sampler* sampler();




  FILE* TearDown();


  void StringEvent(const char* name, const char* value);


  void IntEvent(const char* name, int value);
  void IntPtrTEvent(const char* name, intptr_t value);


  void HandleEvent(const char* name, Object** location);


  void NewEvent(const char* name, void* object, size_t size);
  void DeleteEvent(const char* name, void* object);





  void ResourceEvent(const char* name, const char* tag);



  void SuspectReadEvent(Name* name, Object* obj);



  void DebugTag(const char* call_site_tag);
  void DebugEvent(const char* event_type, Vector<uint16_t> parameter);



  void ApiSecurityCheck();
  void ApiNamedPropertyAccess(const char* tag, JSObject* holder, Object* name);
  void ApiIndexedPropertyAccess(const char* tag,
                                JSObject* holder,
                                uint32_t index);
  void ApiObjectAccess(const char* tag, JSObject* obj);
  void ApiEntryCall(const char* name);



  void addCodeEventListener(CodeEventListener* listener);
  void removeCodeEventListener(CodeEventListener* listener);
  bool hasCodeEventListener(CodeEventListener* listener);



  void CallbackEvent(Name* name, Address entry_point);
  void GetterCallbackEvent(Name* name, Address entry_point);
  void SetterCallbackEvent(Name* name, Address entry_point);

  void CodeCreateEvent(LogEventsAndTags tag, AbstractCode* code,
                       const char* source);
  void CodeCreateEvent(LogEventsAndTags tag, AbstractCode* code, Name* name);
  void CodeCreateEvent(LogEventsAndTags tag, AbstractCode* code,
                       SharedFunctionInfo* shared, CompilationInfo* info,
                       Name* name);
  void CodeCreateEvent(LogEventsAndTags tag, AbstractCode* code,
                       SharedFunctionInfo* shared, CompilationInfo* info,
                       Name* source, int line, int column);
  void CodeCreateEvent(LogEventsAndTags tag, AbstractCode* code,
                       int args_count);

  void CodeDisableOptEvent(AbstractCode* code, SharedFunctionInfo* shared);
  void CodeMovingGCEvent();

  void RegExpCodeCreateEvent(AbstractCode* code, String* source);

  void CodeMoveEvent(AbstractCode* from, Address to);

  void CodeLinePosInfoAddPositionEvent(void* jit_handler_data,
                                       int pc_offset,
                                       int position);

  void CodeLinePosInfoAddStatementPositionEvent(void* jit_handler_data,
                                                int pc_offset,
                                                int position);

  void CodeStartLinePosInfoRecordEvent(PositionsRecorder* pos_recorder);


  void CodeEndLinePosInfoRecordEvent(AbstractCode* code,
                                     void* jit_handler_data);

  void SharedFunctionInfoMoveEvent(Address from, Address to);

  void CodeNameEvent(Address addr, int pos, const char* code_name);



  void HeapSampleBeginEvent(const char* space, const char* kind);
  void HeapSampleEndEvent(const char* space, const char* kind);
  void HeapSampleItemEvent(const char* type, int number, int bytes);
  void HeapSampleJSConstructorEvent(const char* constructor,
                                    int number, int bytes);
  void HeapSampleJSRetainersEvent(const char* constructor,
                                         const char* event);
  void HeapSampleJSProducerEvent(const char* constructor,
                                 Address* stack);
  void HeapSampleStats(const char* space, const char* kind,
                       intptr_t capacity, intptr_t used);

  void SharedLibraryEvent(const std::string& library_path,
                          uintptr_t start,
                          uintptr_t end);

  void CodeDeoptEvent(Code* code, Address pc, int fp_to_sp_delta);
  void CurrentTimeEvent();

  void TimerEvent(StartEnd se, const char* name);

  static void EnterExternal(Isolate* isolate);
  static void LeaveExternal(Isolate* isolate);

  static void DefaultEventLoggerSentinel(const char* name, int event) {}

  inline static void CallEventLogger(Isolate* isolate, const char* name, StartEnd se, bool expose_to_api);





  void RegExpCompileEvent(Handle<JSRegExp> regexp, bool in_cache);

  bool is_logging() {
    return is_logging_;
  }

  bool is_logging_code_events() {
    return is_logging() || jit_logger_ != 0;
  }



  void StopProfiler();

  void LogExistingFunction(Handle<SharedFunctionInfo> shared,
                           Handle<AbstractCode> code);

  void LogCompiledFunctions();

  void LogAccessorCallbacks();

  void LogCodeObjects();

  void LogBytecodeHandlers();


  inline static LogEventsAndTags ToNativeByScript(LogEventsAndTags, Script*);







  static const int kSamplingIntervalMs = 1;



  void LogFailure();

 private:
  explicit Logger(Isolate* isolate);
  ~Logger();


  void ProfilerBeginEvent();


  void CallbackEventInternal(const char* prefix,
                             Name* name,
                             Address entry_point);


  void MoveEventInternal(LogEventsAndTags event, Address from, Address to);


  void LogCodeObject(Object* code_object);


  void InitNameBuffer(LogEventsAndTags tag);


  void TickEvent(TickSample* sample, bool overflow);

  void ApiEvent(const char* name, ...);


  void UncheckedStringEvent(const char* name, const char* value);


  void UncheckedIntEvent(const char* name, int value);
  void UncheckedIntPtrTEvent(const char* name, intptr_t value);

  Isolate* isolate_;


  Ticker* ticker_;




  Profiler* profiler_;


  const char* const* log_events_;



  friend class EventLog;
  friend class Isolate;
  friend class TimeLog;
  friend class Profiler;
  template <StateTag Tag> friend class VMState;
  friend class LoggerTestHelper;

  bool is_logging_;
  Log* log_;
  PerfBasicLogger* perf_basic_logger_;
  PerfJitLogger* perf_jit_logger_;
  LowLevelLogger* ll_logger_;
  JitLogger* jit_logger_;
  List<CodeEventListener*> listeners_;



  bool is_initialized_;

  base::ElapsedTimer timer_;

  friend class CpuProfiler;
};
class TimerEventRecompileSynchronous : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"RecompileSynchronous"; } static bool expose_to_api() { return true; } }; class TimerEventRecompileConcurrent : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"RecompileConcurrent"; } static bool expose_to_api() { return true; } }; class TimerEventCompileIgnition : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"CompileIgnition"; } static bool expose_to_api() { return true; } }; class TimerEventCompileFullCode : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"CompileFullCode"; } static bool expose_to_api() { return true; } }; class TimerEventOptimizeCode : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"OptimizeCode"; } static bool expose_to_api() { return true; } }; class TimerEventCompileCode : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"CompileCode"; } static bool expose_to_api() { return true; } }; class TimerEventDeoptimizeCode : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"DeoptimizeCode"; } static bool expose_to_api() { return true; } }; class TimerEventExecute : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"Execute"; } static bool expose_to_api() { return true; } }; class TimerEventExternal : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"External"; } static bool expose_to_api() { return true; } }; class TimerEventIcMiss : public AllStatic { public: static const char* name(void* unused = 0) { return u8"V8." u8"IcMiss"; } static bool expose_to_api() { return false; } };



template <class TimerEvent>
class TimerEventScope {
 public:
  explicit TimerEventScope(Isolate* isolate) : isolate_(isolate) {
    LogTimerEvent(Logger::START);
  }

  ~TimerEventScope() { LogTimerEvent(Logger::END); }

  void LogTimerEvent(Logger::StartEnd se);

 private:
  Isolate* isolate_;
};

class PositionsRecorder : public Embedded {
 public:
  PositionsRecorder() { jit_handler_data_ = 0; }

  void AttachJITHandlerData(void* user_data) { jit_handler_data_ = user_data; }

  void* DetachJITHandlerData() {
    void* old_data = jit_handler_data_;
    jit_handler_data_ = 0;
    return old_data;
  }

 protected:


  void* jit_handler_data_;

 private:
  PositionsRecorder(const PositionsRecorder&) = delete; void operator=(const PositionsRecorder&) = delete;
};

class CodeEventListener {
 public:
  virtual ~CodeEventListener() {}

  virtual void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                               const char* comment) = 0;
  virtual void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                               Name* name) = 0;
  virtual void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                               SharedFunctionInfo* shared,
                               CompilationInfo* info, Name* name) = 0;
  virtual void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                               SharedFunctionInfo* shared,
                               CompilationInfo* info, Name* source, int line,
                               int column) = 0;
  virtual void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                               int args_count) = 0;
  virtual void CallbackEvent(Name* name, Address entry_point) = 0;
  virtual void GetterCallbackEvent(Name* name, Address entry_point) = 0;
  virtual void SetterCallbackEvent(Name* name, Address entry_point) = 0;
  virtual void RegExpCodeCreateEvent(AbstractCode* code, String* source) = 0;
  virtual void CodeMoveEvent(AbstractCode* from, Address to) = 0;
  virtual void SharedFunctionInfoMoveEvent(Address from, Address to) = 0;
  virtual void CodeMovingGCEvent() = 0;
  virtual void CodeDisableOptEvent(AbstractCode* code,
                                   SharedFunctionInfo* shared) = 0;
};


class CodeEventLogger : public CodeEventListener {
 public:
  CodeEventLogger();
  ~CodeEventLogger() override;

  void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                       const char* comment) override;
  void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                       Name* name) override;
  void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                       int args_count) override;
  void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                       SharedFunctionInfo* shared, CompilationInfo* info,
                       Name* name) override;
  void CodeCreateEvent(Logger::LogEventsAndTags tag, AbstractCode* code,
                       SharedFunctionInfo* shared, CompilationInfo* info,
                       Name* source, int line, int column) override;
  void RegExpCodeCreateEvent(AbstractCode* code, String* source) override;

  void CallbackEvent(Name* name, Address entry_point) override {}
  void GetterCallbackEvent(Name* name, Address entry_point) override {}
  void SetterCallbackEvent(Name* name, Address entry_point) override {}
  void SharedFunctionInfoMoveEvent(Address from, Address to) override {}
  void CodeMovingGCEvent() override {}

 private:
  class NameBuffer;

  virtual void LogRecordedBuffer(AbstractCode* code, SharedFunctionInfo* shared,
                                 const char* name, int length) = 0;

  NameBuffer* name_buffer_;
};


}
}


namespace v8 {


class ApiFunction;

namespace internal {


class StatsCounter;




enum class CodeObjectRequired { kNo, kYes };


class AssemblerBase: public Malloced {
 public:
  AssemblerBase(Isolate* isolate, void* buffer, int buffer_size);
  virtual ~AssemblerBase();

  Isolate* isolate() const { return isolate_; }
  int jit_cookie() const { return jit_cookie_; }

  bool emit_debug_code() const { return emit_debug_code_; }
  void set_emit_debug_code(bool value) { emit_debug_code_ = value; }

  bool serializer_enabled() const { return serializer_enabled_; }
  void enable_serializer() { serializer_enabled_ = true; }

  bool predictable_code_size() const { return predictable_code_size_; }
  void set_predictable_code_size(bool value) { predictable_code_size_ = value; }

  uint64_t enabled_cpu_features() const { return enabled_cpu_features_; }
  void set_enabled_cpu_features(uint64_t features) {
    enabled_cpu_features_ = features;
  }
  bool IsEnabled(CpuFeature f) {
    return (enabled_cpu_features_ & (static_cast<uint64_t>(1) << f)) != 0;
  }

  bool is_constant_pool_available() const {
    if (FLAG_enable_embedded_constant_pool) {
      return constant_pool_available_;
    } else {

      V8_Fatal(".././src/assembler.h", 90, "unreachable code");
      return false;
    }
  }



  static void QuietNaN(HeapObject* nan) { }

  int pc_offset() const { return static_cast<int>(pc_ - buffer_); }



  virtual void AbortedCodeGeneration() { }


  void Print();

  static const int kMinimalBufferSize = 4*KB;

  static void FlushICache(Isolate* isolate, void* start, size_t size);

 protected:


  byte* buffer_;
  int buffer_size_;
  bool own_buffer_;

  void set_constant_pool_available(bool available) {
    if (FLAG_enable_embedded_constant_pool) {
      constant_pool_available_ = available;
    } else {

      V8_Fatal(".././src/assembler.h", 124, "unreachable code");
    }
  }


  byte* pc_;

 private:
  Isolate* isolate_;
  int jit_cookie_;
  uint64_t enabled_cpu_features_;
  bool emit_debug_code_;
  bool predictable_code_size_;
  bool serializer_enabled_;



  bool constant_pool_available_;


  friend class FrameAndConstantPoolScope;
  friend class ConstantPoolUnavailableScope;
};



class DontEmitDebugCodeScope : public Embedded {
 public:
  explicit DontEmitDebugCodeScope(AssemblerBase* assembler)
      : assembler_(assembler), old_value_(assembler->emit_debug_code()) {
    assembler_->set_emit_debug_code(false);
  }
  ~DontEmitDebugCodeScope() {
    assembler_->set_emit_debug_code(old_value_);
  }
 private:
  AssemblerBase* assembler_;
  bool old_value_;
};




class PredictableCodeSizeScope {
 public:
  explicit PredictableCodeSizeScope(AssemblerBase* assembler);
  PredictableCodeSizeScope(AssemblerBase* assembler, int expected_size);
  ~PredictableCodeSizeScope();
  void ExpectSize(int expected_size) { expected_size_ = expected_size; }

 private:
  AssemblerBase* assembler_;
  int expected_size_;
  int start_offset_;
  bool old_value_;
};



class CpuFeatureScope : public Embedded {
 public:

  CpuFeatureScope(AssemblerBase* assembler, CpuFeature f);
  ~CpuFeatureScope();

 private:
  AssemblerBase* assembler_;
  uint64_t old_enabled_;



};
class CpuFeatures : public AllStatic {
 public:
  static void Probe(bool cross_compile) {
    static_assert(NUMBER_OF_CPU_FEATURES <= kBitsPerInt, "NUMBER_OF_CPU_FEATURES <= kBitsPerInt");
    if (initialized_) return;
    initialized_ = true;
    ProbeImpl(cross_compile);
  }

  static unsigned SupportedFeatures() {
    Probe(false);
    return supported_;
  }

  static bool IsSupported(CpuFeature f) {
    return (supported_ & (1u << f)) != 0;
  }

  static inline bool SupportsCrankshaft();

  static inline unsigned icache_line_size() {
    do { if ((!(icache_line_size_ != 0))) { V8_Fatal(".././src/assembler.h", 228, "Check failed: %s.", "icache_line_size_ != 0"); } } while (0);
    return icache_line_size_;
  }

  static inline unsigned dcache_line_size() {
    do { if ((!(dcache_line_size_ != 0))) { V8_Fatal(".././src/assembler.h", 233, "Check failed: %s.", "dcache_line_size_ != 0"); } } while (0);
    return dcache_line_size_;
  }

  static void PrintTarget();
  static void PrintFeatures();

 private:
  friend class ExternalReference;
  friend class AssemblerBase;

  static void FlushICache(void* start, size_t size);


  static void ProbeImpl(bool cross_compile);

  static unsigned supported_;
  static unsigned icache_line_size_;
  static unsigned dcache_line_size_;
  static bool initialized_;
  CpuFeatures(const CpuFeatures&) = delete; void operator=(const CpuFeatures&) = delete;
};
class Label {
 public:
  enum Distance {
    kNear, kFar
  };

  inline Label() {
    Unuse();
    UnuseNear();
  }

  inline ~Label() {
    do { if ((!(!is_linked()))) { V8_Fatal(".././src/assembler.h", 275, "Check failed: %s.", "!is_linked()"); } } while (0);
    do { if ((!(!is_near_linked()))) { V8_Fatal(".././src/assembler.h", 276, "Check failed: %s.", "!is_near_linked()"); } } while (0);
  }

  inline void Unuse() { pos_ = 0; }
  inline void UnuseNear() { near_link_pos_ = 0; }

  inline bool is_bound() const { return pos_ < 0; }
  inline bool is_unused() const { return pos_ == 0 && near_link_pos_ == 0; }
  inline bool is_linked() const { return pos_ > 0; }
  inline bool is_near_linked() const { return near_link_pos_ > 0; }



  int pos() const;
  int near_link_pos() const { return near_link_pos_ - 1; }

 private:






  int pos_;


  int near_link_pos_;

  void bind_to(int pos) {
    pos_ = -pos - 1;
    do { if ((!(is_bound()))) { V8_Fatal(".././src/assembler.h", 306, "Check failed: %s.", "is_bound()"); } } while (0);
  }
  void link_to(int pos, Distance distance = kFar) {
    if (distance == kNear) {
      near_link_pos_ = pos + 1;
      do { if ((!(is_near_linked()))) { V8_Fatal(".././src/assembler.h", 311, "Check failed: %s.", "is_near_linked()"); } } while (0);
    } else {
      pos_ = pos + 1;
      do { if ((!(is_linked()))) { V8_Fatal(".././src/assembler.h", 314, "Check failed: %s.", "is_linked()"); } } while (0);
    }
  }

  friend class Assembler;
  friend class Displacement;
  friend class RegExpMacroAssemblerIrregexp;






};


enum SaveFPRegsMode { kDontSaveFPRegs, kSaveFPRegs };

enum ArgvMode { kArgvOnStack, kArgvInRegister };






enum ICacheFlushMode { FLUSH_ICACHE_IF_NEEDED, SKIP_ICACHE_FLUSH };
class RelocInfo {
 public:
  static const int kNoPosition = -1;





  static const char* const kFillerCommentString;



  static const int kMinRelocCommentSize = 2 + kPointerSize;


  static const int kMaxCallSize = 6;


  static const int kMaxSmallPCDelta;

  enum Mode {

    CODE_TARGET,
    CODE_TARGET_WITH_ID,
    DEBUGGER_STATEMENT,
    EMBEDDED_OBJECT,
    CELL,

    WASM_MEMORY_REFERENCE,


    RUNTIME_ENTRY,
    COMMENT,
    POSITION,
    STATEMENT_POSITION,


    DEBUG_BREAK_SLOT_AT_POSITION,
    DEBUG_BREAK_SLOT_AT_RETURN,
    DEBUG_BREAK_SLOT_AT_CALL,
    DEBUG_BREAK_SLOT_AT_TAIL_CALL,

    EXTERNAL_REFERENCE,
    INTERNAL_REFERENCE,


    INTERNAL_REFERENCE_ENCODED,


    GENERATOR_CONTINUATION,



    CONST_POOL,
    VENEER_POOL,

    DEOPT_REASON,



    PC_JUMP,


    NUMBER_OF_MODES,
    NONE32,
    NONE64,
    CODE_AGE_SEQUENCE,


    FIRST_REAL_RELOC_MODE = CODE_TARGET,
    LAST_REAL_RELOC_MODE = VENEER_POOL,
    LAST_CODE_ENUM = DEBUGGER_STATEMENT,
    LAST_GCED_ENUM = WASM_MEMORY_REFERENCE,
    FIRST_SHAREABLE_RELOC_MODE = CELL,
  };

  static_assert(NUMBER_OF_MODES <= kBitsPerInt, "NUMBER_OF_MODES <= kBitsPerInt");

  explicit RelocInfo(Isolate* isolate) : isolate_(isolate) {
    do { if ((!((isolate) != nullptr))) { V8_Fatal(".././src/assembler.h", 440, "Check failed: %s.", "(isolate) != nullptr"); } } while (0);
  }

  RelocInfo(Isolate* isolate, byte* pc, Mode rmode, intptr_t data, Code* host)
      : isolate_(isolate), pc_(pc), rmode_(rmode), data_(data), host_(host) {
    do { if ((!((isolate) != nullptr))) { V8_Fatal(".././src/assembler.h", 445, "Check failed: %s.", "(isolate) != nullptr"); } } while (0);
  }

  static inline bool IsRealRelocMode(Mode mode) {
    return mode >= FIRST_REAL_RELOC_MODE &&
        mode <= LAST_REAL_RELOC_MODE;
  }
  static inline bool IsCodeTarget(Mode mode) {
    return mode <= LAST_CODE_ENUM;
  }
  static inline bool IsEmbeddedObject(Mode mode) {
    return mode == EMBEDDED_OBJECT;
  }
  static inline bool IsCell(Mode mode) { return mode == CELL; }
  static inline bool IsRuntimeEntry(Mode mode) {
    return mode == RUNTIME_ENTRY;
  }

  static inline bool IsGCRelocMode(Mode mode) {
    return mode <= LAST_GCED_ENUM;
  }
  static inline bool IsComment(Mode mode) {
    return mode == COMMENT;
  }
  static inline bool IsConstPool(Mode mode) {
    return mode == CONST_POOL;
  }
  static inline bool IsVeneerPool(Mode mode) {
    return mode == VENEER_POOL;
  }
  static inline bool IsDeoptReason(Mode mode) {
    return mode == DEOPT_REASON;
  }
  static inline bool IsPosition(Mode mode) {
    return mode == POSITION || mode == STATEMENT_POSITION;
  }
  static inline bool IsStatementPosition(Mode mode) {
    return mode == STATEMENT_POSITION;
  }
  static inline bool IsExternalReference(Mode mode) {
    return mode == EXTERNAL_REFERENCE;
  }
  static inline bool IsInternalReference(Mode mode) {
    return mode == INTERNAL_REFERENCE;
  }
  static inline bool IsInternalReferenceEncoded(Mode mode) {
    return mode == INTERNAL_REFERENCE_ENCODED;
  }
  static inline bool IsDebugBreakSlot(Mode mode) {
    return IsDebugBreakSlotAtPosition(mode) || IsDebugBreakSlotAtReturn(mode) ||
           IsDebugBreakSlotAtCall(mode) || IsDebugBreakSlotAtTailCall(mode);
  }
  static inline bool IsDebugBreakSlotAtPosition(Mode mode) {
    return mode == DEBUG_BREAK_SLOT_AT_POSITION;
  }
  static inline bool IsDebugBreakSlotAtReturn(Mode mode) {
    return mode == DEBUG_BREAK_SLOT_AT_RETURN;
  }
  static inline bool IsDebugBreakSlotAtCall(Mode mode) {
    return mode == DEBUG_BREAK_SLOT_AT_CALL;
  }
  static inline bool IsDebugBreakSlotAtTailCall(Mode mode) {
    return mode == DEBUG_BREAK_SLOT_AT_TAIL_CALL;
  }
  static inline bool IsDebuggerStatement(Mode mode) {
    return mode == DEBUGGER_STATEMENT;
  }
  static inline bool IsNone(Mode mode) {
    return mode == NONE32 || mode == NONE64;
  }
  static inline bool IsCodeAgeSequence(Mode mode) {
    return mode == CODE_AGE_SEQUENCE;
  }
  static inline bool IsGeneratorContinuation(Mode mode) {
    return mode == GENERATOR_CONTINUATION;
  }
  static inline bool IsWasmMemoryReference(Mode mode) {
    return mode == WASM_MEMORY_REFERENCE;
  }
  static inline int ModeMask(Mode mode) { return 1 << mode; }


  Isolate* isolate() const { return isolate_; }
  byte* pc() const { return pc_; }
  void set_pc(byte* pc) { pc_ = pc; }
  Mode rmode() const { return rmode_; }
  intptr_t data() const { return data_; }
  Code* host() const { return host_; }
  void set_host(Code* host) { host_ = host; }





  inline void apply(intptr_t delta);




  bool IsCodedSpecially();



  bool IsInConstantPool();



  inline Address target_address();
  inline void set_target_address(Address target, WriteBarrierMode write_barrier_mode = UPDATE_WRITE_BARRIER, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);




  inline Object* target_object();
  inline Handle<Object> target_object_handle(Assembler* origin);
  inline void set_target_object(Object* target, WriteBarrierMode write_barrier_mode = UPDATE_WRITE_BARRIER, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);




  inline Address target_runtime_entry(Assembler* origin);
  inline void set_target_runtime_entry(Address target, WriteBarrierMode write_barrier_mode = UPDATE_WRITE_BARRIER, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);




  inline Cell* target_cell();
  inline Handle<Cell> target_cell_handle();
  inline void set_target_cell(Cell* cell, WriteBarrierMode write_barrier_mode = UPDATE_WRITE_BARRIER, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);




  inline Handle<Object> code_age_stub_handle(Assembler* origin);
  inline Code* code_age_stub();
  inline void set_code_age_stub(Code* stub, ICacheFlushMode icache_flush_mode = FLUSH_ICACHE_IF_NEEDED);



  inline Address wasm_memory_reference();
  inline void update_wasm_memory_reference( Address old_base, Address new_base, size_t old_size, size_t new_size, ICacheFlushMode icache_flush_mode = SKIP_ICACHE_FLUSH);




  inline Address constant_pool_entry_address();







  inline Address target_address_address();
  inline int target_address_size();



  inline Address target_external_reference();



  inline Address target_internal_reference();



  inline Address target_internal_reference_address();




  inline Address debug_call_address();
  inline void set_debug_call_address(Address target);



  inline void WipeOut();

  template<typename StaticVisitor> inline void Visit(Heap* heap);
  inline void Visit(Isolate* isolate, ObjectVisitor* v);



  bool IsPatchedDebugBreakSlotSequence();




  static bool RequiresRelocation(const CodeDesc& desc);




  static const char* RelocModeName(Mode rmode);
  void Print(Isolate* isolate, std::ostream& os);


  void Verify(Isolate* isolate);


  static const int kCodeTargetMask = (1 << (LAST_CODE_ENUM + 1)) - 1;
  static const int kPositionMask = 1 << POSITION | 1 << STATEMENT_POSITION;
  static const int kDataMask =
      (1 << CODE_TARGET_WITH_ID) | kPositionMask | (1 << COMMENT);
  static const int kDebugBreakSlotMask = 1 << DEBUG_BREAK_SLOT_AT_POSITION |
                                         1 << DEBUG_BREAK_SLOT_AT_RETURN |
                                         1 << DEBUG_BREAK_SLOT_AT_CALL;
  static const int kApplyMask;

 private:
  Isolate* isolate_;




  byte* pc_;
  Mode rmode_;
  intptr_t data_;
  Code* host_;
  friend class RelocIterator;
};




class RelocInfoWriter : public Embedded {
 public:
  RelocInfoWriter()
      : pos_(0),
        last_pc_(0),
        last_id_(0),
        last_position_(0),
        last_mode_(RelocInfo::NUMBER_OF_MODES),
        next_position_candidate_pos_delta_(0),
        next_position_candidate_pc_delta_(0),
        next_position_candidate_flushed_(true) {}
  RelocInfoWriter(byte* pos, byte* pc)
      : pos_(pos),
        last_pc_(pc),
        last_id_(0),
        last_position_(0),
        last_mode_(RelocInfo::NUMBER_OF_MODES),
        next_position_candidate_pos_delta_(0),
        next_position_candidate_pc_delta_(0),
        next_position_candidate_flushed_(true) {}

  byte* pos() const { return pos_; }
  byte* last_pc() const { return last_pc_; }

  void Write(const RelocInfo* rinfo);



  void Reposition(byte* pos, byte* pc) {
    pos_ = pos;
    last_pc_ = pc;
  }

  void Finish() { FlushPosition(); }






  static const int kMaxSize = 15;

 private:
  inline uint32_t WriteLongPCJump(uint32_t pc_delta);

  inline void WriteShortTaggedPC(uint32_t pc_delta, int tag);
  inline void WriteShortTaggedData(intptr_t data_delta, int tag);

  inline void WriteMode(RelocInfo::Mode rmode);
  inline void WriteModeAndPC(uint32_t pc_delta, RelocInfo::Mode rmode);
  inline void WriteIntData(int data_delta);
  inline void WriteData(intptr_t data_delta);
  inline void WritePosition(int pc_delta, int pos_delta, RelocInfo::Mode rmode);

  void FlushPosition();

  byte* pos_;
  byte* last_pc_;
  int last_id_;
  int last_position_;
  RelocInfo::Mode last_mode_;
  int next_position_candidate_pos_delta_;
  uint32_t next_position_candidate_pc_delta_;
  bool next_position_candidate_flushed_;

  RelocInfoWriter(const RelocInfoWriter&) = delete; void operator=(const RelocInfoWriter&) = delete;
};
class RelocIterator: public Malloced {
 public:




  explicit RelocIterator(Code* code, int mode_mask = -1);
  explicit RelocIterator(const CodeDesc& desc, int mode_mask = -1);


  bool done() const { return done_; }
  void next();


  RelocInfo* rinfo() {
    do { if ((!(!done()))) { V8_Fatal(".././src/assembler.h", 772, "Check failed: %s.", "!done()"); } } while (0);
    return &rinfo_;
  }

 private:



  void Advance(int bytes = 1) { pos_ -= bytes; }
  int AdvanceGetTag();
  RelocInfo::Mode GetMode();

  void AdvanceReadLongPCJump();

  int GetShortDataTypeTag();
  void ReadShortTaggedPC();
  void ReadShortTaggedId();
  void ReadShortTaggedPosition();
  void ReadShortTaggedData();

  void AdvanceReadPC();
  void AdvanceReadId();
  void AdvanceReadInt();
  void AdvanceReadPosition();
  void AdvanceReadData();



  bool SetMode(RelocInfo::Mode mode) {
    return (mode_mask_ & (1 << mode)) ? (rinfo_.rmode_ = mode, true) : false;
  }

  byte* pos_;
  byte* end_;
  byte* code_age_sequence_;
  RelocInfo rinfo_;
  bool done_;
  int mode_mask_;
  int last_id_;
  int last_position_;
  RelocIterator(const RelocIterator&) = delete; void operator=(const RelocIterator&) = delete;
};






class SCTableReference;
class Debug_Address;







class ExternalReference : public Embedded {
 public:

  enum Type {


    BUILTIN_CALL,



    BUILTIN_CALL_PAIR,



    BUILTIN_CALL_TRIPLE,



    BUILTIN_COMPARE_CALL,



    BUILTIN_FP_FP_CALL,



    BUILTIN_FP_CALL,



    BUILTIN_FP_INT_CALL,



    DIRECT_API_CALL,



    PROFILING_API_CALL,



    DIRECT_GETTER_CALL,




    PROFILING_GETTER_CALL
  };

  static void SetUp();
  static void InitializeMathExpData();
  static void TearDownMathExpData();

  typedef void* ExternalReferenceRedirector(Isolate* isolate, void* original,
                                            Type type);

  ExternalReference() : address_(0) {}

  ExternalReference(Builtins::CFunctionId id, Isolate* isolate);

  ExternalReference(ApiFunction* ptr, Type type, Isolate* isolate);

  ExternalReference(Builtins::Name name, Isolate* isolate);

  ExternalReference(Runtime::FunctionId id, Isolate* isolate);

  ExternalReference(const Runtime::Function* f, Isolate* isolate);

  explicit ExternalReference(StatsCounter* counter);

  ExternalReference(Isolate::AddressId id, Isolate* isolate);

  explicit ExternalReference(const SCTableReference& table_ref);


  static ExternalReference isolate_address(Isolate* isolate);





  static ExternalReference interpreter_dispatch_table_address(Isolate* isolate);

  static ExternalReference incremental_marking_record_write_function(
      Isolate* isolate);
  static ExternalReference incremental_marking_record_write_code_entry_function(
      Isolate* isolate);
  static ExternalReference store_buffer_overflow_function(
      Isolate* isolate);
  static ExternalReference delete_handle_scope_extensions(Isolate* isolate);

  static ExternalReference get_date_field_function(Isolate* isolate);
  static ExternalReference date_cache_stamp(Isolate* isolate);

  static ExternalReference get_make_code_young_function(Isolate* isolate);
  static ExternalReference get_mark_code_as_executed_function(Isolate* isolate);


  static ExternalReference new_deoptimizer_function(Isolate* isolate);
  static ExternalReference compute_output_frames_function(Isolate* isolate);

  static ExternalReference wasm_f32_trunc(Isolate* isolate);
  static ExternalReference wasm_f32_floor(Isolate* isolate);
  static ExternalReference wasm_f32_ceil(Isolate* isolate);
  static ExternalReference wasm_f32_nearest_int(Isolate* isolate);
  static ExternalReference wasm_f64_trunc(Isolate* isolate);
  static ExternalReference wasm_f64_floor(Isolate* isolate);
  static ExternalReference wasm_f64_ceil(Isolate* isolate);
  static ExternalReference wasm_f64_nearest_int(Isolate* isolate);
  static ExternalReference wasm_int64_to_float32(Isolate* isolate);
  static ExternalReference wasm_uint64_to_float32(Isolate* isolate);
  static ExternalReference wasm_int64_to_float64(Isolate* isolate);
  static ExternalReference wasm_uint64_to_float64(Isolate* isolate);
  static ExternalReference wasm_float32_to_int64(Isolate* isolate);
  static ExternalReference wasm_float32_to_uint64(Isolate* isolate);
  static ExternalReference wasm_float64_to_int64(Isolate* isolate);
  static ExternalReference wasm_float64_to_uint64(Isolate* isolate);
  static ExternalReference wasm_int64_div(Isolate* isolate);
  static ExternalReference wasm_int64_mod(Isolate* isolate);
  static ExternalReference wasm_uint64_div(Isolate* isolate);
  static ExternalReference wasm_uint64_mod(Isolate* isolate);

  static ExternalReference f64_acos_wrapper_function(Isolate* isolate);
  static ExternalReference f64_asin_wrapper_function(Isolate* isolate);
  static ExternalReference f64_atan_wrapper_function(Isolate* isolate);
  static ExternalReference f64_cos_wrapper_function(Isolate* isolate);
  static ExternalReference f64_sin_wrapper_function(Isolate* isolate);
  static ExternalReference f64_tan_wrapper_function(Isolate* isolate);
  static ExternalReference f64_exp_wrapper_function(Isolate* isolate);
  static ExternalReference f64_log_wrapper_function(Isolate* isolate);
  static ExternalReference f64_atan2_wrapper_function(Isolate* isolate);
  static ExternalReference f64_pow_wrapper_function(Isolate* isolate);
  static ExternalReference f64_mod_wrapper_function(Isolate* isolate);


  static ExternalReference log_enter_external_function(Isolate* isolate);
  static ExternalReference log_leave_external_function(Isolate* isolate);


  static ExternalReference keyed_lookup_cache_keys(Isolate* isolate);
  static ExternalReference keyed_lookup_cache_field_offsets(Isolate* isolate);


  static ExternalReference roots_array_start(Isolate* isolate);


  static ExternalReference allocation_sites_list_address(Isolate* isolate);


  static ExternalReference address_of_stack_limit(Isolate* isolate);


  static ExternalReference address_of_real_stack_limit(Isolate* isolate);


  static ExternalReference address_of_regexp_stack_limit(Isolate* isolate);


  static ExternalReference address_of_static_offsets_vector(Isolate* isolate);
  static ExternalReference address_of_regexp_stack_memory_address(
      Isolate* isolate);
  static ExternalReference address_of_regexp_stack_memory_size(
      Isolate* isolate);


  static ExternalReference store_buffer_top(Isolate* isolate);


  static ExternalReference new_space_allocation_top_address(Isolate* isolate);
  static ExternalReference new_space_allocation_limit_address(Isolate* isolate);
  static ExternalReference old_space_allocation_top_address(Isolate* isolate);
  static ExternalReference old_space_allocation_limit_address(Isolate* isolate);

  static ExternalReference mod_two_doubles_operation(Isolate* isolate);
  static ExternalReference power_double_double_function(Isolate* isolate);
  static ExternalReference power_double_int_function(Isolate* isolate);

  static ExternalReference handle_scope_next_address(Isolate* isolate);
  static ExternalReference handle_scope_limit_address(Isolate* isolate);
  static ExternalReference handle_scope_level_address(Isolate* isolate);

  static ExternalReference scheduled_exception_address(Isolate* isolate);
  static ExternalReference address_of_pending_message_obj(Isolate* isolate);


  static ExternalReference address_of_min_int();
  static ExternalReference address_of_one_half();
  static ExternalReference address_of_minus_one_half();
  static ExternalReference address_of_negative_infinity();
  static ExternalReference address_of_the_hole_nan();
  static ExternalReference address_of_uint32_bias();

  static ExternalReference math_log_double_function(Isolate* isolate);

  static ExternalReference math_exp_constants(int constant_index);
  static ExternalReference math_exp_log_table();

  static ExternalReference page_flags(Page* page);

  static ExternalReference ForDeoptEntry(Address entry);

  static ExternalReference cpu_features();

  static ExternalReference is_tail_call_elimination_enabled_address(
      Isolate* isolate);

  static ExternalReference debug_is_active_address(Isolate* isolate);
  static ExternalReference debug_after_break_target_address(Isolate* isolate);

  static ExternalReference is_profiling_address(Isolate* isolate);
  static ExternalReference invoke_function_callback(Isolate* isolate);
  static ExternalReference invoke_accessor_getter_callback(Isolate* isolate);

  static ExternalReference virtual_handler_register(Isolate* isolate);
  static ExternalReference virtual_slot_register(Isolate* isolate);

  static ExternalReference runtime_function_table_address(Isolate* isolate);

  Address address() const { return reinterpret_cast<Address>(address_); }


  static ExternalReference debug_step_in_enabled_address(Isolate* isolate);





  static ExternalReference re_case_insensitive_compare_uc16(Isolate* isolate);


  static ExternalReference re_check_stack_guard_state(Isolate* isolate);


  static ExternalReference re_grow_stack(Isolate* isolate);


  static ExternalReference re_word_character_map();





  static void set_redirector(Isolate* isolate,
                             ExternalReferenceRedirector* redirector) {

    do { if ((!(isolate->external_reference_redirector() == 0))) { V8_Fatal(".././src/assembler.h", 1075, "Check failed: %s.", "isolate->external_reference_redirector() == 0"); } } while (0);
    isolate->set_external_reference_redirector(
        reinterpret_cast<ExternalReferenceRedirectorPointer*>(redirector));
  }

  static ExternalReference stress_deopt_count(Isolate* isolate);

  static ExternalReference fixed_typed_array_base_data_offset();


  static ExternalReference ebcdic_to_ascii_table();

  static ExternalReference ascii_to_ebcdic_table();

 private:
  explicit ExternalReference(void* address)
      : address_(address) {}

  static void* Redirect(Isolate* isolate,
                        Address address_arg,
                        Type type = ExternalReference::BUILTIN_CALL) {
    ExternalReferenceRedirector* redirector =
        reinterpret_cast<ExternalReferenceRedirector*>(
            isolate->external_reference_redirector());
    void* address = reinterpret_cast<void*>(address_arg);
    void* answer =
        (redirector == 0) ? address : (*redirector)(isolate, address, type);
    return answer;
  }

  void* address_;
};

bool operator==(ExternalReference, ExternalReference);
bool operator!=(ExternalReference, ExternalReference);

size_t hash_value(ExternalReference);

std::ostream& operator<<(std::ostream&, ExternalReference);





struct PositionState {
  PositionState() : current_position(RelocInfo::kNoPosition),
                    written_position(RelocInfo::kNoPosition),
                    current_statement_position(RelocInfo::kNoPosition),
                    written_statement_position(RelocInfo::kNoPosition) {}

  int current_position;
  int written_position;

  int current_statement_position;
  int written_statement_position;
};

class AssemblerPositionsRecorder : public PositionsRecorder {
 public:
  explicit AssemblerPositionsRecorder(Assembler* assembler)
      : assembler_(assembler) {}


  void RecordPosition(int pos);


  void RecordStatementPosition(int pos);


  bool WriteRecordedPositions();

  int current_position() const { return state_.current_position; }

  int current_statement_position() const {
    return state_.current_statement_position;
  }

 private:
  Assembler* assembler_;
  PositionState state_;

  AssemblerPositionsRecorder(const AssemblerPositionsRecorder&) = delete; void operator=(const AssemblerPositionsRecorder&) = delete;
};





inline int NumberOfBitsSet(uint32_t x) {
  unsigned int num_bits_set;
  for (num_bits_set = 0; x; x >>= 1) {
    num_bits_set += x & 1;
  }
  return num_bits_set;
}


double power_helper(Isolate* isolate, double x, double y);
double power_double_int(double x, int y);
double power_double_double(double x, double y);




class CallWrapper {
 public:
  CallWrapper() { }
  virtual ~CallWrapper() { }


  virtual void BeforeCall(int call_size) const = 0;

  virtual void AfterCall() const = 0;

  virtual bool NeedsDebugStepCheck() const { return false; }
};


class NullCallWrapper : public CallWrapper {
 public:
  NullCallWrapper() { }
  virtual ~NullCallWrapper() { }
  virtual void BeforeCall(int call_size) const { }
  virtual void AfterCall() const { }
};


class CheckDebugStepCallWrapper : public CallWrapper {
 public:
  CheckDebugStepCallWrapper() {}
  virtual ~CheckDebugStepCallWrapper() {}
  virtual void BeforeCall(int call_size) const {}
  virtual void AfterCall() const {}
  virtual bool NeedsDebugStepCheck() const { return true; }
};





class ConstantPoolEntry {
 public:
  ConstantPoolEntry() {}
  ConstantPoolEntry(int position, intptr_t value, bool sharing_ok)
      : position_(position),
        merged_index_(sharing_ok ? SHARING_ALLOWED : SHARING_PROHIBITED),
        value_(value) {}
  ConstantPoolEntry(int position, double value)
      : position_(position), merged_index_(SHARING_ALLOWED), value64_(value) {}

  int position() const { return position_; }
  bool sharing_ok() const { return merged_index_ != SHARING_PROHIBITED; }
  bool is_merged() const { return merged_index_ >= 0; }
  int merged_index(void) const {
    do { if ((!(is_merged()))) { V8_Fatal(".././src/assembler.h", 1229, "Check failed: %s.", "is_merged()"); } } while (0);
    return merged_index_;
  }
  void set_merged_index(int index) {
    merged_index_ = index;
    do { if ((!(is_merged()))) { V8_Fatal(".././src/assembler.h", 1234, "Check failed: %s.", "is_merged()"); } } while (0);
  }
  int offset(void) const {
    do { if ((!(merged_index_ >= 0))) { V8_Fatal(".././src/assembler.h", 1237, "Check failed: %s.", "merged_index_ >= 0"); } } while (0);
    return merged_index_;
  }
  void set_offset(int offset) {
    do { if ((!(offset >= 0))) { V8_Fatal(".././src/assembler.h", 1241, "Check failed: %s.", "offset >= 0"); } } while (0);
    merged_index_ = offset;
  }
  intptr_t value() const { return value_; }
  uint64_t value64() const { return bit_cast<uint64_t>(value64_); }

  enum Type { INTPTR, DOUBLE, NUMBER_OF_TYPES };

  static int size(Type type) {
    return (type == INTPTR) ? kPointerSize : kDoubleSize;
  }

  enum Access { REGULAR, OVERFLOWED };

 private:
  int position_;
  int merged_index_;
  union {
    intptr_t value_;
    double value64_;
  };
  enum { SHARING_PROHIBITED = -2, SHARING_ALLOWED = -1 };
};





class ConstantPoolBuilder : public Embedded {
 public:
  ConstantPoolBuilder(int ptr_reach_bits, int double_reach_bits);


  ConstantPoolEntry::Access AddEntry(int position, intptr_t value,
                                     bool sharing_ok) {
    ConstantPoolEntry entry(position, value, sharing_ok);
    return AddEntry(entry, ConstantPoolEntry::INTPTR);
  }


  ConstantPoolEntry::Access AddEntry(int position, double value) {
    ConstantPoolEntry entry(position, value);
    return AddEntry(entry, ConstantPoolEntry::DOUBLE);
  }


  ConstantPoolEntry::Access NextAccess(ConstantPoolEntry::Type type) const;

  bool IsEmpty() {
    return info_[ConstantPoolEntry::INTPTR].entries.empty() &&
           info_[ConstantPoolEntry::INTPTR].shared_entries.empty() &&
           info_[ConstantPoolEntry::DOUBLE].entries.empty() &&
           info_[ConstantPoolEntry::DOUBLE].shared_entries.empty();
  }




  int Emit(Assembler* assm);





  inline Label* EmittedPosition() { return &emitted_label_; }

 private:
  ConstantPoolEntry::Access AddEntry(ConstantPoolEntry& entry,
                                     ConstantPoolEntry::Type type);
  void EmitSharedEntries(Assembler* assm, ConstantPoolEntry::Type type);
  void EmitGroup(Assembler* assm, ConstantPoolEntry::Access access,
                 ConstantPoolEntry::Type type);

  struct PerTypeEntryInfo {
    PerTypeEntryInfo() : regular_count(0), overflow_start(-1) {}
    bool overflow() const {
      return (overflow_start >= 0 &&
              overflow_start < static_cast<int>(entries.size()));
    }
    int regular_reach_bits;
    int regular_count;
    int overflow_start;
    std::vector<ConstantPoolEntry> entries;
    std::vector<ConstantPoolEntry> shared_entries;
  };

  Label emitted_label_;
  PerTypeEntryInfo info_[ConstantPoolEntry::NUMBER_OF_TYPES];
};

}
}


namespace v8 {
namespace internal {


template<typename T, class P>
void List<T, P>::Add(const T& element, P alloc) {
  if (length_ < capacity_) {
    data_[length_++] = element;
  } else {
    List<T, P>::ResizeAdd(element, alloc);
  }
}


template<typename T, class P>
void List<T, P>::AddAll(const List<T, P>& other, P alloc) {
  AddAll(other.ToVector(), alloc);
}


template<typename T, class P>
void List<T, P>::AddAll(const Vector<T>& other, P alloc) {
  int result_length = length_ + other.length();
  if (capacity_ < result_length) Resize(result_length, alloc);
  if (base::is_fundamental<T>()) {
    memcpy(data_ + length_, other.start(), sizeof(*data_) * other.length());
  } else {
    for (int i = 0; i < other.length(); i++) data_[length_ + i] = other.at(i);
  }
  length_ = result_length;
}




template<typename T, class P>
void List<T, P>::ResizeAdd(const T& element, P alloc) {
  ResizeAddInternal(element, alloc);
}


template<typename T, class P>
void List<T, P>::ResizeAddInternal(const T& element, P alloc) {
  do { if ((!(length_ >= capacity_))) { V8_Fatal(".././src/list-inl.h", 56, "Check failed: %s.", "length_ >= capacity_"); } } while (0);


  int new_capacity = 1 + 2 * capacity_;


  T temp = element;
  Resize(new_capacity, alloc);
  data_[length_++] = temp;
}


template<typename T, class P>
void List<T, P>::Resize(int new_capacity, P alloc) {
  do { if (std::string* _msg = ::v8::base::CheckLEImpl( (length_), (new_capacity), "length_" " " "<=" " " "new_capacity")) { V8_Fatal(".././src/list-inl.h", 70, "Check failed: %s.", _msg->c_str()); delete _msg; } } while (0);
  T* new_data = NewData(new_capacity, alloc);
  MemCopy(new_data, data_, length_ * sizeof(T));
  List<T, P>::DeleteData(data_);
  data_ = new_data;
  capacity_ = new_capacity;
}


template<typename T, class P>
Vector<T> List<T, P>::AddBlock(T value, int count, P alloc) {
  int start = length_;
  for (int i = 0; i < count; i++) Add(value, alloc);
  return Vector<T>(&data_[start], count);
}


template<typename T, class P>
void List<T, P>::Set(int index, const T& elm) {
  do { if ((!(index >= 0 && index <= length_))) { V8_Fatal(".././src/list-inl.h", 89, "Check failed: %s.", "index >= 0 && index <= length_"); } } while (0);
  data_[index] = elm;
}


template<typename T, class P>
void List<T, P>::InsertAt(int index, const T& elm, P alloc) {
  do { if ((!(index >= 0 && index <= length_))) { V8_Fatal(".././src/list-inl.h", 96, "Check failed: %s.", "index >= 0 && index <= length_"); } } while (0);
  Add(elm, alloc);
  for (int i = length_ - 1; i > index; --i) {
    data_[i] = data_[i - 1];
  }
  data_[index] = elm;
}


template<typename T, class P>
T List<T, P>::Remove(int i) {
  T element = at(i);
  length_--;
  while (i < length_) {
    data_[i] = data_[i + 1];
    i++;
  }
  return element;
}


template<typename T, class P>
bool List<T, P>::RemoveElement(const T& elm) {
  for (int i = 0; i < length_; i++) {
    if (data_[i] == elm) {
      Remove(i);
      return true;
    }
  }
  return false;
}

template <typename T, class P>
void List<T, P>::Swap(List<T, P>* list) {
  std::swap(data_, list->data_);
  std::swap(length_, list->length_);
  std::swap(capacity_, list->capacity_);
}

template<typename T, class P>
void List<T, P>::Allocate(int length, P allocator) {
  DeleteData(data_);
  Initialize(length, allocator);
  length_ = length;
}


template<typename T, class P>
void List<T, P>::Clear() {
  DeleteData(data_);


  data_ = 0;
  capacity_ = 0;
  length_ = 0;
}


template<typename T, class P>
void List<T, P>::Rewind(int pos) {
  do { if ((!(0 <= pos && pos <= length_))) { V8_Fatal(".././src/list-inl.h", 156, "Check failed: %s.", "0 <= pos && pos <= length_"); } } while (0);
  length_ = pos;
}


template<typename T, class P>
void List<T, P>::Trim(P alloc) {
  if (length_ < capacity_ / 4) {
    Resize(capacity_ / 2, alloc);
  }
}


template<typename T, class P>
void List<T, P>::Iterate(void (*callback)(T* x)) {
  for (int i = 0; i < length_; i++) callback(&data_[i]);
}


template<typename T, class P>
template<class Visitor>
void List<T, P>::Iterate(Visitor* visitor) {
  for (int i = 0; i < length_; i++) visitor->Apply(&data_[i]);
}


template<typename T, class P>
bool List<T, P>::Contains(const T& elm) const {
  for (int i = 0; i < length_; i++) {
    if (data_[i] == elm)
      return true;
  }
  return false;
}


template<typename T, class P>
int List<T, P>::CountOccurrences(const T& elm, int start, int end) const {
  int result = 0;
  for (int i = start; i <= end; i++) {
    if (data_[i] == elm) ++result;
  }
  return result;
}


template <typename T, class P>
template <typename CompareFunction>
void List<T, P>::Sort(CompareFunction cmp) {
  Sort(cmp, 0, length_);
}


template <typename T, class P>
template <typename CompareFunction>
void List<T, P>::Sort(CompareFunction cmp, size_t s, size_t l) {
  ToVector().Sort(cmp, s, l);

  for (size_t i = s + 1; i < l; i++) do { if ((!(cmp(&data_[i - 1], &data_[i]) <= 0))) { V8_Fatal(".././src/list-inl.h", 214, "Check failed: %s.", "cmp(&data_[i - 1], &data_[i]) <= 0"); } } while (0);

}


template<typename T, class P>
void List<T, P>::Sort() {
  ToVector().Sort();
}


template <typename T, class P>
template <typename CompareFunction>
void List<T, P>::StableSort(CompareFunction cmp) {
  StableSort(cmp, 0, length_);
}


template <typename T, class P>
template <typename CompareFunction>
void List<T, P>::StableSort(CompareFunction cmp, size_t s, size_t l) {
  ToVector().StableSort(cmp, s, l);

  for (size_t i = s + 1; i < l; i++) do { if ((!(cmp(&data_[i - 1], &data_[i]) <= 0))) { V8_Fatal(".././src/list-inl.h", 237, "Check failed: %s.", "cmp(&data_[i - 1], &data_[i]) <= 0"); } } while (0);

}


template <typename T, class P>
void List<T, P>::StableSort() {
  ToVector().StableSort();
}


template <typename T, typename P>
int SortedListBSearch(const List<T>& list, P cmp) {
  int low = 0;
  int high = list.length() - 1;
  while (low <= high) {
    int mid = low + (high - low) / 2;
    T mid_elem = list[mid];

    if (cmp(&mid_elem) > 0) {
      high = mid - 1;
      continue;
    }
    if (cmp(&mid_elem) < 0) {
      low = mid + 1;
      continue;
    }

    return mid;
  }
  return -1;
}


template<typename T>
class ElementCmp {
 public:
  explicit ElementCmp(T e) : elem_(e) {}
  int operator()(const T* other) {
    return PointerValueCompare(other, &elem_);
  }
 private:
  T elem_;
};


template <typename T>
int SortedListBSearch(const List<T>& list, T elem) {
  return SortedListBSearch<T, ElementCmp<T> > (list, ElementCmp<T>(elem));
}


}
}
namespace v8 {
namespace internal {


class OFStreamBase : public std::streambuf {
 public:
  explicit OFStreamBase(FILE* f);
  virtual ~OFStreamBase();

 protected:
  FILE* const f_;

  virtual int sync();
  virtual int_type overflow(int_type c);
  virtual std::streamsize xsputn(const char* s, std::streamsize n);
};



class OFStream : public std::ostream {
 public:
  explicit OFStream(FILE* f);
  virtual ~OFStream();

 private:
  OFStreamBase buf_;
};



struct AsUC16 {
  explicit AsUC16(uint16_t v) : value(v) {}
  uint16_t value;
};


struct AsUC32 {
  explicit AsUC32(int32_t v) : value(v) {}
  int32_t value;
};


struct AsReversiblyEscapedUC16 {
  explicit AsReversiblyEscapedUC16(uint16_t v) : value(v) {}
  uint16_t value;
};

struct AsEscapedUC16ForJSON {
  explicit AsEscapedUC16ForJSON(uint16_t v) : value(v) {}
  uint16_t value;
};





std::ostream& operator<<(std::ostream& os, const AsReversiblyEscapedUC16& c);


std::ostream& operator<<(std::ostream& os, const AsEscapedUC16ForJSON& c);



std::ostream& operator<<(std::ostream& os, const AsUC16& c);



std::ostream& operator<<(std::ostream& os, const AsUC32& c);

}
}


#pragma convert("ISO8859-1")
namespace v8 {
namespace internal {




bool FLAG_experimental_extras = false;



bool FLAG_use_strict = false;

bool FLAG_es_staging = false;

bool FLAG_harmony = false;
bool FLAG_harmony_shipping = true;


bool FLAG_promise_extra = true;
bool FLAG_harmony_object_observe = false; bool FLAG_harmony_function_sent = false; bool FLAG_harmony_sharedarraybuffer = false; bool FLAG_harmony_simd = false; bool FLAG_harmony_do_expressions = false; bool FLAG_harmony_regexp_property = false; bool FLAG_harmony_string_padding = false;





bool FLAG_harmony_regexp_lookbehind = false; bool FLAG_harmony_tailcalls = false; bool FLAG_harmony_object_values_entries = false; bool FLAG_harmony_object_own_property_descriptors = false; bool FLAG_harmony_exponentiation_operator = false;





bool FLAG_harmony_array_prototype_values = true; bool FLAG_harmony_function_name = true; bool FLAG_harmony_instanceof = true; bool FLAG_harmony_iterator_close = true; bool FLAG_harmony_unicode_regexps = true; bool FLAG_harmony_regexp_exec = true; bool FLAG_harmony_sloppy = true; bool FLAG_harmony_sloppy_let = true; bool FLAG_harmony_sloppy_function = true; bool FLAG_harmony_regexp_subclass = true; bool FLAG_harmony_restrictive_declarations = true; bool FLAG_harmony_species = true;
bool FLAG_compiled_keyed_generic_loads = false;

bool FLAG_allocation_site_pretenuring = true;

bool FLAG_trace_pretenuring = false;

bool FLAG_trace_pretenuring_statistics = false;

bool FLAG_track_fields = true;
bool FLAG_track_double_fields = true;
bool FLAG_track_heap_object_fields = true;
bool FLAG_track_computed_fields = true;
bool FLAG_harmony_instanceof_opt = true;



bool FLAG_track_field_types = true;


bool FLAG_smi_binop = true;


bool FLAG_optimize_for_size = false;






bool FLAG_unbox_double_arrays = true;
bool FLAG_string_slices = true;


bool FLAG_ignition = false;
bool FLAG_ignition_eager = true;
const char* FLAG_ignition_filter = "*";
bool FLAG_print_bytecode = false;

bool FLAG_trace_ignition = false;

bool FLAG_trace_ignition_codegen = false;



bool FLAG_crankshaft = false;
const char* FLAG_hydrogen_filter = "*";
bool FLAG_use_gvn = true;
int FLAG_gvn_iterations = 3;
bool FLAG_use_canonicalizing = true;
bool FLAG_use_inlining = true;
bool FLAG_use_escape_analysis = true;
bool FLAG_use_allocation_folding = true;
bool FLAG_use_local_allocation_folding = false;
bool FLAG_use_write_barrier_elimination = true;

int FLAG_max_inlining_levels = 5;
int FLAG_max_inlined_source_size = 600;

int FLAG_max_inlined_nodes = 196;

int FLAG_max_inlined_nodes_cumulative = 400;

bool FLAG_loop_invariant_code_motion = true;
bool FLAG_fast_math = true;
bool FLAG_collect_megamorphic_maps_from_stub_cache = false;

bool FLAG_hydrogen_stats = false;
bool FLAG_trace_check_elimination = false;
bool FLAG_trace_environment_liveness = false;

bool FLAG_trace_hydrogen = false;
const char* FLAG_trace_hydrogen_filter = "*";
bool FLAG_trace_hydrogen_stubs = false;
const char* FLAG_trace_hydrogen_file = 0;
const char* FLAG_trace_phase = "HLZ";
bool FLAG_trace_inlining = false;
bool FLAG_trace_load_elimination = false;
bool FLAG_trace_store_elimination = false;
bool FLAG_trace_alloc = false;
bool FLAG_trace_all_uses = false;
bool FLAG_trace_range = false;
bool FLAG_trace_gvn = false;
bool FLAG_trace_representation = false;
bool FLAG_trace_removable_simulates = false;
bool FLAG_trace_escape_analysis = false;
bool FLAG_trace_allocation_folding = false;
bool FLAG_trace_track_allocation_sites = false;

bool FLAG_trace_migration = false;
bool FLAG_trace_generalization = false;
bool FLAG_stress_pointer_maps = false;
bool FLAG_stress_environments = false;
int FLAG_deopt_every_n_times = 0;

int FLAG_deopt_every_n_garbage_collections = 0;

bool FLAG_print_deopt_stress = false;
bool FLAG_trap_on_deopt = false;
bool FLAG_trap_on_stub_deopt = false;

bool FLAG_deoptimize_uncommon_cases = true;
bool FLAG_polymorphic_inlining = true;
bool FLAG_use_osr = true;
bool FLAG_array_bounds_checks_elimination = true;

bool FLAG_trace_bce = false;
bool FLAG_array_index_dehoisting = true;
bool FLAG_analyze_environment_liveness = true;

bool FLAG_load_elimination = true;
bool FLAG_check_elimination = true;
bool FLAG_store_elimination = false;
bool FLAG_dead_code_elimination = true;
bool FLAG_fold_constants = true;
bool FLAG_trace_dead_code_elimination = false;
bool FLAG_unreachable_code_elimination = true;
bool FLAG_trace_osr = false;
int FLAG_stress_runs = 0;
bool FLAG_lookup_sample_by_shared = true;


bool FLAG_flush_optimized_code_cache = false;

bool FLAG_inline_construct = true;
bool FLAG_inline_arguments = true;
bool FLAG_inline_accessors = true;
int FLAG_escape_analysis_iterations = 2;


bool FLAG_concurrent_recompilation = true;

bool FLAG_trace_concurrent_recompilation = false;

int FLAG_concurrent_recompilation_queue_length = 8;

int FLAG_concurrent_recompilation_delay = 0;

bool FLAG_block_concurrent_recompilation = false;


bool FLAG_omit_map_checks_for_leaf_maps = true;




bool FLAG_turbo = false;

bool FLAG_turbo_shipping = true;
bool FLAG_turbo_greedy_regalloc = false;
bool FLAG_turbo_sp_frame_access = false;

bool FLAG_turbo_preprocess_ranges = true;

bool FLAG_turbo_loop_stackcheck = true;
const char* FLAG_turbo_filter = "~~";
bool FLAG_trace_turbo = false;
bool FLAG_trace_turbo_graph = false;

const char* FLAG_trace_turbo_cfg_file = 0;

bool FLAG_trace_turbo_types = true;
bool FLAG_trace_turbo_scheduler = false;
bool FLAG_trace_turbo_reduction = false;
bool FLAG_trace_turbo_jt = false;
bool FLAG_trace_turbo_ceq = false;
bool FLAG_turbo_asm = true;
bool FLAG_turbo_asm_deoptimization = false;

bool FLAG_turbo_verify = true;
bool FLAG_turbo_stats = false;
bool FLAG_turbo_splitting = true;
bool FLAG_turbo_types = true;
bool FLAG_turbo_source_positions = false;


bool FLAG_function_context_specialization = false;

bool FLAG_native_context_specialization = true;

bool FLAG_turbo_inlining = true;
bool FLAG_trace_turbo_inlining = false;
bool FLAG_loop_assignment_analysis = true;
bool FLAG_turbo_profiling = false;
bool FLAG_turbo_verify_allocation = true;

bool FLAG_turbo_move_optimization = true;
bool FLAG_turbo_jt = true;
bool FLAG_turbo_osr = true;
bool FLAG_turbo_stress_loop_peeling = false;

bool FLAG_turbo_cf_optimization = true;
bool FLAG_turbo_frame_elision = true;
bool FLAG_turbo_cache_shared_code = true;
bool FLAG_turbo_preserve_shared_code = false;
bool FLAG_turbo_escape = false;
bool FLAG_turbo_instruction_scheduling = false;

bool FLAG_turbo_stress_instruction_scheduling = false;



bool FLAG_expose_wasm = false;
bool FLAG_trace_wasm_encoder = false;
bool FLAG_trace_wasm_decoder = false;
bool FLAG_trace_wasm_decode_time = false;
bool FLAG_trace_wasm_compiler = false;
int FLAG_trace_wasm_ast_start = 0;

int FLAG_trace_wasm_ast_end = 0;
int FLAG_skip_compiling_wasm_funcs = 0;
bool FLAG_wasm_break_on_decoder_error = false;

bool FLAG_wasm_loop_assignment_analysis = true;


bool FLAG_enable_simd_asmjs = false;

bool FLAG_dump_wasm_module = false;
const char* FLAG_dump_wasm_module_path = 0;

int FLAG_typed_array_max_size_in_heap = 64;



int FLAG_frame_count = 1;

int FLAG_interrupt_budget = 0x1800;

int FLAG_type_info_threshold = 25;

int FLAG_generic_ic_threshold = 30;

int FLAG_self_opt_count = 130;

bool FLAG_trace_opt_verbose = false;



bool FLAG_debug_code = false;
bool FLAG_code_comments = false;
bool FLAG_enable_sse3 = true;
bool FLAG_enable_sse4_1 = true;

bool FLAG_enable_sahf = true;

bool FLAG_enable_avx = true;
bool FLAG_enable_fma3 = true;
bool FLAG_enable_bmi1 = true;
bool FLAG_enable_bmi2 = true;
bool FLAG_enable_lzcnt = true;
bool FLAG_enable_popcnt = true;

bool FLAG_enable_vfp3 = true;

bool FLAG_enable_armv7 = true;

bool FLAG_enable_armv8 = true;

bool FLAG_enable_neon = true;

bool FLAG_enable_sudiv = true;

bool FLAG_enable_mls = true;

bool FLAG_enable_movw_movt = false;


bool FLAG_enable_unaligned_accesses = true;

bool FLAG_enable_32dregs = true;

bool FLAG_enable_vldr_imm = false;

bool FLAG_force_long_branches = false;

const char* FLAG_mcpu = "auto";
const char* FLAG_expose_natives_as = 0;
const char* FLAG_expose_debug_as = 0;
bool FLAG_expose_free_buffer = false;
bool FLAG_expose_gc = false;
const char* FLAG_expose_gc_as = 0;


bool FLAG_expose_externalize_string = false;

bool FLAG_expose_trigger_failure = false;
int FLAG_stack_trace_limit = 10;
bool FLAG_builtins_in_stack_traces = false;

bool FLAG_disable_native_files = false;


bool FLAG_inline_new = true;


bool FLAG_trace_codegen = false;

bool FLAG_trace = false;
bool FLAG_mask_constants_with_cookie = true;



bool FLAG_lazy = true;
bool FLAG_trace_opt = false;
bool FLAG_trace_opt_stats = false;
bool FLAG_opt = true;
bool FLAG_always_opt = false;
bool FLAG_always_osr = false;
bool FLAG_prepare_always_opt = false;
bool FLAG_trace_deopt = false;
bool FLAG_trace_stub_failures = false;


bool FLAG_serialize_toplevel = true;
bool FLAG_serialize_eager = false;
bool FLAG_serialize_age_code = false;
bool FLAG_trace_serializer = false;


int FLAG_min_preparse_length = 1024;

int FLAG_max_opt_count = 10;



bool FLAG_compilation_cache = true;

bool FLAG_cache_prototype_transitions = true;


int FLAG_cpu_profiler_sampling_interval = 1000;



bool FLAG_trace_js_array_abuse = false;

bool FLAG_trace_external_array_abuse = false;

bool FLAG_trace_array_abuse = false;





bool FLAG_trace_debug_json = false;
bool FLAG_enable_liveedit = true;
bool FLAG_hard_abort = true;


int FLAG_stack_size = 984;



int FLAG_max_stack_trace_source_length = 300;



bool FLAG_always_inline_smi_code = false;

bool FLAG_verify_operand_stack_depth = false;




int FLAG_min_semi_space_size = 0;


int FLAG_max_semi_space_size = 0;


int FLAG_semi_space_growth_factor = 2;
bool FLAG_experimental_new_space_growth_heuristic = false;


int FLAG_max_old_space_size = 0;
int FLAG_initial_old_space_size = 0;
int FLAG_max_executable_size = 0;
bool FLAG_gc_global = false;
int FLAG_gc_interval = -1;
int FLAG_retain_maps_for_n_gc = 2;

bool FLAG_trace_gc = false;

bool FLAG_trace_gc_nvp = false;


bool FLAG_trace_gc_ignore_scavenger = false;

bool FLAG_trace_idle_notification = false;

bool FLAG_trace_idle_notification_verbose = false;

bool FLAG_print_cumulative_gc_stat = false;

bool FLAG_print_max_heap_committed = false;


bool FLAG_trace_gc_verbose = false;

int FLAG_trace_allocation_stack_interval = -1;

bool FLAG_trace_fragmentation = false;
bool FLAG_trace_fragmentation_verbose = false;

bool FLAG_trace_evacuation = false;
bool FLAG_trace_mutator_utilization = false;

bool FLAG_weak_embedded_maps_in_optimized_code = true;

bool FLAG_weak_embedded_objects_in_optimized_code = true;

bool FLAG_flush_code = true;
bool FLAG_trace_code_flushing = false;
bool FLAG_age_code = true;


bool FLAG_incremental_marking = true;
int FLAG_min_progress_during_incremental_marking_finalization = 32;


int FLAG_max_incremental_marking_finalization_rounds = 3;

bool FLAG_black_allocation = true;
bool FLAG_concurrent_sweeping = true;
bool FLAG_parallel_compaction = true;
bool FLAG_parallel_pointer_update = true;

bool FLAG_trace_incremental_marking = false;

bool FLAG_track_gc_object_stats = false;

bool FLAG_trace_gc_object_stats = false;


bool FLAG_track_detached_contexts = true;

bool FLAG_trace_detached_contexts = false;



bool FLAG_verify_heap = false;

bool FLAG_move_object_start = true;
bool FLAG_memory_reducer = true;
bool FLAG_scavenge_reclaim_unmodified_objects = true;

int FLAG_heap_growing_percent = 0;



int FLAG_histogram_interval = 600000;



bool FLAG_trace_object_groups = false;



bool FLAG_heap_profiler_trace_objects = false;




bool FLAG_sampling_heap_profiler_suppress_randomness = false;




bool FLAG_use_idle_notification = true;


bool FLAG_use_ic = true;
bool FLAG_trace_ic = false;


bool FLAG_native_code_counters = false;



bool FLAG_always_compact = false;
bool FLAG_never_compact = false;

bool FLAG_compact_code_space = true;
bool FLAG_cleanup_code_caches_at_gc = true;


bool FLAG_use_marking_progress_bar = true;


bool FLAG_zap_code_space = true;

int FLAG_random_seed = 0;




bool FLAG_trace_weak_arrays = false;
bool FLAG_track_prototype_users = false;

bool FLAG_trace_prototype_users = false;

bool FLAG_eliminate_prototype_chain_checks = true;


bool FLAG_use_verbose_printer = true;
bool FLAG_trace_for_in_enumerate = false;

bool FLAG_trace_maps = false;



bool FLAG_allow_natives_syntax = false;
bool FLAG_trace_parse = false;


bool FLAG_trace_sim = false;
bool FLAG_debug_sim = false;
bool FLAG_check_icache = false;

int FLAG_stop_sim_at = 0;






int FLAG_sim_stack_alignment = 8;


int FLAG_sim_stack_size = 2 * MB / KB;


bool FLAG_log_regs_modified = true;

bool FLAG_log_colour = true;

bool FLAG_ignore_asm_unimplemented_break = false;

bool FLAG_trace_sim_messages = false;



bool FLAG_stack_trace_on_illegal = false;

bool FLAG_abort_on_uncaught_exception = false;

bool FLAG_randomize_hashes = true;


int FLAG_hash_seed = 0;




bool FLAG_runtime_call_stats = false;


bool FLAG_profile_deserialization = false;

bool FLAG_serialization_statistics = false;



bool FLAG_regexp_optimization = true;


bool FLAG_testing_bool_flag = true;
MaybeBoolFlag FLAG_testing_maybe_bool_flag = {false , false};
int FLAG_testing_int_flag = 13;
double FLAG_testing_float_flag = 2.5;
const char* FLAG_testing_string_flag = "Hello, world!";
int FLAG_testing_prng_seed = 42;




const char* FLAG_testing_serialization_file = "/tmp/serdes";




const char* FLAG_startup_src = 0;

const char* FLAG_startup_blob = 0;



bool FLAG_profile_hydrogen_code_stub_compilation = false;


bool FLAG_predictable = false;






bool FLAG_force_marking_deque_overflows = false;



bool FLAG_stress_compaction = false;



bool FLAG_manual_evacuation_candidates_selection = false;




int FLAG_external_allocation_limit_incremental_time = 1;



bool FLAG_disable_old_api_accessors = false;







bool FLAG_help = false;
bool FLAG_dump_counters = false;

const char* FLAG_map_counters = "";
JSArguments FLAG_js_arguments = {0 , 0};
bool FLAG_enable_slow_asserts = false;




bool FLAG_print_source = false;
bool FLAG_print_builtin_source = false;

bool FLAG_print_ast = false;
bool FLAG_print_builtin_ast = false;
bool FLAG_trap_on_abort = false;


bool FLAG_print_builtin_scopes = false;
bool FLAG_print_scopes = false;


bool FLAG_trace_contexts = false;


bool FLAG_gc_verbose = false;
bool FLAG_heap_stats = false;
bool FLAG_code_stats = false;
bool FLAG_print_handles = false;
bool FLAG_check_handle_count = false;

bool FLAG_print_global_handles = false;


bool FLAG_print_turbo_replay = false;

bool FLAG_trace_turbo_escape = false;


bool FLAG_trace_normalization = false;



bool FLAG_trace_lazy = false;


bool FLAG_collect_heap_spill_statistics = false;


bool FLAG_trace_live_bytes = false;


bool FLAG_trace_isolates = false;


bool FLAG_regexp_possessive_quantifier = false;

bool FLAG_trace_regexp_bytecodes = false;
bool FLAG_trace_regexp_assembler = false;

bool FLAG_trace_regexp_parser = false;


bool FLAG_print_break_location = false;
bool FLAG_log = false;

bool FLAG_log_all = false;
bool FLAG_log_api = false;
bool FLAG_log_code = false;

bool FLAG_log_gc = false;

bool FLAG_log_handles = false;
bool FLAG_log_suspect = false;
bool FLAG_prof = false;

bool FLAG_prof_cpp = false;

bool FLAG_prof_browser_mode = true;

bool FLAG_log_regexp = false;
const char* FLAG_logfile = "v8.log";
bool FLAG_logfile_per_isolate = true;
bool FLAG_ll_prof = false;
bool FLAG_perf_basic_prof = false;


bool FLAG_perf_basic_prof_only_functions = false;


bool FLAG_perf_prof = false;


bool FLAG_perf_prof_debug_info = false;

const char* FLAG_gc_fake_mmap = "/tmp/__v8_gc__";

bool FLAG_log_internal_timer_events = false;
bool FLAG_log_timer_events = false;



bool FLAG_log_instruction_stats = false;
const char* FLAG_log_instruction_file = "arm64_inst.csv";

int FLAG_log_instruction_period = 1 << 22;


bool FLAG_redirect_code_traces = false;


const char* FLAG_redirect_code_traces_to = 0;


bool FLAG_hydrogen_track_positions = false;
bool FLAG_trace_elements_transitions = false;

bool FLAG_trace_creation_allocation_sites = false;



bool FLAG_print_code_stubs = false;
bool FLAG_test_secondary_stub_cache = false;


bool FLAG_test_primary_stub_cache = false;




bool FLAG_print_code = false;
bool FLAG_print_opt_code = false;
bool FLAG_print_unopt_code = false;


bool FLAG_print_code_verbose = false;
bool FLAG_print_builtin_code = false;


bool FLAG_sodium = false;
bool FLAG_print_all_code = false;



static bool const FLAGDEFAULT_experimental_extras = false;



static bool const FLAGDEFAULT_use_strict = false;

static bool const FLAGDEFAULT_es_staging = false;

static bool const FLAGDEFAULT_harmony = false;
static bool const FLAGDEFAULT_harmony_shipping = true;


static bool const FLAGDEFAULT_promise_extra = true;
static bool const FLAGDEFAULT_harmony_object_observe = false; static bool const FLAGDEFAULT_harmony_function_sent = false; static bool const FLAGDEFAULT_harmony_sharedarraybuffer = false; static bool const FLAGDEFAULT_harmony_simd = false; static bool const FLAGDEFAULT_harmony_do_expressions = false; static bool const FLAGDEFAULT_harmony_regexp_property = false; static bool const FLAGDEFAULT_harmony_string_padding = false;





static bool const FLAGDEFAULT_harmony_regexp_lookbehind = false; static bool const FLAGDEFAULT_harmony_tailcalls = false; static bool const FLAGDEFAULT_harmony_object_values_entries = false; static bool const FLAGDEFAULT_harmony_object_own_property_descriptors = false; static bool const FLAGDEFAULT_harmony_exponentiation_operator = false;





static bool const FLAGDEFAULT_harmony_array_prototype_values = true; static bool const FLAGDEFAULT_harmony_function_name = true; static bool const FLAGDEFAULT_harmony_instanceof = true; static bool const FLAGDEFAULT_harmony_iterator_close = true; static bool const FLAGDEFAULT_harmony_unicode_regexps = true; static bool const FLAGDEFAULT_harmony_regexp_exec = true; static bool const FLAGDEFAULT_harmony_sloppy = true; static bool const FLAGDEFAULT_harmony_sloppy_let = true; static bool const FLAGDEFAULT_harmony_sloppy_function = true; static bool const FLAGDEFAULT_harmony_regexp_subclass = true; static bool const FLAGDEFAULT_harmony_restrictive_declarations = true; static bool const FLAGDEFAULT_harmony_species = true;
static bool const FLAGDEFAULT_compiled_keyed_generic_loads = false;

static bool const FLAGDEFAULT_allocation_site_pretenuring = true;

static bool const FLAGDEFAULT_trace_pretenuring = false;

static bool const FLAGDEFAULT_trace_pretenuring_statistics = false;

static bool const FLAGDEFAULT_track_fields = true;
static bool const FLAGDEFAULT_track_double_fields = true;
static bool const FLAGDEFAULT_track_heap_object_fields = true;
static bool const FLAGDEFAULT_track_computed_fields = true;
static bool const FLAGDEFAULT_harmony_instanceof_opt = true;



static bool const FLAGDEFAULT_track_field_types = true;


static bool const FLAGDEFAULT_smi_binop = true;


static bool const FLAGDEFAULT_optimize_for_size = false;






static bool const FLAGDEFAULT_unbox_double_arrays = true;
static bool const FLAGDEFAULT_string_slices = true;


static bool const FLAGDEFAULT_ignition = false;
static bool const FLAGDEFAULT_ignition_eager = true;
static const char* const FLAGDEFAULT_ignition_filter = "*";
static bool const FLAGDEFAULT_print_bytecode = false;

static bool const FLAGDEFAULT_trace_ignition = false;

static bool const FLAGDEFAULT_trace_ignition_codegen = false;



static bool const FLAGDEFAULT_crankshaft = false;
static const char* const FLAGDEFAULT_hydrogen_filter = "*";
static bool const FLAGDEFAULT_use_gvn = true;
static int const FLAGDEFAULT_gvn_iterations = 3;
static bool const FLAGDEFAULT_use_canonicalizing = true;
static bool const FLAGDEFAULT_use_inlining = true;
static bool const FLAGDEFAULT_use_escape_analysis = true;
static bool const FLAGDEFAULT_use_allocation_folding = true;
static bool const FLAGDEFAULT_use_local_allocation_folding = false;
static bool const FLAGDEFAULT_use_write_barrier_elimination = true;

static int const FLAGDEFAULT_max_inlining_levels = 5;
static int const FLAGDEFAULT_max_inlined_source_size = 600;

static int const FLAGDEFAULT_max_inlined_nodes = 196;

static int const FLAGDEFAULT_max_inlined_nodes_cumulative = 400;

static bool const FLAGDEFAULT_loop_invariant_code_motion = true;
static bool const FLAGDEFAULT_fast_math = true;
static bool const FLAGDEFAULT_collect_megamorphic_maps_from_stub_cache = false;

static bool const FLAGDEFAULT_hydrogen_stats = false;
static bool const FLAGDEFAULT_trace_check_elimination = false;
static bool const FLAGDEFAULT_trace_environment_liveness = false;

static bool const FLAGDEFAULT_trace_hydrogen = false;
static const char* const FLAGDEFAULT_trace_hydrogen_filter = "*";
static bool const FLAGDEFAULT_trace_hydrogen_stubs = false;
static const char* const FLAGDEFAULT_trace_hydrogen_file = 0;
static const char* const FLAGDEFAULT_trace_phase = "HLZ";
static bool const FLAGDEFAULT_trace_inlining = false;
static bool const FLAGDEFAULT_trace_load_elimination = false;
static bool const FLAGDEFAULT_trace_store_elimination = false;
static bool const FLAGDEFAULT_trace_alloc = false;
static bool const FLAGDEFAULT_trace_all_uses = false;
static bool const FLAGDEFAULT_trace_range = false;
static bool const FLAGDEFAULT_trace_gvn = false;
static bool const FLAGDEFAULT_trace_representation = false;
static bool const FLAGDEFAULT_trace_removable_simulates = false;
static bool const FLAGDEFAULT_trace_escape_analysis = false;
static bool const FLAGDEFAULT_trace_allocation_folding = false;
static bool const FLAGDEFAULT_trace_track_allocation_sites = false;

static bool const FLAGDEFAULT_trace_migration = false;
static bool const FLAGDEFAULT_trace_generalization = false;
static bool const FLAGDEFAULT_stress_pointer_maps = false;
static bool const FLAGDEFAULT_stress_environments = false;
static int const FLAGDEFAULT_deopt_every_n_times = 0;

static int const FLAGDEFAULT_deopt_every_n_garbage_collections = 0;

static bool const FLAGDEFAULT_print_deopt_stress = false;
static bool const FLAGDEFAULT_trap_on_deopt = false;
static bool const FLAGDEFAULT_trap_on_stub_deopt = false;

static bool const FLAGDEFAULT_deoptimize_uncommon_cases = true;
static bool const FLAGDEFAULT_polymorphic_inlining = true;
static bool const FLAGDEFAULT_use_osr = true;
static bool const FLAGDEFAULT_array_bounds_checks_elimination = true;

static bool const FLAGDEFAULT_trace_bce = false;
static bool const FLAGDEFAULT_array_index_dehoisting = true;
static bool const FLAGDEFAULT_analyze_environment_liveness = true;

static bool const FLAGDEFAULT_load_elimination = true;
static bool const FLAGDEFAULT_check_elimination = true;
static bool const FLAGDEFAULT_store_elimination = false;
static bool const FLAGDEFAULT_dead_code_elimination = true;
static bool const FLAGDEFAULT_fold_constants = true;
static bool const FLAGDEFAULT_trace_dead_code_elimination = false;
static bool const FLAGDEFAULT_unreachable_code_elimination = true;
static bool const FLAGDEFAULT_trace_osr = false;
static int const FLAGDEFAULT_stress_runs = 0;
static bool const FLAGDEFAULT_lookup_sample_by_shared = true;


static bool const FLAGDEFAULT_flush_optimized_code_cache = false;

static bool const FLAGDEFAULT_inline_construct = true;
static bool const FLAGDEFAULT_inline_arguments = true;
static bool const FLAGDEFAULT_inline_accessors = true;
static int const FLAGDEFAULT_escape_analysis_iterations = 2;


static bool const FLAGDEFAULT_concurrent_recompilation = true;

static bool const FLAGDEFAULT_trace_concurrent_recompilation = false;

static int const FLAGDEFAULT_concurrent_recompilation_queue_length = 8;

static int const FLAGDEFAULT_concurrent_recompilation_delay = 0;

static bool const FLAGDEFAULT_block_concurrent_recompilation = false;


static bool const FLAGDEFAULT_omit_map_checks_for_leaf_maps = true;




static bool const FLAGDEFAULT_turbo = false;

static bool const FLAGDEFAULT_turbo_shipping = true;
static bool const FLAGDEFAULT_turbo_greedy_regalloc = false;
static bool const FLAGDEFAULT_turbo_sp_frame_access = false;

static bool const FLAGDEFAULT_turbo_preprocess_ranges = true;

static bool const FLAGDEFAULT_turbo_loop_stackcheck = true;
static const char* const FLAGDEFAULT_turbo_filter = "~~";
static bool const FLAGDEFAULT_trace_turbo = false;
static bool const FLAGDEFAULT_trace_turbo_graph = false;

static const char* const FLAGDEFAULT_trace_turbo_cfg_file = 0;

static bool const FLAGDEFAULT_trace_turbo_types = true;
static bool const FLAGDEFAULT_trace_turbo_scheduler = false;
static bool const FLAGDEFAULT_trace_turbo_reduction = false;
static bool const FLAGDEFAULT_trace_turbo_jt = false;
static bool const FLAGDEFAULT_trace_turbo_ceq = false;
static bool const FLAGDEFAULT_turbo_asm = true;
static bool const FLAGDEFAULT_turbo_asm_deoptimization = false;

static bool const FLAGDEFAULT_turbo_verify = true;
static bool const FLAGDEFAULT_turbo_stats = false;
static bool const FLAGDEFAULT_turbo_splitting = true;
static bool const FLAGDEFAULT_turbo_types = true;
static bool const FLAGDEFAULT_turbo_source_positions = false;


static bool const FLAGDEFAULT_function_context_specialization = false;

static bool const FLAGDEFAULT_native_context_specialization = true;

static bool const FLAGDEFAULT_turbo_inlining = true;
static bool const FLAGDEFAULT_trace_turbo_inlining = false;
static bool const FLAGDEFAULT_loop_assignment_analysis = true;
static bool const FLAGDEFAULT_turbo_profiling = false;
static bool const FLAGDEFAULT_turbo_verify_allocation = true;

static bool const FLAGDEFAULT_turbo_move_optimization = true;
static bool const FLAGDEFAULT_turbo_jt = true;
static bool const FLAGDEFAULT_turbo_osr = true;
static bool const FLAGDEFAULT_turbo_stress_loop_peeling = false;

static bool const FLAGDEFAULT_turbo_cf_optimization = true;
static bool const FLAGDEFAULT_turbo_frame_elision = true;
static bool const FLAGDEFAULT_turbo_cache_shared_code = true;
static bool const FLAGDEFAULT_turbo_preserve_shared_code = false;
static bool const FLAGDEFAULT_turbo_escape = false;
static bool const FLAGDEFAULT_turbo_instruction_scheduling = false;

static bool const FLAGDEFAULT_turbo_stress_instruction_scheduling = false;



static bool const FLAGDEFAULT_expose_wasm = false;
static bool const FLAGDEFAULT_trace_wasm_encoder = false;
static bool const FLAGDEFAULT_trace_wasm_decoder = false;
static bool const FLAGDEFAULT_trace_wasm_decode_time = false;
static bool const FLAGDEFAULT_trace_wasm_compiler = false;
static int const FLAGDEFAULT_trace_wasm_ast_start = 0;

static int const FLAGDEFAULT_trace_wasm_ast_end = 0;
static int const FLAGDEFAULT_skip_compiling_wasm_funcs = 0;
static bool const FLAGDEFAULT_wasm_break_on_decoder_error = false;

static bool const FLAGDEFAULT_wasm_loop_assignment_analysis = true;


static bool const FLAGDEFAULT_enable_simd_asmjs = false;

static bool const FLAGDEFAULT_dump_wasm_module = false;
static const char* const FLAGDEFAULT_dump_wasm_module_path = 0;

static int const FLAGDEFAULT_typed_array_max_size_in_heap = 64;



static int const FLAGDEFAULT_frame_count = 1;

static int const FLAGDEFAULT_interrupt_budget = 0x1800;

static int const FLAGDEFAULT_type_info_threshold = 25;

static int const FLAGDEFAULT_generic_ic_threshold = 30;

static int const FLAGDEFAULT_self_opt_count = 130;

static bool const FLAGDEFAULT_trace_opt_verbose = false;



static bool const FLAGDEFAULT_debug_code = false;
static bool const FLAGDEFAULT_code_comments = false;
static bool const FLAGDEFAULT_enable_sse3 = true;
static bool const FLAGDEFAULT_enable_sse4_1 = true;

static bool const FLAGDEFAULT_enable_sahf = true;

static bool const FLAGDEFAULT_enable_avx = true;
static bool const FLAGDEFAULT_enable_fma3 = true;
static bool const FLAGDEFAULT_enable_bmi1 = true;
static bool const FLAGDEFAULT_enable_bmi2 = true;
static bool const FLAGDEFAULT_enable_lzcnt = true;
static bool const FLAGDEFAULT_enable_popcnt = true;

static bool const FLAGDEFAULT_enable_vfp3 = true;

static bool const FLAGDEFAULT_enable_armv7 = true;

static bool const FLAGDEFAULT_enable_armv8 = true;

static bool const FLAGDEFAULT_enable_neon = true;

static bool const FLAGDEFAULT_enable_sudiv = true;

static bool const FLAGDEFAULT_enable_mls = true;

static bool const FLAGDEFAULT_enable_movw_movt = false;


static bool const FLAGDEFAULT_enable_unaligned_accesses = true;

static bool const FLAGDEFAULT_enable_32dregs = true;

static bool const FLAGDEFAULT_enable_vldr_imm = false;

static bool const FLAGDEFAULT_force_long_branches = false;

static const char* const FLAGDEFAULT_mcpu = "auto";
static const char* const FLAGDEFAULT_expose_natives_as = 0;
static const char* const FLAGDEFAULT_expose_debug_as = 0;
static bool const FLAGDEFAULT_expose_free_buffer = false;
static bool const FLAGDEFAULT_expose_gc = false;
static const char* const FLAGDEFAULT_expose_gc_as = 0;


static bool const FLAGDEFAULT_expose_externalize_string = false;

static bool const FLAGDEFAULT_expose_trigger_failure = false;
static int const FLAGDEFAULT_stack_trace_limit = 10;
static bool const FLAGDEFAULT_builtins_in_stack_traces = false;

static bool const FLAGDEFAULT_disable_native_files = false;


static bool const FLAGDEFAULT_inline_new = true;


static bool const FLAGDEFAULT_trace_codegen = false;

static bool const FLAGDEFAULT_trace = false;
static bool const FLAGDEFAULT_mask_constants_with_cookie = true;



static bool const FLAGDEFAULT_lazy = true;
static bool const FLAGDEFAULT_trace_opt = false;
static bool const FLAGDEFAULT_trace_opt_stats = false;
static bool const FLAGDEFAULT_opt = true;
static bool const FLAGDEFAULT_always_opt = false;
static bool const FLAGDEFAULT_always_osr = false;
static bool const FLAGDEFAULT_prepare_always_opt = false;
static bool const FLAGDEFAULT_trace_deopt = false;
static bool const FLAGDEFAULT_trace_stub_failures = false;


static bool const FLAGDEFAULT_serialize_toplevel = true;
static bool const FLAGDEFAULT_serialize_eager = false;
static bool const FLAGDEFAULT_serialize_age_code = false;
static bool const FLAGDEFAULT_trace_serializer = false;


static int const FLAGDEFAULT_min_preparse_length = 1024;

static int const FLAGDEFAULT_max_opt_count = 10;



static bool const FLAGDEFAULT_compilation_cache = true;

static bool const FLAGDEFAULT_cache_prototype_transitions = true;


static int const FLAGDEFAULT_cpu_profiler_sampling_interval = 1000;



static bool const FLAGDEFAULT_trace_js_array_abuse = false;

static bool const FLAGDEFAULT_trace_external_array_abuse = false;

static bool const FLAGDEFAULT_trace_array_abuse = false;





static bool const FLAGDEFAULT_trace_debug_json = false;
static bool const FLAGDEFAULT_enable_liveedit = true;
static bool const FLAGDEFAULT_hard_abort = true;


static int const FLAGDEFAULT_stack_size = 984;



static int const FLAGDEFAULT_max_stack_trace_source_length = 300;



static bool const FLAGDEFAULT_always_inline_smi_code = false;

static bool const FLAGDEFAULT_verify_operand_stack_depth = false;




static int const FLAGDEFAULT_min_semi_space_size = 0;


static int const FLAGDEFAULT_max_semi_space_size = 0;


static int const FLAGDEFAULT_semi_space_growth_factor = 2;
static bool const FLAGDEFAULT_experimental_new_space_growth_heuristic = false;


static int const FLAGDEFAULT_max_old_space_size = 0;
static int const FLAGDEFAULT_initial_old_space_size = 0;
static int const FLAGDEFAULT_max_executable_size = 0;
static bool const FLAGDEFAULT_gc_global = false;
static int const FLAGDEFAULT_gc_interval = -1;
static int const FLAGDEFAULT_retain_maps_for_n_gc = 2;

static bool const FLAGDEFAULT_trace_gc = false;

static bool const FLAGDEFAULT_trace_gc_nvp = false;


static bool const FLAGDEFAULT_trace_gc_ignore_scavenger = false;

static bool const FLAGDEFAULT_trace_idle_notification = false;

static bool const FLAGDEFAULT_trace_idle_notification_verbose = false;

static bool const FLAGDEFAULT_print_cumulative_gc_stat = false;

static bool const FLAGDEFAULT_print_max_heap_committed = false;


static bool const FLAGDEFAULT_trace_gc_verbose = false;

static int const FLAGDEFAULT_trace_allocation_stack_interval = -1;

static bool const FLAGDEFAULT_trace_fragmentation = false;
static bool const FLAGDEFAULT_trace_fragmentation_verbose = false;

static bool const FLAGDEFAULT_trace_evacuation = false;
static bool const FLAGDEFAULT_trace_mutator_utilization = false;

static bool const FLAGDEFAULT_weak_embedded_maps_in_optimized_code = true;

static bool const FLAGDEFAULT_weak_embedded_objects_in_optimized_code = true;

static bool const FLAGDEFAULT_flush_code = true;
static bool const FLAGDEFAULT_trace_code_flushing = false;
static bool const FLAGDEFAULT_age_code = true;


static bool const FLAGDEFAULT_incremental_marking = true;
static int const FLAGDEFAULT_min_progress_during_incremental_marking_finalization = 32;


static int const FLAGDEFAULT_max_incremental_marking_finalization_rounds = 3;

static bool const FLAGDEFAULT_black_allocation = true;
static bool const FLAGDEFAULT_concurrent_sweeping = true;
static bool const FLAGDEFAULT_parallel_compaction = true;
static bool const FLAGDEFAULT_parallel_pointer_update = true;

static bool const FLAGDEFAULT_trace_incremental_marking = false;

static bool const FLAGDEFAULT_track_gc_object_stats = false;

static bool const FLAGDEFAULT_trace_gc_object_stats = false;


static bool const FLAGDEFAULT_track_detached_contexts = true;

static bool const FLAGDEFAULT_trace_detached_contexts = false;



static bool const FLAGDEFAULT_verify_heap = false;

static bool const FLAGDEFAULT_move_object_start = true;
static bool const FLAGDEFAULT_memory_reducer = true;
static bool const FLAGDEFAULT_scavenge_reclaim_unmodified_objects = true;

static int const FLAGDEFAULT_heap_growing_percent = 0;



static int const FLAGDEFAULT_histogram_interval = 600000;



static bool const FLAGDEFAULT_trace_object_groups = false;



static bool const FLAGDEFAULT_heap_profiler_trace_objects = false;




static bool const FLAGDEFAULT_sampling_heap_profiler_suppress_randomness = false;




static bool const FLAGDEFAULT_use_idle_notification = true;


static bool const FLAGDEFAULT_use_ic = true;
static bool const FLAGDEFAULT_trace_ic = false;


static bool const FLAGDEFAULT_native_code_counters = false;



static bool const FLAGDEFAULT_always_compact = false;
static bool const FLAGDEFAULT_never_compact = false;

static bool const FLAGDEFAULT_compact_code_space = true;
static bool const FLAGDEFAULT_cleanup_code_caches_at_gc = true;


static bool const FLAGDEFAULT_use_marking_progress_bar = true;


static bool const FLAGDEFAULT_zap_code_space = true;

static int const FLAGDEFAULT_random_seed = 0;




static bool const FLAGDEFAULT_trace_weak_arrays = false;
static bool const FLAGDEFAULT_track_prototype_users = false;

static bool const FLAGDEFAULT_trace_prototype_users = false;

static bool const FLAGDEFAULT_eliminate_prototype_chain_checks = true;


static bool const FLAGDEFAULT_use_verbose_printer = true;
static bool const FLAGDEFAULT_trace_for_in_enumerate = false;

static bool const FLAGDEFAULT_trace_maps = false;



static bool const FLAGDEFAULT_allow_natives_syntax = false;
static bool const FLAGDEFAULT_trace_parse = false;


static bool const FLAGDEFAULT_trace_sim = false;
static bool const FLAGDEFAULT_debug_sim = false;
static bool const FLAGDEFAULT_check_icache = false;

static int const FLAGDEFAULT_stop_sim_at = 0;






static int const FLAGDEFAULT_sim_stack_alignment = 8;


static int const FLAGDEFAULT_sim_stack_size = 2 * MB / KB;


static bool const FLAGDEFAULT_log_regs_modified = true;

static bool const FLAGDEFAULT_log_colour = true;

static bool const FLAGDEFAULT_ignore_asm_unimplemented_break = false;

static bool const FLAGDEFAULT_trace_sim_messages = false;



static bool const FLAGDEFAULT_stack_trace_on_illegal = false;

static bool const FLAGDEFAULT_abort_on_uncaught_exception = false;

static bool const FLAGDEFAULT_randomize_hashes = true;


static int const FLAGDEFAULT_hash_seed = 0;




static bool const FLAGDEFAULT_runtime_call_stats = false;


static bool const FLAGDEFAULT_profile_deserialization = false;

static bool const FLAGDEFAULT_serialization_statistics = false;



static bool const FLAGDEFAULT_regexp_optimization = true;


static bool const FLAGDEFAULT_testing_bool_flag = true;
static MaybeBoolFlag const FLAGDEFAULT_testing_maybe_bool_flag = {false , false};
static int const FLAGDEFAULT_testing_int_flag = 13;
static double const FLAGDEFAULT_testing_float_flag = 2.5;
static const char* const FLAGDEFAULT_testing_string_flag = "Hello, world!";
static int const FLAGDEFAULT_testing_prng_seed = 42;




static const char* const FLAGDEFAULT_testing_serialization_file = "/tmp/serdes";




static const char* const FLAGDEFAULT_startup_src = 0;

static const char* const FLAGDEFAULT_startup_blob = 0;



static bool const FLAGDEFAULT_profile_hydrogen_code_stub_compilation = false;


static bool const FLAGDEFAULT_predictable = false;






static bool const FLAGDEFAULT_force_marking_deque_overflows = false;



static bool const FLAGDEFAULT_stress_compaction = false;



static bool const FLAGDEFAULT_manual_evacuation_candidates_selection = false;




static int const FLAGDEFAULT_external_allocation_limit_incremental_time = 1;



static bool const FLAGDEFAULT_disable_old_api_accessors = false;







static bool const FLAGDEFAULT_help = false;
static bool const FLAGDEFAULT_dump_counters = false;

static const char* const FLAGDEFAULT_map_counters = "";
static JSArguments const FLAGDEFAULT_js_arguments = {0 , 0};
static bool const FLAGDEFAULT_enable_slow_asserts = false;




static bool const FLAGDEFAULT_print_source = false;
static bool const FLAGDEFAULT_print_builtin_source = false;

static bool const FLAGDEFAULT_print_ast = false;
static bool const FLAGDEFAULT_print_builtin_ast = false;
static bool const FLAGDEFAULT_trap_on_abort = false;


static bool const FLAGDEFAULT_print_builtin_scopes = false;
static bool const FLAGDEFAULT_print_scopes = false;


static bool const FLAGDEFAULT_trace_contexts = false;


static bool const FLAGDEFAULT_gc_verbose = false;
static bool const FLAGDEFAULT_heap_stats = false;
static bool const FLAGDEFAULT_code_stats = false;
static bool const FLAGDEFAULT_print_handles = false;
static bool const FLAGDEFAULT_check_handle_count = false;

static bool const FLAGDEFAULT_print_global_handles = false;


static bool const FLAGDEFAULT_print_turbo_replay = false;

static bool const FLAGDEFAULT_trace_turbo_escape = false;


static bool const FLAGDEFAULT_trace_normalization = false;



static bool const FLAGDEFAULT_trace_lazy = false;


static bool const FLAGDEFAULT_collect_heap_spill_statistics = false;


static bool const FLAGDEFAULT_trace_live_bytes = false;


static bool const FLAGDEFAULT_trace_isolates = false;


static bool const FLAGDEFAULT_regexp_possessive_quantifier = false;

static bool const FLAGDEFAULT_trace_regexp_bytecodes = false;
static bool const FLAGDEFAULT_trace_regexp_assembler = false;

static bool const FLAGDEFAULT_trace_regexp_parser = false;


static bool const FLAGDEFAULT_print_break_location = false;
static bool const FLAGDEFAULT_log = false;

static bool const FLAGDEFAULT_log_all = false;
static bool const FLAGDEFAULT_log_api = false;
static bool const FLAGDEFAULT_log_code = false;

static bool const FLAGDEFAULT_log_gc = false;

static bool const FLAGDEFAULT_log_handles = false;
static bool const FLAGDEFAULT_log_suspect = false;
static bool const FLAGDEFAULT_prof = false;

static bool const FLAGDEFAULT_prof_cpp = false;

static bool const FLAGDEFAULT_prof_browser_mode = true;

static bool const FLAGDEFAULT_log_regexp = false;
static const char* const FLAGDEFAULT_logfile = "v8.log";
static bool const FLAGDEFAULT_logfile_per_isolate = true;
static bool const FLAGDEFAULT_ll_prof = false;
static bool const FLAGDEFAULT_perf_basic_prof = false;


static bool const FLAGDEFAULT_perf_basic_prof_only_functions = false;


static bool const FLAGDEFAULT_perf_prof = false;


static bool const FLAGDEFAULT_perf_prof_debug_info = false;

static const char* const FLAGDEFAULT_gc_fake_mmap = "/tmp/__v8_gc__";

static bool const FLAGDEFAULT_log_internal_timer_events = false;
static bool const FLAGDEFAULT_log_timer_events = false;



static bool const FLAGDEFAULT_log_instruction_stats = false;
static const char* const FLAGDEFAULT_log_instruction_file = "arm64_inst.csv";

static int const FLAGDEFAULT_log_instruction_period = 1 << 22;


static bool const FLAGDEFAULT_redirect_code_traces = false;


static const char* const FLAGDEFAULT_redirect_code_traces_to = 0;


static bool const FLAGDEFAULT_hydrogen_track_positions = false;
static bool const FLAGDEFAULT_trace_elements_transitions = false;

static bool const FLAGDEFAULT_trace_creation_allocation_sites = false;



static bool const FLAGDEFAULT_print_code_stubs = false;
static bool const FLAGDEFAULT_test_secondary_stub_cache = false;


static bool const FLAGDEFAULT_test_primary_stub_cache = false;




static bool const FLAGDEFAULT_print_code = false;
static bool const FLAGDEFAULT_print_opt_code = false;
static bool const FLAGDEFAULT_print_unopt_code = false;


static bool const FLAGDEFAULT_print_code_verbose = false;
static bool const FLAGDEFAULT_print_builtin_code = false;


static bool const FLAGDEFAULT_sodium = false;
static bool const FLAGDEFAULT_print_all_code = false;

namespace {




struct Flag {
  enum FlagType { TYPE_BOOL, TYPE_MAYBE_BOOL, TYPE_INT, TYPE_FLOAT,
                  TYPE_STRING, TYPE_ARGS };

  FlagType type_;
  const char* name_;
  void* valptr_;
  const void* defptr_;
  const char* cmt_;
  bool owns_ptr_;

  FlagType type() const { return type_; }

  const char* name() const { return name_; }

  const char* comment() const { return cmt_; }

  bool* bool_variable() const {
    do { if ((!(type_ == TYPE_BOOL))) { V8_Fatal("../src/flags.cc", 60, "Check failed: %s.", "type_ == TYPE_BOOL"); } } while (0);
    return reinterpret_cast<bool*>(valptr_);
  }

  MaybeBoolFlag* maybe_bool_variable() const {
    do { if ((!(type_ == TYPE_MAYBE_BOOL))) { V8_Fatal("../src/flags.cc", 65, "Check failed: %s.", "type_ == TYPE_MAYBE_BOOL"); } } while (0);
    return reinterpret_cast<MaybeBoolFlag*>(valptr_);
  }

  int* int_variable() const {
    do { if ((!(type_ == TYPE_INT))) { V8_Fatal("../src/flags.cc", 70, "Check failed: %s.", "type_ == TYPE_INT"); } } while (0);
    return reinterpret_cast<int*>(valptr_);
  }

  double* float_variable() const {
    do { if ((!(type_ == TYPE_FLOAT))) { V8_Fatal("../src/flags.cc", 75, "Check failed: %s.", "type_ == TYPE_FLOAT"); } } while (0);
    return reinterpret_cast<double*>(valptr_);
  }

  const char* string_value() const {
    do { if ((!(type_ == TYPE_STRING))) { V8_Fatal("../src/flags.cc", 80, "Check failed: %s.", "type_ == TYPE_STRING"); } } while (0);
    return *reinterpret_cast<const char**>(valptr_);
  }

  void set_string_value(const char* value, bool owns_ptr) {
    do { if ((!(type_ == TYPE_STRING))) { V8_Fatal("../src/flags.cc", 85, "Check failed: %s.", "type_ == TYPE_STRING"); } } while (0);
    const char** ptr = reinterpret_cast<const char**>(valptr_);
    if (owns_ptr_ && *ptr != 0) DeleteArray(*ptr);
    *ptr = value;
    owns_ptr_ = owns_ptr;
  }

  JSArguments* args_variable() const {
    do { if ((!(type_ == TYPE_ARGS))) { V8_Fatal("../src/flags.cc", 93, "Check failed: %s.", "type_ == TYPE_ARGS"); } } while (0);
    return reinterpret_cast<JSArguments*>(valptr_);
  }

  bool bool_default() const {
    do { if ((!(type_ == TYPE_BOOL))) { V8_Fatal("../src/flags.cc", 98, "Check failed: %s.", "type_ == TYPE_BOOL"); } } while (0);
    return *reinterpret_cast<const bool*>(defptr_);
  }

  int int_default() const {
    do { if ((!(type_ == TYPE_INT))) { V8_Fatal("../src/flags.cc", 103, "Check failed: %s.", "type_ == TYPE_INT"); } } while (0);
    return *reinterpret_cast<const int*>(defptr_);
  }

  double float_default() const {
    do { if ((!(type_ == TYPE_FLOAT))) { V8_Fatal("../src/flags.cc", 108, "Check failed: %s.", "type_ == TYPE_FLOAT"); } } while (0);
    return *reinterpret_cast<const double*>(defptr_);
  }

  const char* string_default() const {
    do { if ((!(type_ == TYPE_STRING))) { V8_Fatal("../src/flags.cc", 113, "Check failed: %s.", "type_ == TYPE_STRING"); } } while (0);
    return *reinterpret_cast<const char* const *>(defptr_);
  }

  JSArguments args_default() const {
    do { if ((!(type_ == TYPE_ARGS))) { V8_Fatal("../src/flags.cc", 118, "Check failed: %s.", "type_ == TYPE_ARGS"); } } while (0);
    return *reinterpret_cast<const JSArguments*>(defptr_);
  }


  bool IsDefault() const {
    switch (type_) {
      case TYPE_BOOL:
        return *bool_variable() == bool_default();
      case TYPE_MAYBE_BOOL:
        return maybe_bool_variable()->has_value == false;
      case TYPE_INT:
        return *int_variable() == int_default();
      case TYPE_FLOAT:
        return *float_variable() == float_default();
      case TYPE_STRING: {
        const char* str1 = string_value();
        const char* str2 = string_default();
        if (str2 == 0) return str1 == 0;
        if (str1 == 0) return str2 == 0;
        return strcmp(str1, str2) == 0;
      }
      case TYPE_ARGS:
        return args_variable()->argc == 0;
    }
    V8_Fatal("../src/flags.cc", 143, "unreachable code");
    return true;
  }


  void Reset() {
    switch (type_) {
      case TYPE_BOOL:
        *bool_variable() = bool_default();
        break;
      case TYPE_MAYBE_BOOL:
        *maybe_bool_variable() = MaybeBoolFlag::Create(false, false);
        break;
      case TYPE_INT:
        *int_variable() = int_default();
        break;
      case TYPE_FLOAT:
        *float_variable() = float_default();
        break;
      case TYPE_STRING:
        set_string_value(string_default(), false);
        break;
      case TYPE_ARGS:
        *args_variable() = args_default();
        break;
    }
  }
};

Flag flags[] = {


{ Flag::TYPE_BOOL, "experimental_extras", &FLAG_experimental_extras, &FLAGDEFAULT_experimental_extras, "enable code compiled in via v8_experimental_extra_library_files", false } ,



{ Flag::TYPE_BOOL, "use_strict", &FLAG_use_strict, &FLAGDEFAULT_use_strict, "enforce strict mode", false } ,

{ Flag::TYPE_BOOL, "es_staging", &FLAG_es_staging, &FLAGDEFAULT_es_staging, "enable test-worthy harmony features (for internal use only)", false } ,

{ Flag::TYPE_BOOL, "harmony", &FLAG_harmony, &FLAGDEFAULT_harmony, "enable all completed harmony features", false } ,
{ Flag::TYPE_BOOL, "harmony_shipping", &FLAG_harmony_shipping, &FLAGDEFAULT_harmony_shipping, "enable all shipped harmony features", false } ,


{ Flag::TYPE_BOOL, "promise_extra", &FLAG_promise_extra, &FLAGDEFAULT_promise_extra, "additional V8 Promise functions", false } ,
{ Flag::TYPE_BOOL, "harmony_object_observe", &FLAG_harmony_object_observe, &FLAGDEFAULT_harmony_object_observe, u8"enable " u8"u8\"harmony Object.observe\"" u8" (in progress)", false } , { Flag::TYPE_BOOL, "harmony_function_sent", &FLAG_harmony_function_sent, &FLAGDEFAULT_harmony_function_sent, u8"enable " u8"u8\"harmony function.sent\"" u8" (in progress)", false } , { Flag::TYPE_BOOL, "harmony_sharedarraybuffer", &FLAG_harmony_sharedarraybuffer, &FLAGDEFAULT_harmony_sharedarraybuffer, u8"enable " u8"u8\"harmony sharedarraybuffer\"" u8" (in progress)", false } , { Flag::TYPE_BOOL, "harmony_simd", &FLAG_harmony_simd, &FLAGDEFAULT_harmony_simd, u8"enable " u8"u8\"harmony simd\"" u8" (in progress)", false } , { Flag::TYPE_BOOL, "harmony_do_expressions", &FLAG_harmony_do_expressions, &FLAGDEFAULT_harmony_do_expressions, u8"enable " u8"u8\"harmony do-expressions\"" u8" (in progress)", false } , { Flag::TYPE_BOOL, "harmony_regexp_property", &FLAG_harmony_regexp_property, &FLAGDEFAULT_harmony_regexp_property, u8"enable " u8"u8\"harmony unicode regexp property classes\"" u8" (in progress)", false } , { Flag::TYPE_BOOL, "harmony_string_padding", &FLAG_harmony_string_padding, &FLAGDEFAULT_harmony_string_padding, u8"enable " u8"u8\"harmony String-padding methods\"" u8" (in progress)", false } ,





{ Flag::TYPE_BOOL, "harmony_regexp_lookbehind", &FLAG_harmony_regexp_lookbehind, &FLAGDEFAULT_harmony_regexp_lookbehind, u8"enable " u8"u8\"harmony regexp lookbehind\"", false } , { Flag::TYPE_BOOL, "harmony_tailcalls", &FLAG_harmony_tailcalls, &FLAGDEFAULT_harmony_tailcalls, u8"enable " u8"u8\"harmony tail calls\"", false } , { Flag::TYPE_BOOL, "harmony_object_values_entries", &FLAG_harmony_object_values_entries, &FLAGDEFAULT_harmony_object_values_entries, u8"enable " u8"u8\"harmony Object.values / Object.entries\"", false } , { Flag::TYPE_BOOL, "harmony_object_own_property_descriptors", &FLAG_harmony_object_own_property_descriptors, &FLAGDEFAULT_harmony_object_own_property_descriptors, u8"enable " u8"u8\"harmony Object.getOwnPropertyDescriptors()\"", false } , { Flag::TYPE_BOOL, "harmony_exponentiation_operator", &FLAG_harmony_exponentiation_operator, &FLAGDEFAULT_harmony_exponentiation_operator, u8"enable " u8"u8\"harmony exponentiation operator `**`\"", false } ,





{ Flag::TYPE_BOOL, "harmony_array_prototype_values", &FLAG_harmony_array_prototype_values, &FLAGDEFAULT_harmony_array_prototype_values, u8"enable " u8"u8\"harmony Array.prototype.values\"", false } , { Flag::TYPE_BOOL, "harmony_function_name", &FLAG_harmony_function_name, &FLAGDEFAULT_harmony_function_name, u8"enable " u8"u8\"harmony Function name inference\"", false } , { Flag::TYPE_BOOL, "harmony_instanceof", &FLAG_harmony_instanceof, &FLAGDEFAULT_harmony_instanceof, u8"enable " u8"u8\"harmony instanceof support\"", false } , { Flag::TYPE_BOOL, "harmony_iterator_close", &FLAG_harmony_iterator_close, &FLAGDEFAULT_harmony_iterator_close, u8"enable " u8"u8\"harmony iterator finalization\"", false } , { Flag::TYPE_BOOL, "harmony_unicode_regexps", &FLAG_harmony_unicode_regexps, &FLAGDEFAULT_harmony_unicode_regexps, u8"enable " u8"u8\"harmony unicode regexps\"", false } , { Flag::TYPE_BOOL, "harmony_regexp_exec", &FLAG_harmony_regexp_exec, &FLAGDEFAULT_harmony_regexp_exec, u8"enable " u8"u8\"harmony RegExp exec override behavior\"", false } , { Flag::TYPE_BOOL, "harmony_sloppy", &FLAG_harmony_sloppy, &FLAGDEFAULT_harmony_sloppy, u8"enable " u8"u8\"harmony features in sloppy mode\"", false } , { Flag::TYPE_BOOL, "harmony_sloppy_let", &FLAG_harmony_sloppy_let, &FLAGDEFAULT_harmony_sloppy_let, u8"enable " u8"u8\"harmony let in sloppy mode\"", false } , { Flag::TYPE_BOOL, "harmony_sloppy_function", &FLAG_harmony_sloppy_function, &FLAGDEFAULT_harmony_sloppy_function, u8"enable " u8"u8\"harmony sloppy function block scoping\"", false } , { Flag::TYPE_BOOL, "harmony_regexp_subclass", &FLAG_harmony_regexp_subclass, &FLAGDEFAULT_harmony_regexp_subclass, u8"enable " u8"u8\"harmony regexp subclassing\"", false } , { Flag::TYPE_BOOL, "harmony_restrictive_declarations", &FLAG_harmony_restrictive_declarations, &FLAGDEFAULT_harmony_restrictive_declarations, u8"enable " u8"u8\"harmony limitations on sloppy mode function declarations\"", false } , { Flag::TYPE_BOOL, "harmony_species", &FLAG_harmony_species, &FLAGDEFAULT_harmony_species, u8"enable " u8"u8\"harmony Symbol.species\"", false } ,
{ Flag::TYPE_BOOL, "compiled_keyed_generic_loads", &FLAG_compiled_keyed_generic_loads, &FLAGDEFAULT_compiled_keyed_generic_loads, "use optimizing compiler to generate keyed generic load stubs", false } ,

{ Flag::TYPE_BOOL, "allocation_site_pretenuring", &FLAG_allocation_site_pretenuring, &FLAGDEFAULT_allocation_site_pretenuring, "pretenure with allocation sites", false } ,

{ Flag::TYPE_BOOL, "trace_pretenuring", &FLAG_trace_pretenuring, &FLAGDEFAULT_trace_pretenuring, "trace pretenuring decisions of HAllocate instructions", false } ,

{ Flag::TYPE_BOOL, "trace_pretenuring_statistics", &FLAG_trace_pretenuring_statistics, &FLAGDEFAULT_trace_pretenuring_statistics, "trace allocation site pretenuring statistics", false } ,

{ Flag::TYPE_BOOL, "track_fields", &FLAG_track_fields, &FLAGDEFAULT_track_fields, "track fields with only smi values", false } ,
{ Flag::TYPE_BOOL, "track_double_fields", &FLAG_track_double_fields, &FLAGDEFAULT_track_double_fields, "track fields with double values", false } ,
{ Flag::TYPE_BOOL, "track_heap_object_fields", &FLAG_track_heap_object_fields, &FLAGDEFAULT_track_heap_object_fields, "track fields with heap values", false } ,
{ Flag::TYPE_BOOL, "track_computed_fields", &FLAG_track_computed_fields, &FLAGDEFAULT_track_computed_fields, "track computed boilerplate fields", false } ,
{ Flag::TYPE_BOOL, "harmony_instanceof_opt", &FLAG_harmony_instanceof_opt, &FLAGDEFAULT_harmony_instanceof_opt, "optimize ES6 instanceof support", false } ,



{ Flag::TYPE_BOOL, "track_field_types", &FLAG_track_field_types, &FLAGDEFAULT_track_field_types, "track field types", false } ,


{ Flag::TYPE_BOOL, "smi_binop", &FLAG_smi_binop, &FLAGDEFAULT_smi_binop, "support smi representation in binary operations", false } ,


{ Flag::TYPE_BOOL, "optimize_for_size", &FLAG_optimize_for_size, &FLAGDEFAULT_optimize_for_size, "Enables optimizations which favor memory size over execution " "speed", false } ,






{ Flag::TYPE_BOOL, "unbox_double_arrays", &FLAG_unbox_double_arrays, &FLAGDEFAULT_unbox_double_arrays, "automatically unbox arrays of doubles", false } ,
{ Flag::TYPE_BOOL, "string_slices", &FLAG_string_slices, &FLAGDEFAULT_string_slices, "use string slices", false } ,


{ Flag::TYPE_BOOL, "ignition", &FLAG_ignition, &FLAGDEFAULT_ignition, "use ignition interpreter", false } ,
{ Flag::TYPE_BOOL, "ignition_eager", &FLAG_ignition_eager, &FLAGDEFAULT_ignition_eager, "eagerly compile and parse with ignition", false } ,
{ Flag::TYPE_STRING, "ignition_filter", &FLAG_ignition_filter, &FLAGDEFAULT_ignition_filter, "filter for ignition interpreter", false } ,
{ Flag::TYPE_BOOL, "print_bytecode", &FLAG_print_bytecode, &FLAGDEFAULT_print_bytecode, "print bytecode generated by ignition interpreter", false } ,

{ Flag::TYPE_BOOL, "trace_ignition", &FLAG_trace_ignition, &FLAGDEFAULT_trace_ignition, "trace the bytecodes executed by the ignition interpreter", false } ,

{ Flag::TYPE_BOOL, "trace_ignition_codegen", &FLAG_trace_ignition_codegen, &FLAGDEFAULT_trace_ignition_codegen, "trace the codegen of ignition interpreter bytecode handlers", false } ,



{ Flag::TYPE_BOOL, "crankshaft", &FLAG_crankshaft, &FLAGDEFAULT_crankshaft, "use crankshaft", false } ,
{ Flag::TYPE_STRING, "hydrogen_filter", &FLAG_hydrogen_filter, &FLAGDEFAULT_hydrogen_filter, "optimization filter", false } ,
{ Flag::TYPE_BOOL, "use_gvn", &FLAG_use_gvn, &FLAGDEFAULT_use_gvn, "use hydrogen global value numbering", false } ,
{ Flag::TYPE_INT, "gvn_iterations", &FLAG_gvn_iterations, &FLAGDEFAULT_gvn_iterations, "maximum number of GVN fix-point iterations", false } ,
{ Flag::TYPE_BOOL, "use_canonicalizing", &FLAG_use_canonicalizing, &FLAGDEFAULT_use_canonicalizing, "use hydrogen instruction canonicalizing", false } ,
{ Flag::TYPE_BOOL, "use_inlining", &FLAG_use_inlining, &FLAGDEFAULT_use_inlining, "use function inlining", false } ,
{ Flag::TYPE_BOOL, "use_escape_analysis", &FLAG_use_escape_analysis, &FLAGDEFAULT_use_escape_analysis, "use hydrogen escape analysis", false } ,
{ Flag::TYPE_BOOL, "use_allocation_folding", &FLAG_use_allocation_folding, &FLAGDEFAULT_use_allocation_folding, "use allocation folding", false } ,
{ Flag::TYPE_BOOL, "use_local_allocation_folding", &FLAG_use_local_allocation_folding, &FLAGDEFAULT_use_local_allocation_folding, "only fold in basic blocks", false } ,
{ Flag::TYPE_BOOL, "use_write_barrier_elimination", &FLAG_use_write_barrier_elimination, &FLAGDEFAULT_use_write_barrier_elimination, "eliminate write barriers targeting allocations in optimized code", false } ,

{ Flag::TYPE_INT, "max_inlining_levels", &FLAG_max_inlining_levels, &FLAGDEFAULT_max_inlining_levels, "maximum number of inlining levels", false } ,
{ Flag::TYPE_INT, "max_inlined_source_size", &FLAG_max_inlined_source_size, &FLAGDEFAULT_max_inlined_source_size, "maximum source size in bytes considered for a single inlining", false } ,

{ Flag::TYPE_INT, "max_inlined_nodes", &FLAG_max_inlined_nodes, &FLAGDEFAULT_max_inlined_nodes, "maximum number of AST nodes considered for a single inlining", false } ,

{ Flag::TYPE_INT, "max_inlined_nodes_cumulative", &FLAG_max_inlined_nodes_cumulative, &FLAGDEFAULT_max_inlined_nodes_cumulative, "maximum cumulative number of AST nodes considered for inlining", false } ,

{ Flag::TYPE_BOOL, "loop_invariant_code_motion", &FLAG_loop_invariant_code_motion, &FLAGDEFAULT_loop_invariant_code_motion, "loop invariant code motion", false } ,
{ Flag::TYPE_BOOL, "fast_math", &FLAG_fast_math, &FLAGDEFAULT_fast_math, "faster (but maybe less accurate) math functions", false } ,
{ Flag::TYPE_BOOL, "collect_megamorphic_maps_from_stub_cache", &FLAG_collect_megamorphic_maps_from_stub_cache, &FLAGDEFAULT_collect_megamorphic_maps_from_stub_cache, "crankshaft harvests type feedback from stub cache", false } ,

{ Flag::TYPE_BOOL, "hydrogen_stats", &FLAG_hydrogen_stats, &FLAGDEFAULT_hydrogen_stats, "print statistics for hydrogen", false } ,
{ Flag::TYPE_BOOL, "trace_check_elimination", &FLAG_trace_check_elimination, &FLAGDEFAULT_trace_check_elimination, "trace check elimination phase", false } ,
{ Flag::TYPE_BOOL, "trace_environment_liveness", &FLAG_trace_environment_liveness, &FLAGDEFAULT_trace_environment_liveness, "trace liveness of local variable slots", false } ,

{ Flag::TYPE_BOOL, "trace_hydrogen", &FLAG_trace_hydrogen, &FLAGDEFAULT_trace_hydrogen, "trace generated hydrogen to file", false } ,
{ Flag::TYPE_STRING, "trace_hydrogen_filter", &FLAG_trace_hydrogen_filter, &FLAGDEFAULT_trace_hydrogen_filter, "hydrogen tracing filter", false } ,
{ Flag::TYPE_BOOL, "trace_hydrogen_stubs", &FLAG_trace_hydrogen_stubs, &FLAGDEFAULT_trace_hydrogen_stubs, "trace generated hydrogen for stubs", false } ,
{ Flag::TYPE_STRING, "trace_hydrogen_file", &FLAG_trace_hydrogen_file, &FLAGDEFAULT_trace_hydrogen_file, "trace hydrogen to given file name", false } ,
{ Flag::TYPE_STRING, "trace_phase", &FLAG_trace_phase, &FLAGDEFAULT_trace_phase, "trace generated IR for specified phases", false } ,
{ Flag::TYPE_BOOL, "trace_inlining", &FLAG_trace_inlining, &FLAGDEFAULT_trace_inlining, "trace inlining decisions", false } ,
{ Flag::TYPE_BOOL, "trace_load_elimination", &FLAG_trace_load_elimination, &FLAGDEFAULT_trace_load_elimination, "trace load elimination", false } ,
{ Flag::TYPE_BOOL, "trace_store_elimination", &FLAG_trace_store_elimination, &FLAGDEFAULT_trace_store_elimination, "trace store elimination", false } ,
{ Flag::TYPE_BOOL, "trace_alloc", &FLAG_trace_alloc, &FLAGDEFAULT_trace_alloc, "trace register allocator", false } ,
{ Flag::TYPE_BOOL, "trace_all_uses", &FLAG_trace_all_uses, &FLAGDEFAULT_trace_all_uses, "trace all use positions", false } ,
{ Flag::TYPE_BOOL, "trace_range", &FLAG_trace_range, &FLAGDEFAULT_trace_range, "trace range analysis", false } ,
{ Flag::TYPE_BOOL, "trace_gvn", &FLAG_trace_gvn, &FLAGDEFAULT_trace_gvn, "trace global value numbering", false } ,
{ Flag::TYPE_BOOL, "trace_representation", &FLAG_trace_representation, &FLAGDEFAULT_trace_representation, "trace representation types", false } ,
{ Flag::TYPE_BOOL, "trace_removable_simulates", &FLAG_trace_removable_simulates, &FLAGDEFAULT_trace_removable_simulates, "trace removable simulates", false } ,
{ Flag::TYPE_BOOL, "trace_escape_analysis", &FLAG_trace_escape_analysis, &FLAGDEFAULT_trace_escape_analysis, "trace hydrogen escape analysis", false } ,
{ Flag::TYPE_BOOL, "trace_allocation_folding", &FLAG_trace_allocation_folding, &FLAGDEFAULT_trace_allocation_folding, "trace allocation folding", false } ,
{ Flag::TYPE_BOOL, "trace_track_allocation_sites", &FLAG_trace_track_allocation_sites, &FLAGDEFAULT_trace_track_allocation_sites, "trace the tracking of allocation sites", false } ,

{ Flag::TYPE_BOOL, "trace_migration", &FLAG_trace_migration, &FLAGDEFAULT_trace_migration, "trace object migration", false } ,
{ Flag::TYPE_BOOL, "trace_generalization", &FLAG_trace_generalization, &FLAGDEFAULT_trace_generalization, "trace map generalization", false } ,
{ Flag::TYPE_BOOL, "stress_pointer_maps", &FLAG_stress_pointer_maps, &FLAGDEFAULT_stress_pointer_maps, "pointer map for every instruction", false } ,
{ Flag::TYPE_BOOL, "stress_environments", &FLAG_stress_environments, &FLAGDEFAULT_stress_environments, "environment for every instruction", false } ,
{ Flag::TYPE_INT, "deopt_every_n_times", &FLAG_deopt_every_n_times, &FLAGDEFAULT_deopt_every_n_times, "deoptimize every n times a deopt point is passed", false } ,

{ Flag::TYPE_INT, "deopt_every_n_garbage_collections", &FLAG_deopt_every_n_garbage_collections, &FLAGDEFAULT_deopt_every_n_garbage_collections, "deoptimize every n garbage collections", false } ,

{ Flag::TYPE_BOOL, "print_deopt_stress", &FLAG_print_deopt_stress, &FLAGDEFAULT_print_deopt_stress, "print number of possible deopt points", false } ,
{ Flag::TYPE_BOOL, "trap_on_deopt", &FLAG_trap_on_deopt, &FLAGDEFAULT_trap_on_deopt, "put a break point before deoptimizing", false } ,
{ Flag::TYPE_BOOL, "trap_on_stub_deopt", &FLAG_trap_on_stub_deopt, &FLAGDEFAULT_trap_on_stub_deopt, "put a break point before deoptimizing a stub", false } ,

{ Flag::TYPE_BOOL, "deoptimize_uncommon_cases", &FLAG_deoptimize_uncommon_cases, &FLAGDEFAULT_deoptimize_uncommon_cases, "deoptimize uncommon cases", false } ,
{ Flag::TYPE_BOOL, "polymorphic_inlining", &FLAG_polymorphic_inlining, &FLAGDEFAULT_polymorphic_inlining, "polymorphic inlining", false } ,
{ Flag::TYPE_BOOL, "use_osr", &FLAG_use_osr, &FLAGDEFAULT_use_osr, "use on-stack replacement", false } ,
{ Flag::TYPE_BOOL, "array_bounds_checks_elimination", &FLAG_array_bounds_checks_elimination, &FLAGDEFAULT_array_bounds_checks_elimination, "perform array bounds checks elimination", false } ,

{ Flag::TYPE_BOOL, "trace_bce", &FLAG_trace_bce, &FLAGDEFAULT_trace_bce, "trace array bounds check elimination", false } ,
{ Flag::TYPE_BOOL, "array_index_dehoisting", &FLAG_array_index_dehoisting, &FLAGDEFAULT_array_index_dehoisting, "perform array index dehoisting", false } ,
{ Flag::TYPE_BOOL, "analyze_environment_liveness", &FLAG_analyze_environment_liveness, &FLAGDEFAULT_analyze_environment_liveness, "analyze liveness of environment slots and zap dead values", false } ,

{ Flag::TYPE_BOOL, "load_elimination", &FLAG_load_elimination, &FLAGDEFAULT_load_elimination, "use load elimination", false } ,
{ Flag::TYPE_BOOL, "check_elimination", &FLAG_check_elimination, &FLAGDEFAULT_check_elimination, "use check elimination", false } ,
{ Flag::TYPE_BOOL, "store_elimination", &FLAG_store_elimination, &FLAGDEFAULT_store_elimination, "use store elimination", false } ,
{ Flag::TYPE_BOOL, "dead_code_elimination", &FLAG_dead_code_elimination, &FLAGDEFAULT_dead_code_elimination, "use dead code elimination", false } ,
{ Flag::TYPE_BOOL, "fold_constants", &FLAG_fold_constants, &FLAGDEFAULT_fold_constants, "use constant folding", false } ,
{ Flag::TYPE_BOOL, "trace_dead_code_elimination", &FLAG_trace_dead_code_elimination, &FLAGDEFAULT_trace_dead_code_elimination, "trace dead code elimination", false } ,
{ Flag::TYPE_BOOL, "unreachable_code_elimination", &FLAG_unreachable_code_elimination, &FLAGDEFAULT_unreachable_code_elimination, "eliminate unreachable code", false } ,
{ Flag::TYPE_BOOL, "trace_osr", &FLAG_trace_osr, &FLAGDEFAULT_trace_osr, "trace on-stack replacement", false } ,
{ Flag::TYPE_INT, "stress_runs", &FLAG_stress_runs, &FLAGDEFAULT_stress_runs, "number of stress runs", false } ,
{ Flag::TYPE_BOOL, "lookup_sample_by_shared", &FLAG_lookup_sample_by_shared, &FLAGDEFAULT_lookup_sample_by_shared, "when picking a function to optimize, watch for shared function " "info, not JSFunction itself", false } ,


{ Flag::TYPE_BOOL, "flush_optimized_code_cache", &FLAG_flush_optimized_code_cache, &FLAGDEFAULT_flush_optimized_code_cache, "flushes the cache of optimized code for closures on every GC", false } ,

{ Flag::TYPE_BOOL, "inline_construct", &FLAG_inline_construct, &FLAGDEFAULT_inline_construct, "inline constructor calls", false } ,
{ Flag::TYPE_BOOL, "inline_arguments", &FLAG_inline_arguments, &FLAGDEFAULT_inline_arguments, "inline functions with arguments object", false } ,
{ Flag::TYPE_BOOL, "inline_accessors", &FLAG_inline_accessors, &FLAGDEFAULT_inline_accessors, "inline JavaScript accessors", false } ,
{ Flag::TYPE_INT, "escape_analysis_iterations", &FLAG_escape_analysis_iterations, &FLAGDEFAULT_escape_analysis_iterations, "maximum number of escape analysis fix-point iterations", false } ,


{ Flag::TYPE_BOOL, "concurrent_recompilation", &FLAG_concurrent_recompilation, &FLAGDEFAULT_concurrent_recompilation, "optimizing hot functions asynchronously on a separate thread", false } ,

{ Flag::TYPE_BOOL, "trace_concurrent_recompilation", &FLAG_trace_concurrent_recompilation, &FLAGDEFAULT_trace_concurrent_recompilation, "track concurrent recompilation", false } ,

{ Flag::TYPE_INT, "concurrent_recompilation_queue_length", &FLAG_concurrent_recompilation_queue_length, &FLAGDEFAULT_concurrent_recompilation_queue_length, "the length of the concurrent compilation queue", false } ,

{ Flag::TYPE_INT, "concurrent_recompilation_delay", &FLAG_concurrent_recompilation_delay, &FLAGDEFAULT_concurrent_recompilation_delay, "artificial compilation delay in ms", false } ,

{ Flag::TYPE_BOOL, "block_concurrent_recompilation", &FLAG_block_concurrent_recompilation, &FLAGDEFAULT_block_concurrent_recompilation, "block queued jobs until released", false } ,


{ Flag::TYPE_BOOL, "omit_map_checks_for_leaf_maps", &FLAG_omit_map_checks_for_leaf_maps, &FLAGDEFAULT_omit_map_checks_for_leaf_maps, "do not emit check maps for constant values that have a leaf map, " "deoptimize the optimized code if the layout of the maps changes.", false } ,




{ Flag::TYPE_BOOL, "turbo", &FLAG_turbo, &FLAGDEFAULT_turbo, "enable TurboFan compiler", false } ,

{ Flag::TYPE_BOOL, "turbo_shipping", &FLAG_turbo_shipping, &FLAGDEFAULT_turbo_shipping, "enable TurboFan compiler on subset", false } ,
{ Flag::TYPE_BOOL, "turbo_greedy_regalloc", &FLAG_turbo_greedy_regalloc, &FLAGDEFAULT_turbo_greedy_regalloc, "use the greedy register allocator", false } ,
{ Flag::TYPE_BOOL, "turbo_sp_frame_access", &FLAG_turbo_sp_frame_access, &FLAGDEFAULT_turbo_sp_frame_access, "use stack pointer-relative access to frame wherever possible", false } ,

{ Flag::TYPE_BOOL, "turbo_preprocess_ranges", &FLAG_turbo_preprocess_ranges, &FLAGDEFAULT_turbo_preprocess_ranges, "run pre-register allocation heuristics", false } ,

{ Flag::TYPE_BOOL, "turbo_loop_stackcheck", &FLAG_turbo_loop_stackcheck, &FLAGDEFAULT_turbo_loop_stackcheck, "enable stack checks in loops", false } ,
{ Flag::TYPE_STRING, "turbo_filter", &FLAG_turbo_filter, &FLAGDEFAULT_turbo_filter, "optimization filter for TurboFan compiler", false } ,
{ Flag::TYPE_BOOL, "trace_turbo", &FLAG_trace_turbo, &FLAGDEFAULT_trace_turbo, "trace generated TurboFan IR", false } ,
{ Flag::TYPE_BOOL, "trace_turbo_graph", &FLAG_trace_turbo_graph, &FLAGDEFAULT_trace_turbo_graph, "trace generated TurboFan graphs", false } ,

{ Flag::TYPE_STRING, "trace_turbo_cfg_file", &FLAG_trace_turbo_cfg_file, &FLAGDEFAULT_trace_turbo_cfg_file, "trace turbo cfg graph (for C1 visualizer) to a given file name", false } ,

{ Flag::TYPE_BOOL, "trace_turbo_types", &FLAG_trace_turbo_types, &FLAGDEFAULT_trace_turbo_types, "trace TurboFan's types", false } ,
{ Flag::TYPE_BOOL, "trace_turbo_scheduler", &FLAG_trace_turbo_scheduler, &FLAGDEFAULT_trace_turbo_scheduler, "trace TurboFan's scheduler", false } ,
{ Flag::TYPE_BOOL, "trace_turbo_reduction", &FLAG_trace_turbo_reduction, &FLAGDEFAULT_trace_turbo_reduction, "trace TurboFan's various reducers", false } ,
{ Flag::TYPE_BOOL, "trace_turbo_jt", &FLAG_trace_turbo_jt, &FLAGDEFAULT_trace_turbo_jt, "trace TurboFan's jump threading", false } ,
{ Flag::TYPE_BOOL, "trace_turbo_ceq", &FLAG_trace_turbo_ceq, &FLAGDEFAULT_trace_turbo_ceq, "trace TurboFan's control equivalence", false } ,
{ Flag::TYPE_BOOL, "turbo_asm", &FLAG_turbo_asm, &FLAGDEFAULT_turbo_asm, "enable TurboFan for asm.js code", false } ,
{ Flag::TYPE_BOOL, "turbo_asm_deoptimization", &FLAG_turbo_asm_deoptimization, &FLAGDEFAULT_turbo_asm_deoptimization, "enable deoptimization in TurboFan for asm.js code", false } ,

{ Flag::TYPE_BOOL, "turbo_verify", &FLAG_turbo_verify, &FLAGDEFAULT_turbo_verify, "verify TurboFan graphs at each phase", false } ,
{ Flag::TYPE_BOOL, "turbo_stats", &FLAG_turbo_stats, &FLAGDEFAULT_turbo_stats, "print TurboFan statistics", false } ,
{ Flag::TYPE_BOOL, "turbo_splitting", &FLAG_turbo_splitting, &FLAGDEFAULT_turbo_splitting, "split nodes during scheduling in TurboFan", false } ,
{ Flag::TYPE_BOOL, "turbo_types", &FLAG_turbo_types, &FLAGDEFAULT_turbo_types, "use typed lowering in TurboFan", false } ,
{ Flag::TYPE_BOOL, "turbo_source_positions", &FLAG_turbo_source_positions, &FLAGDEFAULT_turbo_source_positions, "track source code positions when building TurboFan IR", false } ,


{ Flag::TYPE_BOOL, "function_context_specialization", &FLAG_function_context_specialization, &FLAGDEFAULT_function_context_specialization, "enable function context specialization in TurboFan", false } ,

{ Flag::TYPE_BOOL, "native_context_specialization", &FLAG_native_context_specialization, &FLAGDEFAULT_native_context_specialization, "enable native context specialization in TurboFan", false } ,

{ Flag::TYPE_BOOL, "turbo_inlining", &FLAG_turbo_inlining, &FLAGDEFAULT_turbo_inlining, "enable inlining in TurboFan", false } ,
{ Flag::TYPE_BOOL, "trace_turbo_inlining", &FLAG_trace_turbo_inlining, &FLAGDEFAULT_trace_turbo_inlining, "trace TurboFan inlining", false } ,
{ Flag::TYPE_BOOL, "loop_assignment_analysis", &FLAG_loop_assignment_analysis, &FLAGDEFAULT_loop_assignment_analysis, "perform loop assignment analysis", false } ,
{ Flag::TYPE_BOOL, "turbo_profiling", &FLAG_turbo_profiling, &FLAGDEFAULT_turbo_profiling, "enable profiling in TurboFan", false } ,
{ Flag::TYPE_BOOL, "turbo_verify_allocation", &FLAG_turbo_verify_allocation, &FLAGDEFAULT_turbo_verify_allocation, "verify register allocation in TurboFan", false } ,

{ Flag::TYPE_BOOL, "turbo_move_optimization", &FLAG_turbo_move_optimization, &FLAGDEFAULT_turbo_move_optimization, "optimize gap moves in TurboFan", false } ,
{ Flag::TYPE_BOOL, "turbo_jt", &FLAG_turbo_jt, &FLAGDEFAULT_turbo_jt, "enable jump threading in TurboFan", false } ,
{ Flag::TYPE_BOOL, "turbo_osr", &FLAG_turbo_osr, &FLAGDEFAULT_turbo_osr, "enable OSR in TurboFan", false } ,
{ Flag::TYPE_BOOL, "turbo_stress_loop_peeling", &FLAG_turbo_stress_loop_peeling, &FLAGDEFAULT_turbo_stress_loop_peeling, "stress loop peeling optimization", false } ,

{ Flag::TYPE_BOOL, "turbo_cf_optimization", &FLAG_turbo_cf_optimization, &FLAGDEFAULT_turbo_cf_optimization, "optimize control flow in TurboFan", false } ,
{ Flag::TYPE_BOOL, "turbo_frame_elision", &FLAG_turbo_frame_elision, &FLAGDEFAULT_turbo_frame_elision, "elide frames in TurboFan", false } ,
{ Flag::TYPE_BOOL, "turbo_cache_shared_code", &FLAG_turbo_cache_shared_code, &FLAGDEFAULT_turbo_cache_shared_code, "cache context-independent code", false } ,
{ Flag::TYPE_BOOL, "turbo_preserve_shared_code", &FLAG_turbo_preserve_shared_code, &FLAGDEFAULT_turbo_preserve_shared_code, "keep context-independent code", false } ,
{ Flag::TYPE_BOOL, "turbo_escape", &FLAG_turbo_escape, &FLAGDEFAULT_turbo_escape, "enable escape analysis", false } ,
{ Flag::TYPE_BOOL, "turbo_instruction_scheduling", &FLAG_turbo_instruction_scheduling, &FLAGDEFAULT_turbo_instruction_scheduling, "enable instruction scheduling in TurboFan", false } ,

{ Flag::TYPE_BOOL, "turbo_stress_instruction_scheduling", &FLAG_turbo_stress_instruction_scheduling, &FLAGDEFAULT_turbo_stress_instruction_scheduling, "randomly schedule instructions to stress dependency tracking", false } ,



{ Flag::TYPE_BOOL, "expose_wasm", &FLAG_expose_wasm, &FLAGDEFAULT_expose_wasm, "expose WASM interface to JavaScript", false } ,
{ Flag::TYPE_BOOL, "trace_wasm_encoder", &FLAG_trace_wasm_encoder, &FLAGDEFAULT_trace_wasm_encoder, "trace encoding of wasm code", false } ,
{ Flag::TYPE_BOOL, "trace_wasm_decoder", &FLAG_trace_wasm_decoder, &FLAGDEFAULT_trace_wasm_decoder, "trace decoding of wasm code", false } ,
{ Flag::TYPE_BOOL, "trace_wasm_decode_time", &FLAG_trace_wasm_decode_time, &FLAGDEFAULT_trace_wasm_decode_time, "trace decoding time of wasm code", false } ,
{ Flag::TYPE_BOOL, "trace_wasm_compiler", &FLAG_trace_wasm_compiler, &FLAGDEFAULT_trace_wasm_compiler, "trace compiling of wasm code", false } ,
{ Flag::TYPE_INT, "trace_wasm_ast_start", &FLAG_trace_wasm_ast_start, &FLAGDEFAULT_trace_wasm_ast_start, "start function for WASM AST trace (inclusive)", false } ,

{ Flag::TYPE_INT, "trace_wasm_ast_end", &FLAG_trace_wasm_ast_end, &FLAGDEFAULT_trace_wasm_ast_end, "end function for WASM AST trace (exclusive)", false } ,
{ Flag::TYPE_INT, "skip_compiling_wasm_funcs", &FLAG_skip_compiling_wasm_funcs, &FLAGDEFAULT_skip_compiling_wasm_funcs, "start compiling at function N", false } ,
{ Flag::TYPE_BOOL, "wasm_break_on_decoder_error", &FLAG_wasm_break_on_decoder_error, &FLAGDEFAULT_wasm_break_on_decoder_error, "debug break when wasm decoder encounters an error", false } ,

{ Flag::TYPE_BOOL, "wasm_loop_assignment_analysis", &FLAG_wasm_loop_assignment_analysis, &FLAGDEFAULT_wasm_loop_assignment_analysis, "perform loop assignment analysis for WASM", false } ,


{ Flag::TYPE_BOOL, "enable_simd_asmjs", &FLAG_enable_simd_asmjs, &FLAGDEFAULT_enable_simd_asmjs, "enable SIMD.js in asm.js stdlib", false } ,

{ Flag::TYPE_BOOL, "dump_wasm_module", &FLAG_dump_wasm_module, &FLAGDEFAULT_dump_wasm_module, "dump WASM module bytes", false } ,
{ Flag::TYPE_STRING, "dump_wasm_module_path", &FLAG_dump_wasm_module_path, &FLAGDEFAULT_dump_wasm_module_path, "directory to dump wasm modules to", false } ,

{ Flag::TYPE_INT, "typed_array_max_size_in_heap", &FLAG_typed_array_max_size_in_heap, &FLAGDEFAULT_typed_array_max_size_in_heap, "threshold for in-heap typed array", false } ,



{ Flag::TYPE_INT, "frame_count", &FLAG_frame_count, &FLAGDEFAULT_frame_count, "number of stack frames inspected by the profiler", false } ,

{ Flag::TYPE_INT, "interrupt_budget", &FLAG_interrupt_budget, &FLAGDEFAULT_interrupt_budget, "execution budget before interrupt is triggered", false } ,

{ Flag::TYPE_INT, "type_info_threshold", &FLAG_type_info_threshold, &FLAGDEFAULT_type_info_threshold, "percentage of ICs that must have type info to allow optimization", false } ,

{ Flag::TYPE_INT, "generic_ic_threshold", &FLAG_generic_ic_threshold, &FLAGDEFAULT_generic_ic_threshold, "max percentage of megamorphic/generic ICs to allow optimization", false } ,

{ Flag::TYPE_INT, "self_opt_count", &FLAG_self_opt_count, &FLAGDEFAULT_self_opt_count, "call count before self-optimization", false } ,

{ Flag::TYPE_BOOL, "trace_opt_verbose", &FLAG_trace_opt_verbose, &FLAGDEFAULT_trace_opt_verbose, "extra verbose compilation tracing", false } ,



{ Flag::TYPE_BOOL, "debug_code", &FLAG_debug_code, &FLAGDEFAULT_debug_code, "generate extra code (assertions) for debugging", false } ,
{ Flag::TYPE_BOOL, "code_comments", &FLAG_code_comments, &FLAGDEFAULT_code_comments, "emit comments in code disassembly", false } ,
{ Flag::TYPE_BOOL, "enable_sse3", &FLAG_enable_sse3, &FLAGDEFAULT_enable_sse3, "enable use of SSE3 instructions if available", false } ,
{ Flag::TYPE_BOOL, "enable_sse4_1", &FLAG_enable_sse4_1, &FLAGDEFAULT_enable_sse4_1, "enable use of SSE4.1 instructions if available", false } ,

{ Flag::TYPE_BOOL, "enable_sahf", &FLAG_enable_sahf, &FLAGDEFAULT_enable_sahf, "enable use of SAHF instruction if available (X64 only)", false } ,

{ Flag::TYPE_BOOL, "enable_avx", &FLAG_enable_avx, &FLAGDEFAULT_enable_avx, "enable use of AVX instructions if available", false } ,
{ Flag::TYPE_BOOL, "enable_fma3", &FLAG_enable_fma3, &FLAGDEFAULT_enable_fma3, "enable use of FMA3 instructions if available", false } ,
{ Flag::TYPE_BOOL, "enable_bmi1", &FLAG_enable_bmi1, &FLAGDEFAULT_enable_bmi1, "enable use of BMI1 instructions if available", false } ,
{ Flag::TYPE_BOOL, "enable_bmi2", &FLAG_enable_bmi2, &FLAGDEFAULT_enable_bmi2, "enable use of BMI2 instructions if available", false } ,
{ Flag::TYPE_BOOL, "enable_lzcnt", &FLAG_enable_lzcnt, &FLAGDEFAULT_enable_lzcnt, "enable use of LZCNT instruction if available", false } ,
{ Flag::TYPE_BOOL, "enable_popcnt", &FLAG_enable_popcnt, &FLAGDEFAULT_enable_popcnt, "enable use of POPCNT instruction if available", false } ,

{ Flag::TYPE_BOOL, "enable_vfp3", &FLAG_enable_vfp3, &FLAGDEFAULT_enable_vfp3, "enable use of VFP3 instructions if available", false } ,

{ Flag::TYPE_BOOL, "enable_armv7", &FLAG_enable_armv7, &FLAGDEFAULT_enable_armv7, "enable use of ARMv7 instructions if available (ARM only)", false } ,

{ Flag::TYPE_BOOL, "enable_armv8", &FLAG_enable_armv8, &FLAGDEFAULT_enable_armv8, "enable use of ARMv8 instructions if available (ARM 32-bit only)", false } ,

{ Flag::TYPE_BOOL, "enable_neon", &FLAG_enable_neon, &FLAGDEFAULT_enable_neon, "enable use of NEON instructions if available (ARM only)", false } ,

{ Flag::TYPE_BOOL, "enable_sudiv", &FLAG_enable_sudiv, &FLAGDEFAULT_enable_sudiv, "enable use of SDIV and UDIV instructions if available (ARM only)", false } ,

{ Flag::TYPE_BOOL, "enable_mls", &FLAG_enable_mls, &FLAGDEFAULT_enable_mls, "enable use of MLS instructions if available (ARM only)", false } ,

{ Flag::TYPE_BOOL, "enable_movw_movt", &FLAG_enable_movw_movt, &FLAGDEFAULT_enable_movw_movt, "enable loading 32-bit constant by means of movw/movt " "instruction pairs (ARM only)", false } ,


{ Flag::TYPE_BOOL, "enable_unaligned_accesses", &FLAG_enable_unaligned_accesses, &FLAGDEFAULT_enable_unaligned_accesses, "enable unaligned accesses for ARMv7 (ARM only)", false } ,

{ Flag::TYPE_BOOL, "enable_32dregs", &FLAG_enable_32dregs, &FLAGDEFAULT_enable_32dregs, "enable use of d16-d31 registers on ARM - this requires VFP3", false } ,

{ Flag::TYPE_BOOL, "enable_vldr_imm", &FLAG_enable_vldr_imm, &FLAGDEFAULT_enable_vldr_imm, "enable use of constant pools for double immediate (ARM only)", false } ,

{ Flag::TYPE_BOOL, "force_long_branches", &FLAG_force_long_branches, &FLAGDEFAULT_force_long_branches, "force all emitted branches to be in long mode (MIPS/PPC only)", false } ,

{ Flag::TYPE_STRING, "mcpu", &FLAG_mcpu, &FLAGDEFAULT_mcpu, "enable optimization for specific cpu", false } ,
{ Flag::TYPE_STRING, "expose_natives_as", &FLAG_expose_natives_as, &FLAGDEFAULT_expose_natives_as, "expose natives in global object", false } ,
{ Flag::TYPE_STRING, "expose_debug_as", &FLAG_expose_debug_as, &FLAGDEFAULT_expose_debug_as, "expose debug in global object", false } ,
{ Flag::TYPE_BOOL, "expose_free_buffer", &FLAG_expose_free_buffer, &FLAGDEFAULT_expose_free_buffer, "expose freeBuffer extension", false } ,
{ Flag::TYPE_BOOL, "expose_gc", &FLAG_expose_gc, &FLAGDEFAULT_expose_gc, "expose gc extension", false } ,
{ Flag::TYPE_STRING, "expose_gc_as", &FLAG_expose_gc_as, &FLAGDEFAULT_expose_gc_as, "expose gc extension under the specified name", false } ,


{ Flag::TYPE_BOOL, "expose_externalize_string", &FLAG_expose_externalize_string, &FLAGDEFAULT_expose_externalize_string, "expose externalize string extension", false } ,

{ Flag::TYPE_BOOL, "expose_trigger_failure", &FLAG_expose_trigger_failure, &FLAGDEFAULT_expose_trigger_failure, "expose trigger-failure extension", false } ,
{ Flag::TYPE_INT, "stack_trace_limit", &FLAG_stack_trace_limit, &FLAGDEFAULT_stack_trace_limit, "number of stack frames to capture", false } ,
{ Flag::TYPE_BOOL, "builtins_in_stack_traces", &FLAG_builtins_in_stack_traces, &FLAGDEFAULT_builtins_in_stack_traces, "show built-in functions in stack traces", false } ,

{ Flag::TYPE_BOOL, "disable_native_files", &FLAG_disable_native_files, &FLAGDEFAULT_disable_native_files, "disable builtin natives files", false } ,


{ Flag::TYPE_BOOL, "inline_new", &FLAG_inline_new, &FLAGDEFAULT_inline_new, "use fast inline allocation", false } ,


{ Flag::TYPE_BOOL, "trace_codegen", &FLAG_trace_codegen, &FLAGDEFAULT_trace_codegen, "print name of functions for which code is generated", false } ,

{ Flag::TYPE_BOOL, "trace", &FLAG_trace, &FLAGDEFAULT_trace, "trace function calls", false } ,
{ Flag::TYPE_BOOL, "mask_constants_with_cookie", &FLAG_mask_constants_with_cookie, &FLAGDEFAULT_mask_constants_with_cookie, "use random jit cookie to mask large constants", false } ,



{ Flag::TYPE_BOOL, "lazy", &FLAG_lazy, &FLAGDEFAULT_lazy, "use lazy compilation", false } ,
{ Flag::TYPE_BOOL, "trace_opt", &FLAG_trace_opt, &FLAGDEFAULT_trace_opt, "trace lazy optimization", false } ,
{ Flag::TYPE_BOOL, "trace_opt_stats", &FLAG_trace_opt_stats, &FLAGDEFAULT_trace_opt_stats, "trace lazy optimization statistics", false } ,
{ Flag::TYPE_BOOL, "opt", &FLAG_opt, &FLAGDEFAULT_opt, "use adaptive optimizations", false } ,
{ Flag::TYPE_BOOL, "always_opt", &FLAG_always_opt, &FLAGDEFAULT_always_opt, "always try to optimize functions", false } ,
{ Flag::TYPE_BOOL, "always_osr", &FLAG_always_osr, &FLAGDEFAULT_always_osr, "always try to OSR functions", false } ,
{ Flag::TYPE_BOOL, "prepare_always_opt", &FLAG_prepare_always_opt, &FLAGDEFAULT_prepare_always_opt, "prepare for turning on always opt", false } ,
{ Flag::TYPE_BOOL, "trace_deopt", &FLAG_trace_deopt, &FLAGDEFAULT_trace_deopt, "trace optimize function deoptimization", false } ,
{ Flag::TYPE_BOOL, "trace_stub_failures", &FLAG_trace_stub_failures, &FLAGDEFAULT_trace_stub_failures, "trace deoptimization of generated code stubs", false } ,


{ Flag::TYPE_BOOL, "serialize_toplevel", &FLAG_serialize_toplevel, &FLAGDEFAULT_serialize_toplevel, "enable caching of toplevel scripts", false } ,
{ Flag::TYPE_BOOL, "serialize_eager", &FLAG_serialize_eager, &FLAGDEFAULT_serialize_eager, "compile eagerly when caching scripts", false } ,
{ Flag::TYPE_BOOL, "serialize_age_code", &FLAG_serialize_age_code, &FLAGDEFAULT_serialize_age_code, "pre age code in the code cache", false } ,
{ Flag::TYPE_BOOL, "trace_serializer", &FLAG_trace_serializer, &FLAGDEFAULT_trace_serializer, "print code serializer trace", false } ,


{ Flag::TYPE_INT, "min_preparse_length", &FLAG_min_preparse_length, &FLAGDEFAULT_min_preparse_length, "minimum length for automatic enable preparsing", false } ,

{ Flag::TYPE_INT, "max_opt_count", &FLAG_max_opt_count, &FLAGDEFAULT_max_opt_count, "maximum number of optimization attempts before giving up.", false } ,



{ Flag::TYPE_BOOL, "compilation_cache", &FLAG_compilation_cache, &FLAGDEFAULT_compilation_cache, "enable compilation cache", false } ,

{ Flag::TYPE_BOOL, "cache_prototype_transitions", &FLAG_cache_prototype_transitions, &FLAGDEFAULT_cache_prototype_transitions, "cache prototype transitions", false } ,


{ Flag::TYPE_INT, "cpu_profiler_sampling_interval", &FLAG_cpu_profiler_sampling_interval, &FLAGDEFAULT_cpu_profiler_sampling_interval, "CPU profiler sampling interval in microseconds", false } ,



{ Flag::TYPE_BOOL, "trace_js_array_abuse", &FLAG_trace_js_array_abuse, &FLAGDEFAULT_trace_js_array_abuse, "trace out-of-bounds accesses to JS arrays", false } ,

{ Flag::TYPE_BOOL, "trace_external_array_abuse", &FLAG_trace_external_array_abuse, &FLAGDEFAULT_trace_external_array_abuse, "trace out-of-bounds-accesses to external arrays", false } ,

{ Flag::TYPE_BOOL, "trace_array_abuse", &FLAG_trace_array_abuse, &FLAGDEFAULT_trace_array_abuse, "trace out-of-bounds accesses to all arrays", false } ,





{ Flag::TYPE_BOOL, "trace_debug_json", &FLAG_trace_debug_json, &FLAGDEFAULT_trace_debug_json, "trace debugging JSON request/response", false } ,
{ Flag::TYPE_BOOL, "enable_liveedit", &FLAG_enable_liveedit, &FLAGDEFAULT_enable_liveedit, "enable liveedit experimental feature", false } ,
{ Flag::TYPE_BOOL, "hard_abort", &FLAG_hard_abort, &FLAGDEFAULT_hard_abort, "abort by crashing", false } ,


{ Flag::TYPE_INT, "stack_size", &FLAG_stack_size, &FLAGDEFAULT_stack_size, "default size of stack region v8 is allowed to use (in kBytes)", false } ,



{ Flag::TYPE_INT, "max_stack_trace_source_length", &FLAG_max_stack_trace_source_length, &FLAGDEFAULT_max_stack_trace_source_length, "maximum length of function source code printed in a stack trace.", false } ,



{ Flag::TYPE_BOOL, "always_inline_smi_code", &FLAG_always_inline_smi_code, &FLAGDEFAULT_always_inline_smi_code, "always inline smi code in non-opt code", false } ,

{ Flag::TYPE_BOOL, "verify_operand_stack_depth", &FLAG_verify_operand_stack_depth, &FLAGDEFAULT_verify_operand_stack_depth, "emit debug code that verifies the static tracking of the operand " "stack depth", false } ,




{ Flag::TYPE_INT, "min_semi_space_size", &FLAG_min_semi_space_size, &FLAGDEFAULT_min_semi_space_size, "min size of a semi-space (in MBytes), the new space consists of two" "semi-spaces", false } ,


{ Flag::TYPE_INT, "max_semi_space_size", &FLAG_max_semi_space_size, &FLAGDEFAULT_max_semi_space_size, "max size of a semi-space (in MBytes), the new space consists of two" "semi-spaces", false } ,


{ Flag::TYPE_INT, "semi_space_growth_factor", &FLAG_semi_space_growth_factor, &FLAGDEFAULT_semi_space_growth_factor, "factor by which to grow the new space", false } ,
{ Flag::TYPE_BOOL, "experimental_new_space_growth_heuristic", &FLAG_experimental_new_space_growth_heuristic, &FLAGDEFAULT_experimental_new_space_growth_heuristic, "Grow the new space based on the percentage of survivors instead " "of their absolute value.", false } ,


{ Flag::TYPE_INT, "max_old_space_size", &FLAG_max_old_space_size, &FLAGDEFAULT_max_old_space_size, "max size of the old space (in Mbytes)", false } ,
{ Flag::TYPE_INT, "initial_old_space_size", &FLAG_initial_old_space_size, &FLAGDEFAULT_initial_old_space_size, "initial old space size (in Mbytes)", false } ,
{ Flag::TYPE_INT, "max_executable_size", &FLAG_max_executable_size, &FLAGDEFAULT_max_executable_size, "max size of executable memory (in Mbytes)", false } ,
{ Flag::TYPE_BOOL, "gc_global", &FLAG_gc_global, &FLAGDEFAULT_gc_global, "always perform global GCs", false } ,
{ Flag::TYPE_INT, "gc_interval", &FLAG_gc_interval, &FLAGDEFAULT_gc_interval, "garbage collect after <n> allocations", false } ,
{ Flag::TYPE_INT, "retain_maps_for_n_gc", &FLAG_retain_maps_for_n_gc, &FLAGDEFAULT_retain_maps_for_n_gc, "keeps maps alive for <n> old space garbage collections", false } ,

{ Flag::TYPE_BOOL, "trace_gc", &FLAG_trace_gc, &FLAGDEFAULT_trace_gc, "print one trace line following each garbage collection", false } ,

{ Flag::TYPE_BOOL, "trace_gc_nvp", &FLAG_trace_gc_nvp, &FLAGDEFAULT_trace_gc_nvp, "print one detailed trace line in name=value format " "after each garbage collection", false } ,


{ Flag::TYPE_BOOL, "trace_gc_ignore_scavenger", &FLAG_trace_gc_ignore_scavenger, &FLAGDEFAULT_trace_gc_ignore_scavenger, "do not print trace line after scavenger collection", false } ,

{ Flag::TYPE_BOOL, "trace_idle_notification", &FLAG_trace_idle_notification, &FLAGDEFAULT_trace_idle_notification, "print one trace line following each idle notification", false } ,

{ Flag::TYPE_BOOL, "trace_idle_notification_verbose", &FLAG_trace_idle_notification_verbose, &FLAGDEFAULT_trace_idle_notification_verbose, "prints the heap state used by the idle notification", false } ,

{ Flag::TYPE_BOOL, "print_cumulative_gc_stat", &FLAG_print_cumulative_gc_stat, &FLAGDEFAULT_print_cumulative_gc_stat, "print cumulative GC statistics in name=value format on exit", false } ,

{ Flag::TYPE_BOOL, "print_max_heap_committed", &FLAG_print_max_heap_committed, &FLAGDEFAULT_print_max_heap_committed, "print statistics of the maximum memory committed for the heap " "in name=value format on exit", false } ,


{ Flag::TYPE_BOOL, "trace_gc_verbose", &FLAG_trace_gc_verbose, &FLAGDEFAULT_trace_gc_verbose, "print more details following each garbage collection", false } ,

{ Flag::TYPE_INT, "trace_allocation_stack_interval", &FLAG_trace_allocation_stack_interval, &FLAGDEFAULT_trace_allocation_stack_interval, "print stack trace after <n> free-list allocations", false } ,

{ Flag::TYPE_BOOL, "trace_fragmentation", &FLAG_trace_fragmentation, &FLAGDEFAULT_trace_fragmentation, "report fragmentation for old space", false } ,
{ Flag::TYPE_BOOL, "trace_fragmentation_verbose", &FLAG_trace_fragmentation_verbose, &FLAGDEFAULT_trace_fragmentation_verbose, "report fragmentation for old space (detailed)", false } ,

{ Flag::TYPE_BOOL, "trace_evacuation", &FLAG_trace_evacuation, &FLAGDEFAULT_trace_evacuation, "report evacuation statistics", false } ,
{ Flag::TYPE_BOOL, "trace_mutator_utilization", &FLAG_trace_mutator_utilization, &FLAGDEFAULT_trace_mutator_utilization, "print mutator utilization, allocation speed, gc speed", false } ,

{ Flag::TYPE_BOOL, "weak_embedded_maps_in_optimized_code", &FLAG_weak_embedded_maps_in_optimized_code, &FLAGDEFAULT_weak_embedded_maps_in_optimized_code, "make maps embedded in optimized code weak", false } ,

{ Flag::TYPE_BOOL, "weak_embedded_objects_in_optimized_code", &FLAG_weak_embedded_objects_in_optimized_code, &FLAGDEFAULT_weak_embedded_objects_in_optimized_code, "make objects embedded in optimized code weak", false } ,

{ Flag::TYPE_BOOL, "flush_code", &FLAG_flush_code, &FLAGDEFAULT_flush_code, "flush code that we expect not to use again", false } ,
{ Flag::TYPE_BOOL, "trace_code_flushing", &FLAG_trace_code_flushing, &FLAGDEFAULT_trace_code_flushing, "trace code flushing progress", false } ,
{ Flag::TYPE_BOOL, "age_code", &FLAG_age_code, &FLAGDEFAULT_age_code, "track un-executed functions to age code and flush only " "old code (required for code flushing)", false } ,


{ Flag::TYPE_BOOL, "incremental_marking", &FLAG_incremental_marking, &FLAGDEFAULT_incremental_marking, "use incremental marking", false } ,
{ Flag::TYPE_INT, "min_progress_during_incremental_marking_finalization", &FLAG_min_progress_during_incremental_marking_finalization, &FLAGDEFAULT_min_progress_during_incremental_marking_finalization, "keep finalizing incremental marking as long as we discover at " "least this many unmarked objects", false } ,


{ Flag::TYPE_INT, "max_incremental_marking_finalization_rounds", &FLAG_max_incremental_marking_finalization_rounds, &FLAGDEFAULT_max_incremental_marking_finalization_rounds, "at most try this many times to finalize incremental marking", false } ,

{ Flag::TYPE_BOOL, "black_allocation", &FLAG_black_allocation, &FLAGDEFAULT_black_allocation, "use black allocation", false } ,
{ Flag::TYPE_BOOL, "concurrent_sweeping", &FLAG_concurrent_sweeping, &FLAGDEFAULT_concurrent_sweeping, "use concurrent sweeping", false } ,
{ Flag::TYPE_BOOL, "parallel_compaction", &FLAG_parallel_compaction, &FLAGDEFAULT_parallel_compaction, "use parallel compaction", false } ,
{ Flag::TYPE_BOOL, "parallel_pointer_update", &FLAG_parallel_pointer_update, &FLAGDEFAULT_parallel_pointer_update, "use parallel pointer update during compaction", false } ,

{ Flag::TYPE_BOOL, "trace_incremental_marking", &FLAG_trace_incremental_marking, &FLAGDEFAULT_trace_incremental_marking, "trace progress of the incremental marking", false } ,

{ Flag::TYPE_BOOL, "track_gc_object_stats", &FLAG_track_gc_object_stats, &FLAGDEFAULT_track_gc_object_stats, "track object counts and memory usage", false } ,

{ Flag::TYPE_BOOL, "trace_gc_object_stats", &FLAG_trace_gc_object_stats, &FLAGDEFAULT_trace_gc_object_stats, "trace object counts and memory usage", false } ,


{ Flag::TYPE_BOOL, "track_detached_contexts", &FLAG_track_detached_contexts, &FLAGDEFAULT_track_detached_contexts, "track native contexts that are expected to be garbage collected", false } ,

{ Flag::TYPE_BOOL, "trace_detached_contexts", &FLAG_trace_detached_contexts, &FLAGDEFAULT_trace_detached_contexts, "trace native contexts that are expected to be garbage collected", false } ,



{ Flag::TYPE_BOOL, "verify_heap", &FLAG_verify_heap, &FLAGDEFAULT_verify_heap, "verify heap pointers before and after GC", false } ,

{ Flag::TYPE_BOOL, "move_object_start", &FLAG_move_object_start, &FLAGDEFAULT_move_object_start, "enable moving of object starts", false } ,
{ Flag::TYPE_BOOL, "memory_reducer", &FLAG_memory_reducer, &FLAGDEFAULT_memory_reducer, "use memory reducer", false } ,
{ Flag::TYPE_BOOL, "scavenge_reclaim_unmodified_objects", &FLAG_scavenge_reclaim_unmodified_objects, &FLAGDEFAULT_scavenge_reclaim_unmodified_objects, "remove unmodified and unreferenced objects", false } ,

{ Flag::TYPE_INT, "heap_growing_percent", &FLAG_heap_growing_percent, &FLAGDEFAULT_heap_growing_percent, "specifies heap growing factor as (1 + heap_growing_percent/100)", false } ,



{ Flag::TYPE_INT, "histogram_interval", &FLAG_histogram_interval, &FLAGDEFAULT_histogram_interval, "time interval in ms for aggregating memory histograms", false } ,



{ Flag::TYPE_BOOL, "trace_object_groups", &FLAG_trace_object_groups, &FLAGDEFAULT_trace_object_groups, "print object groups detected during each garbage collection", false } ,



{ Flag::TYPE_BOOL, "heap_profiler_trace_objects", &FLAG_heap_profiler_trace_objects, &FLAGDEFAULT_heap_profiler_trace_objects, "Dump heap object allocations/movements/size_updates", false } ,




{ Flag::TYPE_BOOL, "sampling_heap_profiler_suppress_randomness", &FLAG_sampling_heap_profiler_suppress_randomness, &FLAGDEFAULT_sampling_heap_profiler_suppress_randomness, "Use constant sample intervals to eliminate test flakiness", false } ,




{ Flag::TYPE_BOOL, "use_idle_notification", &FLAG_use_idle_notification, &FLAGDEFAULT_use_idle_notification, "Use idle notification to reduce memory footprint.", false } ,


{ Flag::TYPE_BOOL, "use_ic", &FLAG_use_ic, &FLAGDEFAULT_use_ic, "use inline caching", false } ,
{ Flag::TYPE_BOOL, "trace_ic", &FLAG_trace_ic, &FLAGDEFAULT_trace_ic, "trace inline cache state transitions", false } ,


{ Flag::TYPE_BOOL, "native_code_counters", &FLAG_native_code_counters, &FLAGDEFAULT_native_code_counters, "generate extra code for manipulating stats counters", false } ,



{ Flag::TYPE_BOOL, "always_compact", &FLAG_always_compact, &FLAGDEFAULT_always_compact, "Perform compaction on every full GC", false } ,
{ Flag::TYPE_BOOL, "never_compact", &FLAG_never_compact, &FLAGDEFAULT_never_compact, "Never perform compaction on full GC - testing only", false } ,

{ Flag::TYPE_BOOL, "compact_code_space", &FLAG_compact_code_space, &FLAGDEFAULT_compact_code_space, "Compact code space on full collections", false } ,
{ Flag::TYPE_BOOL, "cleanup_code_caches_at_gc", &FLAG_cleanup_code_caches_at_gc, &FLAGDEFAULT_cleanup_code_caches_at_gc, "Flush inline caches prior to mark compact collection and " "flush code caches in maps during mark compact cycle.", false } ,


{ Flag::TYPE_BOOL, "use_marking_progress_bar", &FLAG_use_marking_progress_bar, &FLAGDEFAULT_use_marking_progress_bar, "Use a progress bar to scan large objects in increments when " "incremental marking is active.", false } ,


{ Flag::TYPE_BOOL, "zap_code_space", &FLAG_zap_code_space, &FLAGDEFAULT_zap_code_space, "Zap free memory in code space with 0xCC while sweeping.", false } ,

{ Flag::TYPE_INT, "random_seed", &FLAG_random_seed, &FLAGDEFAULT_random_seed, "Default seed for initializing random generator " "(0, the default, means to use system random).", false } ,




{ Flag::TYPE_BOOL, "trace_weak_arrays", &FLAG_trace_weak_arrays, &FLAGDEFAULT_trace_weak_arrays, "Trace WeakFixedArray usage", false } ,
{ Flag::TYPE_BOOL, "track_prototype_users", &FLAG_track_prototype_users, &FLAGDEFAULT_track_prototype_users, "Keep track of which maps refer to a given prototype object", false } ,

{ Flag::TYPE_BOOL, "trace_prototype_users", &FLAG_trace_prototype_users, &FLAGDEFAULT_trace_prototype_users, "Trace updates to prototype user tracking", false } ,

{ Flag::TYPE_BOOL, "eliminate_prototype_chain_checks", &FLAG_eliminate_prototype_chain_checks, &FLAGDEFAULT_eliminate_prototype_chain_checks, "Collapse prototype chain checks into single-cell checks", false } ,


{ Flag::TYPE_BOOL, "use_verbose_printer", &FLAG_use_verbose_printer, &FLAGDEFAULT_use_verbose_printer, "allows verbose printing", false } ,
{ Flag::TYPE_BOOL, "trace_for_in_enumerate", &FLAG_trace_for_in_enumerate, &FLAGDEFAULT_trace_for_in_enumerate, "Trace for-in enumerate slow-paths", false } ,

{ Flag::TYPE_BOOL, "trace_maps", &FLAG_trace_maps, &FLAGDEFAULT_trace_maps, "trace map creation", false } ,



{ Flag::TYPE_BOOL, "allow_natives_syntax", &FLAG_allow_natives_syntax, &FLAGDEFAULT_allow_natives_syntax, "allow natives syntax", false } ,
{ Flag::TYPE_BOOL, "trace_parse", &FLAG_trace_parse, &FLAGDEFAULT_trace_parse, "trace parsing and preparsing", false } ,


{ Flag::TYPE_BOOL, "trace_sim", &FLAG_trace_sim, &FLAGDEFAULT_trace_sim, "Trace simulator execution", false } ,
{ Flag::TYPE_BOOL, "debug_sim", &FLAG_debug_sim, &FLAGDEFAULT_debug_sim, "Enable debugging the simulator", false } ,
{ Flag::TYPE_BOOL, "check_icache", &FLAG_check_icache, &FLAGDEFAULT_check_icache, "Check icache flushes in ARM and MIPS simulator", false } ,

{ Flag::TYPE_INT, "stop_sim_at", &FLAG_stop_sim_at, &FLAGDEFAULT_stop_sim_at, "Simulator stop after x number of instructions", false } ,






{ Flag::TYPE_INT, "sim_stack_alignment", &FLAG_sim_stack_alignment, &FLAGDEFAULT_sim_stack_alignment, "Stack alingment in bytes in simulator (4 or 8, 8 is default)", false } ,


{ Flag::TYPE_INT, "sim_stack_size", &FLAG_sim_stack_size, &FLAGDEFAULT_sim_stack_size, "Stack size of the ARM64, MIPS64 and PPC64 simulator " "in kBytes (default is 2 MB)", false } ,


{ Flag::TYPE_BOOL, "log_regs_modified", &FLAG_log_regs_modified, &FLAGDEFAULT_log_regs_modified, "When logging register values, only print modified registers.", false } ,

{ Flag::TYPE_BOOL, "log_colour", &FLAG_log_colour, &FLAGDEFAULT_log_colour, "When logging, try to use coloured output.", false } ,

{ Flag::TYPE_BOOL, "ignore_asm_unimplemented_break", &FLAG_ignore_asm_unimplemented_break, &FLAGDEFAULT_ignore_asm_unimplemented_break, "Don't break for ASM_UNIMPLEMENTED_BREAK macros.", false } ,

{ Flag::TYPE_BOOL, "trace_sim_messages", &FLAG_trace_sim_messages, &FLAGDEFAULT_trace_sim_messages, "Trace simulator debug messages. Implied by --trace-sim.", false } ,



{ Flag::TYPE_BOOL, "stack_trace_on_illegal", &FLAG_stack_trace_on_illegal, &FLAGDEFAULT_stack_trace_on_illegal, "print stack trace when an illegal exception is thrown", false } ,

{ Flag::TYPE_BOOL, "abort_on_uncaught_exception", &FLAG_abort_on_uncaught_exception, &FLAGDEFAULT_abort_on_uncaught_exception, "abort program (dump core) when an uncaught exception is thrown", false } ,

{ Flag::TYPE_BOOL, "randomize_hashes", &FLAG_randomize_hashes, &FLAGDEFAULT_randomize_hashes, "randomize hashes to avoid predictable hash collisions " "(with snapshots this option cannot override the baked-in seed)", false } ,


{ Flag::TYPE_INT, "hash_seed", &FLAG_hash_seed, &FLAGDEFAULT_hash_seed, "Fixed seed to use to hash property keys (0 means random)" "(with snapshots this option cannot override the baked-in seed)", false } ,




{ Flag::TYPE_BOOL, "runtime_call_stats", &FLAG_runtime_call_stats, &FLAGDEFAULT_runtime_call_stats, "report runtime call counts and times", false } ,


{ Flag::TYPE_BOOL, "profile_deserialization", &FLAG_profile_deserialization, &FLAGDEFAULT_profile_deserialization, "Print the time it takes to deserialize the snapshot.", false } ,

{ Flag::TYPE_BOOL, "serialization_statistics", &FLAG_serialization_statistics, &FLAGDEFAULT_serialization_statistics, "Collect statistics on serialized objects.", false } ,



{ Flag::TYPE_BOOL, "regexp_optimization", &FLAG_regexp_optimization, &FLAGDEFAULT_regexp_optimization, "generate optimized regexp code", false } ,


{ Flag::TYPE_BOOL, "testing_bool_flag", &FLAG_testing_bool_flag, &FLAGDEFAULT_testing_bool_flag, "testing_bool_flag", false } ,
{ Flag::TYPE_MAYBE_BOOL, "testing_maybe_bool_flag", &FLAG_testing_maybe_bool_flag, &FLAGDEFAULT_testing_maybe_bool_flag, "testing_maybe_bool_flag", false } ,
{ Flag::TYPE_INT, "testing_int_flag", &FLAG_testing_int_flag, &FLAGDEFAULT_testing_int_flag, "testing_int_flag", false } ,
{ Flag::TYPE_FLOAT, "testing_float_flag", &FLAG_testing_float_flag, &FLAGDEFAULT_testing_float_flag, "float-flag", false } ,
{ Flag::TYPE_STRING, "testing_string_flag", &FLAG_testing_string_flag, &FLAGDEFAULT_testing_string_flag, "string-flag", false } ,
{ Flag::TYPE_INT, "testing_prng_seed", &FLAG_testing_prng_seed, &FLAGDEFAULT_testing_prng_seed, "Seed used for threading test randomness", false } ,




{ Flag::TYPE_STRING, "testing_serialization_file", &FLAG_testing_serialization_file, &FLAGDEFAULT_testing_serialization_file, "file in which to serialize heap", false } ,




{ Flag::TYPE_STRING, "startup_src", &FLAG_startup_src, &FLAGDEFAULT_startup_src, "Write V8 startup as C++ src. (mksnapshot only)", false } ,

{ Flag::TYPE_STRING, "startup_blob", &FLAG_startup_blob, &FLAGDEFAULT_startup_blob, "Write V8 startup blob file. (mksnapshot only)", false } ,



{ Flag::TYPE_BOOL, "profile_hydrogen_code_stub_compilation", &FLAG_profile_hydrogen_code_stub_compilation, &FLAGDEFAULT_profile_hydrogen_code_stub_compilation, "Print the time it takes to lazily compile hydrogen code stubs.", false } ,


{ Flag::TYPE_BOOL, "predictable", &FLAG_predictable, &FLAGDEFAULT_predictable, "enable predictable mode", false } ,






{ Flag::TYPE_BOOL, "force_marking_deque_overflows", &FLAG_force_marking_deque_overflows, &FLAGDEFAULT_force_marking_deque_overflows, "force overflows of marking deque by reducing it's size " "to 64 words", false } ,



{ Flag::TYPE_BOOL, "stress_compaction", &FLAG_stress_compaction, &FLAGDEFAULT_stress_compaction, "stress the GC compactor to flush out bugs (implies " "--force_marking_deque_overflows)", false } ,



{ Flag::TYPE_BOOL, "manual_evacuation_candidates_selection", &FLAG_manual_evacuation_candidates_selection, &FLAGDEFAULT_manual_evacuation_candidates_selection, "Test mode only flag. It allows an unit test to select evacuation " "candidates pages (requires --stress_compaction).", false } ,




{ Flag::TYPE_INT, "external_allocation_limit_incremental_time", &FLAG_external_allocation_limit_incremental_time, &FLAGDEFAULT_external_allocation_limit_incremental_time, "Time spent in incremental marking steps (in ms) once the external " "allocation limit is reached", false } ,



{ Flag::TYPE_BOOL, "disable_old_api_accessors", &FLAG_disable_old_api_accessors, &FLAGDEFAULT_disable_old_api_accessors, "Disable old-style API accessors whose setters trigger through the " "prototype chain", false } ,







{ Flag::TYPE_BOOL, "help", &FLAG_help, &FLAGDEFAULT_help, "Print usage message, including flags, on console", false } ,
{ Flag::TYPE_BOOL, "dump_counters", &FLAG_dump_counters, &FLAGDEFAULT_dump_counters, "Dump counters on exit", false } ,

{ Flag::TYPE_STRING, "map_counters", &FLAG_map_counters, &FLAGDEFAULT_map_counters, "Map counters to a file", false } ,
{ Flag::TYPE_ARGS, "js_arguments", &FLAG_js_arguments, &FLAGDEFAULT_js_arguments, "Pass all remaining arguments to the script. Alias for \"--\".", false } ,
{ Flag::TYPE_BOOL, "enable_slow_asserts", &FLAG_enable_slow_asserts, &FLAGDEFAULT_enable_slow_asserts, "enable asserts that are slow to execute", false } ,




{ Flag::TYPE_BOOL, "print_source", &FLAG_print_source, &FLAGDEFAULT_print_source, "pretty print source code", false } ,
{ Flag::TYPE_BOOL, "print_builtin_source", &FLAG_print_builtin_source, &FLAGDEFAULT_print_builtin_source, "pretty print source code for builtins", false } ,

{ Flag::TYPE_BOOL, "print_ast", &FLAG_print_ast, &FLAGDEFAULT_print_ast, "print source AST", false } ,
{ Flag::TYPE_BOOL, "print_builtin_ast", &FLAG_print_builtin_ast, &FLAGDEFAULT_print_builtin_ast, "print source AST for builtins", false } ,
{ Flag::TYPE_BOOL, "trap_on_abort", &FLAG_trap_on_abort, &FLAGDEFAULT_trap_on_abort, "replace aborts by breakpoints", false } ,


{ Flag::TYPE_BOOL, "print_builtin_scopes", &FLAG_print_builtin_scopes, &FLAGDEFAULT_print_builtin_scopes, "print scopes for builtins", false } ,
{ Flag::TYPE_BOOL, "print_scopes", &FLAG_print_scopes, &FLAGDEFAULT_print_scopes, "print scopes", false } ,


{ Flag::TYPE_BOOL, "trace_contexts", &FLAG_trace_contexts, &FLAGDEFAULT_trace_contexts, "trace contexts operations", false } ,


{ Flag::TYPE_BOOL, "gc_verbose", &FLAG_gc_verbose, &FLAGDEFAULT_gc_verbose, "print stuff during garbage collection", false } ,
{ Flag::TYPE_BOOL, "heap_stats", &FLAG_heap_stats, &FLAGDEFAULT_heap_stats, "report heap statistics before and after GC", false } ,
{ Flag::TYPE_BOOL, "code_stats", &FLAG_code_stats, &FLAGDEFAULT_code_stats, "report code statistics after GC", false } ,
{ Flag::TYPE_BOOL, "print_handles", &FLAG_print_handles, &FLAGDEFAULT_print_handles, "report handles after GC", false } ,
{ Flag::TYPE_BOOL, "check_handle_count", &FLAG_check_handle_count, &FLAGDEFAULT_check_handle_count, "Check that there are not too many handles at GC", false } ,

{ Flag::TYPE_BOOL, "print_global_handles", &FLAG_print_global_handles, &FLAGDEFAULT_print_global_handles, "report global handles after GC", false } ,


{ Flag::TYPE_BOOL, "print_turbo_replay", &FLAG_print_turbo_replay, &FLAGDEFAULT_print_turbo_replay, "print C++ code to recreate TurboFan graphs", false } ,

{ Flag::TYPE_BOOL, "trace_turbo_escape", &FLAG_trace_turbo_escape, &FLAGDEFAULT_trace_turbo_escape, "enable tracing in escape analysis", false } ,


{ Flag::TYPE_BOOL, "trace_normalization", &FLAG_trace_normalization, &FLAGDEFAULT_trace_normalization, "prints when objects are turned into dictionaries.", false } ,



{ Flag::TYPE_BOOL, "trace_lazy", &FLAG_trace_lazy, &FLAGDEFAULT_trace_lazy, "trace lazy compilation", false } ,


{ Flag::TYPE_BOOL, "collect_heap_spill_statistics", &FLAG_collect_heap_spill_statistics, &FLAGDEFAULT_collect_heap_spill_statistics, "report heap spill statistics along with heap_stats " "(requires heap_stats)", false } ,


{ Flag::TYPE_BOOL, "trace_live_bytes", &FLAG_trace_live_bytes, &FLAGDEFAULT_trace_live_bytes, "trace incrementing and resetting of live bytes", false } ,


{ Flag::TYPE_BOOL, "trace_isolates", &FLAG_trace_isolates, &FLAGDEFAULT_trace_isolates, "trace isolate state changes", false } ,


{ Flag::TYPE_BOOL, "regexp_possessive_quantifier", &FLAG_regexp_possessive_quantifier, &FLAGDEFAULT_regexp_possessive_quantifier, "enable possessive quantifier syntax for testing", false } ,

{ Flag::TYPE_BOOL, "trace_regexp_bytecodes", &FLAG_trace_regexp_bytecodes, &FLAGDEFAULT_trace_regexp_bytecodes, "trace regexp bytecode execution", false } ,
{ Flag::TYPE_BOOL, "trace_regexp_assembler", &FLAG_trace_regexp_assembler, &FLAGDEFAULT_trace_regexp_assembler, "trace regexp macro assembler calls.", false } ,

{ Flag::TYPE_BOOL, "trace_regexp_parser", &FLAG_trace_regexp_parser, &FLAGDEFAULT_trace_regexp_parser, "trace regexp parsing", false } ,


{ Flag::TYPE_BOOL, "print_break_location", &FLAG_print_break_location, &FLAGDEFAULT_print_break_location, "print source location on debug break", false } ,
{ Flag::TYPE_BOOL, "log", &FLAG_log, &FLAGDEFAULT_log, "Minimal logging (no API, code, GC, suspect, or handles samples).", false } ,

{ Flag::TYPE_BOOL, "log_all", &FLAG_log_all, &FLAGDEFAULT_log_all, "Log all events to the log file.", false } ,
{ Flag::TYPE_BOOL, "log_api", &FLAG_log_api, &FLAGDEFAULT_log_api, "Log API events to the log file.", false } ,
{ Flag::TYPE_BOOL, "log_code", &FLAG_log_code, &FLAGDEFAULT_log_code, "Log code events to the log file without profiling.", false } ,

{ Flag::TYPE_BOOL, "log_gc", &FLAG_log_gc, &FLAGDEFAULT_log_gc, "Log heap samples on garbage collection for the hp2ps tool.", false } ,

{ Flag::TYPE_BOOL, "log_handles", &FLAG_log_handles, &FLAGDEFAULT_log_handles, "Log global handle events.", false } ,
{ Flag::TYPE_BOOL, "log_suspect", &FLAG_log_suspect, &FLAGDEFAULT_log_suspect, "Log suspect operations.", false } ,
{ Flag::TYPE_BOOL, "prof", &FLAG_prof, &FLAGDEFAULT_prof, "Log statistical profiling information (implies --log-code).", false } ,

{ Flag::TYPE_BOOL, "prof_cpp", &FLAG_prof_cpp, &FLAGDEFAULT_prof_cpp, "Like --prof, but ignore generated code.", false } ,

{ Flag::TYPE_BOOL, "prof_browser_mode", &FLAG_prof_browser_mode, &FLAGDEFAULT_prof_browser_mode, "Used with --prof, turns on browser-compatible mode for profiling.", false } ,

{ Flag::TYPE_BOOL, "log_regexp", &FLAG_log_regexp, &FLAGDEFAULT_log_regexp, "Log regular expression execution.", false } ,
{ Flag::TYPE_STRING, "logfile", &FLAG_logfile, &FLAGDEFAULT_logfile, "Specify the name of the log file.", false } ,
{ Flag::TYPE_BOOL, "logfile_per_isolate", &FLAG_logfile_per_isolate, &FLAGDEFAULT_logfile_per_isolate, "Separate log files for each isolate.", false } ,
{ Flag::TYPE_BOOL, "ll_prof", &FLAG_ll_prof, &FLAGDEFAULT_ll_prof, "Enable low-level linux profiler.", false } ,
{ Flag::TYPE_BOOL, "perf_basic_prof", &FLAG_perf_basic_prof, &FLAGDEFAULT_perf_basic_prof, "Enable perf linux profiler (basic support).", false } ,


{ Flag::TYPE_BOOL, "perf_basic_prof_only_functions", &FLAG_perf_basic_prof_only_functions, &FLAGDEFAULT_perf_basic_prof_only_functions, "Only report function code ranges to perf (i.e. no stubs).", false } ,


{ Flag::TYPE_BOOL, "perf_prof", &FLAG_perf_prof, &FLAGDEFAULT_perf_prof, "Enable perf linux profiler (experimental annotate support).", false } ,


{ Flag::TYPE_BOOL, "perf_prof_debug_info", &FLAG_perf_prof_debug_info, &FLAGDEFAULT_perf_prof_debug_info, "Enable debug info for perf linux profiler (experimental).", false } ,

{ Flag::TYPE_STRING, "gc_fake_mmap", &FLAG_gc_fake_mmap, &FLAGDEFAULT_gc_fake_mmap, "Specify the name of the file for fake gc mmap used in ll_prof", false } ,

{ Flag::TYPE_BOOL, "log_internal_timer_events", &FLAG_log_internal_timer_events, &FLAGDEFAULT_log_internal_timer_events, "Time internal events.", false } ,
{ Flag::TYPE_BOOL, "log_timer_events", &FLAG_log_timer_events, &FLAGDEFAULT_log_timer_events, "Time events including external callbacks.", false } ,



{ Flag::TYPE_BOOL, "log_instruction_stats", &FLAG_log_instruction_stats, &FLAGDEFAULT_log_instruction_stats, "Log AArch64 instruction statistics.", false } ,
{ Flag::TYPE_STRING, "log_instruction_file", &FLAG_log_instruction_file, &FLAGDEFAULT_log_instruction_file, "AArch64 instruction statistics log file.", false } ,

{ Flag::TYPE_INT, "log_instruction_period", &FLAG_log_instruction_period, &FLAGDEFAULT_log_instruction_period, "AArch64 instruction statistics logging period.", false } ,


{ Flag::TYPE_BOOL, "redirect_code_traces", &FLAG_redirect_code_traces, &FLAGDEFAULT_redirect_code_traces, "output deopt information and disassembly into file " "code-<pid>-<isolate id>.asm", false } ,


{ Flag::TYPE_STRING, "redirect_code_traces_to", &FLAG_redirect_code_traces_to, &FLAGDEFAULT_redirect_code_traces_to, "output deopt information and disassembly into the given file", false } ,


{ Flag::TYPE_BOOL, "hydrogen_track_positions", &FLAG_hydrogen_track_positions, &FLAGDEFAULT_hydrogen_track_positions, "track source code positions when building IR", false } ,
{ Flag::TYPE_BOOL, "trace_elements_transitions", &FLAG_trace_elements_transitions, &FLAGDEFAULT_trace_elements_transitions, "trace elements transitions", false } ,

{ Flag::TYPE_BOOL, "trace_creation_allocation_sites", &FLAG_trace_creation_allocation_sites, &FLAGDEFAULT_trace_creation_allocation_sites, "trace the creation of allocation sites", false } ,



{ Flag::TYPE_BOOL, "print_code_stubs", &FLAG_print_code_stubs, &FLAGDEFAULT_print_code_stubs, "print code stubs", false } ,
{ Flag::TYPE_BOOL, "test_secondary_stub_cache", &FLAG_test_secondary_stub_cache, &FLAGDEFAULT_test_secondary_stub_cache, "test secondary stub cache by disabling the primary one", false } ,


{ Flag::TYPE_BOOL, "test_primary_stub_cache", &FLAG_test_primary_stub_cache, &FLAGDEFAULT_test_primary_stub_cache, "test primary stub cache by disabling the secondary one", false } ,




{ Flag::TYPE_BOOL, "print_code", &FLAG_print_code, &FLAGDEFAULT_print_code, "print generated code", false } ,
{ Flag::TYPE_BOOL, "print_opt_code", &FLAG_print_opt_code, &FLAGDEFAULT_print_opt_code, "print optimized code", false } ,
{ Flag::TYPE_BOOL, "print_unopt_code", &FLAG_print_unopt_code, &FLAGDEFAULT_print_unopt_code, "print unoptimized code before " "printing optimized code based on it", false } ,


{ Flag::TYPE_BOOL, "print_code_verbose", &FLAG_print_code_verbose, &FLAGDEFAULT_print_code_verbose, "print more information for code", false } ,
{ Flag::TYPE_BOOL, "print_builtin_code", &FLAG_print_builtin_code, &FLAGDEFAULT_print_builtin_code, "print generated code for builtins", false } ,


{ Flag::TYPE_BOOL, "sodium", &FLAG_sodium, &FLAGDEFAULT_sodium, "print generated code output suitable for use with " "the Sodium code viewer", false } ,
{ Flag::TYPE_BOOL, "print_all_code", &FLAG_print_all_code, &FLAGDEFAULT_print_all_code, "enable all flags related to printing code", false } ,
};

const size_t num_flags = sizeof(flags) / sizeof(*flags);

}


static const char* Type2String(Flag::FlagType type) {
  switch (type) {
    case Flag::TYPE_BOOL: return u8"bool";
    case Flag::TYPE_MAYBE_BOOL: return u8"maybe_bool";
    case Flag::TYPE_INT: return u8"int";
    case Flag::TYPE_FLOAT: return u8"float";
    case Flag::TYPE_STRING: return u8"string";
    case Flag::TYPE_ARGS: return u8"arguments";
  }
  V8_Fatal("../src/flags.cc", 191, "unreachable code");
  return 0;
}


std::ostream& operator<<(std::ostream& os, const Flag& flag) {
  switch (flag.type()) {
    case Flag::TYPE_BOOL:
      os << (*flag.bool_variable() ? u8"true" : u8"false");
      break;
    case Flag::TYPE_MAYBE_BOOL:
      os << (flag.maybe_bool_variable()->has_value
                 ? (flag.maybe_bool_variable()->value ? u8"true" : u8"false")
                 : u8"unset");
      break;
    case Flag::TYPE_INT:
      os << *flag.int_variable();
      break;
    case Flag::TYPE_FLOAT:
      os << *flag.float_variable();
      break;
    case Flag::TYPE_STRING: {
      const char* str = flag.string_value();
      os << (str ? str : u8"NULL");
      break;
    }
    case Flag::TYPE_ARGS: {
      JSArguments args = *flag.args_variable();
      if (args.argc > 0) {
        os << args[0];
        for (int i = 1; i < args.argc; i++) {
          os << args[i];
        }
      }
      break;
    }
  }
  return os;
}



List<const char*>* FlagList::argv() {
  List<const char*>* args = new List<const char*>(8);
  Flag* args_flag = 0;
  for (size_t i = 0; i < num_flags; ++i) {
    Flag* f = &flags[i];
    if (!f->IsDefault()) {
      if (f->type() == Flag::TYPE_ARGS) {
        do { if ((!(args_flag == 0))) { V8_Fatal("../src/flags.cc", 240, "Check failed: %s.", "args_flag == 0"); } } while (0);
        args_flag = f;
        continue;
      }
      {
        bool disabled = f->type() == Flag::TYPE_BOOL && !*f->bool_variable();
        std::ostringstream os;
        os << (disabled ? u8"--no" : u8"--") << f->name();
        args->Add(StrDup(os.str().c_str()));
      }
      if (f->type() != Flag::TYPE_BOOL) {
        std::ostringstream os;
        os << *f;
        args->Add(StrDup(os.str().c_str()));
      }
    }
  }
  if (args_flag != 0) {
    std::ostringstream os;
    os << u8"--" << args_flag->name();
    args->Add(StrDup(os.str().c_str()));
    JSArguments jsargs = *args_flag->args_variable();
    for (int j = 0; j < jsargs.argc; j++) {
      args->Add(StrDup(jsargs[j]));
    }
  }
  return args;
}


inline char NormalizeChar(char ch) {
  return ch == '\x5f' ? '\x2d' : ch;
}






static void SplitArgument(const char* arg,
                          char* buffer,
                          int buffer_size,
                          const char** name,
                          const char** value,
                          bool* is_bool) {
  *name = 0;
  *value = 0;
  *is_bool = false;

  if (arg != 0 && *arg == '\x2d') {

    arg++;
    if (*arg == '\x2d') {
      arg++;
      if (arg[0] == '\x0') {
        const char* kJSArgumentsFlagName = u8"js_arguments";
        *name = kJSArgumentsFlagName;
        return;
      }
    }
    if (arg[0] == '\x6e' && arg[1] == '\x6f') {
      arg += 2;
      if (NormalizeChar(arg[0]) == '\x2d') arg++;
      *is_bool = true;
    }
    *name = arg;


    while (*arg != '\x0' && *arg != '\x3d')
      arg++;


    if (*arg == '\x3d') {

      size_t n = arg - *name;
      do { if ((!(n < static_cast<size_t>(buffer_size)))) { V8_Fatal("../src/flags.cc", 315, "Check failed: %s.", "n < static_cast<size_t>(buffer_size)"); } } while (0);
      MemCopy(buffer, *name, n);
      buffer[n] = '\x0';
      *name = buffer;

      *value = arg + 1;
    }
  }
}


static bool EqualNames(const char* a, const char* b) {
  for (int i = 0; NormalizeChar(a[i]) == NormalizeChar(b[i]); i++) {
    if (a[i] == '\x0') {
      return true;
    }
  }
  return false;
}


static Flag* FindFlag(const char* name) {
  for (size_t i = 0; i < num_flags; ++i) {
    if (EqualNames(name, flags[i].name()))
      return &flags[i];
  }
  return 0;
}



int FlagList::SetFlagsFromCommandLine(int* argc,
                                      char** argv,
                                      bool remove_flags) {
  int return_code = 0;

  for (int i = 1; i < *argc;) {
    int j = i;
    const char* arg = argv[i++];


    char buffer[1*KB];
    const char* name;
    const char* value;
    bool is_bool;
    SplitArgument(arg, buffer, sizeof buffer, &name, &value, &is_bool);

    if (name != 0) {

      Flag* flag = FindFlag(name);
      if (flag == 0) {
        if (remove_flags) {




          continue;
        } else {
          PrintF(( *((__FILEP * const) (*(_Gtab(4))) ) ),"Error: unrecognized flag %s\n"
                 "Try --help for options\n", arg);
          return_code = j;
          break;
        }
      }


      if (flag->type() != Flag::TYPE_BOOL &&
          flag->type() != Flag::TYPE_MAYBE_BOOL &&
          flag->type() != Flag::TYPE_ARGS &&
          value == 0) {
        if (i < *argc) {
          value = argv[i++];
        }
        if (!value) {
          PrintF(( *((__FILEP * const) (*(_Gtab(4))) ) ), "Error: missing value for flag %s of type %s\n"
                 "Try --help for options\n",
                 arg, Type2String(flag->type()));
          return_code = j;
          break;
        }
      }


      char* endp = const_cast<char*>(u8"");
      switch (flag->type()) {
        case Flag::TYPE_BOOL:
          *flag->bool_variable() = !is_bool;
          break;
        case Flag::TYPE_MAYBE_BOOL:
          *flag->maybe_bool_variable() = MaybeBoolFlag::Create(true, !is_bool);
          break;
        case Flag::TYPE_INT: {
          int value_len = strlen(value);
          char value_e[value_len + 1];
          MemCopy(value_e, value, value_len + 1);
          __a2e_s(value_e);
          *flag->int_variable() = strtol(value_e, &endp, 10);
          break;
       }case Flag::TYPE_FLOAT: {
          int value_len = strlen(value);
          char value_e[value_len + 1];
          MemCopy(value_e, value, value_len + 1);
          __a2e_s(value_e);
          *flag->float_variable() = strtod(value_e, &endp);
          break;
    }case Flag::TYPE_STRING:
          flag->set_string_value(value ? StrDup(value) : 0, true);
          break;
        case Flag::TYPE_ARGS: {
          int start_pos = (value == 0) ? i : i - 1;
          int js_argc = *argc - start_pos;
          const char** js_argv = NewArray<const char*>(js_argc);
          if (value != 0) {
            js_argv[0] = StrDup(value);
          }
          for (int k = i; k < *argc; k++) {
            js_argv[k - start_pos] = StrDup(argv[k]);
          }
          *flag->args_variable() = JSArguments::Create(js_argc, js_argv);
          i = *argc;
          break;
        }
      }


      bool is_bool_type = flag->type() == Flag::TYPE_BOOL ||
          flag->type() == Flag::TYPE_MAYBE_BOOL;
      if ((is_bool_type && value != 0) || (!is_bool_type && is_bool) ||
          *endp != '\x0') {
        PrintF(( *((__FILEP * const) (*(_Gtab(4))) ) ),"Error: illegal value for flag %s of type %s\n"
               "Try --help for options\n",
               arg, Type2String(flag->type()));
        return_code = j;
        break;
      }


      if (remove_flags) {
        while (j < i) {
          argv[j++] = 0;
        }
      }
    }
  }


  if (remove_flags) {
    int j = 1;
    for (int i = 1; i < *argc; i++) {
      if (argv[i] != 0)
        argv[j++] = argv[i];
    }
    *argc = j;
  }

  if (FLAG_help) {
    PrintHelp();
    exit(0);
  }

  return return_code;
}


static char* SkipWhiteSpace(char* p) {
  while (*p != '\x0' && isspace(*p) != 0) p++;
  return p;
}


static char* SkipBlackSpace(char* p) {
  while (*p != '\x0' && isspace(*p) == 0) p++;
  return p;
}



int FlagList::SetFlagsFromString(const char* str, int len) {

  ScopedVector<char> copy0(len + 1);
  MemCopy(copy0.start(), str, len);
  copy0[len] = '\0';


  char* copy = SkipWhiteSpace(copy0.start());


  int argc = 1;
  for (char* p = copy; *p != '\x0'; argc++) {
    p = SkipBlackSpace(p);
    p = SkipWhiteSpace(p);
  }


  ScopedVector<char*> argv(argc);


  argc = 1;
  for (char* p = copy; *p != '\x0'; argc++) {
    argv[argc] = p;
    p = SkipBlackSpace(p);
    if (*p != '\x0') *p++ = '\x0';
    p = SkipWhiteSpace(p);
  }


  int result = SetFlagsFromCommandLine(&argc, argv.start(), false);

  return result;
}



void FlagList::ResetAllFlags() {
  for (size_t i = 0; i < num_flags; ++i) {
    flags[i].Reset();
  }
}



void FlagList::PrintHelp() {
  CpuFeatures::Probe(false);
  CpuFeatures::PrintTarget();
  CpuFeatures::PrintFeatures();

  OFStream os(( *((__FILEP * const) (*(_Gtab(3))) ) ));
  os << u8"Usage:\n"
     << u8"  shell [options] -e string\n"
     << u8"    execute string in V8\n"
     << u8"  shell [options] file1 file2 ... filek\n"
     << u8"    run JavaScript scripts in file1, file2, ..., filek\n"
     << u8"  shell [options]\n"
     << u8"  shell [options] --shell [file1 file2 ... filek]\n"
     << u8"    run an interactive JavaScript shell\n"
     << u8"  d8 [options] file1 file2 ... filek\n"
     << u8"  d8 [options]\n"
     << u8"  d8 [options] --shell [file1 file2 ... filek]\n"
     << u8"    run the new debugging shell\n\n"
     << u8"Options:\n";
  for (size_t i = 0; i < num_flags; ++i) {
    Flag* f = &flags[i];
    os << u8"  --" << f->name() << u8" (" << f->comment() << u8")\n"
       << u8"        type: " << Type2String(f->type()) << u8"  default: " << *f
       << u8"\n";
  }
}


static uint32_t flag_hash = 0;


void ComputeFlagListHash() {
  std::ostringstream modified_args_as_string;

  modified_args_as_string << u8"debug";

  for (size_t i = 0; i < num_flags; ++i) {
    Flag* current = &flags[i];
    if (!current->IsDefault()) {
      modified_args_as_string << i;
      modified_args_as_string << *current;
    }
  }
  std::string args(modified_args_as_string.str());
  flag_hash = static_cast<uint32_t>(
      base::hash_range(args.c_str(), args.c_str() + args.length()));
}



void FlagList::EnforceFlagImplications() {


if (FLAG_es_staging) FLAG_harmony = true;



if (FLAG_harmony) FLAG_promise_extra = false;


if (FLAG_es_staging) FLAG_harmony_regexp_lookbehind = true;
if (FLAG_es_staging) FLAG_move_object_start = true;
 if (FLAG_harmony) FLAG_harmony_regexp_lookbehind = true; if (FLAG_harmony) FLAG_harmony_tailcalls = true; if (FLAG_harmony) FLAG_harmony_object_values_entries = true; if (FLAG_harmony) FLAG_harmony_object_own_property_descriptors = true; if (FLAG_harmony) FLAG_harmony_exponentiation_operator = true;





 if (!FLAG_harmony_shipping) FLAG_harmony_array_prototype_values = false; if (!FLAG_harmony_shipping) FLAG_harmony_function_name = false; if (!FLAG_harmony_shipping) FLAG_harmony_instanceof = false; if (!FLAG_harmony_shipping) FLAG_harmony_iterator_close = false; if (!FLAG_harmony_shipping) FLAG_harmony_unicode_regexps = false; if (!FLAG_harmony_shipping) FLAG_harmony_regexp_exec = false; if (!FLAG_harmony_shipping) FLAG_harmony_sloppy = false; if (!FLAG_harmony_shipping) FLAG_harmony_sloppy_let = false; if (!FLAG_harmony_shipping) FLAG_harmony_sloppy_function = false; if (!FLAG_harmony_shipping) FLAG_harmony_regexp_subclass = false; if (!FLAG_harmony_shipping) FLAG_harmony_restrictive_declarations = false; if (!FLAG_harmony_shipping) FLAG_harmony_species = false;




if (FLAG_harmony_sloppy_let) FLAG_harmony_sloppy = true;
if (FLAG_harmony_sloppy_function) FLAG_harmony_sloppy = true;
if (FLAG_track_double_fields) FLAG_track_fields = true;
if (FLAG_track_heap_object_fields) FLAG_track_fields = true;
if (FLAG_track_computed_fields) FLAG_track_fields = true;

if (FLAG_track_field_types) FLAG_track_fields = true;
if (FLAG_track_field_types) FLAG_track_heap_object_fields = true;







if (FLAG_optimize_for_size) FLAG_max_semi_space_size = 1;
if (FLAG_turbo) FLAG_turbo_asm_deoptimization = true;
if (FLAG_trace_turbo_graph) FLAG_trace_turbo = true;
if (FLAG_trace_turbo) FLAG_turbo_source_positions = true;
if (FLAG_trace_opt_verbose) FLAG_trace_opt = true;
if (FLAG_enable_armv8) FLAG_enable_vfp3 = true;
if (FLAG_enable_armv8) FLAG_enable_neon = true;
if (FLAG_enable_armv8) FLAG_enable_32dregs = true;
if (FLAG_enable_armv8) FLAG_enable_sudiv = true;
if (FLAG_enable_armv8) FLAG_enable_mls = true;
if (FLAG_expose_gc_as) FLAG_expose_gc = true;
if (FLAG_trace_array_abuse) FLAG_trace_js_array_abuse = true;
if (FLAG_trace_array_abuse) FLAG_trace_external_array_abuse = true;
if (FLAG_trace_gc_object_stats) FLAG_track_gc_object_stats = true;




if (FLAG_trace_detached_contexts) FLAG_track_detached_contexts = true;
if (FLAG_eliminate_prototype_chain_checks) FLAG_track_prototype_users = true;
if (FLAG_predictable) FLAG_concurrent_recompilation = false;
if (FLAG_predictable) FLAG_concurrent_sweeping = false;
if (FLAG_predictable) FLAG_parallel_compaction = false;
if (FLAG_predictable) FLAG_memory_reducer = false;
if (FLAG_gdbjit) FLAG_compact_code_space = false;
if (FLAG_prof) FLAG_prof_cpp = true;
if (FLAG_perf_basic_prof) FLAG_compact_code_space = false;


if (FLAG_perf_basic_prof_only_functions) FLAG_perf_basic_prof = true;


if (FLAG_perf_prof) FLAG_compact_code_space = false;







if (FLAG_log_timer_events) FLAG_log_internal_timer_events = true;
if (FLAG_log_internal_timer_events) FLAG_prof = true;
if (FLAG_sodium) FLAG_print_code_stubs = true;
if (FLAG_sodium) FLAG_print_code = true;
if (FLAG_sodium) FLAG_print_opt_code = true;
if (FLAG_sodium) FLAG_hydrogen_track_positions = true;
if (FLAG_sodium) FLAG_code_comments = true;


if (FLAG_print_all_code) FLAG_print_code = true;
if (FLAG_print_all_code) FLAG_print_opt_code = true;
if (FLAG_print_all_code) FLAG_print_unopt_code = true;
if (FLAG_print_all_code) FLAG_print_code_verbose = true;
if (FLAG_print_all_code) FLAG_print_builtin_code = true;
if (FLAG_print_all_code) FLAG_print_code_stubs = true;
if (FLAG_print_all_code) FLAG_code_comments = true;

if (FLAG_print_all_code) FLAG_trace_codegen = true;
if (FLAG_unbox_double_fields) FLAG_track_double_fields = true;

  ComputeFlagListHash();
}


uint32_t FlagList::Hash() { return flag_hash; }

#pragma convert(pop)
}
}
